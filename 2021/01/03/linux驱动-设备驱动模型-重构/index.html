<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":"ture","mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux设备模型的核心是使用Bus、Class、Device、Driver四个核心数据结构，将大量的、不同功能的硬件设备（以及驱动该硬件设备的方法），以树状结构的形式，进行归纳、抽象，从而方便Kernel的统一管理。学习平台mt8768，内核版本kernel-4.9">
<meta property="og:type" content="article">
<meta property="og:title" content="linux设备模型">
<meta property="og:url" content="https://example.com/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/index.html">
<meta property="og:site_name" content="braon-z&#39;s blog">
<meta property="og:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Linux设备模型的核心是使用Bus、Class、Device、Driver四个核心数据结构，将大量的、不同功能的硬件设备（以及驱动该硬件设备的方法），以树状结构的形式，进行归纳、抽象，从而方便Kernel的统一管理。学习平台mt8768，内核版本kernel-4.9">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-03T01:14:17.000Z">
<meta property="article:modified_time" content="2021-03-17T01:56:03.133Z">
<meta property="article:author" content="braon-z">
<meta property="article:tag" content="驱动">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://example.com/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>linux设备模型 | braon-z's blog</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">braon-z's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81kobject"><span class="nav-text">一、kobject</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1、相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kobject"><span class="nav-text">1) kobject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-kobj-type"><span class="nav-text">2) kobj_type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-attribute"><span class="nav-text">3) attribute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-sysfs-ops"><span class="nav-text">4) sysfs_ops</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81kobject-%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2、kobject 的创建与初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kobject-create"><span class="nav-text">1) kobject_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-kobject-init"><span class="nav-text">2) kobject_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-kobject-init-internal"><span class="nav-text">3) kobject_init_internal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81kobject-%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-text">3、kobject 的注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kobject-add"><span class="nav-text">1) kobject_add</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-kobject-add-internal"><span class="nav-text">2) kobject_add_internal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C-1"><span class="nav-text">3) 编程实验 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C-2"><span class="nav-text">4) 编程实验 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%9C%A8-sys-%E4%B8%8B%E7%BB%84%E7%BB%87%E5%87%BA%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1"><span class="nav-text">4、在 sys&#x2F; 下组织出目录层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81kobj-%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="nav-text">5、kobj 对象生命周期管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kobject-get"><span class="nav-text">1) kobject_get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-kobject-put"><span class="nav-text">2) kobject_put</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BC%98%E5%8C%96-my-dir"><span class="nav-text">3) 优化 my_dir</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF%E4%BA%A4%E4%BA%92"><span class="nav-text">6、用户空间与内核信息交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E9%80%BB%E8%BE%91"><span class="nav-text">1) 属性文件调用逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8A%E5%88%A0%E9%99%A4"><span class="nav-text">2) 属性文件的创建以及删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9C%A8-my-dir-%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="nav-text">3) 在 my_dir 下创建属性文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BC%98%E5%8C%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">4) 优化属性文件操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81kset"><span class="nav-text">二、kset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81-kset%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%B3%A8%E5%86%8C"><span class="nav-text">1、 kset的创建与注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kset-create"><span class="nav-text">1) kset_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-kset-init"><span class="nav-text">2) kset_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-kset-register"><span class="nav-text">3) kset_register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-kset-create-and-add"><span class="nav-text">3) kset_create_and_add</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%8D%B8%E8%BD%BDkset"><span class="nav-text">2、卸载kset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kset-unregister"><span class="nav-text">1) kset_unregister</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-kset-put"><span class="nav-text">2) kset_put</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81bus%E6%80%BB%E7%BA%BF"><span class="nav-text">三、bus总线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-bus-type"><span class="nav-text">1) bus_type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-subsys-private"><span class="nav-text">2) subsys_private</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81bus-%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2、bus 根目录的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81bus-%E6%80%BB%E7%BA%BF%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-text">3、bus 总线的注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="nav-text">4、创建属性文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81device%E8%AE%BE%E5%A4%87"><span class="nav-text">二、device设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-text">1、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-device"><span class="nav-text">1) device</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-device-private"><span class="nav-text">2) device_private</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81device-%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2、device 根目录的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81device%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-text">3、device的注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-device-register"><span class="nav-text">1) device_register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-device-initialize"><span class="nav-text">2) device_initialize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-device-add"><span class="nav-text">3) device_add</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-get-device-parent"><span class="nav-text">4) get_device_parent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-device-add-class-symlinks"><span class="nav-text">5) device_add_class_symlinks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-device-add-attrs"><span class="nav-text">6) device_add_attrs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-bus-add-device"><span class="nav-text">7) bus_add_device</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-bus-probe-device"><span class="nav-text">8) bus_probe_device</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81device-register%E6%80%BB%E7%BB%93"><span class="nav-text">4、device_register总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A3%80%E6%9F%A5%E8%AE%BE%E5%A4%87%E5%90%8D%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7"><span class="nav-text">1) 检查设备名的合法性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%9C%A8sys-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">2）在sys&#x2F;创建文件目录的层次关系的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%92%8C%E6%8C%82%E6%8E%A5%E7%9A%84bus%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89drv%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D"><span class="nav-text">3）和挂接的bus上的所有drv进行匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%88%9B%E5%BB%BA%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AE%BE%E5%A4%87"><span class="nav-text">5、创建我们自己的设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%9C%A8dev%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="nav-text">6、在dev下创建属性文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81driver%E9%A9%B1%E5%8A%A8"><span class="nav-text">三、driver驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="nav-text">1、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-device-driver"><span class="nav-text">1) device_driver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-driver-private"><span class="nav-text">2) driver_private</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81driver%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-text">2、driver的注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81driver-register-%E6%80%BB%E7%BB%93"><span class="nav-text">3、driver_register 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9C%A8sys-%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E8%8A%82%E7%82%B9"><span class="nav-text">1) 在sys&#x2F;创建对应节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8C%B9%E9%85%8D-bus-%E6%80%BB%E7%BA%BF%E4%B8%8A%E7%9A%84%E8%AE%BE%E5%A4%87"><span class="nav-text">2) 匹配 bus 总线上的设备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%B3%A8%E5%86%8C%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A9%B1%E5%8A%A8"><span class="nav-text">4、注册我们自己的驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%9C%A8driver%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="nav-text">5、在driver目录下创建属性文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81class%E6%80%BB%E7%BA%BF"><span class="nav-text">四、class总线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="nav-text">1、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-subsys-private-1"><span class="nav-text">2) subsys_private</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-text">2、函数接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-classes-init"><span class="nav-text">1) classes_init</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%EF%BC%89class-create"><span class="nav-text">2）class_create</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-class-register"><span class="nav-text">2) __class_register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-device-create"><span class="nav-text">3) device_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3"><span class="nav-text">4) 属性操作接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81platform%E8%AE%BE%E5%A4%87"><span class="nav-text">五、platform设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4"><span class="nav-text">1、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-platform-device"><span class="nav-text">1) platform_device</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-platform-driver"><span class="nav-text">2) platform_driver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-resource"><span class="nav-text">3) resource</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81platform%E6%80%BB%E7%BA%BF%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-text">2、platform总线的构建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81platform-%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3"><span class="nav-text">3、platform 设备接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-platform-device-register"><span class="nav-text">1) platform_device_register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-platform-driver-register"><span class="nav-text">2) platform_driver_register</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84platform%E8%AE%BE%E5%A4%87"><span class="nav-text">4、创建自己的platform设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%94%A8%E5%90%8D%E5%AD%97%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D"><span class="nav-text">1) 用名字进行匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%B9%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">2) 用设备树方式匹配</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="braon-z"
      src="/images/wallhaven.jfif">
  <p class="site-author-name" itemprop="name">braon-z</p>
  <div class="site-description" itemprop="description"> 爱一个人，攀一座山，追一次梦<br>不妨大胆一点，有很多事没有答案</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven.jfif">
      <meta itemprop="name" content="braon-z">
      <meta itemprop="description" content=" 爱一个人，攀一座山，追一次梦<br>不妨大胆一点，有很多事没有答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="braon-z's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux设备模型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-03 09:14:17" itemprop="dateCreated datePublished" datetime="2021-01-03T09:14:17+08:00">2021-01-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-17 09:56:03" itemprop="dateModified" datetime="2021-03-17T09:56:03+08:00">2021-03-17</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>107k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:37</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>&nbsp;&nbsp;&nbsp;&nbsp;Linux设备模型的核心是使用<font color=red>Bus、Class、Device、Driver</font>四个核心数据结构，将大量的、不同功能的硬件设备（以及驱动该硬件设备的方法），以树状结构的形式，进行归纳、抽象，从而方便Kernel的统一管理。<font color = red><strong>学习平台mt8768，内核版本kernel-4.9</strong> </font></p>
<a id="more"></a>

<h1 id="一、kobject"><a href="#一、kobject" class="headerlink" title="一、kobject"></a>一、kobject</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 它是构建设备模型的根基，它使设备模型下能在 /sys/ 下以目录层次的形式呈现、 动态管理着所属对象的生命周期，以及提供了与用户空间进行信息交互的属性文件(attribute).</p>
<blockquote>
<p><strong>温馨提示</strong>目录文件是两个不同的概念，别搞混了。</p>
</blockquote>
<h2 id="1、相关数据结构"><a href="#1、相关数据结构" class="headerlink" title="1、相关数据结构"></a>1、相关数据结构</h2><h3 id="1-kobject"><a href="#1-kobject" class="headerlink" title="1) kobject"></a>1) kobject</h3><p>核心结构kobject，牢牢记住每一个注册到内核的kobject就是一个目录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Kobject: include/linux/kobject.h line 60 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                  <span class="comment">//该Kobject的名称，同时也是sys/中的目录名称。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>         <span class="comment">//用于将该Kobject加入到Kset中的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span>       <span class="comment">//kobject以此形成层次目录结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>         *<span class="title">kset</span>;</span>         <span class="comment">//该kobject所属的Kset，可以为NULL，如果存在且没有指定parent，则会把Kset.kobj做为parent。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>        <span class="comment">//该Kobject属于的kobj_type，只有拥有ktye的kobj才能创建属性文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span> *<span class="title">sd</span>;</span>           <span class="comment">//该Kobject在sysfs中的表示</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>          <span class="title">kref</span>;</span>         <span class="comment">//用于原子操作的引用计数（在include/linux/kref.h中定义）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;  <span class="comment">//指示该Kobject是否已经初始化，在Kobject的Init，Put，Add等操作时进行异常校验。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;     <span class="comment">//指示该Kobject是否已经在sysfs中呈现，以便在自动注销时在从sysfs中移除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 记录是否已经向用户空间发送add uevent，如果有，且没有发送remove uevent，</span></span><br><span class="line"><span class="comment">     * 则在自动注销时，补发remove uevent，以便让用户空间正确处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>; <span class="comment">//如果该字段为1，则表示忽略所有上报的uevent事件。</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobj-type"><a href="#2-kobj-type" class="headerlink" title="2) kobj_type"></a>2) kobj_type</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用户空间怎么和内核进行交互，就是通过这个结构中包含的属性链表，指向的属性文件和属性操作函数进行交互。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/kobject.h, line 108 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">release</span>)(struct kobject *kobj);    <span class="comment">//当引用计数为0时自动调用，将包含该种类型kobject的数据结构的内存空间释放掉</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span>        <span class="comment">//kobject属性操作函数指针，上层在open属性文件时获取这个指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>         <span class="comment">//属性链表指针，指向attribute *数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-attribute"><a href="#3-attribute" class="headerlink" title="3) attribute"></a>3) attribute</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;牢牢记住，每一个注册到内核的 attribute 都是它所属的 kobj 目录下的一个属性文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--include/linux/sysfs.h</span><br><span class="line"><span class="comment">/* FIXME</span></span><br><span class="line"><span class="comment"> * The *owner field is no longer used.</span></span><br><span class="line"><span class="comment"> * x86 tree has been cleaned up. The owner</span></span><br><span class="line"><span class="comment"> * attribute is still left for other arches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>    *name;        <span class="comment">/* 属性的名字,即sys目录中的属性文件名称 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>       <span class="comment">/* 属性的拥有者，已不再使用 */</span></span><br><span class="line">        <span class="keyword">mode_t</span> mode;                <span class="comment">/* 属性的读写权限，定义在include/linux/stat.h*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>读写权限</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/stat.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &quot;0&quot; 表示没有权限</span></span><br><span class="line"><span class="comment"> * &quot;1&quot; 表示可执行权限</span></span><br><span class="line"><span class="comment"> * &quot;2&quot; 表示可写权限</span></span><br><span class="line"><span class="comment"> * &quot;4&quot; 表示可读权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXU 00700 <span class="comment">//用户所有者拥有执行、写、读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUSR 00400 <span class="comment">//用户所有者拥有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUSR 00200 <span class="comment">//用户所有者拥有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUSR 00100 <span class="comment">//用户所有者拥有执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXG 00070 <span class="comment">//用户组拥有xxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRGRP 00040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWGRP 00020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXGRP 00010</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXO 00007 <span class="comment">//其他人拥有xxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IROTH 00004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWOTH 00002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXOTH 00001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/stat.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXUGO   (S_IRWXU|S_IRWXG|S_IRWXO) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IALLUGO   (S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUGO     (S_IRUSR|S_IRGRP|S_IROTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUGO     (S_IWUSR|S_IWGRP|S_IWOTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUGO     (S_IXUSR|S_IXGRP|S_IXOTH)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：kobject是目录，attribute是文件。</strong></p>
</blockquote>
<h3 id="4-sysfs-ops"><a href="#4-sysfs-ops" class="headerlink" title="4) sysfs_ops"></a>4) sysfs_ops</h3><p>属性文件操作函数，当 cat 属性文件时，会调用 kobj-&gt;ktype-&gt;sysfs_ops-&gt;show，当 echo 属性文件时调用 kobj-&gt;ktype-&gt;sysfs_ops-&gt;store 函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--include/linux/sysfs.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span></span> &#123;                                                                     <span class="comment">/* 对属性的操作函数 */</span></span><br><span class="line">        ssize_t (*show)(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *,<span class="built_in">char</span> *);                  <span class="comment">/* 读属性操作函数 */</span></span><br><span class="line">        ssize_t (*store)(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *,<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *,<span class="keyword">const</span> <span class="built_in">char</span> *, size_t);    <span class="comment">/* 写属性操作函数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、kobject-的创建与初始化"><a href="#2、kobject-的创建与初始化" class="headerlink" title="2、kobject 的创建与初始化"></a>2、kobject 的创建与初始化</h2><h3 id="1-kobject-create"><a href="#1-kobject-create" class="headerlink" title="1) kobject_create"></a>1) kobject_create</h3><p>该函数动态申请一个kobject结构，然后调用kobject_init对内部成员进行初始化,并且使用 dynamic_kobj_ktype 作为默认的 ktype</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kernel<span class="number">-4.9</span>/lib/kobject.c</span><br><span class="line"></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line"></span><br><span class="line">    kobj = kzalloc(<span class="keyword">sizeof</span>(*kobj), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kobject_init(kobj, &amp;dynamic_kobj_ktype);</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-init"><a href="#2-kobject-init" class="headerlink" title="2) kobject_init"></a>2) kobject_init</h3><p>该函数初始化kobj的ktype以及内部成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_init</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *err_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj) &#123;   <span class="comment">/* 检测kobj是否为NULL */</span></span><br><span class="line">        err_str = <span class="string">&quot;invalid kobject pointer!&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ktype) &#123;  <span class="comment">/* 检测ktype是否为NULL */</span></span><br><span class="line">        err_str = <span class="string">&quot;must have a ktype to be initialized properly!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_initialized) &#123; <span class="comment">/* 判断kobject是否已经被初始化过，如果初始化过给出警告 */</span></span><br><span class="line">        <span class="comment">/* do not error out as sometimes we can recover */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;kobject (%p): tried to init an initialized &quot;</span></span><br><span class="line">               <span class="string">&quot;object, something is seriously wrong.\n&quot;</span>, kobj);</span><br><span class="line">        dump_stack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kobject_init_internal(kobj);   <span class="comment">/* 初始化kobject内部成员 */</span></span><br><span class="line">    kobj-&gt;ktype = ktype;           <span class="comment">/* 设置ktype */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">error:</span><br><span class="line"></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;kobject (%p): %s\n&quot;</span>, kobj, err_str);</span><br><span class="line">    dump_stack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kobject-init-internal"><a href="#3-kobject-init-internal" class="headerlink" title="3) kobject_init_internal"></a>3) kobject_init_internal</h3><p>该函数初始化引用计数，entry链表以及状态位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_init_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj)	                         <span class="comment">/* 参数检测,确保kobj不为空 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    kref_init(&amp;kobj-&gt;kref);              <span class="comment">/* 引用计数初始化，初始化为1 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;kobj-&gt;entry);        <span class="comment">/* 初始化kobject链表 */</span></span><br><span class="line">    kobj-&gt;state_in_sysfs = <span class="number">0</span>;            <span class="comment">/* 状态位设置:未导出到sys中 */</span></span><br><span class="line">    kobj-&gt;state_add_uevent_sent = <span class="number">0</span>;     <span class="comment">/* 状态位设置:未添加uevent */</span> </span><br><span class="line">    kobj-&gt;state_remove_uevent_sent = <span class="number">0</span>;  <span class="comment">/* 状态位设置:未移除uevent */</span></span><br><span class="line">    kobj-&gt;state_initialized = <span class="number">1</span>;         <span class="comment">/* 状态位设置:已完成初始化 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kobject的创建与初始化基本也就反复用这三个接口了。</p>
</blockquote>
<h2 id="3、kobject-的注册"><a href="#3、kobject-的注册" class="headerlink" title="3、kobject 的注册"></a>3、kobject 的注册</h2><h3 id="1-kobject-add"><a href="#1-kobject-add" class="headerlink" title="1) kobject_add"></a>1) kobject_add</h3><p>设置 kobj 的 name 以及 parent 并将 kobject 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_add</span><span class="params">(struct kobject *kobj, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list vargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name_vargs(kobj, fmt, vargs); <span class="comment">//设置kobject的name</span></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;kobject: can not set name properly!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    kobj-&gt;parent = parent;			<span class="comment">//设置kobject的parent</span></span><br><span class="line">    <span class="keyword">return</span> kobject_add_internal(kobj);		<span class="comment">//在sys/中添加kobject的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-add-internal"><a href="#2-kobject-add-internal" class="headerlink" title="2) kobject_add_internal"></a>2) kobject_add_internal</h3><p>将 kobject 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_add_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj-&gt;name || !kobj-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        WARN(<span class="number">1</span>, <span class="string">&quot;kobject: (%p): attempted to be registered with empty &quot;</span></span><br><span class="line">             <span class="string">&quot;name!\n&quot;</span>, kobj);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent = kobject_get(kobj-&gt;parent); <span class="comment">//如果父节点存在，则增加父节点引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* join kset if set, use it as parent if we do not already have one */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;kset) &#123; <span class="comment">//判断是否存在 kset</span></span><br><span class="line">        <span class="keyword">if</span> (!parent)</span><br><span class="line">            parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj); <span class="comment">//如果父节点不存在则使用Kset-&gt;kobj作为父节点，并增加引用计数</span></span><br><span class="line">        kobj_kset_kobj_kset_leavejoin(kobj);  <span class="comment">//将kobject中的entry链接进入kset中的list链表。</span></span><br><span class="line">        kobj-&gt;parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: parent: &#x27;%s&#x27;, set: &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">         kobject_name(kobj), kobj, __func__,</span><br><span class="line">         parent ? kobject_name(parent) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>,</span><br><span class="line">         kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    error = create_dir(kobj); <span class="comment">//使用kobj创建目录和属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123; <span class="comment">//如果创建失败减少引用计数</span></span><br><span class="line">        kobj_kset_leave(kobj);</span><br><span class="line">        kobject_put(parent);</span><br><span class="line">        kobj-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* be noisy on error issues */</span></span><br><span class="line">        <span class="keyword">if</span> (error == -EEXIST)</span><br><span class="line">            pr_err(<span class="string">&quot;%s failed for %s with -EEXIST, don&#x27;t try to register things with the same name in the same directory.\n&quot;</span>,</span><br><span class="line">                   __func__, kobject_name(kobj));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pr_err(<span class="string">&quot;%s failed for %s (error: %d parent: %s)\n&quot;</span>,</span><br><span class="line">                   __func__, kobject_name(kobj), error,</span><br><span class="line">                   parent ? kobject_name(parent) : <span class="string">&quot;&#x27;none&#x27;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        kobj-&gt;state_in_sysfs = <span class="number">1</span>; <span class="comment">//如果创建成功。将state_in_sysfs建为1。表示该object已经在sysfs中了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便理解我在这里附上 create_dir 、 sysfs_create_dir_ns 以及 populate_dir 的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_dir</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); <span class="comment">//创建kobj目录</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    error = populate_dir(kobj); <span class="comment">//创建kobj默认属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        sysfs_remove_dir(kobj);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分代码***/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_dir_ns</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> <span class="keyword">void</span> *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">parent</span>, *<span class="title">kn</span>;</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(!kobj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;parent) <span class="comment">//判断parent是否存在，如果不存在则在sys/下创建目录</span></span><br><span class="line">        parent = kobj-&gt;parent-&gt;sd; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent = sysfs_root_kn; <span class="comment">// sys/ 所在目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!parent)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    kn = kernfs_create_dir_ns(parent, kobject_name(kobj),</span><br><span class="line">                  S_IRWXU | S_IRUGO | S_IXUGO, kobj, ns); <span class="comment">//创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kn)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(kn) == -EEXIST)</span><br><span class="line">            sysfs_warn_dup(parent, kobject_name(kobj));</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(kn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kobj-&gt;sd = kn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">populate_dir</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> =</span> get_ktype(kobj);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; t-&gt;default_attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; (attr = t-&gt;default_attrs[i]) != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">            error = sysfs_create_file(kobj, attr); <span class="comment">//遍历default_attrs，创建存在的属性文件</span></span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kobjcet的注册主要完成了下面三件事情</p>
<ol>
<li>判断父节点是否存在，如果存在增加父节点引用计数，判断是否存在 kset 如果存在则链接进 kset ，如果 kset 存在且父节点不存在则使用 Kset-&gt;kobj 作为父节点，增加 kset 点引用计数</li>
<li>调用 create_dir 为kobj创建目录和属性文件，在 create_dir 中调用 sysfs_create_dir_ns 为 kobject 创建目录，创建时会判断如果父节点为NULL则使用 sysfs_root_kn 作为父节点，即直接在 sys/ 目录下创建当前目录，在 create_dir 中调用 populate_dir 遍历属性文件链表创建默认属性文件</li>
<li>创建成功则设置 state_in_sysfs 为 1</li>
</ol>
</blockquote>
<p>内核也提供了一些组合API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是将kobject_creat 函数和 kobject_add 函数组合在一起的函数，创建并注册一个 kobject 到内核。</span></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, struct kobject *parent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//就是将 kobject_init 函数和 kobject_add 函数组合在一起的函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_init_and_add</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>》上面的api这么多，可以根据需要灵活选择来创建并注册kobj，我也总结了一条很简单的原则：</p>
<blockquote>
<ul>
<li><font color=red><strong>如果你的 kobject 不需要嵌入到更大的数据结构则使用 kobject_create_and_add</strong></font></li>
<li><font color=red><strong>反之如果你的 kobject 需要嵌入到更大的数据结构则使用 kobject_init_and_add</strong></font></li>
</ul>
</blockquote>
<p>为什么这么选择呢这涉及到后文提到的对对象生命周期管理的内容，这里只需记住这两条规则就行了。</p>
<h3 id="3-编程实验-1"><a href="#3-编程实验-1" class="headerlink" title="3) 编程实验 1"></a>3) 编程实验 1</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;光说不练假把式，这个实验很简单，我们只需要再内核中创建一个名为 my_kobject 的目录，并不需要将 kobject 嵌入到其他数据结构因此选择使用 kobject_create_and_add</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>)<span class="comment">;</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct kobject *my_kobj<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> my_kobject_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    my_kobj = kobject_create_and_add(<span class="string">&quot;my_kobject&quot;</span>, <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void my_kobject_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    kobject_del(my_kobj)<span class="comment">;</span></span><br><span class="line">    kfree(my_kobj)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_kobject_init)<span class="comment">;</span></span><br><span class="line">module_exit(my_kobject_exit)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_kobject</span> <span class="title">power</span> //加载后生成 <span class="title">my_kobject</span> 目录</span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># rmmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span> //卸载后移除 <span class="title">my_kobject</span> 目录</span></span><br></pre></td></tr></table></figure>
<p>上面这种方式内核也用的挺多的，例如我们熟悉的 /sys/dev 、/sys/dev/char 、/sys/dev/block 等都是用这个方式创建的。</p>
<h3 id="4-编程实验-2"><a href="#4-编程实验-2" class="headerlink" title="4) 编程实验 2"></a>4) 编程实验 2</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在sys/下创建一个叫做 my_dir 的目录，这里我们将 kobject 嵌入到我们自己创建的结构中，于是选择 kobject_init_and_add 来创建目录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_del(&amp;my_dirp-&gt;kobj);</span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">k85v1_64:<span class="regexp">/ # ls sys/</span></span><br><span class="line">block<span class="regexp">/     bus/</span>       dev<span class="regexp">/       firmware/</span>  kernel<span class="regexp">/    mtk_rgu/</span></span><br><span class="line">bootinfo<span class="regexp">/  class/</span>     devices<span class="regexp">/   fs/</span>        module<span class="regexp">/    power/</span></span><br><span class="line">k85v1_64:<span class="regexp">/ # ls sys/</span></span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu power</span><br><span class="line">k85v1_64:/ <span class="comment">#</span></span><br><span class="line">k85v1_64:<span class="regexp">/ # cd cache/</span></span><br><span class="line">k85v1_64:/cache <span class="comment"># insmod my_kobject.ko </span></span><br><span class="line">k85v1_64:<span class="regexp">/cache # ls /</span>sys/</span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu my_dir power <span class="regexp">//</span>加载后生成 my_dir 目录</span><br><span class="line">k85v1_64:/cache <span class="comment"># </span></span><br><span class="line"><span class="number">2</span>|k85v1_64:<span class="regexp">/cache # cd /</span>sys<span class="regexp">/my_dir/</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment"># ls</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment">#</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment"># cd ..</span></span><br><span class="line">k85v1_64:/sys <span class="comment"># rmmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/sys <span class="comment"># ls</span></span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu power <span class="regexp">//</span>卸载后移除 my_dir 目录</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;看起来这种方式更加复杂，但实际上我们的 bus、 device、 device_driver 等都是使用这个方式，使用这个方式的优点见后文 “对象生命周期管理”以及”用户空间与内核信息交互”。</p>
<h2 id="4、在-sys-下组织出目录层次"><a href="#4、在-sys-下组织出目录层次" class="headerlink" title="4、在 sys/ 下组织出目录层次"></a>4、在 sys/ 下组织出目录层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;object的核心功能之一，利用 kobject.parent 组织出文件的目录层次，前面 kobject 的注册已经分析的很清楚了这里就不再赘述了，内核还提供了链接文件的创建接口。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在kobj目录下创建指向target目录的软链接，name 为软链接文件名称</span></span><br><span class="line"><span class="built_in">int</span> __must_check sysfs<span class="constructor">_create_link(<span class="params">struct</span> <span class="params">kobject</span> <span class="operator">*</span><span class="params">kobj</span>, <span class="params">struct</span> <span class="params">kobject</span> <span class="operator">*</span><span class="params">target</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">name</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>编程实验</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个实验很简单，在/sys/目录下创建一个目录 father 然后在这个目录下创建两个子文件 son1 和 son2，再在 son1 下创建一个链接到 son2 的链接文件 link_to_son2。 只是单纯的展示层次目录关系，因此无需将kobject嵌入到更大的数据结构，采用 kobject_create_and_add 来注册</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">father</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">son1</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">son2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_kobject_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在 /sys/ 目录下创建一个目录 father</span></span><br><span class="line">    father = kobject_create_and_add(<span class="string">&quot;father&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 father 目录下创建两个子文件 son1 和 son2</span></span><br><span class="line">    son1 = kobject_create_and_add(<span class="string">&quot;son1&quot;</span>, father);</span><br><span class="line">    son2 = kobject_create_and_add(<span class="string">&quot;son2&quot;</span>, father);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 son1 下创建一个链接到son2的链接文件 link_to_son2</span></span><br><span class="line">    sysfs_create_link(son1, son2, <span class="string">&quot;link_to_son2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_kobject_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_del(father);</span><br><span class="line">    kfree(father);</span><br><span class="line"></span><br><span class="line">    kobject_del(son1);</span><br><span class="line">    kfree(son1);</span><br><span class="line"></span><br><span class="line">    kobject_del(son2);</span><br><span class="line">    kfree(son2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_kobject_init);</span><br><span class="line">module_exit(my_kobject_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">k85v1_64</span>:/cache # insmod my_kobject.ko</span><br><span class="line"><span class="attribute">k85v1_64</span>:/cache #</span><br><span class="line"><span class="attribute">k85v1_64</span>:/cache # cd /sys/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys # ls</span><br><span class="line"><span class="attribute">block</span> bootinfo bus class dev devices father firmware fs kernel module mtk_rgu power  //创建出的 father</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys # cd father/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father # ls</span><br><span class="line"><span class="attribute">son1</span> son<span class="number">2</span> //创建出的 son<span class="number">1</span> son<span class="number">2</span></span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father # cd son<span class="number">1</span>/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> # ls</span><br><span class="line"><span class="attribute">link_to_son2</span></span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> # ls -la</span><br><span class="line"><span class="attribute">total</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">drwxr</span>-xr-x <span class="number">2</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">40</span> .</span><br><span class="line"><span class="attribute">drwxr</span>-xr-x <span class="number">4</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">40</span> ..</span><br><span class="line"><span class="attribute">lrwxrwxrwx</span> <span class="number">1</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">41</span> link_to_son<span class="number">2</span> -&gt; ../son<span class="number">2</span> //创建出的链接文件</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> #</span><br></pre></td></tr></table></figure>
<h2 id="5、kobj-对象生命周期管理"><a href="#5、kobj-对象生命周期管理" class="headerlink" title="5、kobj 对象生命周期管理"></a>5、kobj 对象生命周期管理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 还有一个非常强大的功能就是管理所嵌入的对象的生命周期，而引用计数 kref 则是它管理所嵌入对象生命周期的核心。对于kerf内核提供了两个下面函数来进行操作。</p>
<h3 id="1-kobject-get"><a href="#1-kobject-get" class="headerlink" title="1) kobject_get"></a>1) kobject_get</h3><p>增加kobj引用计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_get - increment refcount for object.</span></span><br><span class="line"><span class="comment"> * @kobj: object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_get</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">                   <span class="string">&quot;initialized, yet kobject_get() is being &quot;</span></span><br><span class="line">                   <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">        kref_get(&amp;kobj-&gt;kref); <span class="comment">//增加引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-put"><a href="#2-kobject-put" class="headerlink" title="2) kobject_put"></a>2) kobject_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_put</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">                   <span class="string">&quot;initialized, yet kobject_put() is being &quot;</span></span><br><span class="line">                   <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">        kref_put(&amp;kobj-&gt;kref, kobject_release); <span class="comment">//调用kref_put减少引用计数，同时传入回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 kref_put 减少引用计数，同时传入回调函数 kobject_release，该回调函数在引用计数为0时调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kref_put</span><span class="params">(struct kref *kref, <span class="keyword">void</span> (*release)(struct kref *kref))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        WARN_ON(release == <span class="literal">NULL</span>);</span><br><span class="line">        WARN_ON(release == (<span class="keyword">void</span> (*)(struct kref *))kfree);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (atomic_dec_and_test(&amp;kref-&gt;refcount)) &#123;   <span class="comment">/* 当引用计数为0时，调用 release 函数进行资源的释放  */</span></span><br><span class="line">                release(kref);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少引用计数，当 kref 为 0 时调用传入的 release 回调函数，即前面的 kobject_release 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_release</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        kobject_cleanup(container_of(kref, struct kobject, kref)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kobject_put 传入的回调函数，使用 container_of 函数获取到包含 kref 的 kobjec 结构地址，并传入 kobject_cleanup</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kobject_cleanup - free kobject resources.</span></span><br><span class="line"><span class="comment"> * @kobj: object to cleanup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_cleanup</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> =</span> get_ktype(kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = kobj-&gt;name;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s, parent %p\n&quot;</span>,</span><br><span class="line">         kobject_name(kobj), kobj, __func__, kobj-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; !t-&gt;release) <span class="comment">// 判断 release 函数是否存在</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): does not have a release() &quot;</span></span><br><span class="line">             <span class="string">&quot;function, it is broken and must be fixed.\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send &quot;remove&quot; if the caller did not do it but sent &quot;add&quot; */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_add_uevent_sent &amp;&amp; !kobj-&gt;state_remove_uevent_sent) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): auto cleanup &#x27;remove&#x27; event\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        kobject_uevent(kobj, KOBJ_REMOVE); <span class="comment">//发送 uevent 事件 KOBJ_REMOVE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove from sysfs if the caller did not do it */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_in_sysfs) &#123; <span class="comment">// 如果在sys中存在kobj则调用kobject_del删除kobj</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): auto cleanup kobject_del\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        kobject_del(kobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; t-&gt;release) &#123; <span class="comment">//如果release存在则调用release函数</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): calling ktype release\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        t-&gt;release(kobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free name if we allocated it */</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123; <span class="comment">// 释放name空间</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27;: free name\n&quot;</span>, name);</span><br><span class="line">        kfree_const(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;判断 kobj 的 release 函数是否存在，如果在 sys 中存在 kobj 则调用 kobject_del 删除 kobj, 如果 release 存在则调用 release 函数，该函数需要自己实现，如果是用  kobject_create 创建的 kobj，则会使用默认 dynamic_kobj_ktype 中的 release。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_del - unlink kobject from hierarchy.</span></span><br><span class="line"><span class="comment"> * @kobj: object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_del</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    sd = kobj-&gt;sd;</span><br><span class="line">    sysfs_remove_dir(kobj); <span class="comment">//删除sys目录相关文件</span></span><br><span class="line">    sysfs_put(sd);</span><br><span class="line"></span><br><span class="line">    kobj-&gt;state_in_sysfs = <span class="number">0</span>;</span><br><span class="line">    kobj_kset_leave(kobj);  	<span class="comment">//删除所属的kset链表中的kobj成员，减少该kset引用计数 </span></span><br><span class="line">    kobject_put(kobj-&gt;parent);  <span class="comment">//减少parent计数</span></span><br><span class="line">    kobj-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除sys目录相关文件，减少parent引用计数，并调用 kobj_kset_leave函数从 kset list 中移除这个kobject</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove the kobject from its kset&#x27;s list */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobj_kset_leave</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj-&gt;kset)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">    list_del_init(&amp;kobj-&gt;entry);</span><br><span class="line">    spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">    kset_put(kobj-&gt;kset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到 kobject_put 的实现比较复杂，但总的来说它也就完成了下面几件事情</p>
<ol>
<li>减少 kobject 引用计数，当 kobject 引用计数为 0 时调用 kobject-&gt;ktype-&gt;release 函数。</li>
<li>向用户空间发送 uevent 事件 KOBJ_REMOVE</li>
<li>调用 kobject_del 删除 sys 目录相关文件，从属于的kset链表中删除该 kobj 成员，减少 kset 引用计数，减少 parent 的引用计数(这里分别减少了parent的和所属的kset的引用计数) </li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中我们需要实现的也就是这个回调函数 kobject-&gt;ktype-&gt;release ，但实际上内核提供的设备模型已经都实现好了，例如 bus 总线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bus_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span> =</span> to_subsys_private(kobj);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> priv-&gt;bus;</span><br><span class="line"></span><br><span class="line">    kfree(priv);</span><br><span class="line">    bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">bus_ktype</span> =</span> &#123;</span><br><span class="line">    .sysfs_ops  = &amp;bus_sysfs_ops,</span><br><span class="line">    .release    = bus_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其他的device，device_driver，等凡是内核提供的结构基本内核都帮我们设计好了它的relase函数</p>
<h3 id="3-优化-my-dir"><a href="#3-优化-my-dir" class="headerlink" title="3) 优化 my_dir"></a>3) 优化 my_dir</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;有了上面知识了之后我们也可以用其来优化我们前面创建的 my_dir, 给我们的 my_dir 增加自动释放自身数据结构的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit); </span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_dir</span> <span class="title">power</span> //这里创建出 <span class="title">my_dir</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache <span class="meta"># rmmod my_kobject.ko</span></span><br><span class="line">于此同时内核打印出下面<span class="built_in">log</span></span><br><span class="line">[   <span class="number">52.897412</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">2526</span>:rmmod] my dir release</span><br><span class="line"></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span> //<span class="title">mydir</span> 被移除</span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache # </span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里用了一个非常巧妙的方式实现了，利用 kobject 释放其所嵌入的更大的数据结构的功能，从而实现对 my_dir 生命周期的管理，于是可以得到下面这个结论： <strong><font color = red>凡是需要做对象生命周期管理的对象，都可以通过内嵌kobject来实现需求</font></strong> </p>
<p>该结论来自窝窝科技的文章 <a target="_blank" rel="noopener" href="http://www.wowotech.net/device_model/421.html">http://www.wowotech.net/device_model/421.html</a></p>
<h2 id="6、用户空间与内核信息交互"><a href="#6、用户空间与内核信息交互" class="headerlink" title="6、用户空间与内核信息交互"></a>6、用户空间与内核信息交互</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 的另一个核心功能就是能实现用户空间与内核空间的信息交互，我们知道每一个注册的 kobject 都会在 /sys 中以目录的形式呈现，也就是 bus 等数据结构可以利用嵌入 kobject 可以使它显示在 /sys 中。内核为我们提供了快速修改获取内核中 bus 相关的信息(这些信息可以是变量，字符串等)的方法”属性文件(attribute)”。属性文件就是内核空间和用户空间交互信息的一种方法。在Linux内核中，attribute分为普通的attribute和二进制attribute，这里只记录普通的，二进制的没研究，后面有机会研究了再补充(希望渺茫)</p>
<h3 id="1-属性文件调用逻辑"><a href="#1-属性文件调用逻辑" class="headerlink" title="1) 属性文件调用逻辑"></a>1) 属性文件调用逻辑</h3><p>在 fs/sysfs/file.c 文件下查看相关的逻辑代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct sysfs_ops *<span class="title">sysfs_file_ops</span><span class="params">(struct kernfs_node *kn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> kn-&gt;parent-&gt;priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kn-&gt;flags &amp; KERNFS_LOCKDEP)</span><br><span class="line">        lockdep_assert_held(kn);</span><br><span class="line">    <span class="keyword">return</span> kobj-&gt;ktype ? kobj-&gt;ktype-&gt;sysfs_ops : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kernfs read callback for regular sysfs files with pre-alloc */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">sysfs_kf_read</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">	...</span><br><span class="line">    len = ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">min_t</span>(<span class="keyword">ssize_t</span>, count, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">sysfs_kf_write</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!count)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ops-&gt;store(kobj, of-&gt;kn-&gt;priv, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;代码很简单就不注释了，看起来处理过程很简单在 cat/echo 属性文件时(读/写属性文件写数据时)，先调用 sysfs_file_ops 获取到 kobj-&gt;ktype-&gt;sysfs_ops 指针，在调用对应内核的 show/store 函数。从这里可以看出对于用户空间来讲，只负责把数据丢给内核的store以及从内核的show获取数据，至于store的数据用来做什么和show获取到什么数据则由内核决定。这里还可以得出结论：<font color=red>如果从属的 kobject（就是 attribute 文件所在的目录）没有 ktype，或者没有 ktype-&gt;sysfs_ops 指针，是不允许它注册任何 attribute 的</font></p>
<h3 id="2-属性文件的创建以及删除"><a href="#2-属性文件的创建以及删除" class="headerlink" title="2) 属性文件的创建以及删除"></a>2) 属性文件的创建以及删除</h3><p>内核也提供了创建属性文件的api</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include/linux/sysfs.h</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_file</span><span class="params">(struct kobject *kobj, struct attribute *attr)</span></span>; <span class="comment">//在传入的kobj下创建attr属性文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sysfs_remove_file</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute *attr)</span> <span class="comment">//在传入的kobj下移除attr属性文件</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_files</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute **ptr)</span> <span class="comment">//在kobj下创建传入的prt指向的一组属性文件</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sysfs_remove_files</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute **attr)</span></span>;<span class="comment">//在kobj下移除传入的prt指向的一组属性文件</span></span><br></pre></td></tr></table></figure>
<h3 id="3-在-my-dir-下创建属性文件"><a href="#3-在-my-dir-下创建属性文件" class="headerlink" title="3) 在 my_dir 下创建属性文件"></a>3) 在 my_dir 下创建属性文件</h3><p>动手实践一下，在 my_dir 下创建两个属性文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读属性操作函数, cat 属性文件时调用这个函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_show</span><span class="params">(struct kobject *kobj, struct attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir show  attr-&gt;name : %s\n&quot;</span>, attr-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s\n&quot;</span>, attr-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>((<span class="keyword">char</span>*)attr-&gt;name) +<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写属性操作文件, echo 属性文件时调用这个函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_store</span><span class="params">(struct kobject *kobj,struct attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my dir store : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有 kobj_type 同时还要存在 my_sysfs_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">my_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show  = my_dir_show,</span><br><span class="line">    .store = my_dir_store,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要创建属性文件首先要有 kobj_type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">    .sysfs_ops = &amp;my_sysfs_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个注册的 attribute 结构都是一个属性文件，这里创建两个属性文件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">my_dir_attr1</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_dir_attr1&quot;</span>,</span><br><span class="line">    .mode = S_IRWXUGO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">my_dir_attr2</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_dir_attr2&quot;</span>,</span><br><span class="line">    .mode = S_IRWXUGO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr1 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr2 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko <span class="comment">//加载模块</span></span></span><br><span class="line">k85v1_64:/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># cd /sys/</span></span><br><span class="line">k85v1_64:/sys <span class="meta"># ls</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_dir</span> <span class="title">power</span> //查看生成了 <span class="title">my_dir</span></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/sys <span class="meta"># cd my_dir/  <span class="comment">//进入 my_dir</span></span></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># ls</span></span><br><span class="line">my_dir_attr1 my_dir_attr2   <span class="comment">//查看生成了  my_dir_attr1 my_dir_attr2</span></span><br><span class="line">k85v1_64:/sys/my_dir #</span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># echo 123 &gt; my_dir_attr1 <span class="comment">//写入123</span></span></span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[  <span class="number">848.043148</span>] &lt;<span class="number">0</span>&gt;.(<span class="number">0</span>)[<span class="number">5617</span>:sh]my dir store : <span class="number">123</span></span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># cat my_dir_attr1  <span class="comment">//读取数据</span></span></span><br><span class="line">my_dir_attr1</span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1002.452204</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">8065</span>:cat]my dir show  attr-&gt;name : my_dir_attr1</span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir #</span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># echo 222 &gt; my_dir_attr2</span></span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1028.696923</span>] &lt;<span class="number">1</span>&gt;.(<span class="number">1</span>)[<span class="number">5617</span>:sh]my dir store : <span class="number">222</span></span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># cat my_dir_attr2</span></span><br><span class="line">my_dir_attr2</span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1033.116307</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">8397</span>:cat]my dir show  attr-&gt;name : my_dir_attr2</span><br></pre></td></tr></table></figure>
<h3 id="4-优化属性文件操作"><a href="#4-优化属性文件操作" class="headerlink" title="4) 优化属性文件操作"></a>4) 优化属性文件操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子我们虽然创建了属性文件，也能操作属性文件，但是两个属性文件最终都是调用的同一个 show/store 函数，即这种方式的属性文件拥有共用的属性操作函数。而这样明显属性文件就失去了它的独立性。 </p>
<blockquote>
<p>怎么实现属性文件自己的 show/store ？<br>我们可以将 attribute 嵌入到更大的数据结构中，该数据结构包含真正的 show/store 函数然后使用 my_dir_type 中的 show/store 函数作为中转函数，利用 container_of 调用属性文件真正的 show/store 函数</p>
</blockquote>
<p>于是我们调整代码架构将通用的部分提取出来作为 my_kobject_core.c 这部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_kobject_core.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构 struct my_dir</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读属性文件操作函数中间层 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_show</span><span class="params">(struct kobject *kobj, struct attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> *<span class="title">my_attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">    my_attr = container_of(attr, struct my_attribute, attr);</span><br><span class="line">    <span class="keyword">if</span> (my_attr-&gt;show)</span><br><span class="line">        ret = my_attr-&gt;show(kobj, my_attr, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写属性文件操作函数中间层 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_store</span><span class="params">(struct kobject *kobj,struct attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> *<span class="title">my_attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">    my_attr = container_of(attr, struct my_attribute, attr);</span><br><span class="line">    <span class="keyword">if</span> (my_attr-&gt;store)</span><br><span class="line">        ret = my_attr-&gt;store(kobj, my_attr, buf, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有 kobj_type 同时还要存在 my_sysfs_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">my_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show  = my_dir_show,</span><br><span class="line">    .store = my_dir_store,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要创建属性文件首先要有 kobj_type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">    .sysfs_ops = &amp;my_sysfs_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 /sys/ 下创建一个名为 name dir */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_regiseter</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(my_dir_regiseter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 移除注册的 my_dir */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_unregiseter</span><span class="params">(struct my_dir* my_dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(my_dirp)</span><br><span class="line">        kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(my_dir_unregiseter);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们将公共的部分放在头文件my_kobject_core.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _KOBJECT_CORE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _KOBJECT_CORE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span>  date;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span> <span class="comment">//将 attribute 嵌入到更大的数据结构中</span></span><br><span class="line">    <span class="comment">//真正的 show/store函数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> struct my_dir* <span class="title">my_dir_regiseter</span><span class="params">(<span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">my_dir_unregiseter</span><span class="params">(struct my_dir* my_dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在我们想要创建目录的时候就调用 my_dir_regiseter 来创建 my_dir，想要创建属性文件的时候调用 sysfs_create_file 来创建。 于是在我们真正在 my_kobject.c 中创建 my_dir 以及其属性文件如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_kobject_core.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr1 自己的 show 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_attr1_show</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s : %d\n&quot;</span>, attr-&gt;attr.name, my_dirp-&gt;date);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr1 自己的 store 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span>  <span class="title">my_dir_attr1_store</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于输入的是字符串这里做一个简单的转换，并不严谨仅用于展示功能</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; buf[i] &lt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            tmp = <span class="number">10</span> *tmp + (buf[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;date = tmp;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s store :  my_dirp-&gt;date = %d, buf = %s\n&quot;</span>,attr-&gt;attr.name, my_dirp-&gt;date, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr2 自己的 show 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_attr2_show</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s : %d\n&quot;</span>, attr-&gt;attr.name, my_dirp-&gt;date);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr2 自己的 store 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span>  <span class="title">my_dir_attr2_store</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于输入的是字符串这里做一个简单的转换，并不严谨仅用于展示功能</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; buf[i] &lt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            tmp = <span class="number">10</span> *tmp + (buf[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;date = tmp;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s store :  my_dirp-&gt;date = %d, buf = %s\n&quot;</span>,attr-&gt;attr.name, my_dirp-&gt;date, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里创建两个属性文件 my_dir_attr1、my_dir_attr2 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> <span class="title">my_dir_attr1</span> =</span> &#123;</span><br><span class="line">    .attr =&#123;</span><br><span class="line">        .name = <span class="string">&quot;my_dir_attr1&quot;</span>,</span><br><span class="line">        .mode = S_IRWXUGO,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    .show  = my_dir_attr1_show,</span><br><span class="line">    .store = my_dir_attr1_store,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> <span class="title">my_dir_attr2</span> =</span> &#123;</span><br><span class="line">    .attr =&#123;</span><br><span class="line">        .name = <span class="string">&quot;my_dir_attr2&quot;</span>,</span><br><span class="line">        .mode = S_IRWXUGO,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    .show  = my_dir_attr2_show,</span><br><span class="line">    .store = my_dir_attr2_store,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_dirp = my_dir_regiseter(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr1 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr1.attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr2 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr2.attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_dir_unregiseter(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>验证结果：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># insmod my_kobject_core.ko</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># cd /sys/my_dir/</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># ls</span></span><br><span class="line">my_dir_attr1 my_dir_attr2</span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># echo 11 &gt; my_dir_attr1</span></span><br><span class="line"><span class="comment">//同时内核打印出</span></span><br><span class="line">[ <span class="number">5223.566440</span>] <span class="params">&lt;<span class="number">2</span>&gt;</span>.(<span class="number">2</span>)[<span class="number">23263</span>:sh]my_dir_attr1 store :  my_dirp-&gt;date = <span class="number">11</span>, buf = <span class="number">11</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># cat my_dir_attr1</span></span><br><span class="line">my_dir_attr1 : <span class="number">11</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># echo 22 &gt; my_dir_attr2</span></span><br><span class="line"><span class="comment">//同时内核打印出</span></span><br><span class="line">[ <span class="number">5248.493173</span>] <span class="params">&lt;<span class="number">3</span>&gt;</span>.(<span class="number">3</span>)[<span class="number">23263</span>:sh]my_dir_attr2 store :  my_dirp-&gt;date = <span class="number">22</span>, buf = <span class="number">22</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># cat my_dir_attr2</span></span><br><span class="line">my_dir_attr2 : <span class="number">22</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面的逻辑实现比前面的代码要复杂一点点，可以花点时间看一下，这个方式的牛逼之处在于通过 kobject 我们将我们自己创建的数据结构 struct my_dir 开放到用户空间，以目录的形式呈现出来，同时通过属性文件用户空间能够获取和修改 my_dir.date 这个属于my_dir的成员变量。内核的bus、device、device_driver 等设备模型不过是在这个基础之上增加了一些其他功能，如设备和驱动的匹配等。</p>
<blockquote>
<p><strong><font color=red>错误纠正</font></strong><br><strong><font color=red>前面的代码里面有一处错误，MODULE_AUTHOR(“baron”); MODULE_LICENSE(“GPL”); 这两句代码一定要放在代码最后！！！ ，因为前面没有用 EXPORT_SYMBOL_GPL 模块导出符所以不会有什么影响。</font></strong></p>
</blockquote>
<h1 id="二、kset"><a href="#二、kset" class="headerlink" title="二、kset"></a>二、kset</h1><p>kset的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/kobject.h, line 159 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 该Kset下所有的Kobject都被链接进入该节点               </span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>  <span class="comment">// kset也是kobj的一种，因为c语言无法向面向对象一样继承，因此只能使用这种方式。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 该kset的uevent操作函数集。</span></span><br><span class="line"><span class="comment">    * 当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，</span></span><br><span class="line"><span class="comment">    * 添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。</span></span><br><span class="line"><span class="comment">    * 因此，如果一个kobject不属于任何kset时，是不允许发送uevent的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;因为 kset 本身包含 kobject 结构，因此拥有上述 kobject 的所有特性，而 kset 除了上述的 kobject 的所有功能之外，同时也和它有所区别。要想知道区别是什么就得知道，它多出来的数据结构是干啥的。可以看出主要多出了两个数据结构 list 和 kset_uevent_ops，在前面的 kobject_add 分析中可以知道,只要是 kobject 属于某个 kset 那么都会被链接到所属的 kset 中的 list 链表。 <strong>也就是 kset 具有管理 kobject 的功能</strong>，举个栗子，例如： 当 kernel 关机时， 会在 device_shutdown  中利用 devices_kset-&gt;list 找到该链表上的所有设备，并做相应的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_shutdown</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>, *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过 kset-&gt;list 链表找到链表上的所有设备</span></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;devices_kset-&gt;<span class="built_in">list</span>)) &#123;</span><br><span class="line">        dev = list_entry(devices_kset-&gt;<span class="built_in">list</span>.prev, struct device,  kobj.entry);</span><br><span class="line">	</span><br><span class="line">		...... <span class="comment">//对所有的设备做相关操作</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;除此之外，我们所熟知的热插拔机制的功能也是由 kset 提供的，热插拔指的是当一个设备加入系统，内核如何通知用户空间。感兴趣可以看看这篇文章：<a target="_blank" rel="noopener" href="http://bbs.chinaunix.net/thread-3678367-1-1.html">http://bbs.chinaunix.net/thread-3678367-1-1.html</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;热插拔大致的可以分为两个部分组成，内核部分和用户空间部分，而 kset则负责将事件发送到用户空间，而发送的方式则是 uevent。 大致的流程如下</p>
<blockquote>
<p>外设接入设备，设备产生中断<br>内核响应中断，调用 device_add 添加新设备<br>在device_add中会调用 kobject_uevent 将事件通知给用户空间</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于热插拔的内容相对复杂可以单独成文，而且也不影响对设备模型的理解，因此这里只提一下它的功能，关于热插拔更加详细的内容后面认真学习之后再整理出一篇文章。</p>
<h2 id="1、-kset的创建与注册"><a href="#1、-kset的创建与注册" class="headerlink" title="1、 kset的创建与注册"></a>1、 kset的创建与注册</h2><h3 id="1-kset-create"><a href="#1-kset-create" class="headerlink" title="1) kset_create"></a>1) kset_create</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;动态获取一个 kset 内存空间,初始化 uevent_ops ,初始化 parent_kobj ,<strong>初始化一个内核默认的 kset_ktype</strong> ,初始化 kset 中的 kset 为NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kset *<span class="title">kset_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct kset_uevent_ops *uevent_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    kset = kzalloc(<span class="keyword">sizeof</span>(*kset), GFP_KERNEL); <span class="comment">//动态获得一个 kset 内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (!kset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name(&amp;kset-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name); <span class="comment">//初始化 name</span></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        kfree(kset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kset-&gt;uevent_ops = uevent_ops; 	<span class="comment">//初始化 uenent_ops</span></span><br><span class="line">    kset-&gt;kobj.parent = parent_kobj;    <span class="comment">//初始化 parent_kobj</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The kobject of this kset will have a type of kset_ktype and belong to</span></span><br><span class="line"><span class="comment">     * no kset itself.  That way we can properly free it when it is</span></span><br><span class="line"><span class="comment">     * finished being used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kset-&gt;kobj.ktype = &amp;kset_ktype;  <span class="comment">//初始化该 kset 的 ktype</span></span><br><span class="line">    kset-&gt;kobj.kset = <span class="literal">NULL</span>;	     <span class="comment">//kset 的 kset 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kset-init"><a href="#2-kset-init" class="headerlink" title="2) kset_init"></a>2) kset_init</h3><p>初始化kset的kobj成员，初始化list链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_init - initialize a kset for use</span></span><br><span class="line"><span class="comment"> * @k: kset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_init</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_init_internal(&amp;k-&gt;kobj); <span class="comment">//初始化kobj成员</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;k-&gt;<span class="built_in">list</span>); <span class="comment">//初始化list链表</span></span><br><span class="line">    spin_lock_init(&amp;k-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kset-register"><a href="#3-kset-register" class="headerlink" title="3) kset_register"></a>3) kset_register</h3><p>将 kset 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_register - initialize and add a kset.</span></span><br><span class="line"><span class="comment"> * @k: kset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_register</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    kset_init(k); <span class="comment">//调用kset_init初始化kobj成员，初始化list链表</span></span><br><span class="line">    err = kobject_add_internal(&amp;k-&gt;kobj); <span class="comment">//注册kobj即生成kset对应的目录</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD); <span class="comment">//发送uevent事件，KOBJ_ADD</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kset-create-and-add"><a href="#3-kset-create-and-add" class="headerlink" title="3) kset_create_and_add"></a>3) kset_create_and_add</h3><p>动态创建一个kset结构，并将其注册,其实就是 kset_create 和 kset_register 的组合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kset *<span class="title">kset_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> struct kset_uevent_ops *uevent_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    kset = kset_create(name, uevent_ops, parent_kobj); <span class="comment">//动态创建 kset</span></span><br><span class="line">    <span class="keyword">if</span> (!kset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    error = kset_register(kset); <span class="comment">//注册kset</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(kset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kset 的创建与注册的函数的选择和前面的kobject一样:</p>
<blockquote>
<p><font color=red>当 kset 需要嵌入到更大的数据结构时使用 kset_register</font><br><font color=red>当 kset 不需嵌入到更大的数据结构时使用 kset_create_and_add</font></p>
</blockquote>
<h2 id="2、卸载kset"><a href="#2、卸载kset" class="headerlink" title="2、卸载kset"></a>2、卸载kset</h2><h3 id="1-kset-unregister"><a href="#1-kset-unregister" class="headerlink" title="1) kset_unregister"></a>1) kset_unregister</h3><p>从卸载一个keset</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_unregister - remove a kset.</span></span><br><span class="line"><span class="comment"> * @k: kset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    kobject_del(&amp;k-&gt;kobj);</span><br><span class="line">    kobject_put(&amp;k-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kset-put"><a href="#2-kset-put" class="headerlink" title="2) kset_put"></a>2) kset_put</h3><p>减少kset的kobj成员引用计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kset_put</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;k-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、bus总线"><a href="#三、bus总线" class="headerlink" title="三、bus总线"></a>三、bus总线</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux 认为<font color=red>总线是CPU和一个或多个设备之间信息交互的通道</font>。就设备模型而言，所有设备都是通过总线连接的，<strong>这样的总线有两类</strong>：</p>
<blockquote>
<ul>
<li>第一类是i2c、spi、usb 等这类总线，这类总线有实际的物理总线，它本身就有总线这个概念，我们直接根据功能将其抽象出来成一个个单独的总线。</li>
<li>第二类就是虚拟总线，如i2c控制器、GPIO控制器、UART控制器等，cpu 直接通过寄存器或地址与之进行通信。但是呢我们又想将他们统一到设备模型，因此 platform 这个虚拟总线就诞生了。</li>
</ul>
</blockquote>
<h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-bus-type"><a href="#1-bus-type" class="headerlink" title="1) bus_type"></a>1) bus_type</h3><p>每一个 bus_type 都代表一个 bus</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;		<span class="comment">//总线类型的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *dev_name;		<span class="comment">//当 dev-&gt;init_name 为空时，使用&quot;bus-&gt;dev_name+device ID”的形式，为的设备生成一个名称。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   *<span class="title">dev_root</span>;</span> 		<span class="comment">//bus总线上的设备默认的根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span> <span class="comment">//总线所属设备的默认的属性文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span>	<span class="comment">//默认总线属性文件(一组)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span>	<span class="comment">//该总线下的所有设备的默认属性文件(一组)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span>	<span class="comment">//该总线下的驱动的默认属性文件(一组)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);	<span class="comment">//匹配函数，当任何属于该 bus 的 device 和 device_driver 注册到bus时，调用该接口</span></span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);	<span class="comment">//用于 bus 的 device 对环境变量的添加</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);	<span class="comment">//match成功之后调用这个函数</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);	<span class="comment">//和probe相反</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span> <span class="comment">//描述 bus 在 /sys 中的层次结构，也管理着该总线上的dev和driver以及总线的一些属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-subsys-private"><a href="#2-subsys-private" class="headerlink" title="2) subsys_private"></a>2) subsys_private</h3><p>这个结构被用在两个地方 class 和 bus，在不同的位置有不同的含义，当它出现在 bus下用它描述 bus 在 /sys 中的层次结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span>	 	  <span class="comment">// 该bus 在sysfs中的目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span>	  <span class="comment">// bus目录下的device子目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span>  <span class="comment">// 保存该bus下所有的interface</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span>	<span class="comment">//bus目录下的driver子目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span>	<span class="comment">//bus的设备链表,该bus下的所有device挂接在该节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span>	<span class="comment">//bus的驱动链表,该bus下的所有drivers挂接在该节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;	<span class="comment">//用于控制该bus下的drivers或者device是否自动probe</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">//保存该subsys_private结构所属bus</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span>	<span class="comment">// 在 device_add 中使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">// 当用在class时，保存该subsys_private结构所属的class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、bus-根目录的初始化"><a href="#2、bus-根目录的初始化" class="headerlink" title="2、bus 根目录的初始化"></a>2、bus 根目录的初始化</h2><p>buses_init 在 driver_init 中被调用，用于初始化 bus 的根目录，以后所有的 bus 总线均为该目录的子目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">buses_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_kset = kset_create_and_add(<span class="string">&quot;bus&quot;</span>, &amp;bus_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bus_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    system_kset = kset_create_and_add(<span class="string">&quot;system&quot;</span>, <span class="literal">NULL</span>, &amp;devices_kset-&gt;kobj);</span><br><span class="line">    <span class="keyword">if</span> (!system_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buses_init 会创建以下目录</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys/bus</span><br><span class="line">sys/<span class="keyword">system</span></span><br></pre></td></tr></table></figure>
<h2 id="3、bus-总线的注册"><a href="#3、bus-总线的注册" class="headerlink" title="3、bus 总线的注册"></a>3、bus 总线的注册</h2><p>该函数向内核注册一个 bus 总线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//动态创建一个subsys_private结构priv</span></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    priv-&gt;bus = bus; 	<span class="comment">//初始化priv-&gt;bus</span></span><br><span class="line">    bus-&gt;p = priv;	<span class="comment">//初始化bus-&gt;p</span></span><br><span class="line"></span><br><span class="line">    BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 priv-&gt;subsys.kobj-&gt;name = bus-&gt;name</span></span><br><span class="line">    retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">	</span><br><span class="line">    priv-&gt;subsys.kobj.kset = bus_kset; <span class="comment">//初始化kset</span></span><br><span class="line">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype; <span class="comment">//初始化ktype </span></span><br><span class="line">    priv-&gt;drivers_autoprobe = <span class="number">1</span>; <span class="comment">//设置默认可以自动匹配probe</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里我们发现并没有设置parent，因此使用bus_kset作为parent，创建sys/bus/bus-&gt;name文件夹</span></span><br><span class="line">    retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在总线所在目录创建 uevent 属性文件</span></span><br><span class="line">    retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在总线所在目录创建 devices 目录</span></span><br><span class="line">    priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    <span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在总线所在目录创建 drivers 目录</span></span><br><span class="line">    priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    <span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">    __mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">    <span class="comment">//初始化设备链表 klist_devices，该总线上的所有设备将被链入该链表</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">    <span class="comment">//初始化驱动链表 klist_drivers，该总线上的所有驱动将被链入该链表</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在当前总线所在目录创建 drivers_probe 属性文件</span></span><br><span class="line"><span class="comment">    * 在当前总线所在目录创建 drivers_autoprobe 属性文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    retval = add_probe_files(bus);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在当前总线所在目录创建 bus_groups 属性文件(一组)</span></span><br><span class="line">    retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_groups_fail;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">    remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">    bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">    kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">    kfree(bus-&gt;p);</span><br><span class="line">    bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus_register 会创建以下节点：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>bus/xxx</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/u</span>event</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>devices ----- bus下注册的dev将出现在这个目录</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers ----- bus下注册的drv将出现在这个目录</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers_probe</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers_autoprobe</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;bus_register 创建并初始化 priv-&gt;klist_devices 和 priv-&gt;klist_drivers 这两条由该总线维护的非常重要的两条链表，该总线下的 dev 和 drv 会分别链入这两条链表。</p>
<p><strong>编程实验创建自己的总线</strong><br>在内核中创建一个名为 my_bus 的总线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_match\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_remove</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_bus&quot;</span>,</span><br><span class="line">    .probe = my_bus_probe,</span><br><span class="line">    .match = my_bus_match,</span><br><span class="line">    .remove = my_bus_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_register(&amp;my_bus); <span class="comment">//注册bus总线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_bus_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_unregister(&amp;my_bus); <span class="comment">//卸载bus总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_bus_init);</span><br><span class="line">module_exit(my_bus_exit);</span><br></pre></td></tr></table></figure>
<p><strong>模块验证</strong></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># ls</span></span><br><span class="line">amba        container    gpio iio      scsi    spi</span><br><span class="line">clockevents cpu          hid  mmc      sdio    usb</span><br><span class="line">clocksource event_source i2c  platform snd_seq workqueue</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta">#</span></span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># insmod /cache/my_bus.ko</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta">#</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># ls  <span class="comment">//查看生成了新的总线 my_bus</span></span></span><br><span class="line">amba        container    gpio iio    platform snd_seq workqueue</span><br><span class="line">clockevents cpu          hid  mmc    scsi     spi</span><br><span class="line">clocksource event_source i2c  my_bus sdio     usb</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># cd my_bus/ </span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus/my_bus <span class="meta"># ls <span class="comment">//查看 my_bus 下生成节点</span></span></span><br><span class="line">devices drivers drivers_autoprobe drivers_probe uevent</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus/my_bus <span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>该模块创建下面节点</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>bus/my_bus</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/u</span>event</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers_probe</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers_autoprobe</span><br></pre></td></tr></table></figure>
<h2 id="4、创建属性文件"><a href="#4、创建属性文件" class="headerlink" title="4、创建属性文件"></a>4、创建属性文件</h2><p>内核也提供了在 bus 总线下创建属性文件的接口</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于在bus所在目录创建属性文件</span></span><br><span class="line"><span class="built_in">int</span> bus<span class="constructor">_create_file(<span class="params">struct</span> <span class="params">bus_type</span> <span class="operator">*</span><span class="params">bus</span>, <span class="params">struct</span> <span class="params">bus_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br><span class="line"><span class="comment">//删除在bus所在目录创建的属性文件</span></span><br><span class="line">void bus<span class="constructor">_remove_file(<span class="params">struct</span> <span class="params">bus_type</span> <span class="operator">*</span><span class="params">bus</span>, <span class="params">struct</span> <span class="params">bus_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="二、device设备"><a href="#二、device设备" class="headerlink" title="二、device设备"></a>二、device设备</h1><p>抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。</p>
<h2 id="1、数据结构-1"><a href="#1、数据结构-1" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-device"><a href="#1-device" class="headerlink" title="1) device"></a>1) device</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>    *<span class="title">parent</span>;</span>	 <span class="comment">//父设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>    *<span class="title">p</span>;</span>  <span class="comment">//保存设备链表</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	  <span class="comment">//对应的kobj用于创建dev目录</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *init_name;   <span class="comment">//设备的名称，非常重要，如果不存在则使用&quot;bus-&gt;name + device ID&quot; 如果都不存在则不允许创建设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span> <span class="comment">//设备类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">mutex</span>;</span>  <span class="comment">/* mutex to synchronize calls toits driver. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span>       	<span class="comment">/* 设备挂接的总线 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>       <span class="comment">/* 匹配成功后，链接匹配到的driver */</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data; 	<span class="comment">/* 用于保存私有数据。 */</span></span><br><span class="line">    <span class="keyword">void</span>        *driver_data;   	<span class="comment">/* Driver data, set and get with dev_set get_drvdata */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span>   <span class="title">links</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span>  <span class="title">power</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>    *<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>   *<span class="title">msi_domain</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> *<span class="title">pins</span>;</span> <span class="comment">//pinctrl对应的接口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">msi_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="keyword">int</span>     numa_node;  <span class="comment">/* NUMA node this device is close to */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_map_ops</span> *<span class="title">dma_ops</span>;</span></span><br><span class="line">    u64     *dma_mask;  <span class="comment">/* dma mask (if dma&#x27;able device) */</span></span><br><span class="line">    u64     coherent_dma_mask;<span class="comment">/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   dma_pfn_offset;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">dma_pools</span>;</span>  <span class="comment">/* dma pools (if dma&#x27;ble) */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span> *<span class="title">dma_mem</span>;</span> <span class="comment">/* internal for coherent mem override */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_CMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">cma_area</span>;</span>       <span class="comment">/* contiguous memory area for dma allocations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>  *<span class="title">of_node</span>;</span> <span class="comment">/* associated device tree node */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span>    *<span class="title">fwnode</span>;</span> <span class="comment">/* firmware device node */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">dev_t</span>           devt;   <span class="comment">/* 设备号 */</span></span><br><span class="line">    u32         id; <span class="comment">/* device instance */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span>      devres_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">devres_head</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span>   <span class="title">knode_class</span>;</span> <span class="comment">//链接到dev-&gt;class-&gt;p-&gt;klist_devices节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>        *<span class="keyword">class</span>;</span>		<span class="comment">//所属的class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span>  <span class="comment">/* optional groups */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>    (*release)(struct device *dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iommu_group</span>  *<span class="title">iommu_group</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iommu_fwspec</span> *<span class="title">iommu_fwspec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>            offline_disabled:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span>            offline:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span>            of_node_reused:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-device-private"><a href="#2-device-private" class="headerlink" title="2) device_private"></a>2) device_private</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_children</span>;</span> 	<span class="comment">//用于挂接子设备的 knode_parent</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_parent</span>;</span> 	<span class="comment">//挂接到父设备的 klist_children</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_driver</span>;</span>     <span class="comment">//链入连接的 driver 的 klist_devices 链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span> 	<span class="comment">//链接进入 bus-&gt;p-&gt;klist_devices 链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_probe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>		<span class="comment">//指向所属的 dev</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、device-根目录的初始化"><a href="#2、device-根目录的初始化" class="headerlink" title="2、device 根目录的初始化"></a>2、device 根目录的初始化</h2><p>device文件目录初始化函数，在driver_init中被调用，内核初始化时被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">devices_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在 sys/ 下创建一个名为 devices 目录，deices_kset</span></span><br><span class="line"><span class="comment">    * 在 sys/ 下创建一个名为 dev 的目录，dev_kobj</span></span><br><span class="line"><span class="comment">    * 在 sys/dev/ 下创建一个名为 block 的目录，sysfs_dev_block_kobj</span></span><br><span class="line"><span class="comment">    * 在 sys/dev/ 下创建一个名为 char 的目录，sysfs_dev_char_kobj</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, &amp;device_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!devices_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    dev_kobj = kobject_create_and_add(<span class="string">&quot;dev&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dev_kobj)</span><br><span class="line">        <span class="keyword">goto</span> dev_kobj_err;</span><br><span class="line">    sysfs_dev_block_kobj = kobject_create_and_add(<span class="string">&quot;block&quot;</span>, dev_kobj);</span><br><span class="line">    <span class="keyword">if</span> (!sysfs_dev_block_kobj)</span><br><span class="line">        <span class="keyword">goto</span> block_kobj_err;</span><br><span class="line">    sysfs_dev_char_kobj = kobject_create_and_add(<span class="string">&quot;char&quot;</span>, dev_kobj);</span><br><span class="line">    <span class="keyword">if</span> (!sysfs_dev_char_kobj)</span><br><span class="line">        <span class="keyword">goto</span> char_kobj_err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> char_kobj_err:</span><br><span class="line">    kobject_put(sysfs_dev_block_kobj);</span><br><span class="line"> block_kobj_err:</span><br><span class="line">    kobject_put(dev_kobj);</span><br><span class="line"> dev_kobj_err:</span><br><span class="line">    kset_unregister(devices_kset);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>devices_init 初始化了 device 的基本根目录，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices</span><br><span class="line">/sys/dev</span><br><span class="line">/sys/dev/block</span><br><span class="line">/sys/dev/<span class="keyword">char</span></span><br></pre></td></tr></table></figure>
<p>bus总线管理着该总线下的所有设备和驱动，他们分别位于 /sys/bus/xxx/device 和 /sys/bus/xxx/driver 下</p>
<h2 id="3、device的注册"><a href="#3、device的注册" class="headerlink" title="3、device的注册"></a>3、device的注册</h2><h3 id="1-device-register"><a href="#1-device-register" class="headerlink" title="1) device_register"></a>1) device_register</h3><p>使用 device_regster 注册 device ，这里以源码的形式分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_initialize(dev); <span class="comment">//对dev进行一些初始化</span></span><br><span class="line">    <span class="keyword">return</span> device_add(dev); <span class="comment">//将dev注册进bus</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-device-initialize"><a href="#2-device-initialize" class="headerlink" title="2) device_initialize"></a>2) device_initialize</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_initialize</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dev-&gt;kobj.kset = devices_kset; <span class="comment">//初始化kset</span></span><br><span class="line">    kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype); <span class="comment">//初始化ktypoe</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对一些链表进行初始化</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">    mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">    lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class="line">    spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line">    device_pm_init(dev);</span><br><span class="line">    set_dev_node(dev, <span class="number">-1</span>); 	<span class="comment">//设置该设备节点为-1，一般未注册前默认为-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的初始化可以看出,<font color=green>所有通过device_register注册的dev的dev-&gt;kobj-&gt;list，都将挂接在 devices_kset-&gt;list上</font>(在kobj_add注册时链接) ,<font color=blue>如果没有父设备则设备将使用 devices_kset 作为父设备目录节点</font>，因此可以得出下面结论：</p>
<blockquote>
<ul>
<li><font color=red><strong>所有通过 device_regster 创建的设备都应该是/sys/devices/的子目录</strong></font>
</li>
</ul>
</blockquote>
<h3 id="3-device-add"><a href="#3-device-add" class="headerlink" title="3) device_add"></a>3) device_add</h3><p>这个函数将device注册进bus，同时它也做了很多事情非常多的事情，具体做了什么事情我们跟着源码来看一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_add</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_interface</span> *<span class="title">class_intf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">glue_dir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    dev = get_device(dev); <span class="comment">//增加dev引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (!dev)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">        <span class="comment">/* 动态分配一个 device_private 并且初始化 dev成员*/</span></span><br><span class="line">        error = device_private_init(dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for statically allocated devices, which should all be converted</span></span><br><span class="line"><span class="comment">     * some day, we need to initialize the name. We prevent reading back</span></span><br><span class="line"><span class="comment">     * the name, and force the use of dev_name()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;init_name) &#123;	<span class="comment">// 如果有init_name则设置，设置dev-&gt;kobj-&gt;name 为 init_name</span></span><br><span class="line">        dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, dev-&gt;init_name);</span><br><span class="line">        dev-&gt;init_name = <span class="literal">NULL</span>; <span class="comment">//这里需要注意的是，这个 init_name 被设置为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subsystems can specify simple device enumeration */</span></span><br><span class="line">    <span class="comment">//如果 dev-&gt;kobj-&gt;name 为空且对应的bus设置了dev_name 则使用这个名字+dev-&gt;id作为设备名</span></span><br><span class="line">    <span class="keyword">if</span> (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">        dev_set_name(dev, <span class="string">&quot;%s%u&quot;</span>, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果这没有设置dev-&gt;kobj-name 则直接返回error</span></span><br><span class="line">    <span class="keyword">if</span> (!dev_name(dev)) &#123;</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> name_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;device: &#x27;%s&#x27;: %s\n&quot;</span>, dev_name(dev), __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加 dev-parent 的kobj引用计数</span></span><br><span class="line">    parent = get_device(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回parent-&gt;kobj</span></span><br><span class="line">    kobj = get_device_parent(dev, parent);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kobj)) &#123;</span><br><span class="line">        error = PTR_ERR(kobj);</span><br><span class="line">        <span class="keyword">goto</span> parent_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kobj)</span><br><span class="line">        dev-&gt;kobj.parent = kobj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use parent numa_node */</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE)) <span class="comment">// 一般未注册前默认为-1</span></span><br><span class="line">        set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first, register with generic layer. */</span></span><br><span class="line">    <span class="comment">/* we require the name to be set before, and pass NULL */</span></span><br><span class="line">    <span class="comment">// 注册 dev-&gt;kobj，在 sys/ 下创建相关目录</span></span><br><span class="line">    error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        glue_dir = get_glue_dir(dev);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* notify platform of device entry */</span></span><br><span class="line">    <span class="keyword">if</span> (platform_notify)</span><br><span class="line">        platform_notify(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在dev目录下创建属性文件uevent</span></span><br><span class="line">    error = device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> attrError;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在dev所在目录创建三个链接文件</span></span><br><span class="line"><span class="comment">    * of_node     ---&gt; 设备树生成的节点</span></span><br><span class="line"><span class="comment">    * subsystem   ---&gt; dev-&gt;class</span></span><br><span class="line"><span class="comment">    * device      ---&gt; 父设备目录</span></span><br><span class="line"><span class="comment">    * 同时在所属的class目录下创建指向 dev 目录的链接文件，dev-&gt;init_name</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    error = device_add_class_symlinks(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> SymlinkError;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//该函数用于在 dev下创建所属的 class-&gt;dev_groups, 所属的 type-&gt;groups 和 dev-&gt;groups 指向的属性文件以及属性文件 online</span></span><br><span class="line">    error = device_add_attrs(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> AttrsError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将设备注册进bus，详细分析见后文</span></span><br><span class="line">    error = bus_add_device(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> BusError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电源相关暂时忽略</span></span><br><span class="line">    error = dpm_sysfs_add(dev); </span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> DPMError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电源相关暂时忽略</span></span><br><span class="line">    device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">        <span class="comment">//在设备所在目录下创建属性文件 dev</span></span><br><span class="line">        error = device_create_file(dev, &amp;dev_attr_dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> DevAttrError;</span><br><span class="line">        <span class="comment">//如果存在class则在class所在目录下创建指向dev-&gt;kobj的链接文件&quot;major+minor&quot;,否则在 /sys/char 下创建</span></span><br><span class="line">        error = device_create_sys_dev_entry(dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> SysEntryError;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建设备文件节点 /dev/dev-&gt;init_name</span></span><br><span class="line">        devtmpfs_create_node(dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify clients of device addition.  This call must come</span></span><br><span class="line"><span class="comment">     * after dpm_sysfs_add() and before kobject_uevent().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line">    <span class="comment">//向用户空间发送 uevent 事件 KOBJ_ADD</span></span><br><span class="line">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所挂接的bus上的所有drv，对所有的drv进行匹配，匹配成功则调用相对应的probe函数，详细分析见后文</span></span><br><span class="line">    bus_probe_device(dev);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (parent) <span class="comment">//将 dev-&gt;p-&gt;knode_parent 节点加入 parent-&gt;p-&gt;klist_children</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">                   &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;class) &#123;</span><br><span class="line">        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">        <span class="comment">/* tie the class to the device */</span></span><br><span class="line">        <span class="comment">// 绑定device和class，将dev-&gt;knode_class 节点链接到dev-&gt;class-&gt;p-&gt;klist_devices</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">                   &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* notify any interfaces that the device is here */</span></span><br><span class="line">        list_for_each_entry(class_intf,</span><br><span class="line">                    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">            <span class="keyword">if</span> (class_intf-&gt;add_dev)</span><br><span class="line">                class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"> SysEntryError:</span><br><span class="line">    <span class="keyword">if</span> (MAJOR(dev-&gt;devt))</span><br><span class="line">        device_remove_file(dev, &amp;dev_attr_dev);</span><br><span class="line"> DevAttrError:</span><br><span class="line">    device_pm_remove(dev);</span><br><span class="line">    dpm_sysfs_remove(dev);</span><br><span class="line"> DPMError:</span><br><span class="line">    bus_remove_device(dev);</span><br><span class="line"> BusError:</span><br><span class="line">    device_remove_attrs(dev);</span><br><span class="line"> AttrsError:</span><br><span class="line">    device_remove_class_symlinks(dev);</span><br><span class="line"> SymlinkError:</span><br><span class="line">    device_remove_file(dev, &amp;dev_attr_uevent);</span><br><span class="line"> attrError:</span><br><span class="line">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);</span><br><span class="line">    glue_dir = get_glue_dir(dev);</span><br><span class="line">    kobject_del(&amp;dev-&gt;kobj);</span><br><span class="line"> Error:</span><br><span class="line">    cleanup_glue_dir(dev, glue_dir);</span><br><span class="line">parent_error:</span><br><span class="line">    put_device(parent);</span><br><span class="line">name_error:</span><br><span class="line">    kfree(dev-&gt;p);</span><br><span class="line">    dev-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-get-device-parent"><a href="#4-get-device-parent" class="headerlink" title="4) get_device_parent"></a>4) get_device_parent</h3><p>这个函数用于获取 dev-&gt;kobj-&gt;parent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject *<span class="title">get_device_parent</span><span class="params">(struct device *dev, struct device *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;class) &#123;	<span class="comment">//是否设置class</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent_kobj</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">k</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">        <span class="comment">/* block disks show up in /sys/block */</span></span><br><span class="line">        <span class="keyword">if</span> (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent &amp;&amp; parent-&gt;class == &amp;block_class)</span><br><span class="line">                <span class="keyword">return</span> &amp;parent-&gt;kobj;</span><br><span class="line">            <span class="keyword">return</span> &amp;block_class.p-&gt;subsys.kobj;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we have no parent, we live in &quot;virtual&quot;.</span></span><br><span class="line"><span class="comment">         * Class-devices with a non class-device as parent, live</span></span><br><span class="line"><span class="comment">         * in a &quot;glue&quot; directory to prevent namespace collisions.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) <span class="comment">//parent为空</span></span><br><span class="line">            parent_kobj = virtual_device_parent(dev); <span class="comment">//在/sys/devices/目录下创建 virtual 目录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;class &amp;&amp; !dev-&gt;class-&gt;ns_type) <span class="comment">//dev-&gt;class-&gt;ns_type</span></span><br><span class="line">            <span class="keyword">return</span> &amp;parent-&gt;kobj;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent_kobj = &amp;parent-&gt;kobj; <span class="comment">//设置parent_kobj</span></span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;gdp_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find our class-directory at the parent and reference it */</span></span><br><span class="line">        <span class="comment">//如果已经在dev-&gt;class-&gt;p-&gt;glue_dirs下注册了 parent_kobj 则增加它的引用计数，并直接返回</span></span><br><span class="line">        spin_lock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);</span><br><span class="line">        list_for_each_entry(k, &amp;dev-&gt;class-&gt;p-&gt;glue_dirs.<span class="built_in">list</span>, entry)</span><br><span class="line">            <span class="keyword">if</span> (k-&gt;parent == parent_kobj) &#123;</span><br><span class="line">                kobj = kobject_get(k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        spin_unlock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);</span><br><span class="line">        <span class="keyword">if</span> (kobj) &#123; <span class="comment">//直接返回</span></span><br><span class="line">            mutex_unlock(&amp;gdp_mutex);</span><br><span class="line">            <span class="keyword">return</span> kobj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* or create a new class-directory at the parent device */</span></span><br><span class="line">        <span class="comment">/* 在 parent_kobj 并没有在 dev-&gt;class-&gt;p-&gt;glue_dirs 中，</span></span><br><span class="line"><span class="comment">         * 则在父目录下创建一个名为 dev-&gt;class-&gt;name 的目录，</span></span><br><span class="line"><span class="comment">         * 并将 class-&gt;p-&gt;glue_dirs 作为其kset。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        k = class_dir_create_and_add(dev-&gt;class, parent_kobj);</span><br><span class="line">        <span class="comment">/* do not emit an uevent for this simple &quot;glue&quot; directory */</span></span><br><span class="line">        mutex_unlock(&amp;gdp_mutex);</span><br><span class="line">        <span class="keyword">return</span> k; <span class="comment">//返回dir-&gt;kobj</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subsystems can specify a default root directory for their devices */</span></span><br><span class="line">	<span class="comment">//如果parent为空则且dev-&gt;bus-&gt;dev_root不为空则使用dev-&gt;bus-&gt;dev_root-&gt;kobj作为父节点</span></span><br><span class="line">    <span class="keyword">if</span> (!parent &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_root)</span><br><span class="line">        <span class="keyword">return</span> &amp;dev-&gt;bus-&gt;dev_root-&gt;kobj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)</span><br><span class="line">        <span class="keyword">return</span> &amp;parent-&gt;kobj; <span class="comment">//返回父节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>class_dir_create_and_add</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject* <span class="title">class_dir_create_and_add</span><span class="params">(struct class *class, struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_dir</span> *<span class="title">dir</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    dir = kzalloc(<span class="keyword">sizeof</span>(*dir), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dir)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    dir-&gt;<span class="class"><span class="keyword">class</span> =</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    kobject_init(&amp;dir-&gt;kobj, &amp;class_dir_ktype);</span><br><span class="line"></span><br><span class="line">    dir-&gt;kobj.kset = &amp;class-&gt;p-&gt;glue_dirs;</span><br><span class="line"></span><br><span class="line">    retval = kobject_add(&amp;dir-&gt;kobj, parent_kobj, <span class="string">&quot;%s&quot;</span>, class-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kobject_put(&amp;dir-&gt;kobj);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;dir-&gt;kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get_device_parent函数需要分为情况讨论<br><strong>设备属于某个class且parent为空</strong></p>
<ol>
<li>创建 /sys/devices/virtual目录，并将其作为父目录parent_kobj </li>
<li>遍历 dev-&gt;class-&gt;p-&gt;glue_dirs 下的所有kobj， 如果存在 parent_kobj，则增加其引用计数并直接返回 parent_kobj</li>
<li>否则在parent_kobj下创建一个dir-&gt;kobj (/sys/dev/vitual/dir-&gt;kobj-&gt;name)，使用传入的class-&gt;name 作为其dir-&gt;kobj-&gt;name, 并将class-&gt;p-&gt;glue_dirs作为其kset。并返回dir-&gt;kobj作为parent_kobj，这种情况会曾加如下目录</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/<span class="keyword">virtual</span> </span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/<span class="class"><span class="keyword">class</span>-&gt;</span>name <span class="comment">//dev-&gt;class-&gt;p-&gt;glue_dirs 下不存在 parent_kobj 则创建这个节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>设备属于某个class且parent不为空</strong></p>
<ol>
<li>如果存在 dev-&gt;class-&gt;ns_type 则直接返回 parent_kobj (这种情况不增加目录)</li>
<li>如果上述不存在，则遍历 dev-&gt;class-&gt;p-&gt;glue_dirs 下的所有kobj， 如果存在parent_kobj，则增加其引用计数并直接返回 parent_kobj</li>
<li>否则在 parent_kobj 下创建一个dir-&gt;kobj，使用传入的class-&gt;name 作为其dir-&gt;kobj-&gt;name, 并将class-&gt;p-&gt;glue_dirs作为其kset。并返回dir-&gt;kobj作为parent_kobj，这种情况会增加如下目录</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..../parent_kobj-&gt;name/<span class="class"><span class="keyword">class</span>-&gt;</span>name</span><br></pre></td></tr></table></figure>
<p><strong>设备属不属于某个class</strong><br>如果 parent 为空则且 dev-&gt;bus-&gt;dev_root 不为空则使用 dev-&gt;bus-&gt;dev_root-&gt;kobj 作为父节点，否则直接返回 parent-&gt;kobj</p>
<h3 id="5-device-add-class-symlinks"><a href="#5-device-add-class-symlinks" class="headerlink" title="5) device_add_class_symlinks"></a>5) device_add_class_symlinks</h3><p>该函数会创建class与dev之间的连接，首先在传入的dev所在目录创建三个链接文件，of_node、subsystem、device，同时在所属的class目录下创建指向dev目录的链接文件，dev-&gt;init_name</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_add_class_symlinks</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span> =</span> dev_of_node(dev);</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_node) &#123; <span class="comment">//设备树生成的节点</span></span><br><span class="line">        <span class="comment">//在 dev-&gt;kobj 下创建指向of_node-&gt;kobj的链接文件of_node</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;of_node-&gt;kobj,<span class="string">&quot;of_node&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            dev_warn(dev, <span class="string">&quot;Error %d creating of_node link\n&quot;</span>,error);</span><br><span class="line">        <span class="comment">/* An error here doesn&#x27;t warrant bringing down the device */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;class)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在 dev-&gt;kobj 下创建指向 dev-&gt;class-&gt;p-&gt;subsys.kobj 的链接文件&quot;subsystem&quot;</span></span><br><span class="line">    error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">                  &amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,</span><br><span class="line">                  <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_devnode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 dev-&gt;kobj 下创建指向 dev-&gt;parent-&gt;kobj 的链接文件 device</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent &amp;&amp; device_is_not_partition(dev)) &#123; <span class="comment">//默认情况满足条件</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;parent-&gt;kobj,</span><br><span class="line">                      <span class="string">&quot;device&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_subsys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">    <span class="comment">/* /sys/block has directories and does not need symlinks */</span></span><br><span class="line">    <span class="keyword">if</span> (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link in the class directory pointing to the device */</span></span><br><span class="line">	<span class="comment">//在 dev-&gt;class-&gt;p-&gt;subsys.kobj 下创建指向 dev-&gt;kobj 链接文件 &quot;dev-&gt;init_name&quot;</span></span><br><span class="line">    error = sysfs_create_link(&amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,</span><br><span class="line">                  &amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_device;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_device:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;device&quot;</span>);</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">out_devnode:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;of_node&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-device-add-attrs"><a href="#6-device-add-attrs" class="headerlink" title="6) device_add_attrs"></a>6) device_add_attrs</h3><p>该函数用于在dev下创建所属的 class-&gt;dev_groups, 所属的 type-&gt;groups 和 dev-&gt;groups 指向的属性文件以及属性文件 online</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_add_attrs</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span> =</span> dev-&gt;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span> =</span> dev-&gt;type;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (class) &#123;</span><br><span class="line">        <span class="comment">//创建 class-&gt;dev_groups 属性文件</span></span><br><span class="line">        error = device_add_groups(dev, class-&gt;dev_groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type) &#123;</span><br><span class="line">        <span class="comment">//创建 type-&gt;groups 属性文件</span></span><br><span class="line">        error = device_add_groups(dev, type-&gt;groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> err_remove_class_groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 dev-&gt;groups 属性文件</span></span><br><span class="line">    error = device_add_groups(dev, dev-&gt;groups);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> err_remove_type_groups;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建属性文件 online</span></span><br><span class="line">    <span class="keyword">if</span> (device_supports_offline(dev) &amp;&amp; !dev-&gt;offline_disabled) &#123;</span><br><span class="line">        error = device_create_file(dev, &amp;dev_attr_online);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> err_remove_dev_groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_remove_dev_groups:</span><br><span class="line">    device_remove_groups(dev, dev-&gt;groups);</span><br><span class="line"> err_remove_type_groups:</span><br><span class="line">    <span class="keyword">if</span> (type)</span><br><span class="line">        device_remove_groups(dev, type-&gt;groups);</span><br><span class="line"> err_remove_class_groups:</span><br><span class="line">    <span class="keyword">if</span> (class)</span><br><span class="line">        device_remove_groups(dev, class-&gt;dev_groups);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-bus-add-device"><a href="#7-bus-add-device" class="headerlink" title="7) bus_add_device"></a>7) bus_add_device</h3><p>这个函数将 device 注册进入bus</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_device</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> bus_get(dev-&gt;bus);</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;</span>, bus-&gt;name, dev_name(dev));</span><br><span class="line">        <span class="comment">/* 在当前设备所在目录下创建 dev-&gt;dev_attrs 默认属性文件(有就创建没有就不创建) */</span></span><br><span class="line">        error = device_add_attrs(bus, dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_put;</span><br><span class="line">        <span class="comment">/* 在当前设备所在目录下创建属性文件  bus-&gt;dev_groups */</span></span><br><span class="line">        error = device_add_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_id;</span><br><span class="line">        <span class="comment">/* 在设备所在bus的devices目录下创建指向设备所在目录的软链接，名字为dev-&gt;name */</span></span><br><span class="line">        error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">                        &amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_groups;</span><br><span class="line">        <span class="comment">/* 在设备所在目录下创建指向设备所在总线的的软链接名为 subsystem */</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">                &amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_subsys;</span><br><span class="line">        <span class="comment">/* 将设备链入 bus-&gt;p-&gt;klist_devices 链表 */</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">    sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));</span><br><span class="line">out_groups:</span><br><span class="line">    device_remove_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">out_id:</span><br><span class="line">    device_remove_attrs(bus, dev);</span><br><span class="line">out_put:</span><br><span class="line">    bus_put(dev-&gt;bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus_add_device 会创建以下节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/bus/xxx/devices/dev-&gt;name ----&gt; ..../dev-&gt;name</span><br><span class="line">..../dev-&gt;name/subsystem ----&gt; /sys/bus/xxx</span><br></pre></td></tr></table></figure>
<h3 id="8-bus-probe-device"><a href="#8-bus-probe-device" class="headerlink" title="8) bus_probe_device"></a>8) bus_probe_device</h3><p>如果drivers_autoprobe为1,即可以自动匹配则调用 device_initial_probe(dev)</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void bus<span class="constructor">_probe_device(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> bus_type *bus = dev-&gt;bus;</span><br><span class="line">    <span class="keyword">struct</span> subsys_interface *sif;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        return;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果设置了 bus-&gt;p-&gt;drivers_autoprobe 则进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (bus-&gt;p-&gt;drivers_autoprobe) </span><br><span class="line">        device<span class="constructor">_initial_probe(<span class="params">dev</span>)</span>;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_lock(&amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">    <span class="built_in">list</span><span class="constructor">_for_each_entry(<span class="params">sif</span>, &amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">interfaces</span>, <span class="params">node</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (sif-&gt;add_dev)</span><br><span class="line">            sif-&gt;add<span class="constructor">_dev(<span class="params">dev</span>, <span class="params">sif</span>)</span>;</span><br><span class="line">    mutex<span class="constructor">_unlock(&amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>device_initial_probe</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_initial_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __device_attach(dev, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__device_attach</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach(struct device *dev, <span class="keyword">bool</span> allow_async)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    device_lock(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver) &#123; <span class="comment">//在初始化dev的时候手动指定了driver，则在这里进行绑定</span></span><br><span class="line">        <span class="keyword">if</span> (device_is_bound(dev)) &#123;  <span class="comment">//判断设备和驱动是否已经绑定</span></span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 手动绑定设备和驱动</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">        ret = device_bind_driver(dev); </span></span><br><span class="line"><span class="comment">        if (ret == 0)</span></span><br><span class="line"><span class="comment">            ret = 1;</span></span><br><span class="line"><span class="comment">        else &#123;</span></span><br><span class="line"><span class="comment">            dev-&gt;driver = NULL;</span></span><br><span class="line"><span class="comment">            ret = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        struct device_attach_data data = &#123;</span></span><br><span class="line"><span class="comment">            .dev = dev,</span></span><br><span class="line"><span class="comment">            .check_async = allow_async,</span></span><br><span class="line"><span class="comment">            .want_async = false,</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (dev-&gt;parent)</span></span><br><span class="line"><span class="comment">            pm_runtime_get_sync(dev-&gt;parent);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">        //遍历 dev-&gt;bus 上所有的 drv ，对每一个drv 调用 __device_attach_driver 函数</span></span><br><span class="line"><span class="comment">        ret = bus_for_each_drv(dev-&gt;bus, NULL, &amp;data,</span></span><br><span class="line"><span class="comment">                    __device_attach_driver);</span></span><br><span class="line"><span class="comment">        if (!ret &amp;&amp; allow_async &amp;&amp; data.have_async) &#123;</span></span><br><span class="line"><span class="comment">            /*</span></span><br><span class="line"><span class="comment">             * If we could not find appropriate driver</span></span><br><span class="line"><span class="comment">             * synchronously and we are allowed to do</span></span><br><span class="line"><span class="comment">             * async probes and there are drivers that</span></span><br><span class="line"><span class="comment">             * want to probe asynchronously, we&#x27;ll</span></span><br><span class="line"><span class="comment">             * try them.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dev_dbg(dev, <span class="string">&quot;scheduling asynchronous probe\n&quot;</span>);</span><br><span class="line">            get_device(dev);</span><br><span class="line">            async_schedule(__device_attach_async_helper, dev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pm_request_idle(dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">            pm_runtime_put(dev-&gt;parent);</span><br><span class="line">    &#125;</span><br><span class="line">out_unlock:</span><br><span class="line">    device_unlock(dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>device_bind_driver</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_bind_driver</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建链接文件 .../dev-&gt;driver-&gt;p-&gt;kobj/dev-&gt;kobj-&gt;name</span></span><br><span class="line"><span class="comment">    * 创建链接文件 .../dev-&gt;kobj/driver</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = driver_sysfs_add(dev);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        driver_bound(dev); <span class="comment">//手动绑定</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__device_attach_driver</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach_driver(struct device_driver *drv, <span class="keyword">void</span> *_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attach_data</span> *<span class="title">data</span> =</span> _data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> data-&gt;dev;</span><br><span class="line">    <span class="keyword">bool</span> async_allowed;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check if device has already been claimed. This may</span></span><br><span class="line"><span class="comment">     * happen with driver loading, device discovery/registration,</span></span><br><span class="line"><span class="comment">     * and deferred probe processing happens all at once with</span></span><br><span class="line"><span class="comment">     * multiple threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 调用 drv 所属的 bus 的 match 函数，这里可以看出来如果不初始化 drv-&gt;bus-&gt;match 函数则默认匹配成功。</span></span><br><span class="line"><span class="comment">      static inline int driver_match_device(struct device_driver *drv, struct device *dev)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">          return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = driver_match_device(drv, dev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* no match */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Device match requests probe deferral\n&quot;</span>);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Bus failed to match device: %d&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="comment">/* ret &gt; 0 means positive match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取驱动加载方式是同步加载还是异步加载</span></span><br><span class="line">    async_allowed = driver_allows_async_probing(drv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (async_allowed)</span><br><span class="line">        data-&gt;have_async = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;check_async &amp;&amp; async_allowed != data-&gt;want_async)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用 driver_probe_device</span></span><br><span class="line">    <span class="keyword">return</span> driver_probe_device(drv, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>driver_probe_device</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_probe_device</span><span class="params">(struct device_driver *drv, struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!device_is_registered(dev))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: matched device %s with driver %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">        pm_runtime_get_sync(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    pm_runtime_barrier(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 really_probe 函数</span></span><br><span class="line">    ret = really_probe(dev, drv);</span><br><span class="line">    pm_request_idle(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">        pm_runtime_put(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>really_probe</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -EPROBE_DEFER;</span><br><span class="line">    <span class="keyword">int</span> local_trigger_count = atomic_read(&amp;deferred_trigger_count);</span><br><span class="line">    <span class="keyword">bool</span> test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;</span><br><span class="line">               !drv-&gt;suppress_bind_attrs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTPROF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ts = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (defer_all_probes) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Value of defer_all_probes can be set only by</span></span><br><span class="line"><span class="comment">         * device_defer_all_probes_enable() which, in turn, will call</span></span><br><span class="line"><span class="comment">         * wait_for_device_probe() right after that to avoid any races.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Driver %s force probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atomic_inc(&amp;probe_count);</span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line">    WARN_ON(!list_empty(&amp;dev-&gt;devres_head));</span><br><span class="line"></span><br><span class="line">re_probe:</span><br><span class="line">    dev-&gt;driver = drv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    <span class="comment">// 如果使用了 pinctrl 则会在这里先加载一次，如果 dts 写错了但能编译过了，就是不probe</span></span><br><span class="line">    <span class="comment">// 当移植代码的时候，当我们注册的驱动无法 prob e到设备的时候记得检查一下是否是 dts 的问题，</span></span><br><span class="line">    <span class="comment">// 因为不同个平台的 dts 可能由微小的差别，我就踩过这个坑 =_=</span></span><br><span class="line">    ret = pinctrl_bind_pins(dev);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> pinctrl_bind_failed;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在drv所在目录创建指向dev目录的链接文件，名字使用 dev-&gt;kobj-&gt;name</span></span><br><span class="line"><span class="comment">    * 在dev所在目录创建指向drv目录的连接文件，名字使用 &quot;driver&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, dev_name(dev));</span><br><span class="line">        <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">        ret = dev-&gt;pm_domain-&gt;activate(dev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用 dev-&gt;bus-&gt;probe</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">        TIME_LOG_START();</span><br><span class="line">        ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">        TIME_LOG_END();</span><br><span class="line">        bootprof_probe(ts, dev, drv, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev-&gt;bus-&gt;probe);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123; <span class="comment">//如果 dev-&gt;bus-&gt;probe 不存在则调用 drv-&gt;probe</span></span><br><span class="line">       TIME_LOG_START();</span><br><span class="line">        ret = drv-&gt;probe(dev);</span><br><span class="line">        TIME_LOG_END();</span><br><span class="line">        bootprof_probe(ts, dev, drv, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)drv-&gt;probe);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test_remove) &#123;</span><br><span class="line">        test_remove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">            dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">            drv-&gt;remove(dev);</span><br><span class="line"></span><br><span class="line">        devres_release_all(dev);</span><br><span class="line">        driver_sysfs_remove(dev);</span><br><span class="line">        dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">        dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">            dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">        pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> re_probe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pinctrl_init_done(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">        dev-&gt;pm_domain-&gt;sync(dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立设备与驱动的连接</span></span><br><span class="line">    driver_bound(dev);</span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">probe_failed:</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">pinctrl_bind_failed:</span><br><span class="line">    devres_release_all(dev);</span><br><span class="line">    driver_sysfs_remove(dev);</span><br><span class="line">    dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">    dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">        dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">    pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">        <span class="comment">/* Driver requested deferred probing */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">        <span class="comment">/* Did a trigger occur while probing? Need to re-trigger if yes */</span></span><br><span class="line">        <span class="keyword">if</span> (local_trigger_count != atomic_read(&amp;deferred_trigger_count))</span><br><span class="line">            driver_deferred_probe_trigger();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -ENODEV:</span><br><span class="line">    <span class="keyword">case</span> -ENXIO:</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line">             drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* driver matched but the probe failed */</span></span><br><span class="line">        printk(KERN_WARNING</span><br><span class="line">               <span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">               drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ignore errors returned by -&gt;probe so that the next driver can try</span></span><br><span class="line"><span class="comment">     * its luck.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">    atomic_dec(&amp;probe_count);</span><br><span class="line">    wake_up(&amp;probe_waitqueue);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、device-register总结"><a href="#4、device-register总结" class="headerlink" title="4、device_register总结"></a>4、device_register总结</h2><h3 id="1-检查设备名的合法性"><a href="#1-检查设备名的合法性" class="headerlink" title="1) 检查设备名的合法性"></a>1) 检查设备名的合法性</h3><p>从代码可以看出对于dev来说名字是一个非常重要的参数，首先使用 init_name 作为dev-&gt;kobj的名字同时将init_name设置为空，如果 init_name 初始为空则使用 “bus-&gt;dev_nam + dev-&gt;id” 作为dev-&gt;kobj的名字，<font color=color>如果设备没有设置名字则直接返回错误。</font></p>
<h3 id="2）在sys-创建文件目录的层次关系的创建"><a href="#2）在sys-创建文件目录的层次关系的创建" class="headerlink" title="2）在sys/创建文件目录的层次关系的创建"></a>2）在sys/创建文件目录的层次关系的创建</h3><p>下面列出所有可能出现的情况<br><strong>设备的bus为空，class为空，parent为空</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/xxx</span><br><span class="line">/sys/devices/xxx/power</span><br><span class="line">/sys/devices/xxx/uevent</span><br><span class="line">/sys/devices/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的bus为空，class为空，parent不为空</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/.../xxx-&gt;parent/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/power</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/dev <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/.../xxx-&gt;parent/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的bus不为空，class为空，parent为空</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/xxx</span><br><span class="line">/sys/devices/xxx/power</span><br><span class="line">/sys/devices/xxx/uevent</span><br><span class="line">/sys/devices/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* bus_add_device 创建下面目录 */</span></span><br><span class="line">/sys/bus/xxx-&gt;bus/devices/xxx ---&gt;/sys/devices/xxx	 <span class="comment">//指向设备</span></span><br><span class="line">/sys/devices/xxx/subsystem ---&gt; /sys/bus/xxx-&gt;bus <span class="comment">//指向所挂接的bus总线</span></span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和drv匹配成功创建下面目录</span></span><br><span class="line">/sys/devices/xxx/driver ---&gt; /sys/bus/drivers/xxx-&gt;driver/</span><br><span class="line">/sys/bus/drivers/xxx-&gt;driver/xxx ---&gt; /sys/devices/xxx</span><br></pre></td></tr></table></figure>
<p><strong>设备的bus不为空，class为空，parent不为空</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/.../xxx-&gt;parent/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/power</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* bus_add_device 创建下面目录 */</span></span><br><span class="line">/sys/bus/xxx-&gt;bus/devices/xxx ---&gt;/sys/devices/.../xxx-&gt;parent/xxx	 <span class="comment">//指向设备</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/subsystem ---&gt; /sys/bus/xxx-&gt;bus <span class="comment">//指向所挂接的bus总线</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/.../xxx-&gt;parent/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和drv匹配成功创建下面目录</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/driver ---&gt; /sys/bus/drivers/xxx-&gt;driver/</span><br><span class="line">/sys/bus/drivers/xxx-&gt;driver/xxx ---&gt; /sys/devices/.../xxx-&gt;parent/xxx</span><br></pre></td></tr></table></figure>
<p><strong>设备的 bus 为空，class 不为空，parent 为空</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dir-&gt;kobj使用xxx-&gt;class-&gt;name做名字</span></span><br><span class="line"></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/uevent</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/of_node <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device_add_class_symlinks 创建下面目录 */</span></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/subsystem ---&gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">xxx</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span></span></span><br><span class="line"><span class="class">/<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">dev</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span> ---&gt;</span> /sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx</span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * .../dev-&gt;class-&gt;dev_kobj/&quot;major+minor&quot; ---&gt; /sys/devices/virtual/dir-&gt;kobj/xxx 有dev-&gt;class-&gt;dev_kobj和设备号的设备会创建这个节点</span></span><br><span class="line"><span class="comment"> * dev-&gt;class-&gt;dev_kobj 这个属性在class被注册的时候一般被默认设置为 sysfs_dev_char_kobj,即 /sys/dev/char节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx <span class="comment">//有设备号会默认创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的 bus 为空，class 不为空，parent 不为空</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dir-&gt;kobj使用xxx-&gt;class-&gt;name做名字</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/of_node <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device_add_class_symlinks 创建下面目录 */</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/subsystem ---&gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">xxx</span>-&gt;</span><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">/<span class="title">sys</span>/<span class="title">devices</span>/<span class="title">xxx</span>-&gt;</span>parent/dir-&gt;kobj/xxx/device ---&gt; dev-&gt;parent-&gt;kobj </span><br><span class="line">/sys/<span class="class"><span class="keyword">class</span>/<span class="title">dev</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span> ---&gt;</span> /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx</span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * .../dev-&gt;class-&gt;dev_kobj/&quot;major+minor&quot; ---&gt; /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx 有dev-&gt;class-&gt;dev_kobj和设备号的设备会创建这个节点</span></span><br><span class="line"><span class="comment"> * dev-&gt;class-&gt;dev_kobj 这个属性在class被注册的时候一般被默认设置为 sysfs_dev_char_kobj,即 /sys/dev/char节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx <span class="comment">//有设备号会默认创建这个节点</span></span><br><span class="line"></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么没有同时出现一个设备同时属于bus和class的情况，通过整理 device_add 创建的目录层次可以发现，bus(class)下的设备都会在注册的的时候在设备目录创建 subsystem ，这个链接文件指向bus(class)，同时也会在bus(class)目录创建指向设备的链接文件。在 <font color = blue>device_add_class_symlinks 函数和 bus_add_device 函数中都会在当前设备下创建 “subsystem” 这个属性文件</font>，很明显存在着冲突，这得出一个结论：<font color = red>内核在向bus注册设备的时候，如果设备同属于class和bus时，设备是无法注册的</font></p>
<h3 id="3）和挂接的bus上的所有drv进行匹配"><a href="#3）和挂接的bus上的所有drv进行匹配" class="headerlink" title="3）和挂接的bus上的所有drv进行匹配"></a>3）和挂接的bus上的所有drv进行匹配</h3><p>匹配流程如下</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bus_probe_device</span>---&gt;</span></span><br><span class="line">   <span class="function"><span class="title">device_initial_probe</span>(dev) ---&gt;</span> <span class="comment">//如果bus-&gt;p-&gt;drivers_autoprobe被置位则调用这个函数</span></span><br><span class="line">      ---&gt; __device_attach(dev, <span class="literal">true</span>);</span><br><span class="line">               ---&gt; <span class="function"><span class="title">bus_for_each_drv</span>(dev-&gt;</span>bus, NULL, &amp;<span class="keyword">data</span>, __device_attach_driver); <span class="comment">//对于该bus上的每一个drv都调用__device_attach_driver函数</span></span><br><span class="line">                        ---&gt; __device_attach_driver(drv, <span class="keyword">data</span>) </span><br><span class="line">                                ---&gt; driver_match_device(drv, dev);</span><br><span class="line">                                         ---&gt; <span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>match(dev, drv)</span><br><span class="line">                                         ---&gt; driver_probe_device(drv, dev) <span class="comment">//如果匹配成功则调用这个函数</span></span><br><span class="line">                                                 ---&gt; really_probe(dev, drv);</span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">dev</span>-&gt;</span>driver = drv; <span class="comment">//将匹配成功的驱动赋值给对应的设备</span></span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe(dev) <span class="comment">//默认调用这个</span></span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">probe</span>(dev) //如果没有设置 dev-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe 函数，则调用这</span><br></pre></td></tr></table></figure>
<p><font color = red> dev在注册的时候会和所挂接bus上的所有drv进行匹配，即调用 drv-&gt;bus-&gt;match(dev, drv) 函数，如果匹配成功则调用所在总线上的probe函数，即 dev-&gt;bus-&gt;probe(dev) 函数 </font>, 从这里也可以看出匹配的规则是灵活的，它由总线决定，<font color = blue>由总线来决定设备和驱动的匹配规则</font>, 比如 platform 总线就规定了5种匹配规则，这里只是提一下，后面的platform设备详述。</p>
<h2 id="5、创建我们自己的设备"><a href="#5、创建我们自己的设备" class="headerlink" title="5、创建我们自己的设备"></a>5、创建我们自己的设备</h2><p>我们之前已经创建了一个my_bus总线，现在在这个基础之上再创建一个my_dev</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">my_dev</span> =</span> &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;my_dev&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_device_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_register(&amp;my_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_device_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_unregister(&amp;my_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_device_init);</span><br><span class="line">module_exit(my_device_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># ls</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># insmod /cache/my_device.ko</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># ls</span></span><br><span class="line">my_dev</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># cd my_dev/</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># ls</span></span><br><span class="line">power subsystem uevent</span><br></pre></td></tr></table></figure>
<h2 id="6、在dev下创建属性文件"><a href="#6、在dev下创建属性文件" class="headerlink" title="6、在dev下创建属性文件"></a>6、在dev下创建属性文件</h2><p>属性文件作为用户空间和内核空间交互的常用手段之一，它的重要性不言而喻。 device_register 在 device_initialize 中会将 ktype 初始化为 device_ktype </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">device_ktype</span> =</span> &#123;</span><br><span class="line">    .<span class="built_in">release</span>    = device_release,</span><br><span class="line">    .sysfs_ops  = &amp;dev_sysfs_ops,</span><br><span class="line">    .<span class="keyword">namespace</span>  = device_namespace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">dev_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show   = dev_attr_show,</span><br><span class="line">    .store  = dev_attr_store,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到内核已经实现了 device_release 函数当dev引用计数为0时会自动释放掉自己。同样的内核也实现了属性文件中间层的函数 dev_attr_show 和 dev_attr_store</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ssize_t dev_attr_show(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *kobj, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *attr,</span><br><span class="line">                 <span class="built_in">char</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *dev_attr = to_dev_attr(attr); <span class="comment">//获取到更大的结构 device_attribute</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = kobj_to_dev(kobj);</span><br><span class="line">    ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev_attr-&gt;show)</span><br><span class="line">        ret = dev_attr-&gt;show(dev, dev_attr, buf); <span class="comment">//调用 device_attribute 的成员 show 函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= (ssize_t)PAGE_SIZE) &#123;</span><br><span class="line">        print_symbol(<span class="string">&quot;dev_attr_show: %s returned bad count\n&quot;</span>,</span><br><span class="line">                (unsigned long)dev_attr-&gt;show);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ssize_t dev_attr_store(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *kobj, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *attr,</span><br><span class="line">                  <span class="keyword">const</span> <span class="built_in">char</span> *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *dev_attr = to_dev_attr(attr); <span class="comment">//获取到更大的结构 device_attribute</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = kobj_to_dev(kobj);</span><br><span class="line">    ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev_attr-&gt;store)</span><br><span class="line">        ret = dev_attr-&gt;store(dev, dev_attr, buf, count);<span class="comment">//调用 device_attribute 的成员 store 函数</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span>    attr;</span><br><span class="line">    ssize_t (*show)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *attr,</span><br><span class="line">            <span class="built_in">char</span> *buf);</span><br><span class="line">    ssize_t (*store)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="built_in">char</span> *buf, size_t count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个框架看起来是不是很熟悉，其实前面我们自己在my_dir就已经实现了这个框架了，这里只是换了个壳而已，像前面的 bus，以及后面的 driver 等模型，内核已经帮我们实现了相关框架，我们只需要直接用就行了。创建属性结构的方法太麻烦了，没关系内核也为我们封装了快速创建并初始化 device_attribute 结构的宏了</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个可读可写的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_show、name_store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个只读的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_show</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个只写的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_WO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_WO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_ULONG_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_ulong</span>, <span class="params">device_store_ulong</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_INT_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_int</span>, <span class="params">device_store_int</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_BOOL_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_bool</span>, <span class="params">device_store_bool</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_IGNORE_LOCKDEP(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name =      \</span><br><span class="line">        <span class="constructor">__ATTR_IGNORE_LOCKDEP(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br></pre></td></tr></table></figure>
<p>创建出了 device_attribute 结构，再调用 device_attribute 函数就可以在当前设备下快速创建属性文件。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> device_create_file(struct device *<span class="built_in">dev</span>,</span><br><span class="line">               const struct device_attribute *<span class="built_in">attr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    if (<span class="built_in">dev</span>) &#123;</span><br><span class="line">        WARN(((<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.mode &amp; S_IWUGO) &amp;&amp; !<span class="built_in">attr</span>-&gt;store),</span><br><span class="line">            <span class="string">&quot;Attribute %s: write permission without &#x27;store&#x27;\n&quot;</span>,</span><br><span class="line">            <span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.name);</span><br><span class="line">        WARN(((<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.mode &amp; S_IRUGO) &amp;&amp; !<span class="built_in">attr</span>-&gt;<span class="built_in">show</span>),</span><br><span class="line">            <span class="string">&quot;Attribute %s: read permission without &#x27;show&#x27;\n&quot;</span>,</span><br><span class="line">            <span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.name);</span><br><span class="line">        error = sysfs_create_file(&amp;<span class="built_in">dev</span>-&gt;kobj, &amp;<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>); <span class="comment">//注册属性文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create_file);</span><br></pre></td></tr></table></figure>
<p><strong>编程实现</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;linux/device.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/<span class="keyword">module</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/kernel.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/init.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/<span class="built_in">string</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/sysfs.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/stat.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="constructor">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">extern <span class="keyword">struct</span> bus_type my_bus;</span><br><span class="line">extern <span class="keyword">struct</span> <span class="keyword">class</span> *my_class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> device my_dev = &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;my_dev&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ssize_t my<span class="constructor">_attr_show(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_attribute</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    sprintf(buf, <span class="string">&quot;%s\n&quot;</span>, attr-&gt;attr.name);</span><br><span class="line">    return strlen((<span class="built_in">char</span>*)attr-&gt;attr.name) +<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t my<span class="constructor">_attr_store(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_attribute</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">size_t</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s store : %s\n&quot;</span>,attr-&gt;attr.name, buf);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="constructor">DEVICE_ATTR(<span class="params">my_attr_test</span>, 0664, <span class="params">my_attr_show</span>, <span class="params">my_attr_store</span>)</span>;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> my<span class="constructor">_device_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device<span class="constructor">_register(&amp;<span class="params">my_dev</span>)</span>;</span><br><span class="line">    device<span class="constructor">_create_file(&amp;<span class="params">my_dev</span>,&amp;<span class="params">dev_attr_my_attr_test</span>)</span>; <span class="comment">//注意这里需要添加自己的前缀 dev_attr_</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void my<span class="constructor">_device_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device<span class="constructor">_unregister(&amp;<span class="params">my_dev</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">my_device_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">my_device_exit</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>cat自己创建出的设备节点</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># cat my_attr_test</span></span><br><span class="line">my_attr_test</span><br><span class="line">[  <span class="number">501.905519</span>] &lt;<span class="number">6</span>&gt;.(<span class="number">6</span>)[<span class="number">2845</span>:cat]my_attr_test <span class="regexp">//</span>内核打印</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>ehco自己创建的设备节点</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># echo 123&gt;my_attr_test</span></span><br><span class="line">[  <span class="number">545.227562</span>] &lt;<span class="number">4</span>&gt;.(<span class="number">4</span>)[<span class="number">2821</span>:sh]my_attr_test store : <span class="number">123</span> <span class="regexp">//</span>内核打印</span><br></pre></td></tr></table></figure>
<h1 id="三、driver驱动"><a href="#三、driver驱动" class="headerlink" title="三、driver驱动"></a>三、driver驱动</h1><p>Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。而Linux内核中的驱动开发，基本都围绕该抽象进行（实现所规定的接口函数）。</p>
<h2 id="1、数据结构-2"><a href="#1、数据结构-2" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-device-driver"><a href="#1-device-driver" class="headerlink" title="1) device_driver"></a>1) device_driver</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *name;   <span class="comment">//名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span></span>     *bus; <span class="comment">//挂接的总线</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span></span>       *owner; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *mod_name;  <span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> suppress_bind_attrs;   <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span></span> probe_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span></span>   *of_match_table; <span class="comment">//用设备树匹配时，用于匹配设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span></span> *acpi_match_table;</span><br><span class="line"></span><br><span class="line">    int (*probe) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*remove) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    void (*shutdown) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*suspend) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, pm_message_t state);</span><br><span class="line">    int (*resume) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span></span> **groups;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span></span> *pm;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span></span> *p; <span class="comment">//保存相关链表，也保存了kobj</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-driver-private"><a href="#2-driver-private" class="headerlink" title="2) driver_private"></a>2) driver_private</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span> <span class="comment">//链接到bus-&gt;p-&gt;klist_drivers</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module_kobject</span> *<span class="title">mkobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、driver的注册"><a href="#2、driver的注册" class="headerlink" title="2、driver的注册"></a>2、driver的注册</h2><p>相较于device的注册，driver的注册就比较简单</p>
<ol>
<li>在总线上查找drv，判断drv是否已经注册进bus，防止重复注册</li>
<li>调用bus_add_driver将drv注册进入bus</li>
<li>创建属性文件 drv-&gt;groups</li>
<li>向上层发送uevent事件，KOBJ_ADD</li>
</ol>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int driver_register(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct device_driver *other;</span><br><span class="line"></span><br><span class="line">    BUG_ON(!<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>p);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> ((drv-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">probe</span> &amp;&amp; drv-&gt;</span>probe) ||</span><br><span class="line">        (<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">remove</span> &amp;&amp; drv-&gt;</span>remove) ||</span><br><span class="line">        (<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">shutdown</span> &amp;&amp; drv-&gt;</span>shutdown))</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">            <span class="string">&quot;bus_type methods\n&quot;</span>, <span class="function"><span class="title">drv</span>-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在总线上查找drv，判断drv是否已经注册进bus，防止重复注册</span></span><br><span class="line">    <span class="function"><span class="title">other</span> = driver_find(drv-&gt;</span><span class="function"><span class="title">name</span>, drv-&gt;</span>bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, <span class="function"><span class="title">drv</span>-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        return -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用bus_add_driver将drv注册进入bus</span></span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建属性文件 drv-&gt;groups</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = driver_add_groups(drv, drv-&gt;</span>groups);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向上层发送uevent事件，KOBJ_ADD</span></span><br><span class="line">    <span class="function"><span class="title">kobject_uevent</span>(&amp;drv-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bus_add_driver</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bus = bus_get(drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out_put_bus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化klist_devices</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    priv-&gt;driver = drv; </span><br><span class="line">    drv-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">    priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset; <span class="comment">//初始化kest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于没有设置 parent 因此使用 bus-&gt;p-&gt;drivers_kset 做父节点，并在这里创建drv目录,</span></span><br><span class="line">    <span class="comment">// 从这里可以知道drv的根目录为 /sys/bus/drv-&gt;bus/drivers/</span></span><br><span class="line">    error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">                     <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_unregister;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将priv-&gt;knode_bus 链接进入priv-&gt;bus-&gt;p-&gt;klist_drivers</span></span><br><span class="line">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否可以自动probe,如果可以，则遍历klist_devices，对其中的每一个dev都调用drv-&gt;bus-&gt;match(dev, drv)函数</span></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123; </span><br><span class="line">        <span class="keyword">if</span> (driver_allows_async_probing(drv)) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: probing driver %s asynchronously\n&quot;</span>,</span><br><span class="line">                drv-&gt;bus-&gt;name, drv-&gt;name);</span><br><span class="line">            async_schedule(driver_attach_async, drv);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            error = driver_attach(drv);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">goto</span> out_unregister;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在drv所在目录创建属性文件 uevent</span></span><br><span class="line">    error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在drv所在目录创建属性文件 drv_groups</span></span><br><span class="line">    error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果支持 bind 则在 drv 所在目录创建属性文件 bind 和 unbind</span></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">        error = add_bind_files(drv);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">/* Ditto */</span></span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">                __func__, drv-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">    kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">    <span class="comment">/* drv-&gt;p is freed in driver_release()  */</span></span><br><span class="line">    drv-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">out_put_bus:</span><br><span class="line">    bus_put(bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、driver-register-总结"><a href="#3、driver-register-总结" class="headerlink" title="3、driver_register 总结"></a>3、driver_register 总结</h2><h3 id="1-在sys-创建对应节点"><a href="#1-在sys-创建对应节点" class="headerlink" title="1) 在sys/创建对应节点"></a>1) 在sys/创建对应节点</h3><p>bus_add_driver 会创建下面节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/sys/bus/xxx/drivers/drv-&gt;name</span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/uevent</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 支持 suppress_bind_attrs */</span></span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/unbind</span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/bind</span><br></pre></td></tr></table></figure>
<h3 id="2-匹配-bus-总线上的设备"><a href="#2-匹配-bus-总线上的设备" class="headerlink" title="2) 匹配 bus 总线上的设备"></a>2) 匹配 bus 总线上的设备</h3><p>除了创建节点之外，如果可以自动probe,如果可以，则遍历klist_devices，对其中的每一个dev都调用drv-&gt;bus-&gt;match(dev, drv)函数，如果匹配成功则调用really_probe(drv),在这个函数中默认先调用函数 dev-&gt;bus-&gt;probe(dev)，如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用 drv-&gt;probe(dev),调用流程如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bus_add_driver----&gt;</span><br><span class="line">	driver_attach----&gt; 无论如何最终都会调用这个函数</span><br><span class="line">		bus_for_each_dev----&gt;</span><br><span class="line">			__driver_attach----&gt;</span><br><span class="line">				driver_match_device----&gt;</span><br><span class="line">					drv-&gt;bus-&gt;match(dev, drv) <span class="comment">//如果匹配成功则调用 really_probe</span></span><br><span class="line">					really_probe----&gt;</span><br><span class="line">						dev-&gt;bus-&gt;probe(dev) <span class="comment">//默认点调用这个</span></span><br><span class="line">						drv-&gt;probe(dev) <span class="comment">//如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用这个</span></span><br></pre></td></tr></table></figure>
<h2 id="4、注册我们自己的驱动"><a href="#4、注册我们自己的驱动" class="headerlink" title="4、注册我们自己的驱动"></a>4、注册我们自己的驱动</h2><p>在我们创建的bus上注册我们自己的驱动</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_drv_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_drv_remove</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">my_drv</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_drv&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">    .probe = my_drv_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_drv_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    driver_register(&amp;my_drv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    driver_unregister(&amp;my_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_drv_init);</span><br><span class="line">module_exit(my_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># ls</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># insmod /cache/my</span></span><br><span class="line">my_bus.ko       my_device.ko    my_driver.ko</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># insmod /cache/my_driver.ko</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># ls</span></span><br><span class="line">my_drv</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># cd my_drv/</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers/my_drv <span class="comment"># ls</span></span><br><span class="line">bind uevent unbind</span><br></pre></td></tr></table></figure>
<h2 id="5、在driver目录下创建属性文件"><a href="#5、在driver目录下创建属性文件" class="headerlink" title="5、在driver目录下创建属性文件"></a>5、在driver目录下创建属性文件</h2><p>和前面的device下创建属性文件相同，这里只给接口不再赘述</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> driver_attribute &#123;</span><br><span class="line">    <span class="keyword">struct</span> attribute attr;</span><br><span class="line">    ssize_t (*show)(<span class="keyword">struct</span> device_driver *driver, <span class="built_in">char</span> *buf);</span><br><span class="line">    ssize_t (*store)(<span class="keyword">struct</span> device_driver *driver, const <span class="built_in">char</span> *buf,</span><br><span class="line">             size_t count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_WO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_WO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于在当前 driver 下创建属性文件</span></span><br><span class="line">extern <span class="built_in">int</span> __must_check driver<span class="constructor">_create_file(<span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">driver</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">driver_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除属性文件</span></span><br><span class="line">extern void driver<span class="constructor">_remove_file(<span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">driver</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">driver_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="四、class总线"><a href="#四、class总线" class="headerlink" title="四、class总线"></a>四、class总线</h1><p>用于管理同类的设备，常常被我们用来给上层开辟一个属性节点，多用于查看，修改对应的设备信息。</p>
<h2 id="1、数据结构-3"><a href="#1、数据结构-3" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *name; <span class="comment">//class名称，用来初始化 subsys_private-&gt;susbus.kobj</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span></span>       *owner;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_attribute</span></span>      *class_attrs;   	<span class="comment">//默然属性文件指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span></span>    **dev_groups; <span class="comment">//class管理设备的体现之一，默认的设备属性文件，当注册设备到该class上时，会自动在改设备下创建，即该class下的所有设备都会注册这个属性文件。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span>          *dev_kobj; <span class="comment">//表示class下的设备在/sys/dev下的哪个目录，现在有两个目录char和block，默认选择char。</span></span><br><span class="line"></span><br><span class="line">    int (*dev_uevent)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">kobj_uevent_env</span></span> *env);<span class="comment">//当class下的设备发生变化时，会调用class的uevent函数</span></span><br><span class="line">    <span class="built_in">char</span> *(*devnode)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, umode_t *mode);</span><br><span class="line"></span><br><span class="line">    void (*class_release)(<span class="class"><span class="keyword">struct</span> <span class="title">class</span></span> *class);</span><br><span class="line">    void (*dev_release)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    int (*suspend)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, pm_message_t state);</span><br><span class="line">    int (*resume)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*shutdown)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span></span> *ns_type;</span><br><span class="line">    <span class="keyword">const</span> void *(*namespace)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span></span> *pm;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span></span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-subsys-private-1"><a href="#2-subsys-private-1" class="headerlink" title="2) subsys_private"></a>2) subsys_private</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span>	 	  <span class="comment">// 该 class 在sysfs中的目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span>	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">// 保存上层的class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、函数接口"><a href="#2、函数接口" class="headerlink" title="2、函数接口"></a>2、函数接口</h2><h3 id="1-classes-init"><a href="#1-classes-init" class="headerlink" title="1) classes_init"></a>1) classes_init</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">classes_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    class_kset = kset_create_and_add(<span class="string">&quot;class&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//创建 /sys/class 节点</span></span><br><span class="line">    <span class="keyword">if</span> (!class_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2）class-create"><a href="#2）class-create" class="headerlink" title="2）class_create"></a>2）class_create</h2><p>用于在内核中创建一个 class</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> class_create(owner, name)       \</span></span><br><span class="line">(&#123;                      \</span><br><span class="line">    static <span class="keyword">struct</span> <span class="type">lock_class_key</span> __key; \</span><br><span class="line">    <span class="built_in">__class_create</span>(owner, name, &amp;__key);    \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">class</span> *<span class="built_in">__class_create</span>(struct module *owner, const char *name,</span><br><span class="line">                 struct lock_class_key *<span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">class</span> *<span class="keyword">cls</span>;</span><br><span class="line">    int retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态创建 class 结构</span></span><br><span class="line">    cls = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*cls), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">error</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cls</span>-&gt;name = name; <span class="comment">//初始化 name</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;owner = owner; <span class="comment">//初始化 owner</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;class_release = class_create_release; <span class="comment">//初始化 默认release函数</span></span><br><span class="line"></span><br><span class="line">    retval = <span class="built_in">__class_register</span>(cls, <span class="built_in">key</span>); <span class="comment">//注册class</span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">cls</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">error</span>:</span><br><span class="line">    <span class="built_in">kfree</span>(cls);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(retval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(__class_create);</span><br></pre></td></tr></table></figure>
<h3 id="2-class-register"><a href="#2-class-register" class="headerlink" title="2) __class_register"></a>2) __class_register</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">__class_register(<span class="params">struct</span> <span class="params">class</span> <span class="operator">*</span><span class="params">cls</span>, <span class="params">struct</span> <span class="params">lock_class_key</span> <span class="operator">*</span><span class="params">key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> subsys_private *cp;</span><br><span class="line">    <span class="built_in">int</span> error;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_debug(<span class="string">&quot;device class &#x27;%s&#x27;: registering\n&quot;</span>, <span class="params">cls</span>-&gt;<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="comment">//动态创建一个 subsys_private 结构</span></span><br><span class="line">    cp = kzalloc(sizeof(*cp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!cp)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    klist<span class="constructor">_init(&amp;<span class="params">cp</span>-&gt;<span class="params">klist_devices</span>, <span class="params">klist_class_dev_get</span>, <span class="params">klist_class_dev_put</span>)</span>;</span><br><span class="line">    <span class="constructor">INIT_LIST_HEAD(&amp;<span class="params">cp</span>-&gt;<span class="params">interfaces</span>)</span>;</span><br><span class="line">    kset<span class="constructor">_init(&amp;<span class="params">cp</span>-&gt;<span class="params">glue_dirs</span>)</span>;</span><br><span class="line">    <span class="constructor">__mutex_init(&amp;<span class="params">cp</span>-&gt;<span class="params">mutex</span>, <span class="string">&quot;subsys mutex&quot;</span>, <span class="params">key</span>)</span>;</span><br><span class="line">    error = kobject<span class="constructor">_set_name(&amp;<span class="params">cp</span>-&gt;<span class="params">subsys</span>.<span class="params">kobj</span>, <span class="string">&quot;%s&quot;</span>, <span class="params">cls</span>-&gt;<span class="params">name</span>)</span>; <span class="comment">//初始化 class 目录名</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(cp);</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the default /sys/dev directory for devices of this class */</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;dev_kobj)</span><br><span class="line">        cls-&gt;dev_kobj = sysfs_dev_char_kobj; <span class="comment">//设置子设备的默认类型为char</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_BLOCK)</span><br><span class="line">    <span class="comment">/* let the block class directory show up in the root of sysfs */</span></span><br><span class="line">    <span class="keyword">if</span> (!sysfs_deprecated<span class="operator"> || </span>cls != &amp;block_class)</span><br><span class="line">        cp-&gt;subsys.kobj.kset = class_kset;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    cp-&gt;subsys.kobj.kset = class_kset; <span class="comment">//设置kset为class_kset 即出现在 /sys/class/目录下 (一般是不会设置class的父kobj的，因此默认使用kset作为父kobj)</span></span><br><span class="line">#endif</span><br><span class="line">    cp-&gt;subsys.kobj.ktype = &amp;class_ktype; <span class="comment">//初始化class的默认ktype</span></span><br><span class="line">    cp-&gt;<span class="keyword">class</span> = cls; </span><br><span class="line">    cls-&gt;p = cp;</span><br><span class="line"></span><br><span class="line">    error = kset<span class="constructor">_register(&amp;<span class="params">cp</span>-&gt;<span class="params">subsys</span>)</span>; <span class="comment">//注册kset创建对应的class节点，/sys/class/xxx</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(cp);</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line">    error = add<span class="constructor">_class_attrs(<span class="params">class_get</span>(<span class="params">cls</span>)</span>); <span class="comment">//增加引用计数，创建默认属性文件</span></span><br><span class="line">    <span class="keyword">class</span><span class="constructor">_put(<span class="params">cls</span>)</span>;</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL_GPL(<span class="params">__class_register</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-device-create"><a href="#3-device-create" class="headerlink" title="3) device_create"></a>3) device_create</h3><p>在 class 下创建对应的设备，返回创建的设备结构。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">struct device *device_create(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">                 dev_t devt, void *drvdata, <span class="keyword">const</span> char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list vargs;</span><br><span class="line">    struct device *dev;</span><br><span class="line"></span><br><span class="line">    va_start(vargs, fmt);</span><br><span class="line">    dev = device_create_vargs(<span class="class"><span class="keyword">class</span>, <span class="type">parent</span>, <span class="type">devt</span>, <span class="type">drvdata</span>, <span class="type">fmt</span>, <span class="type">vargs);</span></span></span><br><span class="line">    va_end(vargs);</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create);</span><br><span class="line"></span><br><span class="line">struct device *device_create_vargs(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">                   dev_t devt, void *drvdata, <span class="keyword">const</span> char *fmt,</span><br><span class="line">                   va_list args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> device_create_groups_vargs(<span class="class"><span class="keyword">class</span>, <span class="type">parent</span>, <span class="type">devt</span>, <span class="type">drvdata</span>, <span class="type">NULL</span>,<span class="type"></span></span></span><br><span class="line">                      fmt, args);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create_vargs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct device *</span><br><span class="line">device_create_groups_vargs(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">               dev_t devt, void *drvdata,</span><br><span class="line">               <span class="keyword">const</span> struct attribute_group **groups,</span><br><span class="line">               <span class="keyword">const</span> char *fmt, va_list args)</span><br><span class="line">&#123;</span><br><span class="line">    struct device *dev = NULL;</span><br><span class="line">    int retval = -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">class</span> == <span class="title">NULL</span> || <span class="title">IS_ERR</span></span>(<span class="class"><span class="keyword">class</span>))</span></span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        goto error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    dev-&gt;devt = devt; <span class="comment">//设置设备号</span></span><br><span class="line">    dev-&gt;<span class="class"><span class="keyword">class</span> = <span class="title">class</span>; //设置设备所属的类</span></span><br><span class="line">    dev-&gt;parent = parent; <span class="comment">//设备的父节点</span></span><br><span class="line">    dev-&gt;groups = groups; <span class="comment">//设置设备的默认</span></span><br><span class="line">    dev-&gt;release = device_create_release;</span><br><span class="line">    dev_set_drvdata(dev, drvdata); <span class="comment">//设置设备的私有数据</span></span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    retval = device_add(dev); <span class="comment">//注册设备 </span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>device_add 函数在前面已经有很详细的分析，这里不赘述，不过这里再补充说明一点，device_create 会在 /dev/ 目录下创建设备节点是因为设备有设备号，只要是<strong>调用 device_add 注册的设备，只要有设备号就会在 /dev/ 下创建设备节点</strong>,如果忘记的可以搜一搜 devtmpfs_create_node 这个函数，文章前面有提到这个函数</p>
<h3 id="4-属性操作接口"><a href="#4-属性操作接口" class="headerlink" title="4) 属性操作接口"></a>4) 属性操作接口</h3><p>属性文件是 class 重点内容，我们多用 class 来给上层提供接口，属性文件创建接口如下。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速创建 class_attribute</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">CLASS_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line">#define <span class="constructor">CLASS_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">CLASS_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline <span class="built_in">int</span> __must_check <span class="keyword">class</span><span class="constructor">_create_file(<span class="params">struct</span> <span class="params">class</span> <span class="operator">*</span><span class="params">class</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">class_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="五、platform设备"><a href="#五、platform设备" class="headerlink" title="五、platform设备"></a>五、platform设备</h1><p>在计算机中有这样一类设备，它们通过各自的设备控制器，直接和CPU连接，CPU可以通过常规的寻址操作访问它们（或者说访问它们的控制器）。这种连接方式，并不属于传统意义上的总线连接。但设备模型应该具备普适性，因此Linux就虚构了一条Platform Bus，供这些设备挂靠。</p>
<h2 id="1、数据结构-4"><a href="#1、数据结构-4" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-platform-device"><a href="#1-platform-device" class="headerlink" title="1) platform_device"></a>1) platform_device</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *name; <span class="comment">//设备名称</span></span><br><span class="line">    <span class="keyword">int</span>     id;</span><br><span class="line">    <span class="keyword">bool</span>        id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   <span class="title">dev</span>;</span> <span class="comment">//真正的设备，嵌入在platform_device中</span></span><br><span class="line">    u32     num_resources; <span class="comment">//设备资源</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver_override; <span class="comment">/* 如果设置了这个名字，这用这个名字匹配驱动，它的优先级最高 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>    <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-platform-driver"><a href="#2-platform-driver" class="headerlink" title="2) platform_driver"></a>2) platform_driver</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span></span> &#123;</span><br><span class="line">    int (*probe)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    int (*remove)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    void (*shutdown)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    int (*suspend)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *, pm_message_t state);</span><br><span class="line">    int (*resume)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span></span> driver;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span></span> *id_table;</span><br><span class="line">    <span class="built_in">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-resource"><a href="#3-resource" class="headerlink" title="3) resource"></a>3) resource</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、platform总线的构建"><a href="#2、platform总线的构建" class="headerlink" title="2、platform总线的构建"></a>2、platform总线的构建</h2><p>platform总线是内核提供的虚拟总线，它个构建依赖于前面的，bus，device，driver设备模型。首先内核提供了一个名字叫”platform”的默认总线，它是一个全局结构并且被EXPORT_SYMBOL_GPL导出，如下</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type <span class="attr">platform_bus_type</span> = &#123;</span><br><span class="line">    .<span class="attr">name</span>       = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .<span class="attr">dev_groups</span> = platform_dev_groups,</span><br><span class="line">    .<span class="attr">match</span>      = platform_match,</span><br><span class="line">    .<span class="attr">uevent</span>     = platform_uevent,</span><br><span class="line">    .<span class="attr">pm</span>     = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus_type);</span><br></pre></td></tr></table></figure>
<p>除此之外内核也提供了该总线下的一个设备，名字叫做”platform_bus”</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> platform_bus = </span>&#123;</span><br><span class="line">    .init_name  = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus);</span><br></pre></td></tr></table></figure>
<p><font color=red>这是一个设备结构，并不是bus，虽然他的名字叫做 platform_bus</font>, 我也不知道为啥叫这个名字，第一次读我就以为这是个bus。它作为基本设备，在device_register函数中将使用devices_kset作为它的父目录(没有设置父kobj时自动使用devices_kset作为父节点)，内核将会创建如下节点</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>devices/platform</span><br></pre></td></tr></table></figure>
<p>platform_bus 的结构只初始化了一个名字，为什么要注册一个只有名字的设备在这里，我想是为了方便管理，将它作为以后platform设备的父设备，以后只要是platform设备，都将出现在/sys/devices/platform下，一眼就能找出那些事platform设备。<br>上述的 platform_bus_type 和 platform_bus 是在platform_bus_init 中被注册的，它被driver_init调用，即在内核启动的时候被创建。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __init platform_bus_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">error</span>;</span><br><span class="line"></span><br><span class="line">    early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">error</span> = device_register(&amp;platform_bus); <span class="comment">//创建platform总线</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">error</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">    <span class="keyword">error</span> =  bus_register(&amp;platform_bus_type); <span class="comment">//创建一个名为&quot;platform&quot;的设备</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">error</span>)</span><br><span class="line">        device_unregister(&amp;platform_bus);</span><br><span class="line">    of_platform_register_reconfig_notifier();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后但凡是注册在platform总线上的设备都叫做platform设备，注册在该总线上的驱动叫做platform驱动</p>
<h2 id="3、platform-设备接口"><a href="#3、platform-设备接口" class="headerlink" title="3、platform 设备接口"></a>3、platform 设备接口</h2><p>内核在开机时创建了platform总线，同时也提供了该总线相关操作函数</p>
<h3 id="1-platform-device-register"><a href="#1-platform-device-register" class="headerlink" title="1) platform_device_register"></a>1) platform_device_register</h3><p>使用这个函数注册一个platform设备</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> platform<span class="constructor">_device_register(<span class="params">struct</span> <span class="params">platform_device</span> <span class="operator">*</span><span class="params">pdev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line">#ifdef CONFIG_MTPROF</span><br><span class="line">    unsigned long long ts = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line">    <span class="constructor">TIME_LOG_START()</span>;</span><br><span class="line">	<span class="comment">//对pdev-&gt;dev做一些初始化</span></span><br><span class="line">    device<span class="constructor">_initialize(&amp;<span class="params">pdev</span>-&gt;<span class="params">dev</span>)</span>;</span><br><span class="line">	<span class="comment">// 空函数，啥也没干</span></span><br><span class="line">    arch<span class="constructor">_setup_pdev_archdata(<span class="params">pdev</span>)</span>;</span><br><span class="line">	<span class="comment">//真正的注册函数</span></span><br><span class="line">    ret = platform<span class="constructor">_device_add(<span class="params">pdev</span>)</span>;</span><br><span class="line">    <span class="constructor">TIME_LOG_END()</span>;</span><br><span class="line">    bootprof<span class="constructor">_pdev_register(<span class="params">ts</span>, <span class="params">pdev</span>)</span>;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的注册函数是 platform_device_add</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">int platform_device_add(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    int i, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pdev)</span><br><span class="line">        return -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!pdev-&gt;</span>dev.parent)</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>dev.parent = &amp;platform_bus; <span class="comment">//设置设备的父设备为platform_bus</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">pdev</span>-&gt;</span>dev.bus = &amp;platform_bus_type; <span class="comment">//设置bus为platform_bus_type</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">switch</span> (pdev-&gt;</span><span class="function"><span class="title">id</span>) &#123; 设置 pdev-&gt;</span><span class="function"><span class="title">dev</span>-&gt;</span>init_name </span><br><span class="line">    default:</span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s.%d&quot;, pdev-&gt;</span><span class="function"><span class="title">name</span>,  pdev-&gt;</span>id);</span><br><span class="line">        break;</span><br><span class="line">    case PLATFORM_DEVID_NONE:	<span class="comment">// -1</span></span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s&quot;, pdev-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        break;</span><br><span class="line">    case PLATFORM_DEVID_AUTO: 	<span class="comment">// -2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Automatically allocated device ID. We mark it as such so</span></span><br><span class="line"><span class="comment">         * that we remember it must be freed, and we append a suffix</span></span><br><span class="line"><span class="comment">         * to avoid namespace collision with explicit IDs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ret = ida_simple_get(&amp;platform_devid_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            goto err_out;</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id = ret;</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id_auto = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s.%d.auto&quot;, pdev-&gt;</span><span class="function"><span class="title">name</span>, pdev-&gt;</span>id);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span> (i = 0; i &lt; pdev-&gt;</span>num_resources; i++) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> resource *p, *r = &amp;pdev-&gt;</span>resource[i];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (r-&gt;</span><span class="keyword">name</span> == NULL)</span><br><span class="line">            <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">name</span> = dev_name(&amp;pdev-&gt;</span>dev);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">p</span> = r-&gt;</span>parent;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resource_type(r) == IORESOURCE_MEM)</span><br><span class="line">                p = &amp;iomem_resource;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (resource_type(r) == IORESOURCE_IO)</span><br><span class="line">                p = &amp;ioport_resource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &amp;&amp; insert_resource(p, r)) &#123;</span><br><span class="line">            <span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">&quot;failed to claim resource %d\n&quot;</span>, i);</span><br><span class="line">            ret = -EBUSY;</span><br><span class="line">            goto failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;Registering platform device &#x27;%s&#x27;. Parent at %s\n&quot;</span>,</span><br><span class="line">         <span class="function"><span class="title">dev_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>), dev_name(pdev-&gt;</span>dev.parent));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向内核注册这个设备</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = device_add(&amp;pdev-&gt;</span>dev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line"> failed:</span><br><span class="line">    <span class="function"><span class="title">if</span> (pdev-&gt;</span>id_auto) &#123;</span><br><span class="line">        <span class="function"><span class="title">ida_simple_remove</span>(&amp;platform_devid_ida, pdev-&gt;</span>id);</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id = PLATFORM_DEVID_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> resource *r = &amp;pdev-&gt;</span>resource[i];</span><br><span class="line">        <span class="function"><span class="title">if</span> (r-&gt;</span>parent)</span><br><span class="line">            release_resource(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> err_out:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数设置设备的父设备为platform_bus，以后凡是挂接在 platform 总线上的设备都将使用 platform_bus作为它的父设备。即所有的设备都将在下面目录生成</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>devices<span class="regexp">/platform/</span>xxx</span><br></pre></td></tr></table></figure>
<h3 id="2-platform-driver-register"><a href="#2-platform-driver-register" class="headerlink" title="2) platform_driver_register"></a>2) platform_driver_register</h3><p>同样内核也提供了platform驱动的注册函数</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line">    <span class="variable">__platform_driver_register</span>(drv, THIS_MODULE)</span><br><span class="line"></span><br><span class="line">int <span class="variable">__platform_driver_register</span>(struct platform_driver *drv,</span><br><span class="line">                struct module *<span class="built_in">owner</span>)</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.<span class="built_in">owner</span> = <span class="built_in">owner</span>;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.bus = &amp;platform_bus_type;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.probe = platform_drv_probe;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.remove = platform_drv_remove;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将驱动注册进总线</span></span><br><span class="line">    return driver_register(&amp;drv-&gt;<span class="built_in">driver</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(<span class="variable">__platform_driver_register</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出drv的，probe，rmove函数被分别初始化为platform_drv_probe，platform_drv_remove。最后调用driver_register将驱动注册进总线</p>
<p>对于platform设备的注册最后会调用，device_add，它最终会遍历platform_bus_type上所有的drv，并对每一个drv调用platform_match函数。</p>
<p>而对于platform_driver的注册会调用driver_register，它最终会遍历platform_bus_type上左右的dev，对每一个dev都调用platform_match函数。</p>
<p>像这种交叉遍历的方式在内核中很常见，input子系统中也使用这样的方式。也就是无论如何只要总线上有设备，驱动注册的时候就会去与之匹配，同理总线上有驱动，设备注册时就会去与之匹配。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> platform<span class="constructor">_match(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">drv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> platform_device *pdev = <span class="keyword">to</span><span class="constructor">_platform_device(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> platform_driver *pdrv = <span class="keyword">to</span><span class="constructor">_platform_driver(<span class="params">drv</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* when driver_override is set, only bind to the matching driver */</span></span><br><span class="line">	<span class="comment">/* 如果设置了driver_override，则匹配和driver_override相同名字的驱动 */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        return !strcmp(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attempt an of style match first，使用设备树方式匹配 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">of</span><span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then try acpi style match */</span></span><br><span class="line">	<span class="comment">/* 电源相关，跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi<span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then try to match against the id table */</span></span><br><span class="line">	<span class="comment">/* 如果设置了id_table, 则与id_table中的名字进行匹配 */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        return platform<span class="constructor">_match_id(<span class="params">pdrv</span>-&gt;<span class="params">id_table</span>, <span class="params">pdev</span>)</span> != null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">	<span class="comment">/* 比较驱动和设备的名称 */</span></span><br><span class="line">    return (strcmp(pdev-&gt;name, drv-&gt;name)<span class="operator"> == </span><span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个函数可以看出platform设备的匹配方式有 5 种，按照优先级如下：</p>
<ol>
<li>如果设置了driver_override，则匹配和driver_override相同名字的设备，它的优先级最高</li>
<li>使用设备树方式匹配，这是目前比较常用的方式之一</li>
<li>电源相关方式匹配</li>
<li>如果设置了id_table, 则与id_table中的名字进行匹配</li>
<li>最后比较驱动和设备的名称，也是比较常用的方式之一</li>
</ol>
<p>其中比较常用的是设备树和设备驱动名称进行匹配，下面详细分析一下设备树匹配流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">of_driver_match_device</span><span class="params">(struct device *dev, <span class="keyword">const</span> struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of_match_device(drv-&gt;of_match_table, dev) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> struct of_device_id *<span class="title">of_match_device</span><span class="params">(<span class="keyword">const</span> struct of_device_id *matches, <span class="keyword">const</span> struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!matches) || (!dev-&gt;of_node))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> of_match_node(matches, dev-&gt;of_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *__<span class="title">of_match_node</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">matches</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> <span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">best_match</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> score, best_score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!matches)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; matches-&gt;name[<span class="number">0</span>] || matches-&gt;type[<span class="number">0</span>] || matches-&gt;compatible[<span class="number">0</span>]; matches++) &#123;</span><br><span class="line">        score = __of_device_is_compatible(node, matches-&gt;compatible,</span><br><span class="line">                          matches-&gt;type, matches-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">            best_match = matches;</span><br><span class="line">            best_score = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __of_device_is_compatible(<span class="keyword">const</span> struct device_node *device,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *compat, <span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compatible match has highest priority */</span></span><br><span class="line">    <span class="keyword">if</span> (compat &amp;&amp; compat[<span class="number">0</span>]) &#123;</span><br><span class="line">        prop = __of_find_property(device, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>); <span class="comment">/* 查找 compatible 节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (cp = of_prop_next_string(prop, <span class="literal">NULL</span>); cp;</span><br><span class="line">			<span class="comment">//获取该节点的字符串</span></span><br><span class="line">             cp = of_prop_next_string(prop, cp), index++)  </span><br><span class="line">			&#123;</span><br><span class="line">			<span class="comment">//获得的字符串和compat进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (of_compat_cmp(cp, compat, <span class="built_in">strlen</span>(compat)) == <span class="number">0</span>) &#123;</span><br><span class="line">                score = INT_MAX/<span class="number">2</span> - (index &lt;&lt; <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!score)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Matching type is better than matching name */</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp;&amp; type[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!device-&gt;type || of_node_cmp(type, device-&gt;type))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        score += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Matching name is a bit better than not */</span></span><br><span class="line">    <span class="keyword">if</span> (name &amp;&amp; name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!device-&gt;name || of_node_cmp(name, device-&gt;name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        score++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看 of_device_id 这个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    type[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    compatible[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们用到的是compatible作为匹配的对象，从结构看最对大支持的长度为128个字节。从上述代码可以看出匹配的过程就是匹配drv.id-&gt;compatible 和 dts中的compatible节点比较，hall的dts的节点如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hall: hall&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,hall-gpio-int&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在驱动中如下配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="comment">//创建一个 of_device_id 数组并初始化内部成员。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">hall_switch_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;mediatek,hall-gpio-int&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个platform_driver结构并对里面的driver结构进行初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">hall_driver</span> =</span> &#123;</span><br><span class="line">    .probe = hall_probe,</span><br><span class="line">    .suspend = hall_suspend,</span><br><span class="line">    .resume  = hall_resume,</span><br><span class="line">    .remove = ln4913_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">           .name = <span class="string">&quot;ln4913_Driver&quot;</span>,</span><br><span class="line">           .of_match_table = hall_switch_of_match,</span><br><span class="line">           &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出匹配其实是会遍历 hall_switch_of_match 数组中的compatible描述，也就是说一个驱动可以尝试匹配多个设备，直到匹配到为止。由前面的分析可知一旦匹配成功，就会调用really_probe函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---&gt; really_probe</span><br><span class="line">     ---&gt; dev-&gt;bus-&gt;probe(dev) <span class="comment">//默认点调用这个，明显platform_bus_type，没有设置prob函数</span></span><br><span class="line">     ---&gt; drv-&gt;probe(dev) <span class="comment">//如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用这函数，platform 驱动在注册的时候呢，将其初始化为platform_drv_probe                                                                                                 </span></span><br></pre></td></tr></table></figure>
<p>来看看platform总线提供的probe函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_drv_probe</span><span class="params">(struct device *_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">drv</span> =</span> to_platform_driver(_dev-&gt;driver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span> =</span> to_platform_device(_dev);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = of_clk_set_defaults(_dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = dev_pm_domain_attach(_dev, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != -EPROBE_DEFER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">            ret = drv-&gt;probe(dev); <span class="comment">//最后调用platform_driver结构中的probe函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                dev_pm_domain_detach(_dev, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* don&#x27;t fail if just dev_pm_domain_attach failed */</span></span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;prevent_deferred_probe &amp;&amp; ret == -EPROBE_DEFER) &#123;</span><br><span class="line">        dev_warn(_dev, <span class="string">&quot;probe deferral not supported\n&quot;</span>);</span><br><span class="line">        ret = -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实最终调用了platform_driver结构中的probe函数。</p>
<p>除此之外匹配id也是常用的方式，匹配代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct platform_device_id *<span class="title">platform_match_id</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct platform_device_id *id,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, id-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">            pdev-&gt;id_entry = id;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、创建自己的platform设备"><a href="#4、创建自己的platform设备" class="headerlink" title="4、创建自己的platform设备"></a>4、创建自己的platform设备</h2><h3 id="1-用名字进行匹配"><a href="#1-用名字进行匹配" class="headerlink" title="1) 用名字进行匹配"></a>1) 用名字进行匹配</h3><p><strong>注册platform_device</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span>  <span class="title">my_platform_dev</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_platform&quot;</span>, <span class="comment">//名字要和驱动的名字一样</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_device_register(&amp;my_platform_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_device_register(&amp;my_platform_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_dev_init);</span><br><span class="line">module_exit(my_platform_dev_exit);</span><br></pre></td></tr></table></figure>
<p><strong>注册platform_driver</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;my_platform&quot;</span>, <span class="comment">//名字要和device一样</span></span><br><span class="line">              &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_drv_init);</span><br><span class="line">module_exit(my_platform_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tb8768p1_64_bsp:</span>/cache <span class="meta"># insmod my_platform_drive.ko</span></span><br><span class="line"><span class="symbol">tb8768p1_64_bsp:</span>/cache <span class="meta"># insmod my_platform_device.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核打出my_platform_probe说明匹配成功</span></span><br><span class="line">[ <span class="number">2111.422598</span>] <span class="params">&lt;<span class="number">6</span>&gt;</span>.(<span class="number">5</span>)[<span class="number">3265</span>:insmod]my_platform_probe</span><br></pre></td></tr></table></figure>
<h3 id="2-用设备树方式匹配"><a href="#2-用设备树方式匹配" class="headerlink" title="2) 用设备树方式匹配"></a>2) 用设备树方式匹配</h3><p>dts增加配置</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">my_platform_dts:</span> <span class="class">my_platform_dts </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,my_platform&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注册platform_driver</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_platform_match</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;mediatek,my_platform&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;my_platform&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">                .of_match_table = my_platform_match,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">              &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_drv_init);</span><br><span class="line">module_exit(my_platform_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XF-X2:/cache <span class="comment"># insmod my_platform_drive.ko </span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>加载模块时内核打印出probe</span><br><span class="line">[ <span class="number">1018.455974</span>] &lt;<span class="number">4</span>&gt;.(<span class="number">7</span>)[<span class="number">3165</span>:insmod]my_platform_probe</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong><font color=red>由于作者水平有限，因此不能保证文章内容准确无误。如果你发现了文中的错误(哪怕是错别字也好)，请在评论区指出，任何提高文章质量的建议我都将虚心接纳，thanks</strong></font></li>
</ul>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>braon-z
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://example.com/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/" title="linux设备模型">https://example.com/2021/01/03/linux驱动-设备驱动模型-重构/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%A9%B1%E5%8A%A8/" rel="tag"><i class="fa fa-tag"></i> 驱动</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/" rel="prev" title="linux驱动-i2c">
                  <i class="fa fa-chevron-left"></i> linux驱动-i2c
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/18/makfile%E4%B8%93%E9%A2%98/" rel="next" title="makefile专题">
                  makefile专题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">braon-z</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">323k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:54</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"VsC1eQwQ4Xltm5eA9iYGp3VU-gzGzoHsz","appKey":"kyfyE4RWl6aIojedbxcuJa3V","serverURLs":null,"placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/",
      serverURLs: "https://vsc1eqwq.api.lncldglobal.com"
    }));
  }, window.Valine);
});
</script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fa fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fa fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
