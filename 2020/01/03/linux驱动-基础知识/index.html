<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":"ture","mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="前言: 整理 linux 相关基础知识点，参考文献  linux 字符设备驱动详解 LDD3 韦东山驱动大全&#x2F;linux 应用开发完全手册 4.0 文中提到的相关博客   特别说明：这篇文章为摘抄总结，非原创文章，如果内容涉及侵权请及时告知，作者会立即删除相关内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="linux驱动-基础知识">
<meta property="og:url" content="https://example.com/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="braon-z&#39;s blog">
<meta property="og:description" content="前言: 整理 linux 相关基础知识点，参考文献  linux 字符设备驱动详解 LDD3 韦东山驱动大全&#x2F;linux 应用开发完全手册 4.0 文中提到的相关博客   特别说明：这篇文章为摘抄总结，非原创文章，如果内容涉及侵权请及时告知，作者会立即删除相关内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/6.jpg">
<meta property="og:image" content="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/1-1.jpg">
<meta property="article:published_time" content="2020-01-03T01:14:17.000Z">
<meta property="article:modified_time" content="2021-08-30T04:59:55.171Z">
<meta property="article:author" content="braon-z">
<meta property="article:tag" content="驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/6.jpg">


<link rel="canonical" href="https://example.com/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>linux驱动-基础知识 | braon-z's blog</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">braon-z's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="nav-text">一、字符设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81struct-file-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1、struct file 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81struct-inode-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">2、struct inode 结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81struct-file-operations-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">3、struct file_operations 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89struct-module-owner"><span class="nav-text">1）struct module *owner;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89open-%E5%87%BD%E6%95%B0"><span class="nav-text">2）open() 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89read-%E5%87%BD%E6%95%B0"><span class="nav-text">3）read() 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89write-%E5%87%BD%E6%95%B0"><span class="nav-text">3）write() 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89ioctl-%E5%87%BD%E6%95%B0"><span class="nav-text">4）ioctl() 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">a. 命令的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="nav-text">b. 命令生成方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-text">c. 简单使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89llseek-%E5%87%BD%E6%95%B0"><span class="nav-text">5）llseek()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81struct-cdev-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">4、struct cdev 结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="nav-text">5、字符设备的注册与卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89cdev-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-text">1）cdev_init()初始化函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89cdev-add-%E5%87%BD%E6%95%B0"><span class="nav-text">2）cdev_add()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89cdev-del-%E5%87%BD%E6%95%B0"><span class="nav-text">3）cdev_del()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="nav-text">6、设备节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">7、字符设备驱动流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E7%94%A8%E6%88%B7%E4%B8%8E%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92"><span class="nav-text">8、用户与内核内存交互</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-text">二、同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="nav-text">1、原子变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1) 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-text">2) 原子操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81linux-%E4%B8%AD%E7%9A%84%E9%94%81"><span class="nav-text">2、linux 中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%87%AA%E6%97%8B%E9%94%81-spin-lock"><span class="nav-text">1) 自旋锁 spin_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">2) 信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">3) 互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4) 锁的使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81linux-%E9%98%9F%E5%88%97"><span class="nav-text">三、linux 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-text">1、等待队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E6%88%90%E5%91%98"><span class="nav-text">2. 添加&#x2F;删除等待队列成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%9B%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="nav-text">3. 进程休眠</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-wait-event"><span class="nav-text">1) wait_event</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-wait-event"><span class="nav-text">2) ___wait_event</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-init-wait-entry"><span class="nav-text">3) init_wait_entry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-prepare-to-wait-event"><span class="nav-text">4). prepare_to_wait_event</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B"><span class="nav-text">4. 唤醒进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-wake-up"><span class="nav-text">1) __wake_up</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-wake-up-common"><span class="nav-text">2) __wake_up_common</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">2、工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">3) 操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">1. 初始化工作队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B0%83%E5%BA%A6%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">2. 调度工作队列</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81linux%E5%86%85%E6%A0%B8%E9%80%9A%E7%9F%A5%E9%93%BE"><span class="nav-text">四、linux内核通知链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1、基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%8E%A5%E5%8F%A3%E6%95%B4%E7%90%86"><span class="nav-text">2、接口整理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E5%AD%90%E9%80%9A%E7%9F%A5%E9%93%BE"><span class="nav-text">1、原子通知链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%98%BB%E5%A1%9E%E9%80%9A%E7%9F%A5%E9%93%BE"><span class="nav-text">2、阻塞通知链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%8E%9F%E5%A7%8B%E9%80%9A%E7%9F%A5%E9%93%BE"><span class="nav-text">3、原始通知链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81SRCU-%E9%80%9A%E7%9F%A5%E9%93%BE"><span class="nav-text">4、SRCU 通知链</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="braon-z"
      src="/images/wallhaven.jfif">
  <p class="site-author-name" itemprop="name">braon-z</p>
  <div class="site-description" itemprop="description"> 爱一个人，攀一座山，追一次梦<br>不妨大胆一点，有很多事没有答案</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven.jfif">
      <meta itemprop="name" content="braon-z">
      <meta itemprop="description" content=" 爱一个人，攀一座山，追一次梦<br>不妨大胆一点，有很多事没有答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="braon-z's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux驱动-基础知识
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-03 09:14:17" itemprop="dateCreated datePublished" datetime="2020-01-03T09:14:17+08:00">2020-01-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-30 12:59:55" itemprop="dateModified" datetime="2021-08-30T12:59:55+08:00">2021-08-30</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>48k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>43 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>前言:</strong></p>
<p>整理 linux 相关基础知识点，参考文献</p>
<ul>
<li>linux 字符设备驱动详解</li>
<li>LDD3</li>
<li>韦东山驱动大全/linux 应用开发完全手册 4.0</li>
<li>文中提到的相关博客</li>
</ul>
<blockquote>
<p>特别说明：这篇文章为摘抄总结，非原创文章，如果内容涉及侵权请及时告知，作者会立即删除相关内容。</p>
</blockquote>
<a id="more"></a>
<h1 id="一、字符设备"><a href="#一、字符设备" class="headerlink" title="一、字符设备"></a><div align=center>一、字符设备</div></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;字符设备是指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED设备等，而字符设备用到的核心数据结构有<font color=red>file</font>、<font color=red>inode</font>、<font color=red>cdev</font>、<font color=red>file_operations</font>。</p>
<h2 id="1、struct-file-数据结构"><a href="#1、struct-file-数据结构" class="headerlink" title="1、struct file 数据结构"></a>1、struct file 数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;struct file 结构与用户空间程序中的FILE结构<font color=red>没有任何关联</font>，FILE结构在C库中定义不会出现在内核代码中，struct file 是一个内核结构，它不会出现在用户程序中。struct file 结构代表一个打开的文件(它不仅仅限定于设备驱动程序，<font color=red>系统中每个打开的文件在内核空间都有一个对应的 file 结构</font>)。它由内核在open时创建，并且传递给在该文件上操作的所有函数，直到最后的close函数，在文件的所有实例都被关闭后，内核会释放这个数据结构。在内核和驱动源代码中，<font color=red>struct file 的指针通常被命名为 file 或 filp </font>，为了不和这个结构本身混淆，我们一致将指向该结构的指针称为 filp，file 则为结构本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>        <span class="title">fu_llist</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>          <span class="title">fu_rcuhead</span>;</span></span><br><span class="line"> &#125; f_u;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">path</span>                  <span class="title">f_path</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f_dentry              f_path.dentry</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                 *<span class="title">f_inode</span>;</span>		<span class="comment">/* cached value */</span></span><br><span class="line"> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span>		<span class="comment">/* 和文件关联的操作 */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">  * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">spinlock_t</span>           f_lock;</span><br><span class="line"> <span class="keyword">atomic_long_t</span>        f_count;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span>         f_flags;			<span class="comment">/* 文件标志，如O_RDONLY、O_NONBLOCK、O_SYNC */</span></span><br><span class="line"> <span class="keyword">fmode_t</span>              f_mode;			<span class="comment">/* 文件读/写模式，FMODE_READ和FMODE_WRITE ，文件打开是已经做了判断，基本用不着 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>         <span class="title">f_pos_lock</span>;</span></span><br><span class="line"> <span class="keyword">loff_t</span>               f_pos;			<span class="comment">/* 当前读写位置 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>   <span class="title">f_owner</span>;</span></span><br><span class="line"> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>    *<span class="title">f_cred</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">　 u64                 f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFiG_SECURITY</span></span><br><span class="line"> <span class="keyword">void</span>         *f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line"> <span class="keyword">void</span>         *private_data;           <span class="comment">/* 文件私有数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFiG_EPOLL</span></span><br><span class="line"> <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">f_ep_links</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                                <span class="comment">/* #ifdef CONFiG_EPOLL */</span></span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));        <span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>
<p>这个数据结构中驱动相关的几个重要成员变量如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">重要成员</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">loff_t&nbsp;f_pos</td>
<td>当前读/写位置。loff_t有64位，驱动程序要知道文件中的当前位置，可以读取这个值，但不要去修改它。read/write会使用他们接收到的最后那个指针参数来更新这一位置，而不是直接针对filp-&gt;f_pos进行操作。这一规则的一个例外是llseek方法，该方法的目的本身就是为了修改文件位置</td>
</tr>
<tr>
<td align="left">unsigned&nbsp;int&nbsp;f_flags</td>
<td>文件标志，如O_RDONLY、O_NONBLOCK、O_SYNC，检查用户的请求是否是非阻塞式的操作，驱动程序需要检查O_NONBLOCK标志，而其他标志很少用到。注意：检测读写权限应该使用f_mode而不是f_flags。所有这些标志都被定义在&lt;linux/fcntl.h&gt;中</td>
</tr>
<tr>
<td align="left">struct&nbsp;file_operations&nbsp;*f_op;</td>
<td>与文件相关的操作。内核在执行open操作时对这个指针赋值，以后需要处理这个操作时就读取这个指针。</td>
</tr>
<tr>
<td align="left">void *private_data;</td>
<td>file 结构的私有数据，被初始化为NULL</td>
</tr>
</tbody></table>
<h2 id="2、struct-inode-结构体"><a href="#2、struct-inode-结构体" class="headerlink" title="2、struct inode 结构体"></a>2、struct inode 结构体</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;内核用inode结构在内部表示文件，因此它和file结构不同，后者表示打开的文件描述。对单个文件可能有多个打开的file文件描述(上层可以多次open一个文件)，但他们都指向同一个inode文件。inode包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等大量文件信息。部分数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">umode_t</span> i_mode;        <span class="comment">/* inode的权限 */</span></span><br><span class="line">    <span class="keyword">uid_t</span> i_uid;           <span class="comment">/* inode拥有者的id */</span></span><br><span class="line">    <span class="keyword">gid_t</span> i_gid;           <span class="comment">/* inode所属的群组id */</span></span><br><span class="line">    <span class="keyword">dev_t</span> i_rdev;          <span class="comment">/* 若是设备文件，此字段将记录设备的设备号 */</span></span><br><span class="line">    <span class="keyword">loff_t</span> i_size;         <span class="comment">/* inode所代表的文件大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_atime</span>;</span> <span class="comment">/* inode最近一次的存取时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_mtime</span>;</span> <span class="comment">/* inode最近一次的修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_ctime</span>;</span> <span class="comment">/* inode的产生时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_blkbits;</span><br><span class="line">    <span class="keyword">blkcnt_t</span>        i_blocks;    <span class="comment">/* inode所使用的block数，一个block为512 字节 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">i_cdev</span>;</span>       <span class="comment">/* 若是字符设备，为其对应的cdev结构体指针。 若是块设备，为其对应的block_device结构体指针*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中驱动对驱动编程有用的成员变量只有两个如下：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>dev_t&nbsp;i_rdev</td>
<td>表示设备文件inode结构，它包含了真正的设备编号</td>
</tr>
<tr>
<td>struct&nbsp;cdev&nbsp;*i_cdev</td>
<td>当inode指向一个字符设备文件时，i_cdev为其对应的cdev结构体指针</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在驱动中也可通过i_rdev获取设备号，内核提供了下面两个函数来获取inode结构中i_rdev字段中的设备号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">imajor</span><span class="params">(struct inode* inode)</span></span>;  <span class="comment">//获取主设备号</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">iminor</span><span class="params">(struct inode* inode)</span></span>;  <span class="comment">//获取次设备号</span></span><br></pre></td></tr></table></figure>
<h2 id="3、struct-file-operations-结构体"><a href="#3、struct-file-operations-结构体" class="headerlink" title="3、struct file_operations 结构体"></a>3、struct file_operations 结构体</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;该结构体是系统调用与驱动连接的桥梁，例如：当我们在应用层使用open函数打开一个设备的时候，内核会创建一个file结构并关联file_operations中的一组函数，最终会调用到驱动中关联的file_operations结构体实例中open函数。而file_operations定义了一组操作函数，我们不一定全部用到，通常用到什么函数就关联什么函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">  <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">  <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">  <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">  <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">  <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">  <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line">  <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,<span class="keyword">loff_t</span> len);</span><br><span class="line">  <span class="keyword">int</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;file_operations的重要性不言而喻，因此以下详细给出重要成员的说明.</p>
<h3 id="1）struct-module-owner"><a href="#1）struct-module-owner" class="headerlink" title="1）struct module *owner;"></a>1）struct module *owner;</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一个指向拥有这个结构的模块的指针，内核使用这个字段以避免在模块的操作正在被使用时卸载该模块，几乎所有情况被初始化为THIS_MODULE。</p>
<h3 id="2）open-函数"><a href="#2）open-函数" class="headerlink" title="2）open() 函数"></a>2）open() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对设备文件进行的第一个操作，不要求驱动声明一个对应的方法。如果这个函数没有实现，当用户调用open()时，一直显示成功，但是你的驱动不会得到通知。open函数提供给驱动程序以初始化的能力，从而<font color=red>为以后的操作完成初始化做准备</font>。大部分驱动程序中应当完成下面工作。</p>
<blockquote>
<ol>
<li>检测设备特定的错误（注入设备未就绪或类似的硬件问题）</li>
<li>如果设备是首次打开，则对其进行初始化。</li>
<li>如果有必要，更新fop指针</li>
<li>分配并填写置于 filp-&gt;private_date 里的数据结构</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int (*open) (struct inode *inode , struct file *filp);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>inode</td>
<td>为文件节点(详细见前面inode结构)</td>
</tr>
<tr>
<td>filp</td>
<td>指向内核创建的文件结构(详细见前面file结构)</td>
</tr>
</tbody></table>
<h3 id="3）read-函数"><a href="#3）read-函数" class="headerlink" title="3）read() 函数"></a>3）read() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用来从设备读取数据，成功时函数返回读取的字节数，返回值是一个 “signed size” 类型, 常常是目标平台本地的整数类型，出错时返回一个负值,如果此函数未实现(被指为NULL)，当用户调用read()时，将得到 -EINVAL 的返回值，它与用户空间的fread()函数对应。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>ssize_t (*read) (struct file *filp, char __user *buffer, size_t size , loff_t *ppos);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>filp</td>
<td>指向内核创建的文件结构</td>
</tr>
<tr>
<td>buffer</td>
<td>为对应放置信息的缓冲区（即用户空间内存地址）</td>
</tr>
<tr>
<td>size</td>
<td>为要读取的信息长度,以字节为单位</td>
</tr>
<tr>
<td>ppos</td>
<td>为读的位置相对于文件开头的偏移，在读取信息后，这个指针一般都会移动，移动的值为要读取信息的长度值</td>
</tr>
</tbody></table>
<h3 id="3）write-函数"><a href="#3）write-函数" class="headerlink" title="3）write() 函数"></a>3）write() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;向设备发送数据，成功时返回写入的字节数，如果此函数未实现，当用户调用write()时，将得到 -EINVAL 的返回值，它与用户空间的fwrite()函数对应</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>ssize_t (*write) (struct file * filp, const char __user *buffer, size_t size, loff_t * ppos);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>filp</td>
<td>指向系统open时内核创建的文件结构</td>
</tr>
<tr>
<td>buffe</td>
<td>用户要写入文件的信息缓冲区</td>
</tr>
<tr>
<td>size</td>
<td>要写入信息的长度</td>
</tr>
<tr>
<td>ppos</td>
<td>当前的读/写位置，这个值通常是用来判断写文件是否越界</td>
</tr>
</tbody></table>
<blockquote>
<p>注：这个操作和上面的对文件进行读的操作均为阻塞操作</p>
</blockquote>
<h3 id="4）ioctl-函数"><a href="#4）ioctl-函数" class="headerlink" title="4）ioctl() 函数"></a>4）ioctl() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;提供设备相关控制命令的实现（既不是读操作也不是写操作），当调用成功时，返回给调用程序一个非负值。如果设备不提供ioctl入口点，则对于任何内核未预先定义的请求，ioctl系统调用将返回错误。(-ENOTTY,”No such ioctl for device, 该设备无此iotcl命令”)。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int (*ioctl) (struct inode *inode, struct file *flip, unsigned int cmd, unsigned long arg);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>inode</td>
<td>为文件节点</td>
</tr>
<tr>
<td>filp</td>
<td>指向系统open时内核创建的文件结构</td>
</tr>
<tr>
<td>cmd</td>
<td>从用户那里不改变地传下来的命令</td>
</tr>
<tr>
<td>arg</td>
<td>对应命令的参数</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为了保证用户传递下来的命令安全可靠，内核定义了iotcl命令的组成方式，当使用这个函数是应当遵循这个规则。</p>
<h4 id="a-命令的组成"><a href="#a-命令的组成" class="headerlink" title="a. 命令的组成"></a>a. 命令的组成</h4><img width=800 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/6.jpg" >

<ul>
<li><strong>设备类型</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;设备类型由8位组成，在linux下我们将它称为“幻数”，可以是0~0xFF之间的值，内核中的 ioctl-number.txt 给出了一些推荐的和已经被使用的“幻数”，新设备驱动定义“幻数”的时候要避免与其冲突。</li>
<li><strong>方向</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;方向由2位组成，表示数据传输的方向</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>_IOC_NONE</td>
<td>无数据传输</td>
</tr>
<tr>
<td>_IOC_READ</td>
<td>读操作</td>
</tr>
<tr>
<td>_IOC_WRITE</td>
<td>写操作</td>
</tr>
<tr>
<td>_IOC_READ | _IOC_WRITE</td>
<td>双向操作</td>
</tr>
</tbody></table>
<ul>
<li><strong>数据尺寸</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;数据长度字段表示涉及的用户数据的大小，这个成员的宽度依赖于体系结构，通常是 13 位或者14 位。</p>
<h4 id="b-命令生成方式"><a href="#b-命令生成方式" class="headerlink" title="b. 命令生成方式"></a>b. 命令生成方式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;linux也给出了该命令生成的方式，用户空间与内核空间应声明为相同方式。声明方式如下：</p>
<ul>
<li><strong>_IO()</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;用于生成不涉及数据传输的简单命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IOR()</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;用于生成读操作命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),\</span></span><br><span class="line">  (_IOC_TYPECHECK(size)))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IOW()</strong></li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;用于生成写操作命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),\</span></span><br><span class="line">  (_IOC_TYPECHECK(size)))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IOWR()</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;用于生成即可读也可写的操作命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr), \</span></span><br><span class="line">  (_IOC_TYPECHECK(size)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IO、_IOR 等使用的_IOC 宏</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line">   (((dir) &lt;&lt; _IOC_DIRSHIFT) | \</span><br><span class="line">   ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span><br><span class="line">   ((nr) &lt;&lt; _IOC_NRSHIFT) | \</span><br><span class="line">   ((size) &lt;&lt; _IOC_SIZESHIFT))</span><br></pre></td></tr></table></figure>
<h4 id="c-简单使用"><a href="#c-简单使用" class="headerlink" title="c. 简单使用"></a>c. 简单使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;下面的代码为伪代码，主要用于说明使用方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_NAME <span class="meta-string">&#x27;D&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_CMD				_IO( DEV_NAME, 0)	<span class="comment">//只向内核传递一条DEV_CMD命令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_CMD_READ_SOMTHING	_IOR(DEV_NAME, 1, unsigned int)	<span class="comment">//从内核读取一些数据(数据类型 unsigned int)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_CMD_WRITE_SOMTHING	_IOW(DEV_NAME, 2, unsigned int)	<span class="comment">//向内核写入一些数据(数据类型 int)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5）llseek-函数"><a href="#5）llseek-函数" class="headerlink" title="5）llseek()函数"></a>5）llseek()函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用来修改一个文件当前读写位置，并将新位置返回，出错时这个函数返回一个负值。如果这个函数指针是NULL，对seek的钓鱼用将会以某种不可预期的方式修改file结构中的位置计数器。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>loff_t (*llseek) (struct file *filp , loff_t p, int orig);</th>
</tr>
</thead>
<tbody><tr>
<td>filp</td>
<td>指向系统open时内核创建的文件结构</td>
</tr>
<tr>
<td>p</td>
<td>当前的读/写位置，这个值通常是用来判断写文件是否越界</td>
</tr>
<tr>
<td>orig</td>
<td>文件定位的地址，文件开头（SEEK_SET、0），当前位置（SEEK_CUR、1），文件末尾（SEEK_END、2）</td>
</tr>
</tbody></table>
<blockquote>
<p>更多请参考博客<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Ph-one/p/4670804.html">Ph_one</a>以及书籍<strong>linux设备驱动开发详解</strong></p>
</blockquote>
<h2 id="4、struct-cdev-结构体"><a href="#4、struct-cdev-结构体" class="headerlink" title="4、struct cdev 结构体"></a>4、struct cdev 结构体</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这也是字符设备最重要的数据结构之一，在当前的liux内核中每一个字符设备都有一个cdev描述，即一个cdev结构表示一个字符设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> 			<span class="comment">/* 内嵌的kobject对象 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>			<span class="comment">/* 所属模块*/</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>		<span class="comment">/* 文件操作结构体*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="keyword">dev_t</span> dev;				<span class="comment">/* 设备号*/</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;利用这个数据结构就可以在内核创建一个字符设备，分配和初始化cdev的方式有两种，第一种是直接利用同struct cdev类型创建，除此之外还可以使用运行时使用动态创建以及释放，函数接口如下表所示</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>struct&nbsp;cdev&nbsp;*cdev_alloc(void)</td>
<td>动态申请一个cdev内存。</td>
</tr>
<tr>
<td>void&nbsp;cdev_put(struct cdev *p)</td>
<td>释放cdev_alloc申请的内存</td>
</tr>
</tbody></table>
<h2 id="5、字符设备的注册与卸载"><a href="#5、字符设备的注册与卸载" class="headerlink" title="5、字符设备的注册与卸载"></a>5、字符设备的注册与卸载</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;获得cdev这个结构之后我们还需将其初始化以及注册到内核。</p>
<h3 id="1）cdev-init-初始化函数"><a href="#1）cdev-init-初始化函数" class="headerlink" title="1）cdev_init()初始化函数"></a>1）cdev_init()初始化函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);            <span class="comment">// 将整个结构体清零；</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);              <span class="comment">// 初始化list成员使其指向自身；</span></span><br><span class="line">    cdev-&gt;kobj.ktype = &amp;ktype_cdev_default;   <span class="comment">// 初始ktype</span></span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj);                <span class="comment">// 初始化kobj成员；</span></span><br><span class="line">    cdev-&gt;ops = fops                          <span class="comment">// 初始化ops成员；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;初始化函数主要完成以下几个功能，其中就包括建立cdev和file_operation 之间的连接</p>
<ol>
<li>将整个cdev结构体清零</li>
<li>初始化list成员使其指向自身</li>
<li>初适化kobj成员</li>
<li>初始化cdev-&gt;ops，即建立cdev和file_operation 之间的连接</li>
</ol>
<h3 id="2）cdev-add-函数"><a href="#2）cdev-add-函数" class="headerlink" title="2）cdev_add()函数"></a>2）cdev_add()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;dev = dev;</span><br><span class="line">    p-&gt;count = count;</span><br><span class="line">    <span class="keyword">return</span> kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>, exact_match, exact_lock, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中count参数是应该和该设备关联的设备编号的数量，count经常取1，但是也存在多个设备编号对应一个特定的设备的特殊情况。cdev_add()可能会失败，如果它返回一个负的错误码，则设备不会被添加到系统中。但这个调用几乎总会成功。对cdev_add的调用通常发生在字符设备驱动模块加载函数中，一旦调用成功，我们的设备就”活”了，他的操作就会被内核调用，因此在驱动设备还没有完全准备好处理设备上的操作时，不能调用cdev_add。这个函数主要完成的功能如下：</p>
<ol>
<li>初始化cdev结构的dev设备号</li>
<li>初始化cdev的设备数目</li>
<li>向系统添加一个cdev，完成字符设备的注册</li>
</ol>
<h3 id="3）cdev-del-函数"><a href="#3）cdev-del-函数" class="headerlink" title="3）cdev_del()函数"></a>3）cdev_del()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cdev_unmap(p-&gt;dev, p-&gt;count);</span><br><span class="line">    kobject_put(&amp;p-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;向系统删除一个cdev，完成字符设备的卸载，对cdev_del的调用通常发生在字符设备驱动模块卸载函数中，当cdev_del被调用后对应的cdev结构就不应被访问了。在早期的内核中还有另外一种注册卸载字符设备的方式，使用register_chrdev()注册用unregister_chrdev()卸载具体如下表所示：</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int register_chrdev(unsigned int major, const char* name, struct file_operations* fops)</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>major</td>
<td>设备的主设备号</td>
</tr>
<tr>
<td>name</td>
<td>驱动程序的名称</td>
</tr>
<tr>
<td>fops</td>
<td>默认的file_operations结构</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用这个函数将为给定的主设备号注册0~255作为次设备号，并为每个设备建立一个对应默认cdev结构。使用这一接口的驱动程序必须能够处理所有256个次设备号的open调用，而且也不能使用大于255的主设备号和次设备号。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int unregister_chrdev(unsigned int major, const char* name)</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>major</td>
<td>要卸载的设备的主设备号</td>
</tr>
<tr>
<td>name</td>
<td>要卸载驱动程序的名称</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;新的代码中不应在使用这些接口，这种机制在未来的内核中将会消失。</p>
<h2 id="6、设备节点"><a href="#6、设备节点" class="headerlink" title="6、设备节点"></a>6、设备节点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设备节点设备驱动程序的接口，出现在文件系统中就好像它是普通文件一样，通常在/dev目录下，创建设备节点的方式有两种，一种是手动创建，linux内核在运行起来之后，在系统中通过命令手动创建，命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建设备节点</span></span><br><span class="line">mknod /dev/xyz c（表示是字符设备） 主设备号 次设备号</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看设备信息：</span></span><br><span class="line">ls -l /dev/xyz</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;除此之外还可以在驱动中自动创建设备文件，该方式依赖于设备模型，<font color=red>字符设备和设备模型的通过设备号关联在一起，只要有设备号就会在 /dev/ 下创建设备节点</font>，参考<a target="_blank" rel="noopener" href="https://baron-z.cn/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/#more">设备驱动模型</a>，在这篇文章中搜索 <strong>devtmpfs_create_node</strong>。，一般情况下我们通常按照下面步骤创建</p>
<ol>
<li>调用class_create()函数，可以用它来创建一个类，这个类存放于sys/class/下面，</li>
<li>再调用 device_create() 函数来在/dev目录下创建相应的设备节点，同时也会在sys/class/下创建出对应的设备文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// owner: 模块的拥有着，一般为&quot;THIS_MODULE&quot;</span></span><br><span class="line"><span class="comment">// name : 类名，创建成功后显示 &quot;/sys/class/xxx&quot;</span></span><br><span class="line"><span class="function">struct class *<span class="title">class_create</span><span class="params">(struct <span class="keyword">module</span> *owner, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class: 设备模型中设备所属的类</span></span><br><span class="line"><span class="comment">// parent: 要创建的设备的父设备</span></span><br><span class="line"><span class="comment">// devt: 添加该设备的设备号 dev_t，用于关联字符设备</span></span><br><span class="line"><span class="comment">// drvdata: 该设备的私有数据</span></span><br><span class="line"><span class="comment">// fmt: 备名的名称,创建成功后，将出现 &quot;dev/fmt&quot; 已经 &quot;/sys/class/xxx/fmt&quot;</span></span><br><span class="line"><span class="function">struct device *<span class="title">device_create</span><span class="params">(struct class *class, struct device *parent, <span class="keyword">dev_t</span> devt, <span class="keyword">void</span> *drvdata, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当卸载设备的时候使用函数 device_destroy()从linux内核系统设备驱动程序模型中移除一个设备，并删除/sys/devices/virtual目录下对应的设备目录及/dev/目录下对应的设备文</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dev:  创建的设备类</span></span><br><span class="line"><span class="comment">// devt: 对应的设备号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_destroy</span><span class="params">(struct class *dev, <span class="keyword">dev_t</span> devt)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="7、字符设备驱动流程"><a href="#7、字符设备驱动流程" class="headerlink" title="7、字符设备驱动流程"></a>7、字符设备驱动流程</h2><p>1）应用层使用open、write、read函数操作dev目录下的设备文件<br>2）设备文件通过内核中对应设备的主设备号，次设备号，找到对应的file_operations结构<br>3）调用file_operations结构中对应的open、write、read函数驱动相关硬件进行操作</p>
<img width=300 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/1-1.jpg" >

<h2 id="8、用户与内核内存交互"><a href="#8、用户与内核内存交互" class="headerlink" title="8、用户与内核内存交互"></a>8、用户与内核内存交互</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;用户空间与内核空间之间的数据不能直接进行简单的赋值交互，linux内核提供了两者交互的函数通过 copy_from_user 获取用户空间的数据，通过 copy_to_user 将内核空间的数据传给用户空间，当操作成功后均返回0，操作失败返回负值。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>static inline unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n)</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>to</td>
<td>目标地址，内核空间地址</td>
</tr>
<tr>
<td>from</td>
<td>源地址，用户空间地址</td>
</tr>
<tr>
<td>n</td>
<td>要拷贝的数据字节数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><div align=center><strong>函数接口</strong></td>
<td><div align=center><strong>unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)</strong></td>
</tr>
<tr>
<td>to</td>
<td>目标地址，用户空间地址</td>
</tr>
<tr>
<td>from</td>
<td>源地址，内核空间地址</td>
</tr>
<tr>
<td>n</td>
<td>要拷贝的数据字节数</td>
</tr>
</tbody></table>
<h1 id="二、同步与互斥"><a href="#二、同步与互斥" class="headerlink" title="二、同步与互斥"></a><div align=center>二、同步与互斥</div></h1><p> &nbsp;&nbsp;&nbsp;&nbsp;<font color=red>互斥</font>指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是<strong>无序</strong>的。<font color=red>同步</font>指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的<strong>有序</strong>访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<p>参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxNTAyOTczMw==&mid=2649332930&idx=1&sn=cf6b11d2d344e1f192d07d5f5467bccb&chksm=83977848b4e0f15e0650ec8e39593a755d19f4e4f32b8a25e2a2de7ecb0a641bba98019f7e98&scene=126&sessionid=1594705404&key=fa39e04f3e1bcf44088e1716b6d43d3a03b055518147584373ba2c95ca0956ad080126390dacea464cf8ffc82257ffe2d3bf3ebcb9405b6446a978c602cb657a4da2cd6b3cbf401b3a61731f333a9093&ascene=1&uin=NjY2NDMyNjc3&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=Ac2AMR9MZ4QTTczcCBTu2/E=&pass_ticket=zyBtnDr5s7LlelcQOyYHgtbncGCTFppo47/yH8Kh7rf/WiwN/09CMEDyCfHkbEIF">【干货】同步与互斥的失败例子</a></p>
<h2 id="1、原子变量"><a href="#1、原子变量" class="headerlink" title="1、原子变量"></a>1、原子变量</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1) 基本概念"></a>1) 基本概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 原子操作的基本单位，原子操作指的是由多步操作组成的一个操作。如果操作不能原子地执行，则要么执行完所有的步骤，要么一步也不执行，不可能执行所有步骤的一个子集。<font color=red>原子操作就是不能打断的操作</font>，内核定义的原子变量结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel<span class="number">-4.4</span>/include/linux/types.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;armv6 之前的架构 soc 不支持 smp，因此原子变量的实现非常简单，直接采用关中断的方式，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">arch\arm\include\<span class="keyword">asm</span>\atomic.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OP(op, c_op, asm_op)                 \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> atomic_#<span class="meta">#op(int i, atomic_t *v)  \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;            \  </span><br><span class="line">                                    \  <span class="comment">// 直接关闭中断</span></span><br><span class="line">    raw_local_irq_save(flags);      \</span><br><span class="line">    v-&gt;counter c_op i;              \</span><br><span class="line">    raw_local_irq_restore(flags);   \  <span class="comment">// 打开中断</span></span><br><span class="line">&#125;                                   \</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OP_RETURN(op, c_op, asm_op)              \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> atomic_#<span class="meta">#op##_return(int i, atomic_t *v)      \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;            \</span><br><span class="line">    <span class="keyword">int</span> val;                        \</span><br><span class="line">                                    \</span><br><span class="line">    raw_local_irq_save(flags);      \   <span class="comment">// 直接关闭中断 </span></span><br><span class="line">    v-&gt;counter c_op i;              \</span><br><span class="line">    val = v-&gt;counter;               \</span><br><span class="line">    raw_local_irq_restore(flags);   \  <span class="comment">// 打开中断</span></span><br><span class="line">                                    \</span><br><span class="line">    <span class="keyword">return</span> val;                     \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_FETCH_OP(op, c_op, asm_op)               \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> atomic_fetch_#<span class="meta">#op(int i, atomic_t *v)         \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;            \</span><br><span class="line">    <span class="keyword">int</span> val;                        \</span><br><span class="line">                                    \</span><br><span class="line">    raw_local_irq_save(flags);      \  <span class="comment">// 直接关闭中断 </span></span><br><span class="line">    val = v-&gt;counter;               \</span><br><span class="line">    v-&gt;counter c_op i;              \</span><br><span class="line">    raw_local_irq_restore(flags);   \  <span class="comment">// 打开中断</span></span><br><span class="line">                                    \</span><br><span class="line">    <span class="keyword">return</span> val;                     \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OPS(op, c_op, asm_op)                    \</span></span><br><span class="line">    ATOMIC_OP(op, c_op, asm_op)                 \</span><br><span class="line">    ATOMIC_OP_RETURN(op, c_op, asm_op)              \</span><br><span class="line">    ATOMIC_FETCH_OP(op, c_op, asm_op)</span><br></pre></td></tr></table></figure>



<p>&nbsp;&nbsp;&nbsp;&nbsp;smp 系统则是使用<font color=dark>内联汇编来实现的</font>。对于 atomic_read 和 atomic_set 这些操作都只需要一条汇编指令，他们本身就是原子的。而 atomic_add 等操作，需要读出，修改，写入则需要特别处理,以 atomic_add 为例说明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除接续符方便代码阅读</span></span><br><span class="line">arch\arm\include\<span class="keyword">asm</span>\atomic.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 6  <span class="comment">// 当 arm 架构 &gt; armv6 的实现</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OP(op, c_op, asm_op)                 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> atomic_#<span class="meta">#op(int i, atomic_t *v)          </span></span><br><span class="line">&#123;                                                     </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;                                </span><br><span class="line">    <span class="keyword">int</span> result;                                       </span><br><span class="line">                                                      </span><br><span class="line">    prefetchw(&amp;v-&gt;counter);                           </span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;@ atomic_&quot;</span> <span class="meta">#op <span class="meta-string">&quot;\n&quot;</span>         </span></span><br><span class="line"><span class="string">&quot;1: ldrex   %0, [%3]\n&quot;</span>         <span class="comment">// 从第 3 个操作数 &quot;r&quot; 的地址读出值，存入第 1 个操作数 &quot;=&amp;r&quot;</span></span><br><span class="line"><span class="string">&quot;   &quot;</span> #asm_op <span class="string">&quot; %0, %0, %4\n&quot;</span>   <span class="comment">// 将第 0 个操作数 &quot;=&amp;r&quot; 加上第 4 个操作数 &quot;Ir&quot; 结果存回第 0 个操作数 &quot;=&amp;r&quot;</span></span><br><span class="line"><span class="string">&quot;   strex   %1, %0, [%3]\n&quot;</span>     <span class="comment">// 将第 0 个操作数的值，即计算的结果，存入第 3 个操作数的值，即 v-&gt;counter 中</span></span><br><span class="line"><span class="string">&quot;   teq %1, #0\n&quot;</span>               <span class="comment">// 判断返回值是否为 0 如果不是跳转到 1: 重新执行上述操作。</span></span><br><span class="line"><span class="string">&quot;   bne 1b&quot;</span> </span><br><span class="line">    <span class="comment">// 第 0 个操作数为 &quot;=&amp;r&quot;  值为 result</span></span><br><span class="line">    <span class="comment">// 第 1 个操作数为 &quot;=&amp;r&quot;  值为 tmp</span></span><br><span class="line">    <span class="comment">// 第 2 个操作数为 &quot;+Qo&quot;  值为 v-&gt;counter</span></span><br><span class="line">    <span class="comment">// 第 3 个操作数为 &quot;r&quot;    值为 &amp;v-&gt;counter</span></span><br><span class="line">    <span class="comment">// 第 4 个操作数为 &quot;cc&quot;   值为 i</span></span><br><span class="line">    : <span class="string">&quot;=&amp;r&quot;</span> (result), <span class="string">&quot;=&amp;r&quot;</span> (tmp), <span class="string">&quot;+Qo&quot;</span> (v-&gt;counter) </span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (&amp;v-&gt;counter), <span class="string">&quot;Ir&quot;</span> (i)                     </span><br><span class="line">    : <span class="string">&quot;cc&quot;</span>);                                          </span><br><span class="line">&#125;                                                     </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OPS(op, c_op, asm_op)            \</span></span><br><span class="line">    ATOMIC_OP(op, c_op, asm_op)                 \</span><br><span class="line">    ATOMIC_OP_RETURN(op, c_op, asm_op)          \</span><br><span class="line">    ATOMIC_FETCH_OP(op, c_op, asm_op)</span><br><span class="line"></span><br><span class="line">ATOMIC_OPS(add)</span><br><span class="line">ATOMIC_OPS(sub)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;原子操作的实现也主要依靠上述的两条指令 ldrex 和 strex</p>
<ul>
<li><p>ldrex  r0, [r1]<br>读取 r1 所指内存的数据，存入 r0；</p>
</li>
<li><p>strex  r2, r0, [r1]<br>把 r0 的值写入 r1 所指内存，把 r2 设为 0 表示成功。如果没有写入则把 r2 设为 1 表示失败。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这两条指令怎么实现原子操作的呢，是通过 <font color=blue>Local monitor</font> 和<font color=blue> Global monitor </font>来实现的。<font color=blue>Local monitor</font> ：对非共享内存和共享内存都会使用到，是对该 CPU <font color=red>本地的内存进行标记</font>。<font color=blue> Global monitor </font> ： 对共享内存使用，也就是<font color=purple>多个 CPU 都依赖于Global monitor</font>。</p>
<p>对于同一个 cpu 的多线程处理方式如下</p>
<table>
<thead>
<tr>
<th align="center">thread 1</th>
<th align="center">thread 2</th>
<th align="center">local monitor的状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">Open Access state</td>
</tr>
<tr>
<td align="center">LDREX</td>
<td align="center"></td>
<td align="center">Exclusive Access state</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">LDREX</td>
<td align="center">Exclusive Access state</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Modify</td>
<td align="center">Exclusive Access state</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">STREX</td>
<td align="center">Open Access state</td>
</tr>
<tr>
<td align="center">Modify</td>
<td align="center"></td>
<td align="center">Open Access state</td>
</tr>
<tr>
<td align="center">STREX</td>
<td align="center"></td>
<td align="center">在 Open Access state 的状态下，执行 STREX 指令会导致该指令执行失败</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">保持Open Access state，直到下一个 LDREX 指令</td>
</tr>
</tbody></table>
<ul>
<li>刚开始默认情况 local monitor 的状态为 Open Access state</li>
<li>thread 1 运行 LDREX 这条指令将 local monitor 的状态修改为 Exclusive Access state。</li>
<li>后切换到 thread 2 执行 LDREX 这时检测到 local monitor 的状态为 Exclusive Access state </li>
<li>执行 Modify </li>
<li>执行 STREX，执行完 STREX 之后 local monitor 被设置为 Open Access state </li>
<li>回到 thread 1 执行 Modify</li>
<li>执行 STREX ，当执行 STREX 指令会导致该指令执行失败</li>
<li>结合前面的汇编实现。这时候 thread 1 又会重新执行 LDREX，Modify，STREX 直到执行成功。以此来实现原子操作。</li>
</ul>
<p>可以总结出 ldrex 和 strex 的特性如下。</p>
<table>
<thead>
<tr>
<th>local monitor state</th>
<th>ldrex</th>
<th>strex</th>
</tr>
</thead>
<tbody><tr>
<td>Open&nbsp;Access&nbsp;state</td>
<td>指令正常执行且修改 local monitor 状态为 Exclusive Access state</td>
<td>STREX 指令执行失败并返回 1</td>
</tr>
<tr>
<td>Exclusive&nbsp;Access&nbsp;state</td>
<td>指令正常执行且修改 local monitor 状态为 Exclusive Access state</td>
<td>STREX 正常执行且 local monitor 被设置为 Open Access state 同时返回 0</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Global monitor 则用于多 cpu 之间的，状态和 local monitor 是一样的，这里就不再赘述了。</p>
<blockquote>
<p>参考博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_29379325/article/details/80313840">armv7实现原子操作的本质——ldrex和strex指令</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/w906787/article/details/78907067">ARM同步指令之LDREX和STREX</a></p>
</blockquote>
<h3 id="2-原子操作"><a href="#2-原子操作" class="headerlink" title="2) 原子操作"></a>2) 原子操作</h3><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>atomic_t v = ATOMIC_INIT(0)</td>
<td>定义原子变量并初始化v为0</td>
</tr>
<tr>
<td>void atomic_set(atomic_t* v,int i)</td>
<td>设置原子变量的值为i</td>
</tr>
<tr>
<td>atomic_read(atomic_t* v)</td>
<td>返回原子变量的值</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t* v)</td>
<td>原子变量增加i</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t* v)</td>
<td>原子变量减少i</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t* v)</td>
<td>原子变量自增1</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t* v)</td>
<td>源自变量自减1</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t* v)</td>
<td>原子变量自增1，并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t* v)</td>
<td>原子变量自减1，并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t* v)</td>
<td>原子变量减少i， 并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_add_return(int i, atomic_t* v)</td>
<td>原子变量的值增加i，并返回新的值</td>
</tr>
<tr>
<td>int atomic_sub_return(int i, atomic_t* v)</td>
<td>原子变量的值减少i，并返回新的值</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t* v)</td>
<td>原子变量的值自增1，并返回新的值</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t* v)</td>
<td>原子变量的值自减1，并返回新的值</td>
</tr>
<tr>
<td>void set_bit(nr,void* addr);</td>
<td>设置addr地址的第nr位，即将nr位置1</td>
</tr>
<tr>
<td>void clear_bit(nr, void* addr);</td>
<td>清除addr地址的nr位，即将nr位清0</td>
</tr>
<tr>
<td>void chang_bit(nr, void* addr);</td>
<td>将addr的nr为反置</td>
</tr>
<tr>
<td>test_bit(nr, void* addr);</td>
<td>返回addr的第nr位</td>
</tr>
<tr>
<td>int test_and_set_bit(nt, void* addr);</td>
<td>测试addr的nr位，再设置为1</td>
</tr>
<tr>
<td>int test_and_clear_bit(nr, void* addr);</td>
<td>测试addr的nr位，再清为0</td>
</tr>
<tr>
<td>int test_and_chang_bit(nr, void* addr);</td>
<td>测试addr的nr位，再反置nr位</td>
</tr>
</tbody></table>
<h2 id="2、linux-中的锁"><a href="#2、linux-中的锁" class="headerlink" title="2、linux 中的锁"></a>2、linux 中的锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;linux 内核提供了很多类型的锁，他们可以分为两类，<font color=red>自旋锁(spinning lock)</font>、<font color=blue>睡眠锁(sleeping lock)</font>。自旋锁就是无法获得锁时，<font color=brown>不会休眠，会一直循环等待</font>。睡眠锁则是是无法获得锁时，<font color=purple>当前线程就会休眠</font>。</p>
<h3 id="1-自旋锁-spin-lock"><a href="#1-自旋锁-spin-lock" class="headerlink" title="1) 自旋锁 spin_lock"></a>1) 自旋锁 spin_lock</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁的实现也需要考虑到两种情况，单 cpu 系统和多 cpu 系统(smp 系统)。对于不同的架构自旋锁的实现方式不同，arm 架构自旋锁的数据结构如下所示，其中实现自旋的关键就是 next 和 owner 两个变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">    <span class="keyword">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> magic, owner_cpu;</span><br><span class="line">    <span class="keyword">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">raw_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> lock;</span><br><span class="line">&#125; <span class="keyword">arch_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arch/arm/include/asm/spinlock_types.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        u32 slock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> &#123;</span> <span class="comment">// 实现自旋锁的关键就是 next 和 owner</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">            u16 next;</span><br><span class="line">            u16 owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            u16 owner;</span><br><span class="line">            u16 next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; tickets;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于没有其他 CPU 的单 CPU 系统，如果内核不支持进程抢占（preempt），当前在内核态执行的线程也不可能被其他线程抢占，也就没有其他进程/线程。所以<font color=dark>对于不支持进程抢占（preempt）的单 CPU 系统，spin_lock 是空函数，不需要做其他事情。</font></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果<font color=blue>单 CPU 系统的内核支持进程抢占（preempt）</font>，即当前线程正在执行内核态函数时，它是有可能被别的线程抢占的。这时 spin_lock 的实现就是<font color=brown>调用 preempt_disable() 函数，关闭 cpu 的进程抢占功能。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock(lock) _raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_lock(lock)            __LOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LOCK(lock) \ <span class="comment">// 调用 preempt_disable 关闭进程间抢占功能</span></span></span><br><span class="line">  <span class="keyword">do</span> &#123; preempt_disable(); ___LOCK(lock); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___LOCK(lock) \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; __acquire(lock); (<span class="keyword">void</span>)(lock); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/compiler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CHECKER__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __acquire(x)   __context__(x,1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">define __acquire(x) (<span class="keyword">void</span>)<span class="number">0</span> <span class="comment">// 为空函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于 spin_lock_irq()，在 UP 系统中就退化为 local_irq_disable() 和 preempt_disable()，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LOCK_IRQ(lock) \ <span class="comment">// 多了一个关中断的操作</span></span></span><br><span class="line">  <span class="keyword">do</span> &#123; local_irq_disable(); __LOCK(lock); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于多 cpu 系统内核怎么实现自旋锁的呢，先来看一下源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock(lock) _raw_spin_lock(lock)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/spinlock.c</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    __raw_spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//include/linux/spinlock_api_smp.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable(); <span class="comment">// 关闭进程抢占功能</span></span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_); <span class="comment">// 啥也没干</span></span><br><span class="line">    LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//include/linux/lockdep.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spin_acquire(l, s, t, i)        lock_acquire_exclusive(l, s, t, NULL, i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lock_acquire_exclusive(l, s, t, n, i)       lock_acquire(l, s, t, 0, 1, n, i</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> lock_acquire(l, s, t, r, c, n, i)  do &#123; &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//include/linux/lockdep.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONTENDED(_lock, try, lock)                \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                    \</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">try</span>(_lock)) &#123;                                  \ <span class="comment">// </span></span><br><span class="line">        lock_contended(&amp;(_lock)-&gt;dep_map, _RET_IP_);    \</span><br><span class="line">        lock(_lock);                                    \</span><br><span class="line">    &#125;                                                   \</span><br><span class="line">    lock_acquired(&amp;(_lock)-&gt;dep_map, _RET_IP_);         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏替换之后得到下面函数</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                    </span><br><span class="line">    <span class="keyword">if</span> (!do_raw_spin_trylock(lock)) &#123;                                   </span><br><span class="line">        lock_contended(&amp;(lock)-&gt;dep_map, _RET_IP_);   </span><br><span class="line">        do_raw_spin_lock(lock);                                   </span><br><span class="line">    &#125;                                                   </span><br><span class="line">    lock_acquired(&amp;(lock)-&gt;dep_map, _RET_IP_);        </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux/spinlock.h</span></span><br><span class="line"><span class="function">tatic <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">do_raw_spin_trylock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arch_spin_trylock(&amp;(lock)-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arch/alpha/include/asm/spinlock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">arch_spin_trylock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !test_and_set_bit(<span class="number">0</span>, &amp;lock-&gt;lock); <span class="comment">//原子操作测试 lock-&gt;lock 的第 0 位再设置为 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/spinlock_debug.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_raw_spin_lock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    debug_spin_lock_before(lock);</span><br><span class="line">    arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">    debug_spin_lock_after(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_spin_lock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line">    u32 newval;</span><br><span class="line">    <span class="keyword">arch_spinlock_t</span> lockval;</span><br><span class="line"></span><br><span class="line">    prefetchw(&amp;lock-&gt;slock);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line"><span class="string">&quot;1: ldrex   %0, [%3]\n&quot;</span>       <span class="comment">// 取出 lock-&gt;slock 中的值存入 lockval</span></span><br><span class="line"><span class="string">&quot;   add %1, %0, %4\n&quot;</span>         <span class="comment">// lockval += 1 &lt;&lt; TICKET_SHIFT，TICKET_SHIFT == 16，即 ockval.tickets.next ++</span></span><br><span class="line"><span class="string">&quot;   strex   %2, %1, [%3]\n&quot;</span>   <span class="comment">// 将 lockval 的计算结果重新赋值给 &amp;lock-&gt;slock</span></span><br><span class="line"><span class="string">&quot;   teq %2, #0\n&quot;</span>             <span class="comment">// 确认是否写入成功</span></span><br><span class="line"><span class="string">&quot;   bne 1b&quot;</span>                   <span class="comment">// 写入失败则再来一次，确保操作的原子性</span></span><br><span class="line">    : <span class="string">&quot;=&amp;r&quot;</span> (lockval), <span class="string">&quot;=&amp;r&quot;</span> (newval), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (&amp;lock-&gt;slock), <span class="string">&quot;I&quot;</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span><br><span class="line">    : <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 lockval.tickets.next 不等于 lockval.tickets.owner 则死循环</span></span><br><span class="line">    <span class="keyword">while</span> (lockval.tickets.next != lockval.tickets.owner) &#123;</span><br><span class="line">        wfe(); <span class="comment">// 将 cpu 进入低功耗待机状态，等待一会</span></span><br><span class="line">        lockval.tickets.owner = ACCESS_ONCE(lock-&gt;tickets.owner); <span class="comment">// 更新一下 lock-&gt;tickets.owner 的状态。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到锁可以进行临界区的访问。</span></span><br><span class="line">    smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由源码可以得出 spin_lock 主要做了下面的事情</p>
<ul>
<li>调用 preempt_disable 关闭进程间的抢占</li>
<li>使用 ldrex 和 strex 以实现操作的原子性</li>
<li>如果 lockval.tickets.next 不等于 lockval.tickets.owner 如果不相等，循环将 cpu 进入低功耗待机状态，等待一会之后更新一下 lock-&gt;tickets.owner 的状态。直到拿到锁为止</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;通过 lockval.tickets.next  实现了排队的操作，每一个 spinlock 都有一个独一无二 lockval.tickets.next ，后来的 spinlock 都是在前一个的基础上增加 1，lock-&gt;tickets.owner 则保存当前轮到谁来获取临界资源。当我们释放锁的时候只需要将 lock-&gt;tickets.owner ++，下一个等待的进程进程就能够拿到对应的锁了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_spin_unlock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    smp_mb();</span><br><span class="line">    lock-&gt;tickets.owner++;</span><br><span class="line">    dsb_sev();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spin_lock 常用了接口如下</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>spin_lock_init</td>
<td>初始化自旋锁 lock</td>
</tr>
<tr>
<td>spin_lock</td>
<td>如果能够获得自旋锁则立刻返回，否则将在那里等待，直到该自旋锁的持有者释放。</td>
</tr>
<tr>
<td>spin_unlock</td>
<td>释放自旋锁 lock</td>
</tr>
<tr>
<td>spin_try_lock</td>
<td>尝试获得自旋锁，如果能立刻获得锁返回 true，否则立刻返回 false</td>
</tr>
<tr>
<td>spin_lock_bh/spin_unlock_bh</td>
<td>加锁时禁止下半部(软中断)，解锁时使能下半部(软中断)</td>
</tr>
<tr>
<td>spin_lock_irq/spin_unlock_irq</td>
<td>加锁时禁止中断，解锁时使能中断</td>
</tr>
<tr>
<td>spin_lock_irqsave/spin_lock_restore</td>
<td>加锁时禁止并中断并记录状态，解锁时恢复中断为所记录的状态</td>
</tr>
</tbody></table>
<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2) 信号量"></a>2) 信号量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一个信号量本质上是一个整数值，它和一对函数联合使用，这对函数通常称为 P 和 V。希望进入临界区的进程将在相关信号量上调用 P;如果信号量的值大于 0,则该值会减1，而进程可以继续。相反，如果信号量的值为 0(或者更小)，进程进入休眠并等待直到其他人释放该信号量。对信号量的解锁通过调用 V 来完成；该函数增加信号量的值，并在必要时唤醒等待的进程。当我们需要将信号量用于互斥时，只需将信号量的值设为 1。这样的信号量在任何给定时刻只能由单个线程拥有。内核定义的信号量如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/semaphore.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出信号量其实也使用了 raw_spinlock_t 这个结构体，来看看源码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags); <span class="comment">// 使用自旋锁实现互斥，防止在操作过程被打断</span></span><br><span class="line">    <span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __down(sem);</span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(down);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    __down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sched __down_common(struct semaphore *sem, <span class="keyword">long</span> state,</span><br><span class="line">                                <span class="keyword">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list); <span class="comment">// 将当前信号量添加进 sem-&gt;wait_list 链表。</span></span><br><span class="line">    waiter.task = task;</span><br><span class="line">    waiter.up = <span class="literal">false</span>; <span class="comment">// 初始化唤醒状态为 false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending_state(state, task)) </span><br><span class="line">            <span class="keyword">goto</span> interrupted;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">goto</span> timed_out;</span><br><span class="line">        __set_task_state(task, state);        <span class="comment">// 设置进程状态为 TASK_UNINTERRUPTIBLE</span></span><br><span class="line">        raw_spin_unlock_irq(&amp;sem-&gt;lock);      <span class="comment">// 将前面拿到的锁释放掉，以便其他进行在获取不到信号量是能跑到这里。</span></span><br><span class="line">        timeout = schedule_timeout(timeout);  <span class="comment">// 当今进程进入休眠，调度其他进行运行</span></span><br><span class="line">        raw_spin_lock_irq(&amp;sem-&gt;lock);        <span class="comment">// 唤醒后要先拿锁，两个作用防止后面的状态被打断，同时要和后面 raw_spin_unlock_irqrestore 进行配对。</span></span><br><span class="line">        <span class="keyword">if</span> (waiter.up)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">    list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">    list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;总的来说只有得到信号量的进程才能执行临界区的代码，<font color=red>当得不到信号量时，进程会进入休眠等待状态</font>。并将当前进程放入对应的链表中。当有信号量被释放时遍历这个链表，唤醒被休眠的进程继续执行。信号量释放的流程如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags); <span class="comment">// 拿锁实现互斥，防止同时间其他信号量的释放带来的异常。</span></span><br><span class="line">    <span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list))) <span class="comment">// 当队列中没有需要获取信号量的进程时释放信号量</span></span><br><span class="line">        sem-&gt;count++; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __up(sem); <span class="comment">// 唤醒队列中的第一个进行并将信号量交给该进程。</span></span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(up);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __up(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line">                        struct semaphore_waiter, <span class="built_in">list</span>); <span class="comment">// 获取队列中的第一项</span></span><br><span class="line">    list_del(&amp;waiter-&gt;<span class="built_in">list</span>);       <span class="comment">// 从队列中将其删除</span></span><br><span class="line">    waiter-&gt;up = <span class="literal">true</span>;             <span class="comment">// 设置其唤醒状态</span></span><br><span class="line">    wake_up_process(waiter-&gt;task); <span class="comment">// 唤醒这个进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;常用接口</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECLARE_MUTEX(name);</td>
<td>将信号量name初始化为1</td>
</tr>
<tr>
<td>DECLARE_MUTEX_LOCKED(name);</td>
<td>将信号量name初始化为0</td>
</tr>
<tr>
<td>void init_MUTEX(struct semaphore *sem)</td>
<td>将信号量sem初始化为1</td>
</tr>
<tr>
<td>void init_NUTEX_LOCKED(struct semaphore *sem);</td>
<td>将信号量sem初始化为0</td>
</tr>
<tr>
<td>void sema_init(struct semaphore* sem, int val);</td>
<td>初始化信号量的值为 val</td>
</tr>
<tr>
<td>void&nbsp;down(struct&nbsp;semaphore&nbsp;*sem);</td>
<td>递减信号量的值，获取不到是进程进入休眠</td>
</tr>
<tr>
<td>int&nbsp;down_interruptible(struct&nbsp;semaphore&nbsp;*sem);</td>
<td>递减信号量的值，获取不到是进程进入休眠，但是操作是可以中断的，它允许一个在等待的信号量的用户空间进程被用户中断。如果在操作中被中断，函数会返回一个非零值，并且调用者不持有信号量，真确的使用它需要一直检查返回值并针对性地响应。</td>
</tr>
<tr>
<td>int&nbsp;down_trylock(struct&nbsp;seamphore*&nbsp;sem);</td>
<td>永远不会休眠，如果信号量在调用时不可获得，它会返回一个非零值</td>
</tr>
<tr>
<td>void up(struct semaphore *sem);</td>
<td>当队列中没有需要获取信号量的进程时释放信号量，如果有则唤醒队列中的第一个线程同时将信号量的持有转交给该线程</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;任何拿到信号量的线程都必须通过一次对 up 的调用而释放该信号量。在出现错误的情况下，经常需要特别小心。如果在拥有一个信号量时发生错误，必须将错误状态返回给调用者之前释放该信号量。忘记释放信号量将导致进程在某些无关的位置被意外挂起，很难复现和跟踪</p>
<h3 id="3-互斥锁"><a href="#3-互斥锁" class="headerlink" title="3) 互斥锁"></a>3) 互斥锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;互斥锁主要用于实现内核中的互斥访问功能。一般用来保护一段代码，的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        count; <span class="comment">// 1 表示unlocked，0 表示有线程拿锁，但是没有其他线程排队， -1 表示有线程拿锁，并且有其他线程在排队。</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">owner</span>;</span> <span class="comment">// 用来调试或者优化性能，只有位两个不同的 cpu 进程同时拿锁时，并且只有一个在等待时，就不会休眠会多等待一回合，提高效率。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="keyword">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;mutex 的实现分为两个部分 fastpath 和 slowpath。如果 fastpath 成功就不再使用 slowpath。同样的 mutex 的实现在不同的架构下实现方式也不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/asm/mutex.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LINUX_ARM_ARCH__ &lt; 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-generic/mutex-xchg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-generic/mutex-dec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* _ASM_MUTEX_H */</span></span></span><br></pre></td></tr></table></figure>
<p> armv6 之前的实现就不贴出来了，基本差不多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">mutex_lock</span><span class="params">(struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The locking fastpath is the 1-&gt;0 transition from</span></span><br><span class="line"><span class="comment">     * &#x27;unlocked&#x27; into &#x27;locked&#x27; state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);</span><br><span class="line">    mutex_set_owner(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/mutex-dec.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__mutex_fastpath_lock(<span class="keyword">atomic_t</span> *count, <span class="keyword">void</span> (*fail_fn)(<span class="keyword">atomic_t</span> *))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 count 的初始值 为 1</span></span><br><span class="line">    <span class="comment">// 减 1 后为 0, if 条件不成立直接得到锁返回</span></span><br><span class="line">    <span class="comment">// 如果初始 count &lt; = 0 减 1 后 &lt;= 0 调用回调函数 fail_fn 即 __mutex_lock_slowpath</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(atomic_dec_return_acquire(count) &lt; <span class="number">0</span>))</span><br><span class="line">        fail_fn(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line">__mutex_lock_slowpath(<span class="keyword">atomic_t</span> *lock_count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span> =</span> container_of(lock_count, struct mutex, count);</span><br><span class="line"></span><br><span class="line">    __mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, <span class="number">0</span>,</span><br><span class="line">                <span class="literal">NULL</span>, _RET_IP_, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * kernel/locking/mutex.c</span></span><br><span class="line"><span class="comment"> * lock = lock</span></span><br><span class="line"><span class="comment"> * state = TASK_UNINTERRUPTIBLE</span></span><br><span class="line"><span class="comment"> * subclass = 0</span></span><br><span class="line"><span class="comment"> * nest_lock = null</span></span><br><span class="line"><span class="comment"> * ip = _RET_IP_</span></span><br><span class="line"><span class="comment"> * ww_ctx = NULL</span></span><br><span class="line"><span class="comment"> * use_ww_ctx = 0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span> __sched</span><br><span class="line">__mutex_lock_common(struct mutex *lock, <span class="keyword">long</span> state, <span class="keyword">unsigned</span> <span class="keyword">int</span> subclass,</span><br><span class="line">            struct lockdep_map *nest_lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> ip,</span><br><span class="line">            struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> <span class="keyword">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_ww_ctx) &#123; <span class="comment">// 为 0 直接跳过</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span> =</span> container_of(lock, struct ww_mutex, base);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line">            <span class="keyword">return</span> -EALREADY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preempt_disable(); <span class="comment">// 关闭 cpu 线程抢占功能</span></span><br><span class="line">    mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也许其他 cpu 获得了 mutex 它会很快释放，可能不需要休眠</span></span><br><span class="line">    <span class="keyword">if</span> (mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx)) &#123;</span><br><span class="line">        <span class="comment">/* got the lock, yay! */</span></span><br><span class="line">        preempt_enable();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 spin_lock 实现操作的互斥性</span></span><br><span class="line">    spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次尝试获取 mutex 锁。 </span></span><br><span class="line">    <span class="keyword">if</span> (!mutex_is_locked(lock) &amp;&amp;</span><br><span class="line">        (atomic_xchg_acquire(&amp;lock-&gt;count, <span class="number">0</span>) == <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">goto</span> skip_wait;</span><br><span class="line"></span><br><span class="line">    debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line">    debug_mutex_add_waiter(lock, &amp;waiter, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前进程放入 mutex 的 wait_list,这个 wait_list 是 FIFO ，谁先排队，谁就可以先得到 mutex。</span></span><br><span class="line">    list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;lock-&gt;wait_list);</span><br><span class="line">    waiter.task = task;</span><br><span class="line"></span><br><span class="line">    lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 再次尝试获取锁</span></span><br><span class="line">        <span class="comment">// 如果 count == 1 ，表示锁没有人用，我们将其设置为 -1 ，直接退出</span></span><br><span class="line">        <span class="comment">// 如果 count == 0 ，表示锁被人拿走，并且没人排队，我们将其设置为 -1，继续往下</span></span><br><span class="line">        <span class="comment">// 如果 count &lt; 0 ，表示锁被别人拿走，并且有人在排队，继续往下</span></span><br><span class="line">        <span class="keyword">if</span> (atomic_read(&amp;lock-&gt;count) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (atomic_xchg_acquire(&amp;lock-&gt;count, <span class="number">-1</span>) == <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测进程是否可以休眠，如果有信号在 pending 状态，而且 state 状态还是UNINTERRUPTIBLE 状态的话，是不能休眠等待的</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(signal_pending_state(state, task))) &#123;</span><br><span class="line">            ret = -EINTR;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx-&gt;acquired &gt; <span class="number">0</span>) &#123; <span class="comment">// use_ww_ctx 为 0</span></span><br><span class="line">            ret = __ww_mutex_lock_check_stamp(lock, ww_ctx);</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置进程状态</span></span><br><span class="line">        __set_task_state(task, state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* didn&#x27;t get the lock, go to sleep: */</span></span><br><span class="line">        spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">        schedule_preempt_disabled(); <span class="comment">// 调度进程进入休眠</span></span><br><span class="line">        spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    __set_task_state(task, TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前进程从 mutex 链表中删除</span></span><br><span class="line">    mutex_remove_waiter(lock, &amp;waiter, task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如过没有其他进程等待获取 mutex 锁将 count 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))</span><br><span class="line">        atomic_set(&amp;lock-&gt;count, <span class="number">0</span>);</span><br><span class="line">    debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line">    <span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">    lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line">    mutex_set_owner(lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_ww_ctx) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span> =</span> container_of(lock, struct ww_mutex, base);</span><br><span class="line">        ww_mutex_set_context_slowpath(ww, ww_ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags); <span class="comment">// 关闭前面获取的 spin lock</span></span><br><span class="line">    preempt_enable(); <span class="comment">// 打开进程抢占功能，到这里我们已经获取到 mutex 锁，可以正常访问临界区了。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    mutex_remove_waiter(lock, &amp;waiter, task);</span><br><span class="line">    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">    mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">    preempt_enable();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;总结：进程在获取 mutex 锁时 count 为 1 时，将 count 减 1 直接获取该锁，访问临界区。如果获取锁时获取不到，则进入如下的休眠流程。</p>
<ul>
<li>将当前进程放入 mutex 的 wait_list</li>
<li>将 count 设置为 -1 ，表示有进程正在排队</li>
<li>设置进程状态，进程休眠，调度其他进程工作</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;再来看一下释放流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">mutex_unlock</span><span class="params">(struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    mutex_clear_owner(lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    __mutex_fastpath_unlock(&amp;lock-&gt;count, __mutex_unlock_slowpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(mutex_unlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/mutex-dec.h</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__mutex_fastpath_unlock(<span class="keyword">atomic_t</span> *count, <span class="keyword">void</span> (*fail_fn)(<span class="keyword">atomic_t</span> *))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// count 曾加 1 如果结果 &gt; 0 表示无人等待直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(atomic_inc_return_release(count) &lt;= <span class="number">0</span>))</span><br><span class="line">        fail_fn(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line">__visible <span class="keyword">void</span> __mutex_unlock_slowpath(<span class="keyword">atomic_t</span> *lock_count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span> =</span> container_of(lock_count, struct mutex, count);</span><br><span class="line"></span><br><span class="line">    __mutex_unlock_common_slowpath(lock, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line">__mutex_unlock_common_slowpath(struct mutex *lock, <span class="keyword">int</span> nested)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __mutex_slowpath_needs_to_unlock() 这是个宏被初始化为 1</span></span><br><span class="line">    <span class="comment">// 因此这里就是将 count 设置为 1</span></span><br><span class="line">    <span class="keyword">if</span> (__mutex_slowpath_needs_to_unlock())</span><br><span class="line">        atomic_set(&amp;lock-&gt;count, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 spin lock</span></span><br><span class="line">    spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    mutex_release(&amp;lock-&gt;dep_map, nested, _RET_IP_);</span><br><span class="line">    debug_mutex_unlock(lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;lock-&gt;wait_list)) &#123;</span><br><span class="line">        <span class="comment">// 如果还有进程在等待获取锁则，从 wait_list 中取出第一个进程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> *<span class="title">waiter</span> =</span></span><br><span class="line">                list_entry(lock-&gt;wait_list.next,</span><br><span class="line">                       struct mutex_waiter, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        debug_mutex_wake_waiter(lock, waiter);</span><br><span class="line">        wake_q_add(&amp;wake_q, waiter-&gt;task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放前面获取的 spin lock</span></span><br><span class="line">    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    wake_up_q(&amp;wake_q); <span class="comment">// 唤醒这个进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;总结：如果 count = 0 表示没线程等待，直接将 count 加 1。如果 count 等于 -1 表示有线程等待，进入唤醒流程</p>
<ul>
<li>从 wait_list 中取出第一个进程，并将其唤醒</li>
<li>根据是否还有进程在等待设置 count 的状态，有进程等待设置为 -1，没有则设置为 0</li>
<li>唤醒的进程从 mutex 链表中删除自己</li>
<li>被唤醒的进程访问临界区资源</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;常用接口如下</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name);</td>
<td>静态创建化互斥锁 name</td>
</tr>
<tr>
<td>mutex_init(&amp;mutex);</td>
<td>动态初始化互斥锁 mutex</td>
</tr>
<tr>
<td>mutex_lock(lock)；</td>
<td>获取互斥锁，获取不到则进入睡眠</td>
</tr>
<tr>
<td>mutex_trylock(lock)；</td>
<td>尝试获取互斥锁，成功返回1，    失败返回0</td>
</tr>
<tr>
<td>mutex_unlock(lock)；</td>
<td>释放互斥锁</td>
</tr>
<tr>
<td>mutex_is_lock(lock)；</td>
<td>如果锁已被使用返回1，否则返回0</td>
</tr>
</tbody></table>
<h3 id="4-锁的使用场景"><a href="#4-锁的使用场景" class="headerlink" title="4) 锁的使用场景"></a>4) 锁的使用场景</h3><ul>
<li>在可以睡眠的用户上下文中加锁使用<font color=red>信号量(semaphore)</font>和<font color=blue>互斥锁(mutex)</font>。其中 mutex 一般不会被长期持有，用于保护一段代码。</li>
<li>在用户上下文与 Softirqs 之间加锁使用 spin_lock_bh/spin_unlock_bh</li>
<li>在用户上下文与 Tasklet 之间加锁 spin_lock_bh/spin_unlock_bh</li>
<li>在用户上下文与 Timer 之间加锁 spin_lock_bh/spin_unlock_bh</li>
<li>不同 cpu 之间在 Tasklet 与 Timer 之间无需加锁</li>
<li>在 Softirq 之间加锁 spin_lock/pin_unlock</li>
</ul>
<h1 id="三、linux-队列"><a href="#三、linux-队列" class="headerlink" title="三、linux 队列"></a><div align=center>三、linux 队列</div></h1><h2 id="1、等待队列"><a href="#1、等待队列" class="headerlink" title="1、等待队列"></a>1、等待队列</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;等待队列从功能上可以简单理解为：让进程进入睡眠，在你想让他工作的时候唤醒。它有两部分组成首先是挂接我们等待队列项的等待头，等待队列头的数据结构描述如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include/linux/wait.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock; <span class="comment">// 在对task_list与操作的过程中，使用该锁实现对等待队列的互斥访问。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">task_list</span>;</span> <span class="comment">// 链接等待进程 wait_queue_t</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>而挂接在其上面的等待队列项的数据局结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> <span class="title">wait_queue_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* falgs 标识 wait_queue_t 成员的状态和属性 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE   0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_WOKEN       0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_BOOKMARK    0x04</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        flags;</span><br><span class="line">    <span class="keyword">void</span>            *<span class="keyword">private</span>;  <span class="comment">// 保存当前任务的 task_struct 对象地址，一般默认为 current</span></span><br><span class="line">    <span class="keyword">wait_queue_func_t</span>   func;  <span class="comment">// 唤醒函数的回调函数，一般默认为 default_wake_function</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span> <span class="comment">// 用于将该结构挂接到 wait_queue_head_t</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>他们的创建与与初始化如下</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECLARE_WAIT_QUEUE_HEAD(name)</td>
<td>声明等待队列头 name</td>
</tr>
<tr>
<td>init_waitqueue_head(name)</td>
<td>初始化等待队列头 name</td>
</tr>
<tr>
<td>DECLARE_WAITQUEUE(name, tsk)</td>
<td>定义等待队列成员 name</td>
</tr>
</tbody></table>
<h3 id="2-添加-删除等待队列成员"><a href="#2-添加-删除等待队列成员" class="headerlink" title="2. 添加/删除等待队列成员"></a>2. 添加/删除等待队列成员</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; <span class="comment">//将 WQ_FLAG_EXCLUSIVE 清零</span></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue(wq_head, wq_entry);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue_exclusive</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wq_entry-&gt;flags |= WQ_FLAG_EXCLUSIVE; <span class="comment">//将 WQ_FLAG_EXCLUSIVE 置为</span></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue_entry_tail(wq_head, wq_entry);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue_exclusive);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue_entry_tail(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">    list_add_tail(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_wait_queue</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    __remove_wait_queue(wq_head, wq_entry);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(remove_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">    list_del(&amp;wq_entry-&gt;entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-进程休眠"><a href="#3-进程休眠" class="headerlink" title="3. 进程休眠"></a>3. 进程休眠</h3><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>wait_event(wq,&nbsp;condition)</td>
<td>如果condition为0，则进程休眠，且休眠状态不能被中断打断</td>
</tr>
<tr>
<td>wait_event_timeout(wq,&nbsp;condition,&nbsp;timeout)</td>
<td>如果condition为0，则进入休眠，当 timeout 到了则唤醒进程不管此时condition为真为假都会返回</td>
</tr>
<tr>
<td>wait_event_interruptible(wq,&nbsp;condition)</td>
<td>如果condition为0，则进程休眠，休眠状态可以被中断打断，当休眠被中断打断时返回0，这时驱动应返回 -ERESTARTSYS</td>
</tr>
<tr>
<td>wait_event_interruptible_timeout(wq,&nbsp;condition,&nbsp;timeout)</td>
<td>如果condition为0，则进程休眠，休眠状态可以被中断打断，当休眠被中断打断时返回0，这时驱动应返回 -ERESTARTSY，当 timeout 到了则唤醒进程不管此时condition为真为假都会返回</td>
</tr>
</tbody></table>
<p>源码分析如下</p>
<h4 id="1-wait-event"><a href="#1-wait-event" class="headerlink" title="1) wait_event"></a>1) wait_event</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq_head, condition)                      </span></span><br><span class="line"><span class="keyword">do</span> &#123;                                        </span><br><span class="line">    might_sleep();                              </span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="comment">//如果 condition  为真直接返回     </span></span><br><span class="line">        <span class="keyword">break</span>;                              </span><br><span class="line">    __wait_event(wq_head, condition);                   </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq_head, condition)                    \</span></span><br><span class="line">    (<span class="keyword">void</span>)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="number">0</span>, schedule())</span><br></pre></td></tr></table></figure>
<h4 id="2-wait-event"><a href="#2-wait-event" class="headerlink" title="2) ___wait_event"></a>2) ___wait_event</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__wait_event 的默认值如下</span></span><br><span class="line"><span class="comment">//state = TASK_UNINTERRUPTIBLE</span></span><br><span class="line"><span class="comment">//exclusive = 0</span></span><br><span class="line"><span class="comment">//ret = 0</span></span><br><span class="line"><span class="comment">//cmd = schedule()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___wait_event(wq_head, condition, state, exclusive, ret, cmd)       </span></span><br><span class="line">(&#123;                                      </span><br><span class="line">    __label__ __out;                            </span><br><span class="line">    <span class="comment">//创建一个等待队列成员 __wq_entry</span></span><br><span class="line">    struct wait_queue_entry __wq_entry;                </span><br><span class="line">    <span class="keyword">long</span> __ret = ret;   <span class="comment">/* explicit shadow */</span>               </span><br><span class="line">                                                         </span><br><span class="line">    <span class="comment">//初始化等待队列成员 __wq_entry</span></span><br><span class="line">    <span class="comment">//flags 为 0</span></span><br><span class="line">    <span class="comment">//private 被初始化为 current</span></span><br><span class="line">    <span class="comment">//fun 被初始化为 autoremove_wake_function</span></span><br><span class="line">    init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : <span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//死循环</span></span><br><span class="line">        <span class="comment">// 1. 检查当前信号是否有待处理的信号</span></span><br><span class="line">        <span class="comment">// 2. 检测链表状态防止等待队列成员未插入等待队列头</span></span><br><span class="line">        <span class="comment">// 3. 设置进程状态为 TASK_UNINTERRUPTIBLE</span></span><br><span class="line">        <span class="keyword">long</span> __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);</span><br><span class="line">                                        </span><br><span class="line">        <span class="keyword">if</span> (condition)    <span class="comment">//再次检测 condition 如果为真则返回                  </span></span><br><span class="line">            <span class="keyword">break</span>;                          </span><br><span class="line">         <span class="comment">//进程有待处理信号且处于可中断状态(TASK_INTERRUPTIBLE、TASK_KILLABLE)则跳出循环                               </span></span><br><span class="line">        <span class="keyword">if</span> (___wait_is_interruptible(state) &amp;&amp; __int) &#123;         </span><br><span class="line">            __ret = __int;                      </span><br><span class="line">            <span class="keyword">goto</span> __out;                     </span><br><span class="line">        &#125;                               </span><br><span class="line">                                        </span><br><span class="line">        cmd; <span class="comment">//调用 schedule() 函数,让进程休眠，调度其他进程工作。</span></span><br><span class="line">    &#125;                                   </span><br><span class="line">    finish_wait(&amp;wq_head, &amp;__wq_entry);                 </span><br><span class="line">__out:  __ret;                                  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="3-init-wait-entry"><a href="#3-init-wait-entry" class="headerlink" title="3) init_wait_entry"></a>3) init_wait_entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wait_entry</span><span class="params">(struct wait_queue_entry *wq_entry, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wq_entry-&gt;flags = flags;</span><br><span class="line">    wq_entry-&gt;<span class="keyword">private</span> = current;</span><br><span class="line">    wq_entry-&gt;func = autoremove_wake_function;</span><br><span class="line">    INIT_LIST_HEAD(&amp;wq_entry-&gt;entry);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(init_wait_entry);</span><br></pre></td></tr></table></figure>
<h4 id="4-prepare-to-wait-event"><a href="#4-prepare-to-wait-event" class="headerlink" title="4). prepare_to_wait_event"></a>4). prepare_to_wait_event</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">prepare_to_wait_event</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123; <span class="comment">// 检测信号状态是否是待处理状态</span></span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;wq_entry-&gt;entry);</span><br><span class="line">        ret = -ERESTARTSYS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;wq_entry-&gt;entry)) &#123; <span class="comment">// 检查链表是否已经插入等待队列头</span></span><br><span class="line">            <span class="keyword">if</span> (wq_entry-&gt;flags &amp; WQ_FLAG_EXCLUSIVE)</span><br><span class="line">                __add_wait_queue_entry_tail(wq_head, wq_entry); <span class="comment">//将其插入到队列头的尾部</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                __add_wait_queue(wq_head, wq_entry); <span class="comment">//将其插入到等待队列头</span></span><br><span class="line">        &#125;</span><br><span class="line">        set_current_state(state); <span class="comment">//设置进程状态为 TASK_UNINTERRUPTIBLE</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_to_wait_event);</span><br></pre></td></tr></table></figure>
<h3 id="4-唤醒进程"><a href="#4-唤醒进程" class="headerlink" title="4. 唤醒进程"></a>4. 唤醒进程</h3><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void&nbsp;wake_up(wait_queue_head_t&nbsp;*q);</td>
<td>唤醒等待队列 q 上的进程，如果 condition 为真则返回</td>
</tr>
<tr>
<td>void&nbsp;wake_up_interruptible(wait_queue_head_t&nbsp;*q);</td>
<td>唤醒等待队列 q 上的进程，如果 condition 为真则返回</td>
</tr>
</tbody></table>
<p>源码分析如下</p>
<h4 id="1-wake-up"><a href="#1-wake-up" class="headerlink" title="1) __wake_up"></a>1) __wake_up</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __wake_up(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    __wake_up_common_lock(wq_head, mode, nr_exclusive, <span class="number">0</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__wake_up);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common_lock(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">wait_queue_entry_t</span> bookmark; <span class="comment">// 创建一个等待队列成员 bookmark</span></span><br><span class="line"></span><br><span class="line">    bookmark.flags = <span class="number">0</span>;          <span class="comment">// 初始化 flag 为 0</span></span><br><span class="line">    bookmark.<span class="keyword">private</span> = <span class="literal">NULL</span>;     <span class="comment">// 初始化 private 为空</span></span><br><span class="line">    bookmark.func = <span class="literal">NULL</span>;        <span class="comment">// 初始化唤醒函数为空</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;bookmark.entry);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &amp;bookmark);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bookmark.flags &amp; WQ_FLAG_BOOKMARK) &#123;</span><br><span class="line">        spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">        nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,</span><br><span class="line">                        wake_flags, key, &amp;bookmark);</span><br><span class="line">        spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-wake-up-common"><a href="#2-wake-up-common" class="headerlink" title="2) __wake_up_common"></a>2) __wake_up_common</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __wake_up_common(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key,</span><br><span class="line">            <span class="keyword">wait_queue_entry_t</span> *bookmark)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">wait_queue_entry_t</span> *curr, *next;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) &#123;</span><br><span class="line">        curr = list_next_entry(bookmark, entry); <span class="comment">//获取bookmark的下一个等待队列成员</span></span><br><span class="line"></span><br><span class="line">        list_del(&amp;bookmark-&gt;entry); <span class="comment">//删除当前成员 bookmark</span></span><br><span class="line">        bookmark-&gt;flags = <span class="number">0</span>; <span class="comment">//将当前的 flag 清零</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        curr = list_first_entry(&amp;wq_head-&gt;head, <span class="keyword">wait_queue_entry_t</span>, entry); <span class="comment">//查找等待队列头的第一个的等待队列成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (&amp;curr-&gt;entry == &amp;wq_head-&gt;head) <span class="comment">//如果当前等待队列是空则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nr_exclusive;</span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123; <span class="comment">//从 curr 的下一个等待成员开始循环遍历一遍等待队列头中的等待队列成员。</span></span><br><span class="line">        <span class="keyword">unsigned</span> flags = curr-&gt;flags; <span class="comment">//获取 flags</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; WQ_FLAG_BOOKMARK) <span class="comment">//如果为 WQ_FLAG_BOOKMARK 进入下次循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用对应的 func 成员函数,一般为默认的唤醒函数 autoremove_wake_function</span></span><br><span class="line">        ret = curr-&gt;func(curr, mode, wake_flags, key);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果唤醒的进程的 flags 为WQ_FLAG_EXCLUSIVE 且 nr_exclusive 为 0 则推出</span></span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;</span><br><span class="line">                (&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123;</span><br><span class="line">            bookmark-&gt;flags = WQ_FLAG_BOOKMARK;</span><br><span class="line">            list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nr_exclusive;</span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure>
<h2 id="2、工作队列"><a href="#2、工作队列" class="headerlink" title="2、工作队列"></a>2、工作队列</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;工作队列（work queue）是一种将工作推后执行的形式，它和tasklet有所不同。工作队列可以把工作推后，交由一个内核线程去执行，也就是说，这个下半部分可以在进程上下文中执行。这样，通过工作队列执行的代码能占尽进程上下文的所有优势。最重要的就是工作队列允许被重新调度甚至是睡眠。它的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/bullbat/article/details/7410563">Linux内核实践之工作队列</a></p>
<h3 id="3-操作函数"><a href="#3-操作函数" class="headerlink" title="3) 操作函数"></a>3) 操作函数</h3><h4 id="1-初始化工作队列"><a href="#1-初始化工作队列" class="headerlink" title="1. 初始化工作队列"></a>1. 初始化工作队列</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>INIT_WORK(work,func)</td>
<td>初始化工作队列项 work，并设置回调函数func</td>
</tr>
<tr>
<td>DECLARE_WORK(name,func)</td>
<td>声明一个等待队列项 name，并设置回调函数func</td>
</tr>
</tbody></table>
<h4 id="2-调度工作队列"><a href="#2-调度工作队列" class="headerlink" title="2. 调度工作队列"></a>2. 调度工作队列</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>schedule_work(&amp;work)</td>
<td>调度工作队列</td>
</tr>
<tr>
<td>schedule_delayed_work(&amp;work,tick)</td>
<td>延时tick个滴答应答之后调度工作队列</td>
</tr>
</tbody></table>
<h1 id="四、linux内核通知链"><a href="#四、linux内核通知链" class="headerlink" title="四、linux内核通知链"></a>四、linux内核通知链</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;内核中不同模块间的消息通知机制，告诉其他模块，当前发生了什么事情。内核通知链只能用于内核之间，不能用于内核于用户空间之间的通信。实现原理很简单，就是<font color=red>通知的模块</font>提供一个链表，<font color=blue>被通知的模块</font>将回调函数注册进入通知模块提供的链表中。当发生事件时通知模块遍历链表中的所有回调函数，并根据传入的参数依次调用。以原子通知链为例进行说名，原子通知链提供的链表头如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">//原子通知链的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span> <span class="comment">//用于挂接该链表上的 notifier_block 结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>无论是什么通知链，都是使用 notifier_block 作为该通知链的成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">notifier_fn_t</span>)</span><span class="params">(struct notifier_block *nb,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">notifier_fn_t</span> notifier_call;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">next</span>;</span> <span class="comment">//指向所属的链表头</span></span><br><span class="line">    <span class="keyword">int</span> priority; <span class="comment">//优先级，越大优先级越高，且将位于队列的更前面，更先被调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;实现过程很简单，就两步，第一步<font color=red>注册被通知模块的成员 notifier_block 到发出通知模块提供的链表头 atomic_notifier_head 上</font>，第二步<font color=blue>当发出通知模块要通知时，调用该链表头上的成员的回调函数即可</font>。注册过程很简单如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_chain_register</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;nh-&gt;lock, flags);</span><br><span class="line">    ret = notifier_chain_register(&amp;nh-&gt;head, n); <span class="comment">//将 n 注册到 nh-&gt;head 链表</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_chain_register);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_chain_register</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((*nl) != <span class="literal">NULL</span>) &#123; <span class="comment">//遍历到 atomic_notifier_head 的尾部</span></span><br><span class="line">        <span class="keyword">if</span> (n-&gt;priority &gt; (*nl)-&gt;priority)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nl = &amp;((*nl)-&gt;next); </span><br><span class="line">    &#125;</span><br><span class="line">    n-&gt;next = *nl; <span class="comment">//指向对应的链表头 nl</span></span><br><span class="line">    rcu_assign_pointer(*nl, n); <span class="comment">//将 n 插入到链表头 nl 的尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下调用过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_call_chain</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __atomic_notifier_call_chain(nh, val, v, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_call_chain);</span><br><span class="line">NOKPROBE_SYMBOL(atomic_notifier_call_chain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __atomic_notifier_call_chain(struct atomic_notifier_head *nh,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v,</span><br><span class="line">                 <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">//调用 notifier_call_chain 回调 atomic_notifier_head 上成员的回调函数</span></span><br><span class="line">    ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call, nr_calls);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__atomic_notifier_call_chain);</span><br><span class="line">NOKPROBE_SYMBOL(__atomic_notifier_call_chain);</span><br><span class="line"></span><br><span class="line"><span class="comment">// nl = &amp;nh-&gt;head</span></span><br><span class="line"><span class="comment">// val = val</span></span><br><span class="line"><span class="comment">// v = v</span></span><br><span class="line"><span class="comment">// nr_to_call = -1</span></span><br><span class="line"><span class="comment">// nr_calls = NULL</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_call_chain</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = NOTIFY_DONE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">nb</span>, *<span class="title">next_nb</span>;</span></span><br><span class="line"></span><br><span class="line">    nb = rcu_dereference_raw(*nl); <span class="comment">//获取链表指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nb &amp;&amp; nr_to_call) &#123; <span class="comment">//循环遍历 nb 链表上的 notifier_block ，nr_to_call 表示调用的次数。</span></span><br><span class="line">        next_nb = rcu_dereference_raw(nb-&gt;next); <span class="comment">//获取下一个 notifier_block</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_NOTIFIERS </span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!func_ptr_is_kernel_text(nb-&gt;notifier_call))) &#123; <span class="comment">//debug检测是否有 notifier_call 回调函数，如果没有则直接调用下一个。</span></span><br><span class="line">            WARN(<span class="number">1</span>, <span class="string">&quot;Invalid notifier called!&quot;</span>);</span><br><span class="line">            nb = next_nb;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ret = nb-&gt;notifier_call(nb, val, v); <span class="comment">//调用回调函数 notifier_call</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nr_calls)</span><br><span class="line">            (*nr_calls)++; <span class="comment">//用于记调用了几个回调函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &amp; NOTIFY_STOP_MASK)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nb = next_nb;</span><br><span class="line">        nr_to_call--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(notifier_call_chain);</span><br></pre></td></tr></table></figure>
<h2 id="2、接口整理"><a href="#2、接口整理" class="headerlink" title="2、接口整理"></a>2、接口整理</h2><h3 id="1、原子通知链"><a href="#1、原子通知链" class="headerlink" title="1、原子通知链"></a>1、原子通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;可以看出原子通知链使用的是自旋锁，因此原子通知链可以用在中断上下文中，不能阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">//原子通知链的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span> <span class="comment">//用于挂接该链表上的 notifier_block 结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;创建原子通知连</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_HEAD(name)              \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> <span class="title">name</span> =</span>          \</span><br><span class="line">        ATOMIC_NOTIFIER_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_INIT(name) &#123;                \</span></span><br><span class="line">        .lock = __SPIN_LOCK_UNLOCKED(name.lock),    \</span><br><span class="line">        .head = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用原子通知链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 actorn</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_call_chain</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 action</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="comment">// nr_to_call = 遍历多少个 atomic_notifier_head 中的成员</span></span><br><span class="line"><span class="comment">// nr_calls = 用于记录遍历了几个成员</span></span><br><span class="line"><span class="keyword">int</span> __atomic_notifier_call_chain(struct atomic_notifier_head *nh,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v, <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注册原子通知链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">atomic_notifier_chain_register</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct notifier_block *nb)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2、阻塞通知链"><a href="#2、阻塞通知链" class="headerlink" title="2、阻塞通知链"></a>2、阻塞通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;阻塞通知连使用的读写信号量，因此阻塞通知链使用在进程上下文，可以阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;创建阻塞通知链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_HEAD(name)                \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">name</span> =</span>            \</span><br><span class="line">        BLOCKING_NOTIFIER_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_INIT(name) &#123;              \</span></span><br><span class="line">        .rwsem = __RWSEM_INITIALIZER((name).rwsem), \</span><br><span class="line">        .head = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用阻塞通知链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 actorn</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blocking_notifier_call_chain</span><span class="params">(struct blocking_notifier_head *nh, <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 action</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="comment">// nr_to_call = 遍历多少个 atomic_notifier_head 中的成员</span></span><br><span class="line"><span class="comment">// nr_calls = 用于记录遍历了几个成员</span></span><br><span class="line"><span class="keyword">int</span> __blocking_notifier_call_chain(struct blocking_notifier_head *nh,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v, <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注册阻塞通知链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">blocking_notifier_chain_register</span><span class="params">(struct blocking_notifier_head *nh,struct notifier_block *nb)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="3、原始通知链"><a href="#3、原始通知链" class="headerlink" title="3、原始通知链"></a>3、原始通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;非常原始，啥锁都没有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">raw_notifier_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;创建原始通知链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_HEAD(name)                 \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">raw_notifier_head</span> <span class="title">name</span> =</span>             \</span><br><span class="line">        RAW_NOTIFIER_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_INIT(name) &#123;               \</span></span><br><span class="line">        .head = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用原始通知链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 actorn</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raw_notifier_call_chain</span><span class="params">(struct raw_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 action</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="comment">// nr_to_call = 遍历多少个 atomic_notifier_head 中的成员</span></span><br><span class="line"><span class="comment">// nr_calls = 用于记录遍历了几个成员</span></span><br><span class="line"><span class="keyword">int</span> __raw_notifier_call_chain(struct raw_notifier_head *nh,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v, <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注册原始通链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raw_notifier_chain_register</span><span class="params">(struct raw_notifier_head *nh, struct notifier_block *nb)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="4、SRCU-通知链"><a href="#4、SRCU-通知链" class="headerlink" title="4、SRCU 通知链"></a>4、SRCU 通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;可以阻塞的通知链。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">srcu_notifier_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mutex</span> <span class="title">mutex</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">srcu_struct</span>  <span class="title">srcu</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>braon-z
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://example.com/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="linux驱动-基础知识">https://example.com/2020/01/03/linux驱动-基础知识/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%A9%B1%E5%8A%A8/" rel="tag"><i class="fa fa-tag"></i> 驱动</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2020/01/03/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="next" title="c语言基础知识">
                  c语言基础知识 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">braon-z</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">478k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:14</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"VsC1eQwQ4Xltm5eA9iYGp3VU-gzGzoHsz","appKey":"kyfyE4RWl6aIojedbxcuJa3V","serverURLs":null,"placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      serverURLs: "https://vsc1eqwq.api.lncldglobal.com"
    }));
  }, window.Valine);
});
</script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fa fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fa fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
