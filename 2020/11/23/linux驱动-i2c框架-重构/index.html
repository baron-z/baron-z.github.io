<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":"ture","mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文借助mtk平台分析linux的i2c框架，mtk平台mt6765，内核版本kernel-4.9，本文只分析linux的i2c框架，不讨论i2c总线协议相关内容.">
<meta property="og:type" content="article">
<meta property="og:title" content="linux驱动-i2c">
<meta property="og:url" content="https://example.com/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/index.html">
<meta property="og:site_name" content="braon-z&#39;s blog">
<meta property="og:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文借助mtk平台分析linux的i2c框架，mtk平台mt6765，内核版本kernel-4.9，本文只分析linux的i2c框架，不讨论i2c总线协议相关内容.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/4.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605171541;10245085141&q-key-time=1605171541;10245085141&q-header-list=&q-url-param-list=&q-signature=f24cd44d860eae2aa76aaf53aaaba7c7a9aaa151">
<meta property="og:image" content="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/i2c%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6dts.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605671309;10245584909&q-key-time=1605671309;10245584909&q-header-list=&q-url-param-list=&q-signature=6d339c3be8f9cb9e5dc2ab4b199e9f70b72450fc">
<meta property="article:published_time" content="2020-11-23T01:14:17.000Z">
<meta property="article:modified_time" content="2021-01-18T02:02:54.887Z">
<meta property="article:author" content="braon-z">
<meta property="article:tag" content="驱动">
<meta property="article:tag" content="i2c">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/4.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605171541;10245085141&q-key-time=1605171541;10245085141&q-header-list=&q-url-param-list=&q-signature=f24cd44d860eae2aa76aaf53aaaba7c7a9aaa151">


<link rel="canonical" href="https://example.com/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>linux驱动-i2c | braon-z's blog</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">braon-z's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">一、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81i2c-client"><span class="nav-text">1、i2c_client</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81i2c-adapter"><span class="nav-text">2、i2c_adapter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81i2c-board-info"><span class="nav-text">3、i2c_board_info</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81i2c-driver"><span class="nav-text">4、i2c_driver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81i2c-device-id"><span class="nav-text">5、i2c_device_id</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81i2c-msg"><span class="nav-text">6、i2c_msg</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E6%A0%B8i2c%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6"><span class="nav-text">三、内核i2c驱动框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8dts%E6%B7%BB%E5%8A%A0i2c%E8%AE%BE%E5%A4%87"><span class="nav-text">1、使用dts添加i2c设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%80%9A%E8%BF%87%E6%80%BB%E7%BA%BF%E5%8F%B7%E6%B7%BB%E5%8A%A0i2c%E8%AE%BE%E5%A4%87"><span class="nav-text">2、通过总线号添加i2c设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0i2c%E8%AE%BE%E5%A4%87"><span class="nav-text">3、动态添加i2c设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%8A%A8%E6%80%81%E6%8E%A2%E6%B5%8BI2C%E6%80%BB%E7%BA%BF%E6%B7%BB%E5%8A%A0i2c%E8%AE%BE%E5%A4%87"><span class="nav-text">4、动态探测I2C总线添加i2c设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0i2c%E8%AE%BE%E5%A4%87"><span class="nav-text">5、从用户空间添加i2c设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81acpi%E6%96%B9%E5%BC%8F%E6%B7%BB%E5%8A%A0"><span class="nav-text">6、acpi方式添加</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%8E%B7%E5%8F%96-i2c-client-%E7%BB%93%E6%9E%84"><span class="nav-text">三、获取 i2c_client 结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8-i2c-client-%E9%80%9A%E4%BF%A1"><span class="nav-text">四、使用 i2c_client 通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81i2c-master-send"><span class="nav-text">1、i2c_master_send</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81i2c-master-recv"><span class="nav-text">2、i2c_master_recv</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81i2c-transfer"><span class="nav-text">3、i2c_transfer</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="braon-z"
      src="/images/wallhaven.jfif">
  <p class="site-author-name" itemprop="name">braon-z</p>
  <div class="site-description" itemprop="description"> 爱一个人，攀一座山，追一次梦<br>不妨大胆一点，有很多事没有答案</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wallhaven.jfif">
      <meta itemprop="name" content="braon-z">
      <meta itemprop="description" content=" 爱一个人，攀一座山，追一次梦<br>不妨大胆一点，有很多事没有答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="braon-z's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux驱动-i2c
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-23 09:14:17" itemprop="dateCreated datePublished" datetime="2020-11-23T09:14:17+08:00">2020-11-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-18 10:02:54" itemprop="dateModified" datetime="2021-01-18T10:02:54+08:00">2021-01-18</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>41k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>37 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>&nbsp;&nbsp;&nbsp;&nbsp;本文借助mtk平台分析linux的i2c框架，mtk平台mt6765，内核版本kernel-4.9，本文只分析linux的i2c框架，不讨论i2c总线协议相关内容.</p>
<a id="more"></a>

<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><h2 id="1、i2c-client"><a href="#1、i2c-client" class="headerlink" title="1、i2c_client"></a>1、i2c_client</h2><p>具体的i2次设备的软件抽象，它拥有所有i2c次设备的信息：</p>
<ol>
<li>包括i2c总线(物理总线)的控制器的硬件描述信息，这些信息通过结构 adapter 来进行描述</li>
<li>以及具体设备的addr信息，中断，以及name，这些信息通过结构 i2c_board_info 来进行描述</li>
</ol>
<p>i2c_client这个结构被注册时候就被注册到 i2c bus 上了，因此我们可以利用 i2c bus 获取到这个结构</p>
<blockquote>
<p><font color = red>说明：i2c有两个总线的概念，一个是设备模型中虚拟的i2c总线，另一个则是实际的物理上的i2c总线，在不说明的情况下默认设备模型中的虚拟总线。</font></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> flags;      <span class="comment">//i2c通信标志位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> addr;       <span class="comment">//次设备，i2c地址7位地址位，flags+addr组成8位地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[I2C_NAME_SIZE];	  <span class="comment">//设备名称，i2c_board_info 的 type 成员，driver 匹配时会用到该名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>  <span class="comment">//指向挂接的总线上的控制器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>      <span class="comment">//设备模型dev结构</span></span><br><span class="line">    <span class="keyword">int</span> irq;                <span class="comment">//用到的中断号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">i2c_slave_cb_t</span> slave_cb; <span class="comment">/* callback for slave mode  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、i2c-adapter"><a href="#2、i2c-adapter" class="headerlink" title="2、i2c_adapter"></a>2、i2c_adapter</h2><p>i2c适配器，adapter翻译过来就是适配器的意思，这个结构描述了硬件上的i2c总线的控制器信息，<font color = red><strong>注意不是我们理解的设备模型上虚拟的i2c总线，而是实实在在的接在cpu上面的硬件i2c总线的控制器信息</strong></font></p>
<p>其中 algo 链接着该总线的i2c通信相关结构 i2c_algorithm 。 按理来讲通信方式也是总线控制器的一部分为什么要将其分离出来，这样做是为了代码的复用性，如果系统有6个i2c总线则需要写6个通信接口，而区别往往只是一些和控制器某些寄存器的值不同而已，为了提高代码的效率，于是将 i2c_algorithm 独立出来作为一个共有的模块。</p>
<p>很明显作为总线控制器的描述，i2c_adapter 不会描述具体的设备信息，具体的设备信息由中间结构 i2c_board_info 描述，并将其存入 i2c_client 结构。</p>
<p>从上面的描述可以知道 i2c 适配器的数量其实是固定的，硬件有多少个 i2c 总线，就会有多少个 i2c 适配器，例如 mt6765 有6个物理的i2c总线i2c0-i2c6，因此mt6765就有6个i2c适配器。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>       <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">//i2c通信接口</span></span><br><span class="line">    <span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices   */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     i2c总线访问（发送或者接收数据）在传输失败的时候，可以选择重试。retries表示从试的次数。</span></span><br><span class="line"><span class="comment">     另外，有些设备对结果的返回是有时间要求的，因此不能无节制的重试，</span></span><br><span class="line"><span class="comment">     timeout字段（单位为jiffies）在retries基础上，增加了时间限制，超过这个时间，就不能重试了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> timeout;	<span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">int</span> retries;    <span class="comment">//重复次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>  <span class="comment">//设备模型dev，用于在sys/生成目录结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr;	<span class="comment">//i2c总线号，例如，0代表使用i2c0，这个不是我们所说的设备模型里面的i2c总线，是cpu中的i2c物理总线号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">48</span>]; <span class="comment">//adapter的名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span> <span class="comment">//用于管理用户空间创建的i2c设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通信方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 作为主设备时的通信函数 *</span></span><br><span class="line"><span class="comment">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);</span></span><br><span class="line"><span class="comment">	/* 作为从设备时的通信函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">int</span> (*reg_slave)(struct i2c_client *client);</span><br><span class="line">    <span class="keyword">int</span> (*unreg_slave)(struct i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3、i2c-board-info"><a href="#3、i2c-board-info" class="headerlink" title="3、i2c_board_info"></a>3、i2c_board_info</h2><p>这个结构用于描述具体的i2c设备的硬件信息，设备地址，通信方式，中断号等。</p>
<ol>
<li>当使用dts创建 i2c_client 时，它作为中间结构，当他把硬件信息传递给真正的设备结构 i2c_client，它的使命也就完成了，dts中的设备信息先在内核中转换为 i2c_board_info 这个结构，然后通过这个结构传给 i2c_client 。</li>
<li>当使用老式的使用总线号创建 i2c_client时，所有的由 i2c_register_board_info 动态创建的 i2c_board_info 描述的设备信息将被链接到 __i2c_board_list 链表进行维护，在加载内核时查询 __i2c_board_list 将 i2c_board_info 描述的信息传给 i2c_client</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>        type[I2C_NAME_SIZE]; <span class="comment">//i2c设备设名称，将被设置到client-&gt;name</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  addr; <span class="comment">//设备地址</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span> <span class="comment">//设备节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span></span><br><span class="line">    <span class="keyword">int</span>     irq; <span class="comment">//中断号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4、i2c-driver"><a href="#4、i2c-driver" class="headerlink" title="4、i2c_driver"></a>4、i2c_driver</h2><p>该结构用来描述虚拟 i2c bus 总线上的 driver ，通过向 i2c bus 注册该结构进行匹配，获取对应的 i2c_client</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_driver &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">     * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;  <span class="comment">//这个方法已经被过时，不应该被使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *); <span class="comment">//当匹配到i2c_client时调用这个函数</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *); <span class="comment">//和probe相反</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">     * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">     * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">     * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">     * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">     * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">     * with the device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> device_driver driver; <span class="comment">//设备模型中的device_driver结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *id_table; <span class="comment">//指向用来和i2c总线上的i2c_client进行匹配的一组 name </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">    <span class="keyword">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *); <span class="comment">//动态扫描的方式注册i2c_client, linux并不推荐这种方式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *address_list; <span class="comment">//动态扫描时使用的一组地址</span></span><br><span class="line">    <span class="keyword">struct</span> list_head clients;  <span class="comment">//用于链接detect动态扫描生成的设备。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5、i2c-device-id"><a href="#5、i2c-device-id" class="headerlink" title="5、i2c_device_id"></a>5、i2c_device_id</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_device_id &#123;</span><br><span class="line">    <span class="function"><span class="title">char</span> <span class="keyword">name</span>[I2C_NAME_SIZE]; //用于匹配的<span class="keyword">name</span>，这个<span class="keyword">name</span>将去匹配 i2c_client-&gt;</span><span class="keyword">name</span></span><br><span class="line">    kernel_ulong_t driver_data; <span class="comment">/* 用于保存驱动的私有数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6、i2c-msg"><a href="#6、i2c-msg" class="headerlink" title="6、i2c_msg"></a>6、i2c_msg</h2><p>linux的i2c通信是以 i2c_msg 作为操作单位</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    <span class="variable">__u16</span> addr; 	<span class="comment">//设备地址</span></span><br><span class="line">    <span class="variable">__u16</span> flags;	<span class="comment">//传输标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD        0x0001  <span class="comment">//设置了这个表示表示本次通信为接收数据，否则为发送数据。</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">//设置了这个表示从设备地址有10bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN      0x0400  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">//在读操作中不需要ack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">//当前i2cmsg忽略i2c器件的ack和nack信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">//读写标志位反过来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">//当前i2c_msg不发送start信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    <span class="variable">__u16</span> len;      <span class="comment">//数据长度，单位为byte</span></span><br><span class="line">    <span class="variable">__u8</span> *buf;      <span class="comment">//数据缓冲区指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="三、内核i2c驱动框架"><a href="#三、内核i2c驱动框架" class="headerlink" title="三、内核i2c驱动框架"></a>三、内核i2c驱动框架</h1><p>li2c总线的硬件结构一般如下图所示</p>
<div align=left> <img width=800 src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/4.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605171541;10245085141&q-key-time=1605171541;10245085141&q-header-list=&q-url-param-list=&q-signature=f24cd44d860eae2aa76aaf53aaaba7c7a9aaa151" > </div>

<p>cpu作为主设备挂接在所有总线上，而对应的设备根据硬件设计挂接在相应的总线上。图所示gsensor挂接在i2c0上，camera挂接在i2c1上，tp挂接在i2c2上。硬件结构非常简单，而linux的实现相对而言复杂度还是蛮高的，向上面的i2c设备 gsensor、camera、tp 等对于总线来讲只是地址上的不同而已，本质上都是i2c设备没有什么不同。 linux-4.9提供6种添加i2c设备的方法，参考 Documentation/i2c/instantiating-devices，下面逐一讨论。</p>
<h2 id="1、使用dts添加i2c设备"><a href="#1、使用dts添加i2c设备" class="headerlink" title="1、使用dts添加i2c设备"></a>1、使用dts添加i2c设备</h2><p>只需在dts文件中添加i2c设备相关节点，内核就会自动创建对应的  i2c_client 结构。 例如:添加两个设备 24c256、pca9532以以100kHz的速度连接到i2c1总线。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i2c1:</span> <span class="class">i2c@400a0000 </span>&#123;</span><br><span class="line">    <span class="comment">/* ... master properties skipped ... */</span></span><br><span class="line">    clock-frequency = <span class="params">&lt;<span class="number">100000</span>&gt;</span>; <span class="comment">//100KHZ</span></span><br><span class="line"></span><br><span class="line">    <span class="class">flash@50 </span>&#123;</span><br><span class="line">        compatible = <span class="string">&quot;atmel,24c256&quot;</span>;</span><br><span class="line">        reg = <span class="params">&lt;<span class="number">0x50</span>&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">    pca9532:</span> <span class="class">gpio@60 </span>&#123;</span><br><span class="line">        compatible = <span class="string">&quot;nxp,pca9532&quot;</span>;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">        reg = <span class="params">&lt;<span class="number">0x60</span>&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样内核在加载的时候就会自动创建出 name 为 24c256 和 pca9532 的i2c_client结构并将其注册进入i2c bus。它的流程如下所示：</p>
<div align=left> <img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/i2c%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6dts.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605671309;10245584909&q-key-time=1605671309;10245584909&q-header-list=&q-url-param-list=&q-signature=6d339c3be8f9cb9e5dc2ab4b199e9f70b72450fc" > </div>

<p>上图展示了整个注册流程，对于驱动工程师来讲非常简单，只需在dts中填充对应的信息就行了。而内核却帮我我们完成了一系类注册流程。而作为驱动工程师不仅仅要做到知其然，还要知其所以然，下面以mtk平台为例分析整个注册流程。</p>
<p>源码路径drivers/i2c/busses/i2c-mtk.c，ic原厂提供i2c函数都被放在drivers/i2c/busses/这个目录</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static s32 __init mt<span class="constructor">_i2c_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_MTK_I2C_ARBITRATION</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = enable<span class="constructor">_arbitration()</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Cannot enalbe arbitration.\n&quot;</span>)</span>;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!map<span class="constructor">_dma_regs()</span>)</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Mapp dma regs successfully.\n&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mt<span class="constructor">_i2c_parse_comp_data()</span>)</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Get compatible data from dts successfully.\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_info(<span class="string">&quot; mt_i2c_init driver as platform device\n&quot;</span>)</span>;</span><br><span class="line">    return platform<span class="constructor">_driver_register(&amp;<span class="params">mt_i2c_driver</span>)</span>; <span class="comment">//向内核注册 mt_i2c_driver </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码向内核注册了一个名叫 “mt-i2c” 的 platform 驱动</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_DRV_NAME           <span class="meta-string">&quot;mt-i2c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mtk_i2c_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;mediatek,i2c&quot;</span>, .data = &amp;i2c_common_compat&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mt_i2c_driver</span> =</span> &#123;</span><br><span class="line">    .probe = mt_i2c_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = mt_i2c_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = I2C_DRV_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .pm = &amp;mt_i2c_dev_pm_ops,</span><br><span class="line">        .of_match_table = of_match_ptr(mtk_i2c_of_match),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到它 match 的设备的 compatible 字段是 “mediatek,i2c” ，于是在dts中找对应的设备节点。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i2c0:</span> <span class="class">i2c0@11007000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">0</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c1:</span> <span class="class">i2c1@11008000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">1</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c2:</span> <span class="class">i2c2@11009000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">2</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c3:</span> <span class="class">i2c3@1100f000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">3</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c4:</span> <span class="class">i2c4@11011000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">4</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c5:</span> <span class="class">i2c5@11016000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">5</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c6:</span> <span class="class">i2c6@1100d000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">6</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>凡是在dts中具有compatible字段的节点，都会被内核注册为platform设备，例如上面的 i2c0，将会被转换为名字为”11007000.i2c0”的platform设备,再看i2c0到i2c6的节点都有相同的compatible字段”mediatek,i2c”，因此当驱动mt_i2c_driver注册的时候，会分别与之匹配调用对应的 mt_i2c_probe 函数，也就是说会调用6次mt_i2c_probe函数分别注册i2c0到i2c6, 以i2c0为例进行分析。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static int mt_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int cnt = 0;</span></span><br><span class="line">    struct mt_i2c *i2c; <span class="comment">//这个结构中包含了 i2c_adapter 结构</span></span><br><span class="line">    unsigned int clk_src_in_hz;</span><br><span class="line">    struct resource *res;</span><br><span class="line">    const struct of_device_id *of_id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(struct mt_i2c), GFP_KERNEL); </span><br><span class="line">    <span class="keyword">if</span> (i2c == NULL)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取dts中的相关数据其中包括 i2c-&gt;id </span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = mt_i2c_parse_dt(pdev-&gt;</span>dev.of_node, i2c); </span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        return -EINVAL;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev_comp</span> = of_id-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.of_node = pdev-&gt;</span>dev.of_node; <span class="comment">//设置设备节点为 i2c0 根节点</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev</span> = &amp;i2c-&gt;</span>adap.dev; </span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.parent = &amp;pdev-&gt;</span>dev;	<span class="comment">//设置父设备为传入的platform设备&quot;11007000.i2c0&quot;，有此可知所有的i2c_adapter设备都将是platform设备的子设备,都将位于 /sys/devices/110xx000.i2cx/ 之下</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo = &amp;mt_i2c_algorithm; <span class="comment">//这里始化了i2c的通信操作函数，这个函数有mtk原厂实现，这个是平台相关的寄存器操作</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo_data = NULL;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.timeout = <span class="number">2</span> * HZ; <span class="comment">//超时时间2s，从这里可知mtk的i2c超时时间为2s</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.retries = <span class="number">1</span>;	<span class="comment">//mtk平台设置，重复次数1次</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.nr = i2c-&gt;</span>id; <span class="comment">//表示使用的i2c总线号，0表示i2c0</span></span><br><span class="line">    <span class="function"><span class="title">spin_lock_init</span>(&amp;i2c-&gt;</span>cg_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(i2c-&gt;</span><span class="function"><span class="title">adap</span>.<span class="keyword">name</span>, I2C_DRV_NAME, sizeof(i2c-&gt;</span>adap.<span class="keyword">name</span>)); <span class="comment">//初始化adap的名字为mt-i2c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ret = i2c_add_adapter(&amp;i2c-&gt;adap); */</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = i2c_add_numbered_adapter(&amp;i2c-&gt;</span>adap); <span class="comment">//将adap注册进内核</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数，从dts获取相关的平台台相关的硬件信息，通信方式(mt_i2c_algorithm)、硬件总线号(adap.nr)等，以及平台相关的信息，通信超时时间、通信重复次数等，利用这些信息创建并初始化一个 i2c_adapter（包含在mt_i2c中），并将其注册进内核，来看看它的注册过程，它的代码在 drivers/i2c/i2c-core.c</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_add_numbered_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr<span class="operator"> == </span>-<span class="number">1</span>) <span class="comment">/* -1 means dynamically assign bus id */</span></span><br><span class="line">        return i2c<span class="constructor">_add_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="constructor">__i2c_add_numbered_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL_GPL(<span class="params">i2c_add_numbered_adapter</span>)</span>;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> <span class="constructor">__i2c_add_numbered_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> id;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_lock(&amp;<span class="params">core_lock</span>)</span>;</span><br><span class="line">    id = idr<span class="constructor">_alloc(&amp;<span class="params">i2c_adapter_idr</span>, <span class="params">adap</span>, <span class="params">adap</span>-&gt;<span class="params">nr</span>, <span class="params">adap</span>-&gt;<span class="params">nr</span> + 1, GFP_KERNEL)</span>;</span><br><span class="line">    mutex<span class="constructor">_unlock(&amp;<span class="params">core_lock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">WARN(<span class="params">id</span> &lt; 0, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>)</span>)</span><br><span class="line">        return id<span class="operator"> == </span>-ENOSPC ? -EBUSY : id;</span><br><span class="line"></span><br><span class="line">    return i2c<span class="constructor">_register_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到其实是调用了内核提供 i2c_register_adapter 函数来进行注册，来看看它干了什么</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    int res = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!is_registered)) &#123;	<span class="comment">//检查adap是否已经注册，防止存重复注册</span></span><br><span class="line">        res = -EAGAIN;</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity checks */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (WARN(!adap-&gt;</span><span class="keyword">name</span>[<span class="number">0</span>], <span class="string">&quot;i2c adapter has no name&quot;</span>)) <span class="comment">//检查 i2c_adapter 的名字，没有名字直接返回</span></span><br><span class="line">        goto out_list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!adap-&gt;</span>algo) &#123;	<span class="comment">// i2c_adapter检查是否有发送接收函数，没有直接返回</span></span><br><span class="line">        <span class="function"><span class="title">pr_err</span>(&quot;adapter &#x27;%s&#x27;: no algo supplied!\n&quot;, adap-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!adap-&gt;</span>lock_ops)</span><br><span class="line">        <span class="function"><span class="title">adap</span>-&gt;</span>lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">rt_mutex_init</span>(&amp;adap-&gt;</span>bus_lock);</span><br><span class="line">    <span class="function"><span class="title">rt_mutex_init</span>(&amp;adap-&gt;</span>mux_lock);</span><br><span class="line">    <span class="function"><span class="title">mutex_init</span>(&amp;adap-&gt;</span>userspace_clients_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;<span class="function"><span class="title">adap</span>-&gt;</span>userspace_clients);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (adap-&gt;</span>timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="function"><span class="title">adap</span>-&gt;</span>timeout = HZ; <span class="comment">//设置如果没设置超时时间则，默认超时时间为1s</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_set_name</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, &quot;i2c-%d&quot;, adap-&gt;</span><span class="function"><span class="title">nr</span>); // 设置 adap-&gt;</span>dev 的名字i2c-<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="title">adap</span>-&gt;</span>dev.bus = &amp;i2c_bus_type; <span class="comment">//设置总线</span></span><br><span class="line">    <span class="function"><span class="title">adap</span>-&gt;</span>dev.type = &amp;i2c_adapter_type;	<span class="comment">//设置 adapter 的设备类型</span></span><br><span class="line">    <span class="function"><span class="title">res</span> = device_register(&amp;adap-&gt;</span>dev); <span class="comment">// 向 i2c_bus_type 总线注册adapter设备 ，将生成 /sys/devices/11007000.i2c0/i2c-0 节点</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="function"><span class="title">pr_err</span>(&quot;adapter &#x27;%s&#x27;: can&#x27;t register device (%d)\n&quot;, adap-&gt;</span><span class="keyword">name</span>, res);</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, &quot;adapter [%s] registered\n&quot;, adap-&gt;</span><span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 电源相关忽略 */</span></span><br><span class="line">    <span class="function"><span class="title">pm_runtime_no_callbacks</span>(&amp;adap-&gt;</span>dev);</span><br><span class="line">    <span class="function"><span class="title">pm_suspend_ignore_children</span>(&amp;adap-&gt;</span>dev, <span class="literal">true</span>);</span><br><span class="line">    <span class="function"><span class="title">pm_runtime_enable</span>(&amp;adap-&gt;</span>dev);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    <span class="function"><span class="title">res</span> = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;</span>dev,</span><br><span class="line">                       <span class="function"><span class="title">adap</span>-&gt;</span>dev.parent);</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        <span class="function"><span class="title">dev_warn</span>(&amp;adap-&gt;</span>dev,</span><br><span class="line">             <span class="string">&quot;Failed to create compatibility class link\n&quot;</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    i2c_init_recovery(adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    of_i2c_register_devices(adap); <span class="comment">//遍历设备节点注册对应的 client</span></span><br><span class="line">    i2c_acpi_register_devices(adap); <span class="comment">//百度了一下说acpi是电源管理相关的东西，那就先不管</span></span><br><span class="line">    i2c_acpi_install_space_handler(adap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (adap-&gt;</span>nr &lt; __i2c_first_dynamic_bus_num) </span><br><span class="line">        i2c_scan_static_board_info(adap); <span class="comment">//老的方式注册adap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify drivers */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    <span class="function"><span class="title">idr_remove</span>(&amp;i2c_adapter_idr, adap-&gt;</span>nr);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数对adapte进行了一些错误检查，并进一步对它进行初始化，并将其注册进i2c总线，该函数还会调用 of_i2c_register_devices 创建 dts中对应的 i2c 设备相关的 i2c_client，看看它怎么做的。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static void of_i2c_register_devices(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    struct device_node *bus, *<span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    struct</span> i2c_client *client;</span><br><span class="line"></span><br><span class="line">    /* Only register child devices if the adapter has a <span class="keyword">node</span> <span class="title">pointer</span> set */</span><br><span class="line">    if (!adap-&gt;dev.of_node) //检测设备节点是否存在</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: walking child nodes\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bus = of_get_child_by_name(adap-&gt;dev.of_node, <span class="string">&quot;i2c-bus&quot;</span>); //mtk平台这个i2c-bus设备节点并不存在。</span><br><span class="line">    if (!bus)</span><br><span class="line">        bus = of_node_get(adap-&gt;dev.of_node); //直接返回i2c0设备节点，在前面被初始化</span><br><span class="line"></span><br><span class="line">    for_each_available_child_of_node(bus, <span class="keyword">node</span><span class="title">) &#123; //遍历 i2c0</span>的设备节点下的子节点</span><br><span class="line">        if (of_node_test_and_set_flag(<span class="keyword">node</span><span class="title">, OF_POPULATED</span>))</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        client = of_i2c_register_device(adap, <span class="keyword">node</span><span class="title">); //对于子节点执行这个函数</span></span><br><span class="line"><span class="title">        if</span> (IS_ERR(client)) &#123;</span><br><span class="line">            dev_warn(&amp;adap-&gt;dev,</span><br><span class="line">                 <span class="string">&quot;Failed to create I2C device for %s\n&quot;</span>,</span><br><span class="line">                 <span class="keyword">node</span><span class="title">-&gt;full_name</span>);</span><br><span class="line">            of_node_clear_flag(<span class="keyword">node</span><span class="title">, OF_POPULATED</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    of_node_put(bus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就是检测adap的硬件总线控制器设备节点是否存在，如果存在则对该总线节点的每一个子节点执行 of_i2c_register_device 函数，来看看它干了什么。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i2c0的子节点</span></span><br><span class="line">&amp;i2c0 &#123;</span><br><span class="line">    cap_touch@<span class="number">24</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;mediatek,cap_touch&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x24</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;pio&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">0</span> IRQ_TYPE_EDGE_FALLING <span class="number">0</span> <span class="number">0</span>&gt;;</span><br><span class="line">        int-gpio = &lt;&amp;pio <span class="number">0</span> <span class="number">0</span>&gt;;</span><br><span class="line">        rst-gpio = &lt;&amp;pio <span class="number">174</span> <span class="number">0</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *of_i2c_register_device(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span></span> *adap,</span><br><span class="line">                         <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *result;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span></span> info = &#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span></span> dev_ad = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> __be32 *addr_be;</span><br><span class="line">    <span class="built_in">u32</span> addr;</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: register %s\n&quot;</span>, node-&gt;full_name);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取节点下的 compatible 字段逗号后面的字符串，如果没有逗号则获取 compatible 字段的字符串，</span></span><br><span class="line">    这里将返回 cap_touch 并将其存入 info.<span class="keyword">type</span></span><br><span class="line">    <span class="keyword">if</span> (of_modalias_node(node, info.<span class="keyword">type</span>, sizeof(info.<span class="keyword">type</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: modalias failure on %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取reg描述&quot;0x24&quot;，即设备地址</span></span><br><span class="line">    addr_be = of_get_property(node, <span class="string">&quot;reg&quot;</span>, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!addr_be || (len &lt; sizeof(*addr_be))) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: invalid reg on %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = be32_to_cpup(addr_be); <span class="comment">//将其转化为16进制的0x24</span></span><br><span class="line">    <span class="keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">        addr &amp;= ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">        info.flags |= I2C_CLIENT_TEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123; <span class="comment">//地址检测</span></span><br><span class="line">        addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">        info.flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i2c_check_addr_validity(addr, info.flags)) &#123; <span class="comment">//地址检测</span></span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: invalid addr=%x on %s\n&quot;</span>,</span><br><span class="line">            addr, node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.addr = addr; <span class="comment">//初始化 i2c_board_info 结构地址</span></span><br><span class="line">    info.of_node = of_node_get(node); <span class="comment">//初始化设备节点为i2c0</span></span><br><span class="line">    info.archdata = &amp;dev_ad; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_get_property(node, <span class="string">&quot;wakeup-source&quot;</span>, NULL))</span><br><span class="line">        info.flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">    result = i2c_new_device(adap, &amp;info); <span class="comment">//创建并注册一个i2c_client,即注册一个新的i2c设备。</span></span><br><span class="line">    <span class="keyword">if</span> (result == NULL) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: Failure registering %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数创建了一个局部的i2c_board_info结构，从dts中获取到i2c子设备相关信息并将其初始化之后，将作为参数用于创建i2c_client,看看i2c_new_device怎么创建一个新的i2c设备。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client *</span><br><span class="line">i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client;</span><br><span class="line">    int         status;</span><br><span class="line"></span><br><span class="line">    client = kzalloc(sizeof *client, GFP_KERNEL); <span class="comment">//动态创建一个client结构</span></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>adapter = adap; <span class="comment">//初始化adapter成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.platform_data = info-&gt;</span>platform_data; <span class="comment">// 初始化platform_data成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (info-&gt;</span>archdata)</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.archdata = *info-&gt;</span>archdata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">flags</span> = info-&gt;</span>flags; <span class="comment">//初始化flag成员</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">addr</span> = info-&gt;</span>addr;	 <span class="comment">//初始化设备地址</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">irq</span> = info-&gt;</span>irq;	 <span class="comment">//初始化中断引脚，这里没有初始化，也会在i2c_device_probe中重新，获取相关的中断号。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(client-&gt;</span><span class="function"><span class="title">name</span>, info-&gt;</span><span class="function"><span class="title">type</span>, sizeof(client-&gt;</span><span class="function"><span class="title">name</span>)); //设置<span class="keyword">name</span>为info-&gt;</span>type，即设置为前面获取的cap_touch，这个名字非常重要，因为驱动匹配将使用这个名字。</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">status</span> = i2c_check_addr_validity(client-&gt;</span><span class="function"><span class="title">addr</span>, client-&gt;</span>flags);	<span class="comment">//检测i2c地址</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">            <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">flags</span> &amp; I2C_CLIENT_TEN ? 10 : 7, client-&gt;</span>addr);</span><br><span class="line">        goto out_err_silent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for address business */</span></span><br><span class="line">    status = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto out_err;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.parent = &amp;client-&gt;</span><span class="function"><span class="title">adapter</span>-&gt;</span>dev; <span class="comment">//设置设备父节点</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>dev.bus = &amp;i2c_bus_type; <span class="comment">//设置总线为i2c总线</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>dev.type = &amp;i2c_client_type; <span class="comment">//设置设备类型</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.of_node = info-&gt;</span>of_node; <span class="comment">//设置设备节点为i2c0</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.fwnode = info-&gt;</span>fwnode; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * dev_set_name(&amp;client-&gt;dev, &quot;%d-%04x&quot;, i2c_adapter_id(adap), i2c_encode_flags_to_addr(client));</span></span><br><span class="line"><span class="comment">     * 设置设备名字为 0-0024 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i2c_dev_set_name(adap, client); </span><br><span class="line">    <span class="function"><span class="title">status</span> = device_register(&amp;client-&gt;</span>dev); <span class="comment">//将设备注册进入bus总线，同时会生成节点 /sys/devices/11007000.i2c0/i2c-0/0-0024</span></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto out_err;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span>dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">name</span>, dev_name(&amp;client-&gt;</span>dev));</span><br><span class="line"></span><br><span class="line">    return client;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">    <span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev,</span><br><span class="line">        <span class="string">&quot;Failed to register i2c client %s at 0x%02x (%d)\n&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">name</span>, client-&gt;</span>addr, status);</span><br><span class="line">out_err_silent:</span><br><span class="line">    kfree(client);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止就完成了i2c0节点下的cap_touch的设备注册，of_i2c_register_devices函数会遍历i2c0节点下的子节点并依次进行注册。</p>
<p>最后在来对整个注册流程进行一个梳理，对应前面的框图，对于mtk平台对每一个i2c总线节点都会注册一个adapter，在adapter注册的时候后会遍历子节点下的每个i2c设备并创建对应的i2c设备结构client。而在创建过程中会用到一个中间结构 i2c_board_info，它用于描述i2c设备的硬件信息，在注册完成之后就被释放掉。</p>
<h2 id="2、通过总线号添加i2c设备"><a href="#2、通过总线号添加i2c设备" class="headerlink" title="2、通过总线号添加i2c设备"></a>2、通过总线号添加i2c设备</h2><p>这种方法适用于许多I2C总线是系统总线的嵌入式系统。 在这样的系统上，每个I2C总线都有一个事先已知的编号。 因此可以预先声明该总线上的I2C设备。 这是通过调用i2c_register_board_info（）注册的struct i2c_board_info数组完成的，在没有dts之前使用的就是这种方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_BOARD_INFO(dev_type, dev_addr) \</span></span><br><span class="line">    .type = dev_type, .addr = (dev_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct i2c_board_info h4_i2c_board_info[] __initdata = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;isp1301_omap&quot;</span>, <span class="number">0x2d</span>),</span><br><span class="line">        .irq        = OMAP_GPIO_IRQ(<span class="number">125</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;   <span class="comment">/* EEPROM on mainboard */</span></span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;24c01&quot;</span>, <span class="number">0x52</span>),</span><br><span class="line">        .platform_data  = &amp;m24c01,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;   <span class="comment">/* EEPROM on cpu card */</span></span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;24c01&quot;</span>, <span class="number">0x57</span>),</span><br><span class="line">        .platform_data  = &amp;m24c01,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">omap_h4_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (...)</span><br><span class="line">    i2c_register_board_info(<span class="number">1</span>, h4_i2c_board_info,</span><br><span class="line">            ARRAY_SIZE(h4_i2c_board_info));</span><br><span class="line">    (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在I2C总线1上声明了3个设备，包括它们各自的地址和其驱动程序所需的自定义数据。 注册I2C总线查询后，I2C内核将自动实例化I2C设备。以s3c2410为例进行分析,代码路径：drivers/i2c/busses/i2c-s3c2410.c</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int s3c24xx_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c24xx_i2c *i2c;</span><br><span class="line">    struct s3c2410_platform_i2c *pdata = NULL;</span><br><span class="line">    struct resource *res;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(i2c-&gt;</span><span class="function"><span class="title">adap</span>.<span class="keyword">name</span>, &quot;s3c2410-i2c&quot;, sizeof(i2c-&gt;</span>adap.<span class="keyword">name</span>));</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo = &amp;s3c24xx_i2c_algorithm; </span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.retries = <span class="number">2</span>; <span class="comment">//初始化重复次数</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.class = I2C_CLASS_DEPRECATED; <span class="comment">//不支持自动检测</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>tx_setup = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo_data = i2c;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.parent = &amp;pdev-&gt;</span>dev; <span class="comment">//初始化父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.nr = i2c-&gt;</span><span class="function"><span class="title">pdata</span>-&gt;</span>bus_num;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.of_node = pdev-&gt;</span>dev.of_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ret</span> = i2c_add_numbered_adapter(&amp;i2c-&gt;</span>adap); <span class="comment">//注册adapter</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">pm_runtime_disable</span>(&amp;pdev-&gt;</span>dev);</span><br><span class="line">        s3c24xx_i2c_deregister_cpufreq(i2c);</span><br><span class="line">        <span class="function"><span class="title">clk_unprepare</span>(i2c-&gt;</span>clk);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>同样是初始化adapter相关参数并向内核注册adapter</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">        i2c_register_adapter</span><br></pre></td></tr></table></figure>
<p>最后还是调用 i2c_register_adapter 这个函数来看看这种方式调用的是什么函数</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_register_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">        i2c<span class="constructor">_scan_static_board_info(<span class="params">adap</span>)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于前面已经分析过这个函数，就直接给出关键代码，在这句代码中发现一个参数 __i2c_first_dynamic_bus_num 这是一个内核创建的全来表示当前局整型变量用的i2c总线的数量，这个机制的一个特点就是i2c总线的数量是由设备注册的时候添加的。它是什么时候添加的呢？先往下看</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void i2c_scan_static_board_info(<span class="name">struct</span> i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_devinfo  *devinfo<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    down_read(<span class="name">&amp;__i2c_board_lock</span>)<span class="comment">;</span></span><br><span class="line">    list_for_each_entry(<span class="name">devinfo</span>, <span class="symbol">&amp;__i2c_board_list</span>, list) &#123;</span><br><span class="line">        if (<span class="name">devinfo-&gt;busnum</span> == adapter-&gt;nr</span><br><span class="line">                <span class="symbol">&amp;&amp;</span> !i2c_new_device(<span class="name">adapter</span>,</span><br><span class="line">                        <span class="symbol">&amp;devinfo-&gt;board_info</span>))</span><br><span class="line">            dev_err(<span class="name">&amp;adapter-&gt;dev</span>,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create device at 0x%02x\n&quot;</span>,</span><br><span class="line">                devinfo-&gt;board_info.addr)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    up_read(<span class="name">&amp;__i2c_board_lock</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个函数很简单，就是遍历 __i2c_board_list 链表，找到其中挂接在 adapter-&gt;nr 上的设备, 然后使用它的设备信息调用 i2c_new_device 创建一个 i2c_client 设备。 设备信息是通过 i2c_register_board_info 注册的，来看一下这个函数。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_register_board_info(<span class="params">int</span> <span class="params">busnum</span>, <span class="params">struct</span> <span class="params">i2c_board_info</span> <span class="params">const</span> <span class="operator">*</span><span class="params">info</span>, <span class="params">unsigned</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line"></span><br><span class="line">    down<span class="constructor">_write(&amp;<span class="params">__i2c_board_lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;i2c_register_board_info busnum = %d\n&quot;</span>,busnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dynamic bus numbers will be assigned after the last static one */</span></span><br><span class="line">    <span class="keyword">if</span> (busnum &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">        __i2c_first_dynamic_bus_num = busnum + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (status = <span class="number">0</span>; len; len--, info++) &#123;</span><br><span class="line">        <span class="keyword">struct</span> i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">        devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!devinfo) &#123;</span><br><span class="line">            pr<span class="constructor">_debug(<span class="string">&quot;i2c-core: can&#x27;t register boardinfo!\n&quot;</span>)</span>;</span><br><span class="line">            status = -ENOMEM;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devinfo-&gt;busnum = busnum;</span><br><span class="line">        devinfo-&gt;board_info = *info;</span><br><span class="line">        <span class="built_in">list</span><span class="constructor">_add_tail(&amp;<span class="params">devinfo</span>-&gt;<span class="params">list</span>, &amp;<span class="params">__i2c_board_list</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    up<span class="constructor">_write(&amp;<span class="params">__i2c_board_lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看见这个函数的功能很简单，当前 busnum 大于 __i2c_first_dynamic_bus_num 则更新 __i2c_first_dynamic_bus_num ，总线数量其实是在添加设备信息的时候添加的。当添加了设备信息之后将该设备信息链接到 __i2c_board_list 全局链表，__i2c_board_list 维护着由 i2c_register_board_info 注册的设备信息。</p>
<blockquote>
<p><strong>整个过程分为两步：</strong></p>
<ol>
<li>首先 arch/arm/mach-xxx 文件调用 i2c_register_board_info 函数 先向 __i2c_board_list 链表添加板子上的设备信息</li>
<li>然后在调用 drivers/i2c/busses/i2c-xxx 文件向内核注册创建并初始化adapter结构并注册进内核，在内核中遍历 __i2c_board_list 使用挂接在对应adapter上的设备信息 i2c_devinfo-&gt;info 创建出对应的i2c_client,调用流程如下:</li>
</ol>
</blockquote>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span> ---&gt;</span></span><br><span class="line">        <span class="function"><span class="title">i2c_register_adapter</span> ---&gt;</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (adap-&gt;</span>nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">                <span class="function"><span class="title">i2c_scan_static_board_info</span>(adap); ---&gt;</span></span><br><span class="line">                    <span class="function"><span class="title">if</span> (devinfo-&gt;</span><span class="function"><span class="title">busnum</span> == adapter-&gt;</span><span class="function"><span class="title">nr</span> &amp;&amp; !i2c_new_device(adapter, &amp;devinfo-&gt;</span>board_info))</span><br></pre></td></tr></table></figure>
<h2 id="3、动态添加i2c设备"><a href="#3、动态添加i2c设备" class="headerlink" title="3、动态添加i2c设备"></a>3、动态添加i2c设备</h2><p>前面的两种方式都是静态的方式添加的，就是在内核加载之前先提供i2c设备信息，在加载的时候创建，而内核也提供了动态加载的方法。一个个典型的例子是电视适配器。它们通常是通过I2C总线连接到主芯片的调谐器，视频解码器，音频解码器等。 由于不会事先知道I2C总线的编号，因此无法使用上述方法1和2。 </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">struct</span> i2c_board_info sfe4001_hwmon_info = &#123;</span><br><span class="line">    <span class="constructor">I2C_BOARD_INFO(<span class="string">&quot;max6647&quot;</span>, 0x4e)</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sfe4001<span class="constructor">_init(<span class="params">struct</span> <span class="params">efx_nic</span> <span class="operator">*</span><span class="params">efx</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    efx-&gt;board_info.hwmon_client =</span><br><span class="line">        i2c<span class="constructor">_new_device(&amp;<span class="params">efx</span>-&gt;<span class="params">i2c_adap</span>, &amp;<span class="params">sfe4001_hwmon_info</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个方式自己创建出一个 i2c_board_info 结构，并直接调用函数 i2c_new_device 创建一个i2c_client.上面的代码实例化了所讨论的网络适配器上I2C总线上的1个I2C设备，这个方式是动态的添加一个 i2c_client 的方式，使用这个方式的原因是我们事先不知道，我们的设备会挂在哪个i2c总线上。这种情况下还有一种可能就是我们不知道，总线上是否存在这样一个设备，我们想在创建前先检测这个总线是否存在这个设备于是可以使用下面的方式</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static const unsigned short normal_i2c<span class="literal">[]</span> = &#123; <span class="number">0x2c</span>, <span class="number">0x2d</span>, I2C_CLIENT_END &#125;;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> usb<span class="constructor">_hcd_nxp_probe(<span class="params">struct</span> <span class="params">platform_device</span> <span class="operator">*</span><span class="params">pdev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *i2c_adap;</span><br><span class="line">    <span class="keyword">struct</span> i2c_board_info i2c_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    i2c_adap = i2c<span class="constructor">_get_adapter(2)</span>;</span><br><span class="line">    memset(&amp;i2c_info, <span class="number">0</span>, sizeof(<span class="keyword">struct</span> i2c_board_info));</span><br><span class="line">    strlcpy(i2c_info.<span class="keyword">type</span>, <span class="string">&quot;isp1301_nxp&quot;</span>, I2C_NAME_SIZE);</span><br><span class="line">    isp1301_i2c_client = i2c<span class="constructor">_new_probed_device(<span class="params">i2c_adap</span>, &amp;<span class="params">i2c_info</span>, <span class="params">normal_i2c</span>, NULL)</span>;</span><br><span class="line">    i2c<span class="constructor">_put_adapter(<span class="params">i2c_adap</span>)</span>;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在所讨论的OHCI适配器上的I2C总线上最多实例化1个I2C设备。 它首先尝试在地址0x2c处进行尝试，如果在该位置未找到任何内容，则尝试在地址0x2d中进行处理，如果仍然找不到任何内容，则放弃。这里面有个关键函数 i2c_new_probed_device 来看看这个函数的实现原理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_client *</span><br><span class="line">i2c_new_probed_device(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">              <span class="keyword">struct</span> i2c_board_info *info,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">const</span> *addr_list,</span><br><span class="line">              <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> i2c_adapter *, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!probe)</span><br><span class="line">        probe = i2c_default_probe; <span class="comment">//如果没有probe则使用内核默认的i2c检测函数，这个函数检测当前总线上的设备是否存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; addr_list[i] != I2C_CLIENT_END; i++) &#123;</span><br><span class="line">        <span class="comment">/* Check address validity */</span></span><br><span class="line">        <span class="keyword">if</span> (i2c_check_7bit_addr_validity_strict(addr_list[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dev_warn(&amp;adap-&gt;dev, <span class="string">&quot;Invalid 7-bit address 0x%02x\n&quot;</span>,</span><br><span class="line">                 addr_list[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check address availability (7 bit, no need to encode flags) */</span></span><br><span class="line">        <span class="keyword">if</span> (i2c_check_addr_busy(adap, addr_list[i])) &#123;</span><br><span class="line">            dev_dbg(&amp;adap-&gt;dev,</span><br><span class="line">                <span class="string">&quot;Address 0x%02x already in use, not probing\n&quot;</span>,</span><br><span class="line">                addr_list[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Test address responsiveness */</span></span><br><span class="line">        <span class="keyword">if</span> (probe(adap, addr_list[i])) <span class="comment">//检测当前总线上的设i2c备是否存在。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr_list[i] == I2C_CLIENT_END) &#123;</span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;Probing failed, no device found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;addr = addr_list[i];</span><br><span class="line">    <span class="keyword">return</span> i2c_new_device(adap, info); <span class="comment">//创建i2c_client</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数的功能就是向当前总线上的i2c设备发送一个i2c信息，看看设备是否应答，用来判断是否存在i2c设备 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i2c_default_probe(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">union</span> i2c_smbus_data dummy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0x73</span> &amp;&amp; (adap-&gt;<span class="keyword">class</span> &amp; I2C_CLASS_HWMON)</span><br><span class="line">     &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_BYTE_DATA, &amp;dummy);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!((addr &amp; ~<span class="number">0x07</span>) == <span class="number">0x30</span> || (addr &amp; ~<span class="number">0x0f</span>) == <span class="number">0x50</span>)</span><br><span class="line">     &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_WRITE, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_QUICK, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_BYTE, &amp;dummy);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_warn(&amp;adap-&gt;dev, <span class="string">&quot;No suitable probing method supported for address 0x%02X\n&quot;</span>,</span><br><span class="line">             addr);</span><br><span class="line">        err = -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、动态探测I2C总线添加i2c设备"><a href="#4、动态探测I2C总线添加i2c设备" class="headerlink" title="4、动态探测I2C总线添加i2c设备"></a>4、动态探测I2C总线添加i2c设备</h2><p>有时没有足够的有关I2C设备的信息，甚至无法调用i2c_new_probed_device（）。典型的情况是PC主板上的硬件监视芯片。有几十种模型，它们可以存在于25个不同的地址。鉴于那里有大量的主板，几乎不可能建立一个完整的硬件监控芯片清单。幸运的是，这些芯片中的大多数都有制造商和设备ID寄存器，因此可以通过探测来识别它们。也就是我们的detect内核中的机制了。<strong>在这种情况下，既不声明也不显式实例化I2C设备。取而代之的是，i2c-core会在加载驱动程序后立即探测此类设备，如果找到了驱动程序，则会自动实例化I2C设备</strong>。<font color = red><strong>这也就是 adapter 中 class 成员变量的作用了，内核在加载驱动时会使用驱动提供的地址链表 i2c_driver-&gt;address_list，自动去具有同类 class 的 adapter 上探测这个链表上的地址，如果探测到了则实例化驱动</strong></font></p>
<p>为了防止此机制的任何不当行为，适用以下限制：</p>
<ol>
<li>I2C设备驱动程序必须实现detect（）方法，该方法通过从任意寄存器读取来识别支持的设备。</li>
<li>仅对可能具有受支持设备并同意进行探测的总线进行探测。例如，这避免了在电视适配器上探测硬盘监控芯片的麻烦。<br>例：请参阅drivers/hwmon/lm90.c中的lm90_driver和lm90_detect（）</li>
</ol>
<p>那些熟悉2.4内核和早期2.6内核的i2c子系统的人会发现，此方法本质上与此处所做的相似。两个重要区别是：</p>
<ol>
<li>探测只是现在实例化I2C设备的一种方法，而那是那时的唯一方法。<strong>在可能的情况下，应首选方法1、2、3。方法4仅应在没有其他方法的情况下使用，因为它可能会产生不良的副作用。</strong></li>
<li>I2C总线必须明确地说明哪些I2C驱动程序类可以对其进行探测（通过类位域），<strong>而所有I2C总线默认情值为空类，这意味着不进行探测。类位域的目的是限制上述不希望的副作用。</strong></li>
</ol>
<p><font color=red><strong>再一次声明，应尽可能避免使用方法4。显式设备实例化（方法1、2、3）是更可取的，因为它更安全，更快捷。</strong></font></p>
<p>由于内核不推荐使用这种方式就不详细分析了给出调用流程就行了，感兴趣跟着调用流程看看</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span> ---&gt;</span></span><br><span class="line">        <span class="function"><span class="title">i2c_register_adapter</span> ---&gt;</span></span><br><span class="line">            <span class="function"><span class="title">bus_for_each_drv</span>(&amp;i2c_bus_type, NULL, adap, __process_new_adapter); ---&gt;</span></span><br><span class="line">                <span class="function"><span class="title">i2c_do_add_adapter</span> ---&gt;</span></span><br><span class="line">                    <span class="function"><span class="title">i2c_detect</span> ---&gt;</span></span><br><span class="line">                        <span class="function"><span class="title">i2c_detect_address</span> ---&gt;</span></span><br><span class="line">                            i2c_default_probe <span class="comment">//判断设备是否在这个总线上</span></span><br><span class="line">                            <span class="function"><span class="title">driver</span>-&gt;</span>detect(temp_client, &amp;info); <span class="comment">//调用这个函数，在这个函数和设备通信，获取到设备信息，完善info中的信息。</span></span><br><span class="line">                            i2c_new_device <span class="comment">//创建i2c_client</span></span><br><span class="line">                            <span class="function"><span class="title">list_add_tail</span>(&amp;client-&gt;</span><span class="function"><span class="title">detected</span>, &amp;driver-&gt;</span>clients); <span class="comment">// 将设备链接到 clients</span></span><br></pre></td></tr></table></figure>
<p>这种方式适用于不知道设备被挂在哪个总线上的情况，通过遍历所有的总线，去判断设备是否在总线上,如果存在则调用 driver-&gt;detect 进一步获取设备信息，用于完善info结构，如果设备信息完善则创建 i2c_client。</p>
<h2 id="5、从用户空间添加i2c设备"><a href="#5、从用户空间添加i2c设备" class="headerlink" title="5、从用户空间添加i2c设备"></a>5、从用户空间添加i2c设备</h2><p>通常，内核应该知道连接了哪些I2C设备以及它们位于什么地址。但是，在某些情况下却没有，因此添加了sysfs接口以让用户提供信息。该接口由2个属性文件组成，new_device和delete_device。这两个文件都是只写的，并且必须为它们写正确的参数，以便正确地创建或删除I2C设备。</p>
<p><strong>创建一个i2c设备</strong><br>文件 new_device 用于创建一个i2c设备，具有2个参数：I2C设备的名称（字符串）和I2C设备的地址（一个数字，通常以十六进制表示，以0x开头，但也可以以十进制表示。）例如：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo eeprom <span class="number">0</span>x50&gt;<span class="regexp">/sys/</span>bus<span class="regexp">/i2c/</span>devices<span class="regexp">/i2c-3/</span>new_device</span><br></pre></td></tr></table></figure>
<p><strong>删除一个i2c设备</strong><br>文件delete_device，用于删除一个i2c设备，具有一个参数：I2C设备的地址。由于在给定的I2C网段上没有两个设备可以住在同一地址，因此该地址足以唯一地标识要删除的设备。例：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span>x50&gt;<span class="regexp">/sys/</span>bus<span class="regexp">/i2c/</span>devices<span class="regexp">/i2c-3/</span>delete_device</span><br></pre></td></tr></table></figure>
<p>来看看内核的实现</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> =</span> to_i2c_adapter(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *blank, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct i2c_board_info));</span><br><span class="line"></span><br><span class="line">    blank = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!blank) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Missing parameters\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blank - buf &gt; I2C_NAME_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Invalid device name\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(info.type, buf, blank - buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse remaining parameters, reject extra parameters */</span></span><br><span class="line">    res = <span class="built_in">sscanf</span>(++blank, <span class="string">&quot;%hi%c&quot;</span>, &amp;info.addr, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t parse I2C address\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; <span class="built_in">end</span> != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Extra parameters\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((info.addr &amp; I2C_ADDR_OFFSET_TEN_BIT) == I2C_ADDR_OFFSET_TEN_BIT) &#123;</span><br><span class="line">        info.addr &amp;= ~I2C_ADDR_OFFSET_TEN_BIT;</span><br><span class="line">        info.flags |= I2C_CLIENT_TEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.addr &amp; I2C_ADDR_OFFSET_SLAVE) &#123;</span><br><span class="line">        info.addr &amp;= ~I2C_ADDR_OFFSET_SLAVE;</span><br><span class="line">        info.flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client = i2c_new_device(adap, &amp;info);</span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep track of the added device */</span></span><br><span class="line">    mutex_lock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    list_add_tail(&amp;client-&gt;detected, &amp;adap-&gt;userspace_clients);</span><br><span class="line">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    dev_info(dev, <span class="string">&quot;%s: Instantiated device %s at 0x%02hx\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>,</span><br><span class="line">         info.type, info.addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(new_device, S_IWUSR, <span class="literal">NULL</span>, i2c_sysfs_new_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">i2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> =</span> to_i2c_adapter(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> addr;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse parameters, reject extra parameters */</span></span><br><span class="line">    res = <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%hi%c&quot;</span>, &amp;addr, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t parse I2C address\n&quot;</span>, <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; <span class="built_in">end</span> != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Extra parameters\n&quot;</span>, <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the device was added through sysfs */</span></span><br><span class="line">    res = -ENOENT;</span><br><span class="line">    mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class="line">              i2c_adapter_depth(adap));</span><br><span class="line">    list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class="line">                 detected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i2c_encode_flags_to_addr(client) == addr) &#123;</span><br><span class="line">            dev_info(dev, <span class="string">&quot;%s: Deleting device %s at 0x%02hx\n&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;delete_device&quot;</span>, client-&gt;name, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">            list_del(&amp;client-&gt;detected);</span><br><span class="line">            i2c_unregister_device(client);</span><br><span class="line">            res = count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t find device in list\n&quot;</span>,</span><br><span class="line">            <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR_IGNORE_LOCKDEP</span><span class="params">(delete_device, S_IWUSR, <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   i2c_sysfs_delete_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">i2c_adapter_attrs</span>[] =</span> &#123;</span><br><span class="line">    &amp;dev_attr_name.attr,</span><br><span class="line">    &amp;dev_attr_new_device.attr,</span><br><span class="line">    &amp;dev_attr_delete_device.attr,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line">ATTRIBUTE_GROUPS(i2c_adapter);</span><br></pre></td></tr></table></figure>
<p>可以看见其实很简单，就是获取初入的name和addr动态初始化一个info，然后利用 new_device 函数创建一个i2c_client ，这种方式和方式2是一样的，只是将方式2开放给用户空间一个接口。</p>
<h2 id="6、acpi方式添加"><a href="#6、acpi方式添加" class="headerlink" title="6、acpi方式添加"></a>6、acpi方式添加</h2><p>参考: kernel-4.9/Documentation/acpi/enumeration.txt.</p>
<h1 id="三、获取-i2c-client-结构"><a href="#三、获取-i2c-client-结构" class="headerlink" title="三、获取 i2c_client 结构"></a>三、获取 i2c_client 结构</h1><p>有了具体的设备结构 i2c_client, 我们要怎么用呢，比如我想向i2c0上的 cap_touch 发送数据，怎么获取到对应的 i2c_client 结构呢？很简单因为 i2c_client 被挂接到了 i2c 总线上，因此我们只需要向 i2c 总线上注册一个 i2c_driver ，并且使用要用到的 i2c_client 的name作为 i2c_driver 的 i2c_device_id-&gt;name。那么总线就会去匹配和 i2c_device_id-&gt;name 相同 name 的 i2c_client(这是i2c总线的match函数匹配规则)，匹配成功则调用driver的probe成员函数并且将i2c_client作为参数传入，这样我们就获取到了我们想要的具体的 i2c_client 设备结构。 于是想要获取到 cap_touch 的 i2c_client 的示例代码如下（代码并不完整这只是一个伪代码）：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> my<span class="constructor">_i2c_probe(<span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_device_id</span> <span class="operator">*</span><span class="params">id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_probe\n&quot;</span>); </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> my<span class="constructor">_i2c_remove(<span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span> <span class="params">client</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_remove\n&quot;</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历这里数组中的 i2c_device_id.name 一个一个匹配</span></span><br><span class="line">static const <span class="keyword">struct</span> i2c_device_id my_id_table<span class="literal">[]</span> = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;cap_touch&quot;</span>, <span class="number">0</span> &#125;, <span class="comment">//通过这个名字获取到我们需要的 i2c_client 设备结构 </span></span><br><span class="line">    &#123; NULL, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">struct</span> i2c_driver my_i2c_driver = &#123;</span><br><span class="line">    .probe  = my_i2c_probe,</span><br><span class="line">    .remove = my_i2c_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">           .name = <span class="string">&quot;cap_touch&quot;</span>, <span class="comment">//驱动的name将出现在 /sys/bus/i2c/ 下</span></span><br><span class="line">           &#125;,</span><br><span class="line">	.id_table = my_id_table, <span class="comment">//匹配用到的结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> my<span class="constructor">_i2c_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i2c<span class="constructor">_add_driver(&amp;<span class="params">my_i2c_driver</span>)</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void my<span class="constructor">_i2c_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">my_i2c_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">my_i2c_exit</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>i2c_add_driver 的内部工作原理到底是怎么样的呢，看看源码。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define i2c<span class="constructor">_add_driver(<span class="params">driver</span>)</span> \</span><br><span class="line">    i2c<span class="constructor">_register_driver(THIS_MODULE, <span class="params">driver</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_register_driver(<span class="params">struct</span> <span class="params">module</span> <span class="operator">*</span><span class="params">owner</span>, <span class="params">struct</span> <span class="params">i2c_driver</span> <span class="operator">*</span><span class="params">driver</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">WARN_ON(!<span class="params">is_registered</span>)</span>)</span><br><span class="line">        return -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add the driver to the list of i2c drivers in the driver core */</span></span><br><span class="line">    driver-&gt;driver.owner = owner;</span><br><span class="line">    driver-&gt;driver.bus = &amp;i2c_bus_type; <span class="comment">//初始化总线</span></span><br><span class="line">    <span class="constructor">INIT_LIST_HEAD(&amp;<span class="params">driver</span>-&gt;<span class="params">clients</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment">     * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将驱动注册进入bus总线</span></span><br><span class="line">    res = driver<span class="constructor">_register(&amp;<span class="params">driver</span>-&gt;<span class="params">driver</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_debug(<span class="string">&quot;driver [%s] registered\n&quot;</span>, <span class="params">driver</span>-&gt;<span class="params">driver</span>.<span class="params">name</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the adapters that are already present */</span></span><br><span class="line">    <span class="comment">//对应前面提到的 动态探测I2C总线添加i2c设备 内核不推荐使用这种方式。</span></span><br><span class="line">    i2c<span class="constructor">_for_each_dev(<span class="params">driver</span>, <span class="params">__process_new_driver</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用driver_register这个函数将驱动注册进入内核时，会使用设备模型的匹配机制，和总线上的设备进行匹配。简单描述一下调用流程：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bus_add_driver</span>----&gt;</span></span><br><span class="line">	<span class="function"><span class="title">driver_attach</span>----&gt;</span> 无论如何最终都会调用这个函数</span><br><span class="line">		<span class="function"><span class="title">bus_for_each_dev</span>----&gt;</span></span><br><span class="line">			__<span class="function"><span class="title">driver_attach</span>----&gt;</span></span><br><span class="line">				<span class="function"><span class="title">driver_match_device</span>----&gt;</span></span><br><span class="line">					<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>match(dev, drv) <span class="comment">//如果匹配成功则调用 really_probe</span></span><br><span class="line">					<span class="function"><span class="title">really_probe</span>----&gt;</span></span><br><span class="line">						<span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe(dev) <span class="comment">//默认点调用这个</span></span><br><span class="line">						<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">probe</span>(dev) //如果没有设置 dev-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe 函数，则调用这个</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终调用总线上的match函数 i2c_device_match </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_device_match(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">drv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_client   *client = i2c<span class="constructor">_verify_client(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> i2c_driver   *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">of</span><span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>) <span class="comment">//设备树方式匹配</span></span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi<span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>) <span class="comment">//先不管，后面有机会补充</span></span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    driver = <span class="keyword">to</span><span class="constructor">_i2c_driver(<span class="params">drv</span>)</span>;</span><br><span class="line">    <span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;id_table) <span class="comment">// id_table 进行匹配</span></span><br><span class="line">        return i2c<span class="constructor">_match_id(<span class="params">driver</span>-&gt;<span class="params">id_table</span>, <span class="params">client</span>)</span> != NULL;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从该函数知道，i2c总线提供了3中匹配的方式，无论是什么方式都是获取我们需要的 i2c_client 结构：</p>
<ol>
<li>使用设备树 compatible 字段进行匹配</li>
<li>acpi 方式匹配（这个用了再来补充）</li>
<li>使用 id_table方式进行匹配</li>
</ol>
<p>其中设备树方式在设备模型中已讨论，这种匹配方式只能匹配到设备树中生成的设备，而我们根本不会将 i2c_client 写到设备树中，因此这个匹配方式是匹配不到我们需要的 i2c_client 设备的，我也不知道为什么会写入这种规则，有大佬知道可以告知一下，这里讨论 id_table 方式</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *i2c_match_id(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="keyword">id</span>,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">id</span>-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strcmp(client-&gt;name, <span class="keyword">id</span>-&gt;name) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">id</span>;</span><br><span class="line">        <span class="keyword">id</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看起来很简单，就是比较 i2c_client-&gt;name 和 i2c_device_id-&gt;name 是否相同，如果相同则匹配成功，匹配成功后调用总线对应的 probe 函数 i2c_device_probe</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_device_probe(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_client   *client = i2c<span class="constructor">_verify_client(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> i2c_driver   *driver;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line">        <span class="built_in">int</span> irq = -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;of_node) &#123; <span class="comment">//更新irq</span></span><br><span class="line">            irq = <span class="keyword">of</span><span class="constructor">_irq_get_byname(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="string">&quot;irq&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (irq<span class="operator"> == </span>-EINVAL<span class="operator"> || </span>irq<span class="operator"> == </span>-ENODATA)</span><br><span class="line">                irq = <span class="keyword">of</span><span class="constructor">_irq_get(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, 0)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="constructor">ACPI_COMPANION(<span class="params">dev</span>)</span>) &#123;</span><br><span class="line">            irq = acpi<span class="constructor">_dev_gpio_irq_get(ACPI_COMPANION(<span class="params">dev</span>)</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (irq<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">            return irq;</span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">            irq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        client-&gt;irq = irq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver = <span class="keyword">to</span><span class="constructor">_i2c_driver(<span class="params">dev</span>-&gt;<span class="params">driver</span>)</span>; <span class="comment">//获取对应的 i2c_driver 结构</span></span><br><span class="line">    <span class="keyword">if</span> (!driver-&gt;probe<span class="operator"> || </span>!driver-&gt;id_table)</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_WAKE) &#123;</span><br><span class="line">        <span class="built_in">int</span> wakeirq = -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">            wakeirq = <span class="keyword">of</span><span class="constructor">_irq_get_byname(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="string">&quot;wakeup&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (wakeirq<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">                return wakeirq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        device<span class="constructor">_init_wakeup(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wakeirq &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>wakeirq != client-&gt;irq)</span><br><span class="line">            status = dev<span class="constructor">_pm_set_dedicated_wake_irq(<span class="params">dev</span>, <span class="params">wakeirq</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>)</span><br><span class="line">            status = dev<span class="constructor">_pm_set_wake_irq(<span class="params">dev</span>, <span class="params">client</span>-&gt;<span class="params">irq</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            dev<span class="constructor">_warn(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="string">&quot;failed to set up wakeup irq\n&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev<span class="constructor">_dbg(<span class="params">dev</span>, <span class="string">&quot;probe\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="keyword">of</span><span class="constructor">_clk_set_defaults(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        goto err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    status = dev<span class="constructor">_pm_domain_attach(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (status<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">        goto err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    status = driver-&gt;probe(client, i2c<span class="constructor">_match_id(<span class="params">driver</span>-&gt;<span class="params">id_table</span>, <span class="params">client</span>)</span>); <span class="comment">//最终调用i2c_driver下的probe函数，并使用 client 匹配成功的driver-&gt;id_table作为参数</span></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto err_detach_pm_domain;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_detach_pm_domain:</span><br><span class="line">    dev<span class="constructor">_pm_domain_detach(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line">err_clear_wakeup_irq:</span><br><span class="line">    dev<span class="constructor">_pm_clear_wake_irq(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>)</span>;</span><br><span class="line">    device<span class="constructor">_init_wakeup(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_device_probe 函数又根据更新了了一次 irq，并最终调用了注册的  i2c_driver 结构的 probe 成员函数。于是在 probe 函数中我们就获取到了我们需要的 i2c_client 结构。内核也提供了一个demo，参考kernel-4.9，Documentation/i2c/upgrading-clients</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span>   *client;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int example_probe(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *client,</span><br><span class="line">                 <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span></span> *id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> *state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = &amp;client-&gt;dev;</span><br><span class="line"></span><br><span class="line">    state = kzalloc(sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (state == NULL) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;failed to create our state\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;client = client;</span><br><span class="line">    i2c_set_clientdata(client, state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rest of the initialisation goes here. */</span></span><br><span class="line"></span><br><span class="line">    dev_info(dev, <span class="string">&quot;example client created\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int example_remove(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *client)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> *state = i2c_get_clientdata(client);</span><br><span class="line"></span><br><span class="line">    kfree(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span></span> example_idtable[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;example&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(i2c, example_idtable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span></span> example_driver = &#123;</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .owner      = THIS_MODULE,</span><br><span class="line">        .name       = <span class="string">&quot;example&quot;</span>,</span><br><span class="line">        .pm     = &amp;example_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table   = example_idtable,</span><br><span class="line">    .probe      = example_probe,</span><br><span class="line">    .remove     = example_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="四、使用-i2c-client-通信"><a href="#四、使用-i2c-client-通信" class="headerlink" title="四、使用 i2c_client 通信"></a>四、使用 i2c_client 通信</h1><p>获取到 i2c_client 结构之后，就可以使用它来进行i2c通信了，内核使用 i2c_msg 结构装了传输的数据，每次通讯都是以 i2c_msg 为单位的</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    <span class="variable">__u16</span> addr; 	<span class="comment">//设备地址</span></span><br><span class="line">    <span class="variable">__u16</span> flags;	<span class="comment">//传输标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD        0x0001  <span class="comment">//设置了这个表示表示本次通信为接收数据，否则为发送数据。</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">//设置了这个表示从设备地址有10bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN      0x0400  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">//在读操作中不需要ack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">//当前i2cmsg忽略i2c器件的ack和nack信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">//读写标志位反过来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">//当前i2c_msg不发送start信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    <span class="variable">__u16</span> len;      <span class="comment">//数据长度，单位为byte</span></span><br><span class="line">    <span class="variable">__u8</span> *buf;      <span class="comment">//数据缓冲区指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1、i2c-master-send"><a href="#1、i2c-master-send" class="headerlink" title="1、i2c_master_send"></a>1、i2c_master_send</h2><p>该函数用于向 i2c_client 发送buf指向的数据，数据长度为count字节</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_master_send(<span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    <span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.len = count;</span><br><span class="line">    msg.buf = (<span class="built_in">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">    ret = i2c<span class="constructor">_transfer(<span class="params">adap</span>, &amp;<span class="params">msg</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If everything went ok (i.e. 1 msg transmitted), return #bytes</span></span><br><span class="line"><span class="comment">     * transmitted, else error code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    return (ret<span class="operator"> == </span><span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL(<span class="params">i2c_master_send</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2、i2c-master-recv"><a href="#2、i2c-master-recv" class="headerlink" title="2、i2c_master_recv"></a>2、i2c_master_recv</h2><p>该函数用于向 i2c_client 接收数据长度为count字节的数据，数据被存在buf中。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_master_recv(<span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    <span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.flags <span class="pattern-match">|= <span class="constructor">I2C_M_RD</span>;</span></span><br><span class="line"><span class="pattern-match">    msg.len = count;</span></span><br><span class="line"><span class="pattern-match">    msg.buf = buf;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    ret = i2c<span class="constructor">_transfer(<span class="params">adap</span>, &amp;<span class="params">msg</span>, 1)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span></span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="constructor">If</span> everything went ok (i.e. 1 msg received), return #<span class="built_in">bytes</span> received,</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="keyword">else</span> error code.</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">    return (ret <span class="operator">==</span> 1) ? count : ret;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">EXPORT_SYMBOL(<span class="params">i2c_master_recv</span>)</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、i2c-transfer"><a href="#3、i2c-transfer" class="headerlink" title="3、i2c_transfer"></a>3、i2c_transfer</h2><p>该函数向 i2c_adapter 所表示的总线上传输 num 个 msgs。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">ret</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ret</span> = 0; <span class="keyword">ret</span> &lt; num; <span class="keyword">ret</span>++) &#123;</span><br><span class="line">            dev_dbg(&amp;adap-&gt;dev,</span><br><span class="line">                <span class="string">&quot;master_xfer[%d] %c, addr=0x%02x, len=%d%s\n&quot;</span>,</span><br><span class="line">                <span class="keyword">ret</span>, (msgs[<span class="keyword">ret</span>].flags &amp; I2C_M_RD) ? &#x27;R&#x27; : &#x27;W&#x27;,</span><br><span class="line">                msgs[<span class="keyword">ret</span>].addr, msgs[<span class="keyword">ret</span>].len,</span><br><span class="line">                (msgs[<span class="keyword">ret</span>].flags &amp; I2C_M_RECV_LEN) ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_atomic() || irqs_disabled()) &#123;</span><br><span class="line">            <span class="keyword">ret</span> = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">ret</span>)</span><br><span class="line">                <span class="comment">/* I2C activity is ongoing. */</span></span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i2c_lock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ret</span> = __i2c_transfer(adap, msgs, num);</span><br><span class="line">        i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>braon-z
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://example.com/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/" title="linux驱动-i2c">https://example.com/2020/11/23/linux驱动-i2c框架-重构/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%A9%B1%E5%8A%A8/" rel="tag"><i class="fa fa-tag"></i> 驱动</a>
              <a href="/tags/i2c/" rel="tag"><i class="fa fa-tag"></i> i2c</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/02/05/c++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="prev" title="c++基础知识">
                  <i class="fa fa-chevron-left"></i> c++基础知识
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/" rel="next" title="linux设备模型">
                  linux设备模型 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">braon-z</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">342k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:11</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"VsC1eQwQ4Xltm5eA9iYGp3VU-gzGzoHsz","appKey":"kyfyE4RWl6aIojedbxcuJa3V","serverURLs":null,"placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/",
      serverURLs: "https://vsc1eqwq.api.lncldglobal.com"
    }));
  }, window.Valine);
});
</script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fa fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fa fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
