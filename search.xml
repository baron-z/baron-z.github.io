<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>makefile专题</title>
    <url>/2021/01/18/makfile%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>记录makefile基本知识</p>
<a id="more"></a>
<h1 id="一、make-和-makefile"><a href="#一、make-和-makefile" class="headerlink" title="一、make 和 makefile"></a><div align=center>一、make 和 makefile</h1><h2 id="1-make是一个应用程序"><a href="#1-make是一个应用程序" class="headerlink" title="1. make是一个应用程序"></a>1. make是一个应用程序</h2><ul>
<li><strong>解析源程序之间的依赖关系</strong></li>
<li><strong>根据依赖关系自动维护编译工作</strong></li>
<li><strong>执行宿主操作系统中的各种命令</strong><h2 id="2-makefile的本质"><a href="#2-makefile的本质" class="headerlink" title="2. makefile的本质"></a>2. makefile的本质</h2></li>
<li><strong>makefile是一个描述文件</strong></li>
<li><strong>makefile可以定义一系列的规则来指定源文件编译的先后顺序</strong></li>
<li><strong>makefile拥有特定的语法规则，支持函数定义和函数调用</strong></li>
<li><strong>makefile能够直接集成操作系统中的各种命令</strong><h2 id="3-make和makefile之间的关系"><a href="#3-make和makefile之间的关系" class="headerlink" title="3. make和makefile之间的关系"></a>3. make和makefile之间的关系</h2></li>
<li><strong>makefile中的描述用于指导make如何完成工作</strong></li>
<li><strong>make根据makefile中的规则执行命令，最后完成编译输出</strong><h2 id="4-最简单的makefle"><a href="#4-最简单的makefle" class="headerlink" title="4. 最简单的makefle"></a>4. 最简单的makefle</h2><h3 id="1）最简单的makefile程序"><a href="#1）最简单的makefile程序" class="headerlink" title="1）最简单的makefile程序"></a>1）最简单的makefile程序</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hello </span>: </span><br><span class="line">	<span class="variable">@echo</span> “hello makefile”</span><br></pre></td></tr></table></figure>
程序说明：<br>&nbsp; &nbsp;&nbsp;hello –&gt; 目标<br>&nbsp; &nbsp;&nbsp;@echo “hello makefile” -&gt; 实现目标所需要执行的命令<blockquote>
<p>注意：目标后的命令需要用tab键（’\t’）隔开！</p>
</blockquote>
<h3 id="2）运行makefile"><a href="#2）运行makefile" class="headerlink" title="2）运行makefile"></a>2）运行makefile</h3>要运行makefile在linux下执行以下命令： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">make</span> –<span class="selector-tag">f</span> <span class="selector-tag">mf</span><span class="selector-class">.txt</span> <span class="selector-tag">hello</span></span><br></pre></td></tr></table></figure>
命令功能说明：以hello关键字作为目标查找mf.txt文件，并执行hello处的命令<h1 id="二、初识makefile的结构"><a href="#二、初识makefile的结构" class="headerlink" title="二、初识makefile的结构"></a><div align=center>二、初识makefile的结构</h1><h2 id="1-makefile的意义"><a href="#1-makefile的意义" class="headerlink" title="1. makefile的意义"></a>1. makefile的意义</h2>makefile用于定义源文件之间的依赖关系<br>makefile说明如何编译各个源文件并生成可执行文件<h2 id="2-依赖的定义"><a href="#2-依赖的定义" class="headerlink" title="2. 依赖的定义"></a>2. 依赖的定义</h2><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">targets : prerequisite ; comma<span class="symbol">nd1</span></span><br><span class="line">	‘\t’ comma<span class="symbol">nd2</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Makefile中的元素含义"><a href="#3-Makefile中的元素含义" class="headerlink" title="3. Makefile中的元素含义"></a>3. Makefile中的元素含义</h2><h3 id="1）targets"><a href="#1）targets" class="headerlink" title="1）targets"></a>1）targets</h3>通常是需要生成的目标文件名<br>make所需执行的命令名称<br>可以包含多个目标，使用空格对将多个目标隔开<h3 id="2）prerequisite"><a href="#2）prerequisite" class="headerlink" title="2）prerequisite"></a>2）prerequisite</h3>当前目标所依赖的其他目标或文件<br>可以包含多个依赖，使用空格对将多个依赖隔开<h3 id="3）command"><a href="#3）command" class="headerlink" title="3）command"></a>3）command</h3>完成目标所需要执行的命令<h3 id="4）规则中的注意事项"><a href="#4）规则中的注意事项" class="headerlink" title="4）规则中的注意事项"></a>4）规则中的注意事项</h3></li>
<li>*[tab]键：’\t’**<br>&nbsp;&nbsp;&nbsp;&nbsp;每一个命令必须以[tab]字符开始<br>&nbsp;&nbsp;&nbsp;&nbsp;[tab]字符告诉make此行是一个命令行</li>
<li><em>续行符：*</em><br>&nbsp;&nbsp;&nbsp;&nbsp;可以将内容分开写到下一行，提高可读性<h2 id="3-makefile依赖示例"><a href="#3-makefile依赖示例" class="headerlink" title="3. makefile依赖示例"></a>3. makefile依赖示例</h2><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">all : test</span><br><span class="line">	echo “make all”</span><br><span class="line"><span class="keyword">test </span>: </span><br><span class="line">	echo “make test”</span><br></pre></td></tr></table></figure>
说明：上述makefile定义了两条依赖规则，all这个目标依赖于test，如果test这个目标成立，就执行 echo “make all” 这个命令，如果test不成立，就会去寻找test这个子目标，test没有子目标因此只需执行 echo “make test”  test这个子目标就完成了。<h2 id="4-依赖规则"><a href="#4-依赖规则" class="headerlink" title="4. 依赖规则"></a>4. 依赖规则</h2>当目标对应的文件不存在，执行对应命令<br>当依赖在时间上比目标更新，执行对应命令<br>当依赖关系连续发生时，对比依赖链上每一个目标<blockquote>
<p>小技巧：makfile中可以在命令的前面加上@符，作用为命令无回显。</p>
</blockquote>
<h2 id="5-第一个make的编译案例"><a href="#5-第一个make的编译案例" class="headerlink" title="5. 第一个make的编译案例"></a>5. 第一个make的编译案例</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">hello</span><span class="selector-class">.out</span> : <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span></span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.out</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span> : </span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">-c</span> <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">func</span><span class="selector-class">.o</span> : </span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span> <span class="selector-tag">-c</span> <span class="selector-tag">func</span><span class="selector-class">.c</span></span><br></pre></td></tr></table></figure>
小技巧：工程开发中可以将最终可执行文件名和all同时作为makefile中第一条规则<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">hello</span><span class="selector-class">.out</span> <span class="selector-tag">all</span> : <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span> </span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.out</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">fun</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure>
当我们想手动编译时执行make all 就会编译，直接make则会检测hello.out。<h1 id="三、伪目标的引入"><a href="#三、伪目标的引入" class="headerlink" title="三、伪目标的引入"></a><div align=center>三、伪目标的引入</h1><h2 id="1-makefile中目标的含义"><a href="#1-makefile中目标的含义" class="headerlink" title="1. makefile中目标的含义"></a>1. makefile中目标的含义</h2><h3 id="1）默认情况下"><a href="#1）默认情况下" class="headerlink" title="1）默认情况下"></a>1）默认情况下</h3>make 认为目标对应着一个文件<br>make 比较目标文件和依赖文件的新旧关系，决定是否执行命令<br>make 以文件处理作为第一优先级<h3 id="2）makefile中的伪目标"><a href="#2）makefile中的伪目标" class="headerlink" title="2）makefile中的伪目标"></a>2）makefile中的伪目标</h3>通过.PHONY关键字声明一个伪目标<br>伪目标不对应任何实际的文件<br>不管目标的依赖是否更新，命令总是执行<h3 id="3）伪目标的语法"><a href="#3）伪目标的语法" class="headerlink" title="3）伪目标的语法"></a>3）伪目标的语法</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">.PHONY : <span class="type">Target</span> </span><br></pre></td></tr></table></figure>
<h3 id="4-伪目标的本质"><a href="#4-伪目标的本质" class="headerlink" title="4) 伪目标的本质"></a>4) 伪目标的本质</h3>伪目标是make中特殊目标.PHONY的依赖，先声明、后使用。<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">.PHONY : <span class="type">clean</span> rebuild <span class="keyword">all</span> </span><br><span class="line"></span><br><span class="line">## other rules ## </span><br><span class="line"></span><br><span class="line">rebuile : <span class="type">clean</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">clean : </span><br><span class="line">	rm *o hello.<span class="keyword">out</span></span><br></pre></td></tr></table></figure>
原理：当一个目标的依赖包含伪目标时，伪目标所定义的命令总是会被执行<h2 id="2-绕开-PHONY关键字定义伪目标"><a href="#2-绕开-PHONY关键字定义伪目标" class="headerlink" title="2. 绕开.PHONY关键字定义伪目标"></a>2. 绕开.PHONY关键字定义伪目标</h2>如果一个规则没有命令或者依赖，并且它的目标不是一个存在的文件名；在执行此规则时，目标总是被认为是最新的。<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">clean : <span class="keyword">FORCE</span></span><br><span class="line">	rm *.o hello.<span class="keyword">out</span></span><br><span class="line"><span class="keyword">FORCE</span> :</span><br></pre></td></tr></table></figure>
<h1 id="四、变量和不同的赋值方式"><a href="#四、变量和不同的赋值方式" class="headerlink" title="四、变量和不同的赋值方式"></a><div align=center>四、变量和不同的赋值方式</h1><h2 id="1-makefile中的变量"><a href="#1-makefile中的变量" class="headerlink" title="1. makefile中的变量"></a>1. makefile中的变量</h2>makefile中支持程序设计语言中变量的概念<br>makefile中变量只代表文本数据<h2 id="2-makefile中变量命名规则"><a href="#2-makefile中变量命名规则" class="headerlink" title="2. makefile中变量命名规则"></a>2. makefile中变量命名规则</h2>变量名大小写敏感<br>变量名可以包含字符，数字，下划线<br>不能包含 ”:” , “#” , “=” , 或 ” ”<br>makefile未定义的变量的值为空值<h2 id="3-makefile中变量的赋值方式"><a href="#3-makefile中变量的赋值方式" class="headerlink" title="3. makefile中变量的赋值方式"></a>3. makefile中变量的赋值方式</h2><h3 id="1-简单赋值"><a href="#1-简单赋值" class="headerlink" title="1)    简单赋值 :="></a>1)    简单赋值 :=</h3>程序设计语言中的通用赋值方式<br>只针对当前语句变量有效<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := foo</span><br><span class="line"><span class="symbol">y</span> := $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> := new</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = new</span><br><span class="line">	<span class="symbol">y</span> = foob</span><br></pre></td></tr></table></figure>
<h3 id="2-递归赋值"><a href="#2-递归赋值" class="headerlink" title="2)    递归赋值 ="></a>2)    递归赋值 =</h3>赋值操作可能影响多个其他变量<br>所有与目标变量相关的其他变量将受到影响<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> = foo</span><br><span class="line"><span class="symbol">y</span> = $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> = new</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = new</span><br><span class="line">	<span class="symbol">y</span> = newb</span><br></pre></td></tr></table></figure>
<h3 id="3-条件赋值"><a href="#3-条件赋值" class="headerlink" title="3) 条件赋值 ?="></a>3) 条件赋值 ?=</h3>如果变量未定义，使用赋值符号中的值定义变量<br>如果变量已经定义，赋值无效<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := foo</span><br><span class="line"><span class="symbol">y</span> := $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> ?= new</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = foo</span><br><span class="line">	<span class="symbol">y</span> = foob</span><br></pre></td></tr></table></figure>
<h3 id="4-追加赋值"><a href="#4-追加赋值" class="headerlink" title="4) 追加赋值 +="></a>4) 追加赋值 +=</h3>原变量值之后加上一个新值<br>原变量值与新值之间由空格隔开<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := foo</span><br><span class="line"><span class="symbol">y</span> := $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> += $(<span class="symbol">y</span>)</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = foo foob</span><br><span class="line">	<span class="symbol">y</span> = foob</span><br></pre></td></tr></table></figure>
<h1 id="五、预定义变量的使用"><a href="#五、预定义变量的使用" class="headerlink" title="五、预定义变量的使用"></a><div align=center>五、预定义变量的使用</h1><h2 id="1-自动变量"><a href="#1-自动变量" class="headerlink" title="1. 自动变量"></a>1. 自动变量</h2>$@  当前规则中触发命令被执行的目标<br>$^  当前规则中的所有依赖<br>$&lt;  当前规则中的第一个依赖<h2 id="2-自动变量的使用"><a href="#2-自动变量的使用" class="headerlink" title="2. 自动变量的使用"></a>2. 自动变量的使用</h2><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">PHONY : <span class="keyword">all</span> first second third</span><br><span class="line"></span><br><span class="line"><span class="keyword">all</span> : first second third</span><br><span class="line">	@echo “\<span class="symbol">$</span><span class="symbol">$</span>@ =&gt; <span class="symbol">$</span>@”</span><br><span class="line">	@echo “<span class="symbol">$</span><span class="symbol">$</span>^ =&gt; <span class="symbol">$</span><span class="symbol">$</span>^”</span><br><span class="line">	@echo “<span class="symbol">$</span><span class="symbol">$</span>&lt; =&gt; <span class="symbol">$</span>&lt;”</span><br><span class="line"></span><br><span class="line">first :</span><br><span class="line">second : </span><br><span class="line">third : </span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">$</span>@ =&gt; <span class="keyword">all</span></span><br><span class="line">	<span class="symbol">$</span>^ =&gt; first second third</span><br><span class="line">	<span class="symbol">$</span>&lt; =&gt; first</span><br></pre></td></tr></table></figure>
小贴士：<br>&nbsp;&nbsp;&nbsp;&nbsp;“$”对于makefile有特殊含义，输出时加上一个$进行转义<br>&nbsp;&nbsp;&nbsp;&nbsp;“$@”对于Bash Shell 有特殊含义，输出时加上”\”进行转义<h2 id="2-特殊变量"><a href="#2-特殊变量" class="headerlink" title="2. 特殊变量"></a>2. 特殊变量</h2></li>
<li><strong>$(MAKE)</strong><br>当前make解释器的文件名</li>
<li><strong>$(MAKECMDGOALS)</strong><br>命令中指定的目标名（make的命令行参数）</li>
<li><strong>$(MAKEFILE_LIST)</strong><br>make所需要处理的makefile文件列表<br>当前makefile的文件名总是位于列表的最后<br>文件名之间以空格进行划分</li>
<li><strong>$(MAKE_VERSION)</strong><br>当前make解释器的版本</li>
<li>**$(CURDIR) **<br>当前make解释器的工作目录</li>
<li><strong>$(.VARIABLES)</strong><br>所有已经定义的变量名列表，其中包括预定义变量和自定义变量<h1 id="六、变量的高级主题"><a href="#六、变量的高级主题" class="headerlink" title="六、变量的高级主题"></a><div align=center>六、变量的高级主题</h1><h2 id="1-常用语法"><a href="#1-常用语法" class="headerlink" title="1. 常用语法"></a>1. 常用语法</h2><h3 id="1）-变量值的替换"><a href="#1）-变量值的替换" class="headerlink" title="1） 变量值的替换"></a>1） 变量值的替换</h3>使用指定字符（串）替换变量中的后缀字符（串）<br>语法格式<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$(var:<span class="attribute">a</span>=b)或$&#123;var:<span class="attribute">a</span>=b&#125;</span><br></pre></td></tr></table></figure>
替换表达式中不能有任何的空格<br>make中支持使用${}对变量进行取值<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">src := a.cc b.cc c.cc</span><br><span class="line">obj := $(src:cc=o)</span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo ”obj =&gt; $(obj)”</span><br><span class="line"></span><br><span class="line">输出结果：obj = &gt; a.o b.o c.o</span><br></pre></td></tr></table></figure>
<h3 id="2）变量的模式替换"><a href="#2）变量的模式替换" class="headerlink" title="2）变量的模式替换"></a>2）变量的模式替换</h3>使用%保留变量值中的指定字符，替换其他字符<br>语法格式<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">var</span>:a%b=<span class="symbol">x</span>%<span class="symbol">y</span>)或$&#123;<span class="keyword">var</span>:a%b=<span class="symbol">x</span>%<span class="symbol">y</span>&#125;</span><br></pre></td></tr></table></figure>
替换表达式中不能有任何的空格<br>make中支持使用${}对变量进行取值<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">src :<span class="operator">=</span> a<span class="number">1</span>b.<span class="keyword">c</span> a<span class="number">2</span>b.<span class="keyword">c</span> a<span class="number">3</span>b.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">obj :<span class="operator">=</span> $(src:a<span class="variable">%b.c</span><span class="operator">=</span><span class="keyword">x</span><span class="variable">%y</span>)</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	<span class="title">@echo</span> <span class="string">&quot;obj =&gt; $(obj)&quot;</span></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	obj <span class="operator">=</span>&gt; <span class="keyword">x</span><span class="number">1</span>y <span class="keyword">x</span><span class="number">2</span>y <span class="keyword">x</span><span class="number">3</span>y</span><br></pre></td></tr></table></figure>
<h3 id="3）规则中的模式替换"><a href="#3）规则中的模式替换" class="headerlink" title="3）规则中的模式替换"></a>3）规则中的模式替换</h3><h4 id="a）直接模式替换（自己起的名字）"><a href="#a）直接模式替换（自己起的名字）" class="headerlink" title="a）直接模式替换（自己起的名字）"></a>a）直接模式替换（自己起的名字）</h4><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">targets-<span class="built_in">pattern</span> : prereq-<span class="built_in">pattern</span></span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	…</span><br></pre></td></tr></table></figure>
在当前路径查找满足条件的依赖并与目标构成完整的规则<br>实例说明<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line"><span class="keyword">test </span>: a.o b.o</span><br><span class="line"></span><br><span class="line">a.o :</span><br><span class="line">	@echo &quot;I&#x27;m rule of a.o&quot;</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">	gcc -o $@ -c $^</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	I&#x27;m rule of a.o</span><br><span class="line">	gcc -o b.o -c b.c</span><br></pre></td></tr></table></figure>
如果未对a.o、b.O进行规则声明，则默认生成以下规则<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.o</span> : <span class="selector-tag">a</span>.c</span><br><span class="line">	gcc -o <span class="selector-tag">a</span><span class="selector-class">.o</span> -c <span class="selector-tag">a</span>.c</span><br><span class="line"><span class="selector-tag">b</span><span class="selector-class">.o</span> : <span class="selector-tag">b</span>.c</span><br><span class="line">	gcc -o <span class="selector-tag">b</span><span class="selector-class">.o</span> -c <span class="selector-tag">b</span>.o</span><br></pre></td></tr></table></figure>
但此处对a.o已经有了自己的模式规则因此，上述代码等价于<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.PHONY</span> : test</span><br><span class="line"></span><br><span class="line">test : <span class="selector-tag">a</span><span class="selector-class">.o</span> <span class="selector-tag">b</span>.o</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.o</span> :</span><br><span class="line">	@echo <span class="string">&quot;I&#x27;m rule of a.o&quot;</span></span><br><span class="line"><span class="selector-tag">b</span><span class="selector-class">.o</span> : <span class="selector-tag">b</span>.c</span><br><span class="line">	gcc -o <span class="selector-tag">b</span><span class="selector-class">.o</span> -c <span class="selector-tag">b</span>.o</span><br></pre></td></tr></table></figure>
<h4 id="b）间接模式替换（自己起的名字）"><a href="#b）间接模式替换（自己起的名字）" class="headerlink" title="b）间接模式替换（自己起的名字）"></a>b）间接模式替换（自己起的名字）</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">targets : <span class="type">targets</span>-pattern : <span class="type">prereq</span>-pattern</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	…</span><br></pre></td></tr></table></figure>
通过targets-pattern从targets中匹配子目标<br>再通过prereq-pattern从子目标生成依赖,进而构成完整的规则<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">OBJS : func.o main.o</span><br><span class="line"></span><br><span class="line">$(OBJS) : %.o : %.c</span><br><span class="line">	gcc -o $@ -c $^</span><br></pre></td></tr></table></figure>
等价于<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">OBJS : func<span class="selector-class">.o</span> main.o</span><br><span class="line"></span><br><span class="line">func<span class="selector-class">.o</span> : func.c</span><br><span class="line">	gcc -o $@ -c $^</span><br><span class="line">main<span class="selector-class">.o</span> : main.c</span><br><span class="line">	gcc -o $@ -c $^</span><br></pre></td></tr></table></figure>
<h3 id="4）变量值的嵌套引用"><a href="#4）变量值的嵌套引用" class="headerlink" title="4）变量值的嵌套引用"></a>4）变量值的嵌套引用</h3>一个变量名之中可以包含对其他变量的引用<br>嵌套引用的本质是使用一个变量表示另一个变量<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">x := y</span><br><span class="line">y := z</span><br><span class="line">a := $($(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo &quot;a ==&gt; $(a)&quot;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	a ==&gt; z</span><br></pre></td></tr></table></figure>
<h3 id="5）命令行变量"><a href="#5）命令行变量" class="headerlink" title="5）命令行变量"></a>5）命令行变量</h3>运行make时，在命令行定义变量<br>命令行变量默认覆盖makefile中定义的变量<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">hm := hello makefile</span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo “hm =&gt; $(hm)”</span><br><span class="line"></span><br><span class="line">执行：make hm := cmd</span><br><span class="line"></span><br><span class="line">运行结果：hm =&gt; cmd</span><br></pre></td></tr></table></figure>
<h3 id="6）override关键字"><a href="#6）override关键字" class="headerlink" title="6）override关键字"></a>6）override关键字</h3>用于指示makefile中定义的变量不能被覆盖<br>变量的定义和赋值都要用到override关键字<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">override var := test</span><br><span class="line"><span class="keyword">test </span>: </span><br><span class="line">	@echo “var =&gt; $(var)”</span><br><span class="line"></span><br><span class="line">执行：make var:=cmd</span><br><span class="line"></span><br><span class="line">执行结果：hm =&gt; test</span><br></pre></td></tr></table></figure>
<h3 id="7）define关键字"><a href="#7）define关键字" class="headerlink" title="7）define关键字"></a>7）define关键字</h3>用于在makefile中定义多行变量<br>多行变量的定义从变量名开始到endef结束<br>可以使用override关键字防止变量被覆盖<br>define定义的变量等价于使用=定义的变量<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">define foo</span><br><span class="line">I’m fool:</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">override define <span class="keyword">cmd</span></span><br><span class="line"><span class="bash">@<span class="built_in">echo</span> <span class="string">&quot;run cmd begin ...&quot;</span></span></span><br><span class="line">@echo <span class="string">&quot;run cmd end ...&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	@echo <span class="string">&quot;$(foo)&quot;</span></span><br><span class="line">	$(<span class="keyword">cmd</span><span class="bash">)</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	I’m fool:</span><br><span class="line">	<span class="keyword">run</span><span class="bash"> cmd begin ...</span></span><br><span class="line">	<span class="keyword">run</span><span class="bash"> cmd end ...</span></span><br></pre></td></tr></table></figure>
<h2 id="2-环境变量（全局变量）"><a href="#2-环境变量（全局变量）" class="headerlink" title="2. 环境变量（全局变量）"></a>2. 环境变量（全局变量）</h2>makefile中能够直接使用环境变量的值<br>定义了同名变量，默认环境变量将被覆盖<br>运行make时指定”-e”选项使用系统默认环境变量<br>环境变量可以在所有的makefile中使用<br>过多的依赖环境变量会使系统的移植性降低<h2 id="3-目标变量（局部变量）"><a href="#3-目标变量（局部变量）" class="headerlink" title="3. 目标变量（局部变量）"></a>3. 目标变量（局部变量）</h2>作用域只在指定目标及连带规则中</li>
<li>*语法格式**<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">target : <span class="keyword">variable</span><span class="number">_n</span>ame := <span class="keyword">variable</span>-<span class="keyword">value</span></span><br></pre></td></tr></table></figure></li>
<li>*举例说明**<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">var : D.T.Software</span><br><span class="line"><span class="keyword">test </span>: var := test-var</span><br><span class="line"><span class="keyword">test </span>: </span><br><span class="line">	@echo “test:”</span><br><span class="line">	@echo “var =&gt; $(var)”</span><br></pre></td></tr></table></figure>
<h2 id="4-模式变量（局部变量）"><a href="#4-模式变量（局部变量）" class="headerlink" title="4. 模式变量（局部变量）"></a>4. 模式变量（局部变量）</h2>模式变量是目标变量的扩展<br>作用域只在符合模式的目标及连带规则中</li>
<li>*语法格式**<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">%target : <span class="keyword">variable</span><span class="number">_n</span>ame := <span class="keyword">variable</span>-<span class="keyword">value</span></span><br></pre></td></tr></table></figure></li>
<li>*举例说明**<br>当前要定义一个名为new的局部变量，new的作用域是所有已e结尾的目标及连带规则。<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> := TDelphi</span><br><span class="line">%e : <span class="keyword">override</span> <span class="keyword">new</span> := test-<span class="keyword">new</span></span><br><span class="line">rule : </span><br><span class="line"><span class="keyword">@echo</span> “rule:”</span><br><span class="line">	<span class="keyword">@echo</span> ”<span class="keyword">new</span> =&gt; $(<span class="keyword">new</span>)”</span><br></pre></td></tr></table></figure>
<h2 id="3-变量在不同的makefile中的传递方式"><a href="#3-变量在不同的makefile中的传递方式" class="headerlink" title="3. 变量在不同的makefile中的传递方式"></a>3. 变量在不同的makefile中的传递方式</h2>直接在外部定义环境变量进行传递<br>使用explort定义变量进行传递（定义零时环境变量）<br>定义make命令行进行环境变量传递（推荐）<h1 id="七、条件判断语句"><a href="#七、条件判断语句" class="headerlink" title="七、条件判断语句"></a><div align=center>七、条件判断语句</h1><h2 id="1-makefile中的条件判断语句"><a href="#1-makefile中的条件判断语句" class="headerlink" title="1. makefile中的条件判断语句"></a>1. makefile中的条件判断语句</h2>可以根据条件值来决定make的执行<br>可以比较两个不同变量或变量和常量值<h2 id="2-表现形式"><a href="#2-表现形式" class="headerlink" title="2. 表现形式"></a>2. 表现形式</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifxxx</span> (arg<span class="number">1</span>,arg<span class="number">2</span>)</span><br><span class="line"> <span class="comment"># for true</span></span><br><span class="line"><span class="attribute">else</span></span><br><span class="line"> <span class="comment"># for false</span></span><br><span class="line"><span class="attribute">endif</span></span><br></pre></td></tr></table></figure>
其他合法形式<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifxxx</span> “arg<span class="number">1</span>” “arg<span class="number">2</span>”</span><br><span class="line"><span class="attribute">ifxxx</span> “arg<span class="number">1</span>” ‘arg<span class="number">2</span>’</span><br><span class="line"><span class="attribute">ifxxx</span> ‘arg<span class="number">1</span>’ “arg<span class="number">2</span>”</span><br><span class="line"><span class="attribute">ifxxx</span> ‘arg<span class="number">1</span>’ “arg<span class="number">2</span>’</span><br></pre></td></tr></table></figure>
<h2 id="3-条件判断关键字"><a href="#3-条件判断关键字" class="headerlink" title="3. 条件判断关键字"></a>3. 条件判断关键字</h2></li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq  ($(x),$(y))</td>
<td>判断参数是否相等，相等为true，否则为false</td>
</tr>
<tr>
<td>ifneq ($(x),$(y))</td>
<td>判断参数是否不相等，不相等则为true，否则为false</td>
</tr>
<tr>
<td>ifdef  x</td>
<td>判断变量是否有值，有值为true，否则为false</td>
</tr>
<tr>
<td>ifndef x</td>
<td>判断变量是否没有值，没有为true，否则为false</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：条件判断语句只能用与控制make中实际执行的语句；但是，不能控制规则中命令的执行过程。</p>
</blockquote>
<h2 id="4-工程使用小结"><a href="#4-工程使用小结" class="headerlink" title="4. 工程使用小结"></a>4. 工程使用小结</h2><p>条件判断语句之前可以有空格，但不能有tab字符（’t\’）<br>在条件判断语句中不要用自动变量（$@,$^,$&lt;）<br>一条完整的条件语句必须位于同一个makefile中<br>条件判断类似于c语言中的宏，预处理阶段有效，执行阶段无效<br>make在加载makefile时首先计算表达式的值（赋值方式不同计算方式不同）<br>根据判断语句的表达式决定执行的内容</p>
<h2 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5.举例说明"></a>5.举例说明</h2><h3 id="1）条件判断关键字程序实例"><a href="#1）条件判断关键字程序实例" class="headerlink" title="1）条件判断关键字程序实例"></a>1）条件判断关键字程序实例</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">.PHONY : test  </span><br><span class="line">	  </span><br><span class="line">var1 := cmd</span><br><span class="line">var2 := $(var1)</span><br><span class="line"></span><br><span class="line">test:  </span><br><span class="line">    ife<span class="string">q ($(var1)</span>,$(var2))</span><br><span class="line">	@echo <span class="string">&quot;var1 == var2&quot;</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">	@echo <span class="string">&quot;var1 != var2&quot;</span></span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">    ifne<span class="string">q ($(var1)</span>,$(var2))</span><br><span class="line">	@echo <span class="string">&quot;var1 != var2&quot;</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">	@echo <span class="string">&quot;var1 == var2&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    ifdef var1</span><br><span class="line">	@echo <span class="string">&quot;var1 is NOT empty&quot;</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	@echo <span class="string">&quot;var1 is empty&quot;</span></span><br><span class="line">    endif</span><br><span class="line">	</span><br><span class="line">    ifndef var1</span><br><span class="line">	@echo <span class="string">&quot;var1 is empty&quot;</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	@echo <span class="string">&quot;var1 is NOT empty&quot;</span></span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var1 == var2</span><br><span class="line">	var1 == var2</span><br><span class="line">	var1 is NOT empty</span><br><span class="line">	var1 is NOT empty</span><br></pre></td></tr></table></figure>
<h3 id="2）条件判断关键字异常分析"><a href="#2）条件判断关键字异常分析" class="headerlink" title="2）条件判断关键字异常分析"></a>2）条件判断关键字异常分析</h3><h4 id="a）异常情况1"><a href="#a）异常情况1" class="headerlink" title="a）异常情况1"></a>a）异常情况1</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(</span>var3)</span><br><span class="line"></span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var3</span> </span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var4</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is defined&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is NOT defined&quot;</span>    </span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var3 is NOT <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br><span class="line">	var4 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br></pre></td></tr></table></figure>
<p><strong>运行结果分析</strong><br>我们所期望的运行结果是var3与var4都是未定义，但这里运行结果表示var4的值为定义。<br><strong>原因分析</strong><br>产生这个结果的原因就是，make在加载makefile时首先计算表达式的值，由于我们使用的赋值表达式为 = 因此，makfile在预处理 ifdef var4 时无法确定var4的值是否定义，因此make解释器在这里默认为var4的值为已定义的值。</p>
<h4 id="b）异常情况2"><a href="#b）异常情况2" class="headerlink" title="b）异常情况2"></a>b）异常情况2</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(</span>var3)</span><br><span class="line"></span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var3</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var4</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">var3 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var3 is NOT <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br><span class="line">	var4 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br></pre></td></tr></table></figure>
<h4 id="c）异常情况3"><a href="#c）异常情况3" class="headerlink" title="c）异常情况3"></a>c）异常情况3</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(</span>var3)</span><br><span class="line">var3 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var3</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var4</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var3 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br><span class="line">	var4 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：<br>a为不对var3赋值<br>b、c为var赋值的位置不同产生的结果不同</p>
</blockquote>
<h1 id="八、函数的定义以及调用"><a href="#八、函数的定义以及调用" class="headerlink" title="八、函数的定义以及调用"></a><div align=center>八、函数的定义以及调用</h1><h2 id="1-makefile支持函数的概念"><a href="#1-makefile支持函数的概念" class="headerlink" title="1. makefile支持函数的概念"></a>1. makefile支持函数的概念</h2><p>make解释器提供了一系列的函数供makefile调用<br>在makefile中支持自定义函数实现，并调用执行<br>通过define关键字实现自定义函数</p>
<h2 id="2-自定义函数语法"><a href="#2-自定义函数语法" class="headerlink" title="2. 自定义函数语法"></a>2. 自定义函数语法</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">define func1</span><br><span class="line">	<span class="meta">@echo</span> “My name <span class="keyword">is</span> $(<span class="number">0</span>)”</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define func2</span><br><span class="line">	<span class="meta">@echo</span> “My name <span class="keyword">is</span> $(<span class="number">0</span>)”</span><br><span class="line">	<span class="meta">@echo</span> “Param =&gt; $(<span class="number">1</span>)”</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>函数调用：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test </span>: </span><br><span class="line">	$(call func1)</span><br><span class="line">	$(call func2,D.T.Software)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数通过call关键字调用，$(0)、$(1)、$(3)、…代表依次传入的参数</p>
</blockquote>
<h2 id="3-深入理解自定义函数"><a href="#3-深入理解自定义函数" class="headerlink" title="3. 深入理解自定义函数"></a>3. 深入理解自定义函数</h2><p>自定义函数是一个多行变量，无法直接调用<br>自定义函数是一个过程调用，没有任何返回值<br>自定义函数用于定义命令集合，并应用于规则中</p>
<h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4. 实例分析"></a>4. 实例分析</h2><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">define func1</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define func2</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; $(1)&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	$(func1)</span><br><span class="line">	$(func2)</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	$(<span class="built_in">call</span> func1)</span><br><span class="line">	$(<span class="built_in">call</span> func2, Delphi)</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	My <span class="built_in">name</span> is </span><br><span class="line">	My <span class="built_in">name</span> is </span><br><span class="line">	<span class="built_in">Param</span> =&gt; </span><br><span class="line">	</span><br><span class="line">	My <span class="built_in">name</span> is func1</span><br><span class="line">	My <span class="built_in">name</span> is func2</span><br><span class="line">	<span class="built_in">Param</span> =&gt;  Delphi</span><br></pre></td></tr></table></figure>
<p>函数调用的本质就是宏替换的过程，通过call可以将相应的”形参”替换成”实参” $(0)、$(1)、$(3)、…，因此上述代码在运行的时候等价于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">define func1</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is <span class="subst">$(0)</span>&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define func2</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is <span class="subst">$(0)</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; <span class="subst">$(1)</span>&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">.PHONY : <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> :</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is func1&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is func2&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; Delphi&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="九、变量与函数的综合示例"><a href="#九、变量与函数的综合示例" class="headerlink" title="九、变量与函数的综合示例"></a><div align=center>九、变量与函数的综合示例</h1><h2 id="1-实战需求"><a href="#1-实战需求" class="headerlink" title="1. 实战需求"></a>1. 实战需求</h2><p>自动生成target文件夹存放可执行文件<br>自动生成bojs文件夹存放编译生成的目标文件（*.o）<br>支持调试版本的编译选项<br>考虑代码的扩展性</p>
<h2 id="2-工具原料"><a href="#2-工具原料" class="headerlink" title="2. 工具原料"></a>2. 工具原料</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">wildcard</span> <span class="params">_pattern</span>)</span></span><br></pre></td></tr></table></figure>
<p>获取当前工作目录中满足_pattern的文件或目录列表</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">addprefix</span> <span class="params">_prefix</span>, <span class="params">_names</span>)</span></span><br></pre></td></tr></table></figure>
<p>给名字列表_name中的每一个名字增加前缀_prefix</p>
<h2 id="3-关键技巧"><a href="#3-关键技巧" class="headerlink" title="3. 关键技巧"></a>3. 关键技巧</h2><ul>
<li><strong>1) 自动获取当前目录小的文件列表（函数调用）</strong><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure></li>
<li><strong>2) 根据源文件列表生成目标文件列表（变量的值替换）</strong><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">OBJS :</span>= $(<span class="attr">SRCS:</span>.c=.o)</span><br></pre></td></tr></table></figure></li>
<li><strong>3) 对每个目标文件加上前缀路径（函数调用）</strong><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> apth/,<span class="variable">$(OBJS)</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="4-编译规则的依赖"><a href="#4-编译规则的依赖" class="headerlink" title="4. 编译规则的依赖"></a>4. 编译规则的依赖</h2></li>
</ul>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/1.png" >

<h2 id="5-编程实现"><a href="#5-编程实现" class="headerlink" title="5. 编程实现"></a>5. 编程实现</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DIR_OBJS := objs</span><br><span class="line">DIR_TARGET := target</span><br><span class="line">DIRS := <span class="variable">$(DIR_OBJS)</span> <span class="variable">$(DIR_TARGET)</span></span><br><span class="line"></span><br><span class="line">APP := <span class="variable">$(DIR_TARGET)</span>/app.out</span><br><span class="line"></span><br><span class="line">RM := rm -rf</span><br><span class="line">CC := gcc</span><br><span class="line">MKDIR := mkdir</span><br><span class="line"></span><br><span class="line">SRCE := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS := $(SRCE:.c=.o)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_OBJS)</span>/,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line">DEBUG :=</span><br><span class="line"></span><br><span class="line">CFLAGS := </span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">.PHONY : all clean rebuild</span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(DIRS)</span> <span class="variable">$(APP)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;target ==&gt; <span class="variable">$@</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;&quot;</span></span><br><span class="line">	@./<span class="variable">$(APP)</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIRS)</span> :</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OBJS)</span>/%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIRS)</span></span><br><span class="line">	</span><br><span class="line">rebuild : clean all</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>在当前目录下创建objs target文件，编译链接当前目录下.C文件，将生成的.o文件存放到objs文件夹，生成的可执行文件app.out存放在target文件夹，最后运行可执行程序app.out。其中当DEBUG=true时添加编译选项 -g 实现调试功能</p>
<h1 id="十、sed流编辑器"><a href="#十、sed流编辑器" class="headerlink" title="十、sed流编辑器"></a><div align=center>十、sed流编辑器</h1><h2 id="1-Linux中的sed命令"><a href="#1-Linux中的sed命令" class="headerlink" title="1. Linux中的sed命令"></a>1. Linux中的sed命令</h2><p>sed是一个流编辑器，用于流文本的修改（增/删/查/改）<br>sed可以用于流文本中的字符串替换<br>sed字符串替换方式为：sed ‘s:src:des:g’</p>
<h2 id="2-sed字符串替换实例"><a href="#2-sed字符串替换实例" class="headerlink" title="2. sed字符串替换实例"></a>2. sed字符串替换实例</h2><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo &quot;test = &gt; abc+abc=abc&quot; | sed &#x27;s:abc:xyz:g&#x27;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	test =&gt; xyz+xyz=xyz</span><br></pre></td></tr></table></figure>
<h2 id="3-sed支持正则表达式"><a href="#3-sed支持正则表达式" class="headerlink" title="3. sed支持正则表达式"></a>3. sed支持正则表达式</h2><p>在sed中可以用正则表达式匹配替换目标<br>并且可以使用匹配的目标生成替换结果</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">sed &#x27;s,<span class="symbol">\(</span>.*<span class="symbol">\)</span><span class="symbol">\.</span>o[ :]*,objs/<span class="symbol">\1</span>.o : ,g&#x27;</span><br></pre></td></tr></table></figure>
<p>该表达式的结果为将流文本中的.o文件加上路径前缀 objs/</p>
<h1 id="十一、makefile小知识"><a href="#十一、makefile小知识" class="headerlink" title="十一、makefile小知识"></a><div align=center>十一、makefile小知识</h1><h2 id="1-生成依赖关系"><a href="#1-生成依赖关系" class="headerlink" title="1. 生成依赖关系"></a>1. 生成依赖关系</h2><p>获取目标的完整依赖关系</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -M <span class="keyword">test</span>.c</span><br></pre></td></tr></table></figure>
<p>获取目标的部分依赖关系</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -MM <span class="keyword">test</span>.c</span><br></pre></td></tr></table></figure>
<h2 id="2-拆分目标的依赖"><a href="#2-拆分目标的依赖" class="headerlink" title="2. 拆分目标的依赖"></a>2. 拆分目标的依赖</h2><p>将目标的完整依赖拆分为多个部分依赖</p>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/2.png" >

<h2 id="3-make中的命令执行机制"><a href="#3-make中的命令执行机制" class="headerlink" title="3. make中的命令执行机制"></a>3. make中的命令执行机制</h2><p>规则中的每个命令默认是在一个新的进程中执行（shell）</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	<span class="keyword">mkdir</span> <span class="keyword">test</span></span><br><span class="line">	<span class="keyword">cd</span> <span class="keyword">test</span> </span><br><span class="line">	<span class="keyword">mkdir</span> subtest</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br>期待的运行结果为，创建一个文件夹test，在test中创建子文件夹subtest，但实际运行结果为在当前目录下创建出两个文件夹分别为test和subtest<br><strong>运行结果分析：</strong><br>make创建一个进程执行 mkdir test，执行完后进程结束，回到当前目录。make又创建一个进程执行 cd test，执行完后进程结束，回到当前目录。make再次创建一个进程执行 mkdir subtest，执行完后进程结束，回到当前目录。因此最终结果在当前目录下创建两个文件夹test和subtest。<br><strong>解决方案</strong><br>set-e指定发生错误后立即退出执行<br>可以通过分号 ; 和接续符 \ 将多个命令组合成一个命令<br>组合的命令一次在同一个进程中被执行，无论是否出错<br><strong>代码修改</strong></p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	<span class="keyword">set</span> -<span class="keyword">e</span>; \</span><br><span class="line">	<span class="keyword">mkdir</span> <span class="keyword">test</span>; \</span><br><span class="line">	<span class="keyword">cd</span> <span class="keyword">test</span>; \</span><br><span class="line">	<span class="keyword">mkdir</span> subtest</span><br></pre></td></tr></table></figure>
<h2 id="4-makefile中嵌入shell的for循环"><a href="#4-makefile中嵌入shell的for循环" class="headerlink" title="4. makefile中嵌入shell的for循环"></a>4. makefile中嵌入shell的for循环</h2><h3 id="1）语法规则"><a href="#1）语法规则" class="headerlink" title="1）语法规则"></a>1）语法规则</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/11.jpg" >

<blockquote>
<p><strong>说明：</strong><br>makefile中嵌入shell代码时，如果用到shell变量的值，必须在变量名前加上$$(例：$$dir)</p>
</blockquote>
<h3 id="2）编程实验"><a href="#2）编程实验" class="headerlink" title="2）编程实验"></a>2）编程实验</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">MODULES := common <span class="string">\</span></span><br><span class="line">           main <span class="string">\</span></span><br><span class="line">           <span class="built_in">module</span></span><br><span class="line">           </span><br><span class="line">compile : </span><br><span class="line">	@set -e;<span class="string">\</span></span><br><span class="line">	<span class="keyword">for</span> dir <span class="keyword">in</span> $(MODULES);<span class="string">\</span></span><br><span class="line">	<span class="keyword">do</span><span class="string">\</span></span><br><span class="line">		echo $$dir;<span class="string">\</span></span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	common</span><br><span class="line">	main</span><br><span class="line">	<span class="built_in">module</span></span><br></pre></td></tr></table></figure>
<h1 id="十二、makefile中的include关键字"><a href="#十二、makefile中的include关键字" class="headerlink" title="十二、makefile中的include关键字"></a><div align=center>十二、makefile中的include关键字</h1><h2 id="1-makefile对include关键字的处理"><a href="#1-makefile对include关键字的处理" class="headerlink" title="1. makefile对include关键字的处理"></a>1. makefile对include关键字的处理</h2><p>在当前目录搜索或指定目录搜索目标文件</p>
<h3 id="1）搜索成功"><a href="#1）搜索成功" class="headerlink" title="1）搜索成功"></a>1）搜索成功</h3><p>类似于c语言中include关键字，将文件内容直接搬到makefile中</p>
<h4 id="编程实验"><a href="#编程实验" class="headerlink" title="编程实验"></a>编程实验</h4><p>test.txt文件中的内容</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">test </span>:</span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;this is test&quot;</span></span><br></pre></td></tr></table></figure>
<p>makefile内容</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">.PHONY : <span class="keyword">all</span> clean</span><br><span class="line"></span><br><span class="line">include test.txt </span><br><span class="line"> </span><br><span class="line"><span class="keyword">all</span> :</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;this is all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">make</span> <span class="keyword">all</span> 运行结果：</span><br><span class="line">	this <span class="keyword">is</span> test</span><br></pre></td></tr></table></figure>
<h3 id="2）搜索失败"><a href="#2）搜索失败" class="headerlink" title="2）搜索失败"></a>2）搜索失败</h3><p>产生警告，以文件作为目标查找并执行相应规则，当文件名对应的规则不存在时，最终产生错误</p>
<h4 id="a）规则存在"><a href="#a）规则存在" class="headerlink" title="a）规则存在"></a>a）规则存在</h4><p>test.txt文件不存在</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">include test.txt </span><br><span class="line"> </span><br><span class="line"><span class="keyword">all</span> :</span><br><span class="line">	@echo <span class="string">&quot;this is all&quot;</span></span><br><span class="line"></span><br><span class="line">test.txt :</span><br><span class="line">	@echo <span class="string">&quot;test.txt is not exist&quot;</span></span><br><span class="line"></span><br><span class="line">make <span class="keyword">all</span> 运行结果：</span><br><span class="line">	makefile:<span class="number">2</span>: test.txt: 没有那个文件或目录</span><br><span class="line">	test.txt <span class="keyword">is</span> <span class="keyword">not</span> exist</span><br><span class="line">	this <span class="keyword">is</span> <span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<h4 id="b）规则不存在"><a href="#b）规则不存在" class="headerlink" title="b）规则不存在"></a>b）规则不存在</h4><p>test.txt文件不存在</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">include</span> <span class="selector-tag">test</span><span class="selector-class">.txt</span> </span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">all</span> :</span><br><span class="line">	<span class="keyword">@echo</span> <span class="string">&quot;this is all&quot;</span></span><br><span class="line"></span><br><span class="line">make all 运行结果：</span><br><span class="line">	<span class="attribute">makefile:</span><span class="number">2</span>: test.<span class="attribute">txt:</span> 没有那个文件或目录</span><br><span class="line">	<span class="attribute">make:</span> *** 没有规则可以创建目标“test.txt”。 停止。</span><br></pre></td></tr></table></figure>
<h2 id="2-include关键字使用总结"><a href="#2-include关键字使用总结" class="headerlink" title="2. include关键字使用总结"></a>2. include关键字使用总结</h2><h3 id="1）当目标文件不存在"><a href="#1）当目标文件不存在" class="headerlink" title="1）当目标文件不存在"></a>1）当目标文件不存在</h3><img width=800 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/3.png" >

<h3 id="2）当目标文件存在"><a href="#2）当目标文件存在" class="headerlink" title="2）当目标文件存在"></a>2）当目标文件存在</h3><img width=1000 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/4.png" >

<h1 id="十三、自动生成依赖关系"><a href="#十三、自动生成依赖关系" class="headerlink" title="十三、自动生成依赖关系"></a><div align=center>十三、自动生成依赖关系</h1><h2 id="1-编译行为带来的缺陷"><a href="#1-编译行为带来的缺陷" class="headerlink" title="1. 编译行为带来的缺陷"></a>1. 编译行为带来的缺陷</h2><p>预处理器直接将头文件中的代码直接插入源文件<br>编译器只通过预处理后的源文件产生目标文件<br>因此，规则中以源文件为依赖，修改头文件后，命令可能无法执行</p>
<h2 id="2-实验中解决方案与问题"><a href="#2-实验中解决方案与问题" class="headerlink" title="2. 实验中解决方案与问题"></a>2. 实验中解决方案与问题</h2><ul>
<li><strong>解决方案</strong><br>头文件作为依赖条件出现于每一个目标对应的规则中<br>当头文件改动，任何源文件都将被重新编译（编译低效）</li>
<li><strong>存在问题</strong><br>当项目中头文件数量巨大时，makefile将很难维护<h2 id="3-思考是否可以自动生成依赖解决"><a href="#3-思考是否可以自动生成依赖解决" class="headerlink" title="3.思考是否可以自动生成依赖解决"></a>3.思考是否可以自动生成依赖解决</h2>通过命令自动生成对头文件的依赖<br>将生成的依赖自动包含进makefile中<br>当头文件改动后，自动确认需要重新编译的文件<h2 id="4-自动生成-dep依赖文件"><a href="#4-自动生成-dep依赖文件" class="headerlink" title="4. 自动生成.dep依赖文件"></a>4. 自动生成.dep依赖文件</h2><h3 id="1）得到依赖文件"><a href="#1）得到依赖文件" class="headerlink" title="1）得到依赖文件"></a>1）得到依赖文件</h3>通过gcc -MM 和 sed 得到.dep依赖文件（目标的部分依赖）</li>
<li>*技术点：**规则中命令的连续执行<h3 id="2）自动生成依赖文件"><a href="#2）自动生成依赖文件" class="headerlink" title="2）自动生成依赖文件"></a>2）自动生成依赖文件</h3>通过include指令包含所有的.dep依赖文件</li>
<li>*技术点：**当.dep依赖文件不存在时,使用规则自动生成<h3 id="3）编程实现"><a href="#3）编程实现" class="headerlink" title="3）编程实现"></a>3）编程实现</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line">MKDIR := mkdir</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">DEPS := $(SRCS:.c=.dep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	@echo all</span><br><span class="line"></span><br><span class="line">%.dep : %.c</span><br><span class="line">	@echo <span class="string">&quot;Creating <span class="variable">$@</span>...&quot;</span></span><br><span class="line">	set -e;\</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$^</span> | sed &#x27;s,\(.*\)\.o[ :]*,objs/\1.o : ,g&#x27; &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> *.dep</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	creat sub.dep ...</span><br><span class="line">	creat add.dep ...</span><br><span class="line">	creat a.dep ...</span><br><span class="line">	all</span><br></pre></td></tr></table></figure>
<h2 id="5-集中管理-dep文件"><a href="#5-集中管理-dep文件" class="headerlink" title="5. 集中管理.dep文件"></a>5. 集中管理.dep文件</h2><h3 id="1）当include发现-dep文件不存在"><a href="#1）当include发现-dep文件不存在" class="headerlink" title="1）当include发现.dep文件不存在"></a>1）当include发现.dep文件不存在</h3>通过规则和命令创建deps文件夹<br>将所有的.dep文件创建到deps文件夹<br>.dep文件中记录目标文件的依赖关系<h3 id="2）编程实现"><a href="#2）编程实现" class="headerlink" title="2）编程实现"></a>2）编程实现</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -fr</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">DIR_DEPS := deps</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">DEPS := $(SRCS:.c=.dep)</span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_DEPS)</span>/,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	@echo <span class="string">&quot;all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>:</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_DEPS)</span>)</span>, )</span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>/%.dep : <span class="variable">$(DIR_DEPS)</span> %.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>/%.dep : %.c</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">	@echo <span class="string">&quot;Creating <span class="variable">$@</span> ...&quot;</span></span><br><span class="line">	@set -e; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM -E <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$^</span>)</span> | sed &#x27;s,\(.*\)\.o[ :]*,objs/\1.o : ,g&#x27; &gt; <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_DEPS)</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	mkdir deps</span><br><span class="line">	Creating deps/sub.dep ...</span><br><span class="line">	Creating deps/add.dep ...</span><br><span class="line">	Creating deps/a.dep ...</span><br><span class="line">	Creating deps/sub.dep ...</span><br><span class="line">	all	</span><br></pre></td></tr></table></figure>
<h3 id="3）一些-dep文件会被重复创建多次"><a href="#3）一些-dep文件会被重复创建多次" class="headerlink" title="3）一些.dep文件会被重复创建多次"></a>3）一些.dep文件会被重复创建多次</h3>deps文件夹的时间属性会因为依赖文件创建而发生改变<br>make发现deps文件夹比对应的目标更新<br>触发相应规则的重新解析和命令的执行</li>
<li>*解决方案**<br>添加宏代码块进行判断，当不存在deps文件添加文件依赖关系，否则取消文件依赖关系<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">ifeq ($(wildcard $(DIR_DEPS)), )</span><br><span class="line">$(DIR_DEPS)/%.dep : $(DIR_DEPS) %.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">$(DIR_DEPS)/%.dep : %.c</span><br></pre></td></tr></table></figure>
<h2 id="6-自动生成依赖的最终实现"><a href="#6-自动生成依赖的最终实现" class="headerlink" title="6. 自动生成依赖的最终实现"></a>6. 自动生成依赖的最终实现</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -fr</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">DIR_DEPS := deps</span><br><span class="line">DIR_OBJS := objs</span><br><span class="line">DIR_EXE  := exes</span><br><span class="line">DIRS := <span class="variable">$(DIR_OBJS)</span> <span class="variable">$(DIR_EXE)</span></span><br><span class="line"></span><br><span class="line">APP = <span class="variable">$(DIR_EXE)</span>/app.out</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">DEPS := $(SRCS:.c=.dep)</span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_DEPS)</span>/,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_OBJS)</span>/,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line">	</span><br><span class="line">all : <span class="variable">$(APP)</span></span><br><span class="line">	./<span class="variable">$(APP)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span> : <span class="variable">$(DIRS)</span> <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;target ==&gt; <span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIRS)</span> :</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OBJS)</span>/%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$^</span>)</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>,<span class="string">&quot;all&quot;</span>)</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>:</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_DEPS)</span>)</span>, )</span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>/%.dep : <span class="variable">$(DIR_DEPS)</span> %.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>/%.dep : %.c</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">	@echo <span class="string">&quot;Creating <span class="variable">$@</span> ...&quot;</span></span><br><span class="line">	@set -e; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM -E <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$^</span>)</span> | sed &#x27;s,\(.*\)\.o[ :]*,objs/\1.o : ,g&#x27; &gt; <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_DEPS)</span> <span class="variable">$(DIRS)</span></span><br></pre></td></tr></table></figure>
代码存在问题，当头文件中包含其他头文件时可能出现修改头文件，make无法执行的情况，解决方案，在生成的依赖中加入dep文件目标，即修改上述代码52行,在冒号前加入$@<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">$(CC) -MM -E $(<span class="keyword">filter</span> %.c, $^) | sed <span class="string">&#x27;s,\(.*\)\.o[ :]*,objs/\1.o $@: ,g&#x27;</span> &gt; $@</span><br></pre></td></tr></table></figure>
<h1 id="十四、make的隐式规则"><a href="#十四、make的隐式规则" class="headerlink" title="十四、make的隐式规则"></a><div align=center>十四、make的隐式规则</h1><h2 id="1-makfile中出现同名目标时"><a href="#1-makfile中出现同名目标时" class="headerlink" title="1. makfile中出现同名目标时"></a>1. makfile中出现同名目标时</h2></li>
<li>*依赖：**所有的依赖合并在一起，成为目标的最终依赖</li>
<li>*命令：**当多处出现同一目标命令时，make发出警告所有之前定义的命令被最后定义的命令取代<blockquote>
<p>注意事项：<br>当使用include关键字包含其他文件时，需要确保被包含文件中的同名目标只有依赖，没有命令否则，同名文件将被覆盖！</p>
</blockquote>
<h2 id="2-隐式规则"><a href="#2-隐式规则" class="headerlink" title="2. 隐式规则"></a>2. 隐式规则</h2>make提供了一些常用的，例行的规则实现<br>make提供了生成目标文件的隐式规则<br>隐式规则会使用预定义变量完成编译工作<br>改变预定义变量将部分改变隐式规则的行为<br>当存在自定义规则时，不在使用隐式规则<br>当相应目标的规则未提供时，make尝试使用隐式规则<h2 id="3-隐式规则的副作用"><a href="#3-隐式规则的副作用" class="headerlink" title="3. 隐式规则的副作用"></a>3. 隐式规则的副作用</h2></li>
<li><strong>编译行为难以控制</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;大量使用隐式规则可能产生意想不到的编译行为</li>
<li><strong>编译效率低下</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;make从隐式规则和自定义规则中选择最终使用的规则</li>
<li><strong>隐式规则链</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;当依赖目标存在时，make会极力组合各种隐式规则对目标进行创建，进而产生意料之外的编译行为！<h2 id="4-查看隐式规则"><a href="#4-查看隐式规则" class="headerlink" title="4. 查看隐式规则"></a>4. 查看隐式规则</h2></li>
<li>*查看所有**<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make -p</span></span><br></pre></td></tr></table></figure></li>
<li>*查看具体规则**<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">make</span> -<span class="keyword">p</span> | <span class="keyword">grep</span> <span class="string">&quot;XXX&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-隐式规则的禁用"><a href="#5-隐式规则的禁用" class="headerlink" title="5. 隐式规则的禁用"></a>5. 隐式规则的禁用</h2>在makefile中自定义规则<br>在makefile中自定义模式（如：%.o : %.c）<br>全局禁用：make -r<h2 id="6-后缀规则"><a href="#6-后缀规则" class="headerlink" title="6. 后缀规则"></a>6. 后缀规则</h2><h3 id="1）后缀规则简介"><a href="#1）后缀规则简介" class="headerlink" title="1）后缀规则简介"></a>1）后缀规则简介</h3>后缀规则是旧式的“模式规则”<br>可以通过后缀描述的方式自定义规则</li>
</ul>
<img width=400 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/5.png">

<h3 id="2）双后缀规则"><a href="#2）双后缀规则" class="headerlink" title="2）双后缀规则"></a>2）双后缀规则</h3><p>定义一对文件后缀（依赖文件后缀和目标文件后缀）</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">.cpp.o</span> &lt;==&gt; %<span class="string">.o</span> : %<span class="string">.cpp</span></span><br></pre></td></tr></table></figure>
<h3 id="3）单后缀规则"><a href="#3）单后缀规则" class="headerlink" title="3）单后缀规则"></a>3）单后缀规则</h3><p>定义单个后缀文件（源文件后缀）</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">.c  &lt;==&gt; <span class="meta">%</span> : <span class="meta">%</span>.c</span><br></pre></td></tr></table></figure>
<h2 id="7-后缀规则注意事项"><a href="#7-后缀规则注意事项" class="headerlink" title="7. 后缀规则注意事项"></a>7. 后缀规则注意事项</h2><p>后缀规则中不允许有依赖<br>后缀规则必须有命令，否则无意义<br>后缀规则将逐步被模式规则取代</p>
<h1 id="十五、makefile中的路径搜索"><a href="#十五、makefile中的路径搜索" class="headerlink" title="十五、makefile中的路径搜索"></a><div align=center>十五、makefile中的路径搜索</h1><p>项目中的makefile必须能够正确的定位源文件和依赖文件，最终编译生成可执行程序。</p>
<h2 id="1-特殊的预定义变量VPATH（全大写）"><a href="#1-特殊的预定义变量VPATH（全大写）" class="headerlink" title="1. 特殊的预定义变量VPATH（全大写）"></a>1. 特殊的预定义变量VPATH（全大写）</h2><h3 id="1）VPATH说明"><a href="#1）VPATH说明" class="headerlink" title="1）VPATH说明"></a>1）VPATH说明</h3><p>VPATH变量的值用于指示make如何查找文件<br>不同文件夹可作为VPATH的值同时出现<br>文件夹的名字需要使用分隔符进行区分</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">VPATH :</span>= inc src （空格）</span><br><span class="line"><span class="attr">VPATH :</span>= inc;src （分号）</span><br><span class="line"><span class="attr">VPATH :</span>= <span class="attr">inc:</span>src （冒号）</span><br></pre></td></tr></table></figure>
<h3 id="2）make对于VAPATH值得处理方式"><a href="#2）make对于VAPATH值得处理方式" class="headerlink" title="2）make对于VAPATH值得处理方式"></a>2）make对于VAPATH值得处理方式</h3><p>当前文件夹找不到需要的文件时，VPATH会被使用<br>make会在VPATH指定的文件夹中依次搜索文件<br>当多个文件夹存在同名文件时，选择第一次搜索到的文件</p>
<blockquote>
<p><strong>注意事项：</strong><br>   VPATH只能决定make的搜索路径，无法决定命令的搜索路径<br>   对于特定的编译命令（gcc），需要独立指定编译搜索路径<br>   <strong>语法：gcc -I include-path</strong></p>
</blockquote>
<h3 id="3）VAPATH使用实例"><a href="#3）VAPATH使用实例" class="headerlink" title="3）VAPATH使用实例"></a>3）VAPATH使用实例</h3><p>.c文件存放于src文件夹，.o文件存放于inc文件夹，make自动搜索相关路径生成可执行文件app.out</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">APP := app.out</span><br><span class="line"></span><br><span class="line">DIR_INC := inc</span><br><span class="line">DIR_SRC := src</span><br><span class="line"></span><br><span class="line">VPATH := inc src</span><br><span class="line"></span><br><span class="line">CFLAGS := -I<span class="variable">$(DIR_INC)</span></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(APP)</span> </span><br><span class="line">	@echo <span class="string">&quot;target ==&gt; <span class="variable">$(APP)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span> : a.o sub.o add.o</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line">	</span><br><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> *.o *.out</span><br></pre></td></tr></table></figure>
<p><strong>VPATH存在问题</strong><br>当inc文件意外出现源文件（c/cpp文件），那可能出现编译错误！<br><strong>解决方案</strong><br>使用vpath为不同类型的文件指定不同的搜索路径</p>
<h2 id="2-vapath关键字（全小写）"><a href="#2-vapath关键字（全小写）" class="headerlink" title="2. vapath关键字（全小写）"></a>2. vapath关键字（全小写）</h2><ul>
<li><strong>语法</strong><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">vpath</span> <span class="built_in">Pattern</span> <span class="built_in">Directory</span></span><br></pre></td></tr></table></figure>
在Directory下搜索符合Pattern的规则文件</li>
<li><strong>将上述VPATH修改为vpath</strong><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vpath %</span>.h inc</span><br><span class="line"><span class="built_in">vpath %</span>.c src</span><br></pre></td></tr></table></figure>
<h2 id="3-取消搜索规则"><a href="#3-取消搜索规则" class="headerlink" title="3. 取消搜索规则"></a>3. 取消搜索规则</h2>取消已经设置的某个搜索规则</li>
<li><strong>语法</strong><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">vpath <span class="built_in">Pattern</span></span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">vpath %.h <span class="keyword">inc</span>  <span class="meta">#在inc中搜索.h文件</span></span><br><span class="line">Vpath %h       <span class="meta">#不在inc中搜索.h文件</span></span><br></pre></td></tr></table></figure></li>
<li><strong>取消所有已经设置的规则</strong><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vpath</span></span><br></pre></td></tr></table></figure>
<h2 id="4-问题分析"><a href="#4-问题分析" class="headerlink" title="4. 问题分析"></a>4. 问题分析</h2><h3 id="1-常见问题-1"><a href="#1-常见问题-1" class="headerlink" title="1) 常见问题 1"></a>1) 常见问题 1</h3></li>
<li>*当VPATH和vpath关键字同时出现，make会如何处理？**<br>make首先在当前文件夹下搜索需要的文件<br>如果失败:<br>&nbsp;&nbsp;&nbsp;&nbsp;make首先在vpath提供的路径下寻搜索目标文件<br>&nbsp;&nbsp;&nbsp;&nbsp;当搜索失败时，转而搜索VPATH指定的文件夹<h3 id="2）常见问题-2"><a href="#2）常见问题-2" class="headerlink" title="2）常见问题 2"></a>2）常见问题 2</h3></li>
<li>*当使用vpath对同一个Pattern指定多个文件夹时，make会如何处理？**<br>make首先在当前文件夹搜索需要的文件<br>如果失败：<br>&nbsp;&nbsp;&nbsp;&nbsp;make以自上而下的顺序搜索vpath指定的文件夹<br>&nbsp;&nbsp;&nbsp;&nbsp;当找到目标文件，搜索结束<blockquote>
<p>小贴士：<br>在实际工程开发中优先选择vpath关键字预防make隐式规则的副作用</p>
</blockquote>
<h3 id="3）常见问题-3"><a href="#3）常见问题-3" class="headerlink" title="3）常见问题 3"></a>3）常见问题 3</h3></li>
<li>*通过VPATH变量指定搜索路径后，make如何决定目标文件的最终位置？**</li>
<li>*当app.out完全不存在:**<br>&nbsp;&nbsp;&nbsp;&nbsp;make在当前文件夹下创建app.out</li>
<li>*当src文件中存在app.out**<br>&nbsp;&nbsp;&nbsp;&nbsp;所有目标依赖的新旧关系不变，make不会创建app.out<br>&nbsp;&nbsp;&nbsp;&nbsp;当依赖文件被更新，make在当前文件夹下创建app.out<blockquote>
<p><strong>解决方案</strong><br>使用GPATH特殊变量指定目标文件夹 <strong>GPATH := src</strong><br>当app.out完全不存在,make默认在当前文件夹创建app.out。当app.out存在于src，且依赖文件被更新。make在src中创建app.out</p>
</blockquote>
<h2 id="5-工程建议"><a href="#5-工程建议" class="headerlink" title="5.工程建议"></a>5.工程建议</h2>尽量使用vpath为不同文件指定搜索路径<br>不要在源代码文件夹中生成目标文件<br>为编译得到的结果创立独立的文件夹<br>避免VTPAH和GPATH特殊变量的使用<br>只要使用VPATH就要考虑是否使用GPATH<h1 id="十六、路径搜索的综合示例"><a href="#十六、路径搜索的综合示例" class="headerlink" title="十六、路径搜索的综合示例"></a><div align=center>十六、路径搜索的综合示例</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2>1）工程项目中不希望源码文件夹在编译过程中被改动（只读文件夹）<br>2）在编译时自动创建文件夹（build）用于存放编译的结果<br>3）编译过程能够自动搜索需要的文件<br>4）makefile易于扩展，能够复用于相同类型的项目<br>5）支持调试版本的编译选项<h2 id="2-项目类型分析"><a href="#2-项目类型分析" class="headerlink" title="2. 项目类型分析"></a>2. 项目类型分析</h2></li>
</ul>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/6.png">

<h2 id="3-工具原料"><a href="#3-工具原料" class="headerlink" title="3. 工具原料"></a>3. 工具原料</h2><p>1）获取$(DIR)文件夹中满足_pattern的文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR)</span>/_pattern)</span></span><br></pre></td></tr></table></figure>
<p>2）去除_names中每一个文件名的路径前缀</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">notdir</span> <span class="params">_names</span>)</span></span><br></pre></td></tr></table></figure>
<p>3）将_text中符合_pattern的部分替换为replacement</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">patsubst</span> <span class="params">_pattern</span>, <span class="params">replacement</span>, <span class="params">_text</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="4-关键技巧"><a href="#4-关键技巧" class="headerlink" title="4. 关键技巧"></a>4. 关键技巧</h2><ol>
<li>自动获取源文件列表（函数调用）<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> src/*.c)</span></span><br></pre></td></tr></table></figure></li>
<li>根据源文件列表生成目标文件列表（变量值的替换）<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">OBJS :</span>= $(<span class="attr">SRCS:</span>.c=.o)</span><br></pre></td></tr></table></figure></li>
<li>替换每一个目标的路径前缀（函数调用）<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> src/%,build/% , <span class="variable">$(OBJS)</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="5-编程实现-1"><a href="#5-编程实现-1" class="headerlink" title="5.编程实现"></a>5.编程实现</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">DIR_INC := inc</span><br><span class="line">DIR_SRC := src</span><br><span class="line">DIR_BUILDS := build</span><br><span class="line"></span><br><span class="line">TYPE_INT := .h</span><br><span class="line">TYPE_SRC := .c</span><br><span class="line">TYPE_OBJ := .o</span><br><span class="line"></span><br><span class="line">DEBUG := </span><br><span class="line"></span><br><span class="line">LFLAGS := </span><br><span class="line">CFLAGS := -I<span class="variable">$(DIR_INC)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">APP := <span class="variable">$(DIR_BUILDS)</span>/app.out</span><br><span class="line"></span><br><span class="line">SCRS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_SRC)</span>/*<span class="variable">$(TYPE_SRC)</span>)</span></span><br><span class="line">OBJS := $(SCRS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_OBJ)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%,<span class="variable">$(DIR_BUILDS)</span>/%,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line">HDRS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_INC)</span>/*<span class="variable">$(TYPE_INC)</span>)</span></span><br><span class="line">HDRS := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(HDRS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_SRC)</span> <span class="variable">$(DIR_SRC)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(DIR_BUILDS)</span> <span class="variable">$(APP)</span> </span><br><span class="line">	./<span class="variable">$(APP)</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIR_BUILDS)</span> :</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;target ==&gt; <span class="variable">$(APP)</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(LFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_BUILDS)</span>/%<span class="variable">$(TYPE_OBJ)</span> : %<span class="variable">$(TYPE_SRC)</span> <span class="variable">$(HDRS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_BUILDS)</span></span><br></pre></td></tr></table></figure>
<h1 id="十七、打造专业的编译环境"><a href="#十七、打造专业的编译环境" class="headerlink" title="十七、打造专业的编译环境"></a><div align=center>十七、打造专业的编译环境</h1><h2 id="1-大型项目目录结构-无第三库"><a href="#1-大型项目目录结构-无第三库" class="headerlink" title="1. 大型项目目录结构(无第三库)"></a>1. 大型项目目录结构(无第三库)</h2></li>
</ol>
<img width=800 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/7.jpg">

<h2 id="2-需要打造的编译环境"><a href="#2-需要打造的编译环境" class="headerlink" title="2. 需要打造的编译环境"></a>2. 需要打造的编译环境</h2><p>源码文件夹在编译时不能被改动（只读文件夹）<br>在编译时自动创建文件夹（build）用于存放编译结果<br>编译过程中自动生成依赖关系，自动搜索需要的文件<br>每个模块可以拥有自己独立的编译方式<br>支持调试版本的编译选项</p>
<h2 id="3-项目架构设计分析"><a href="#3-项目架构设计分析" class="headerlink" title="3. 项目架构设计分析"></a>3. 项目架构设计分析</h2><h3 id="1）项目被划分为多个不同模块"><a href="#1）项目被划分为多个不同模块" class="headerlink" title="1）项目被划分为多个不同模块"></a>1）项目被划分为多个不同模块</h3><p>每个模块的代码用一个文件夹进行管理<br>&nbsp;&nbsp;&nbsp;&nbsp;文件夹由inc,src,makfile构成<br>每个模块的对外函数声明统一放置于common/inc中<br>&nbsp;&nbsp;&nbsp;&nbsp;如：common.h xxfunc.h</p>
<h3 id="2）实现阶段分析"><a href="#2）实现阶段分析" class="headerlink" title="2）实现阶段分析"></a>2）实现阶段分析</h3><p>由项目的目录结构将整个makefile的实现分为两个阶段编译（Compile）和链接（Link）</p>
<ul>
<li><strong>Compile阶段</strong><br>将每个文件中的代码编译成静态库文件</li>
</ul>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/8.jpg">

<blockquote>
<p>任务：<br>完成可用于各个模块可编译的makefile文件<br>每个模块的编译结果为静态库文件（.a文件）</p>
</blockquote>
<ul>
<li><strong>link阶段</strong><br>将每个模块的静态库文件链接生成最终可执行程序</li>
</ul>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/9.jpg">

<blockquote>
<p>任务:<br>完成整编译个工程的makefile文件<br>调用模块的makefile编译生成静态库文件<br>链接所有的静态库文件，最终得到可执行程序</p>
</blockquote>
<h2 id="4-Compile阶段实现"><a href="#4-Compile阶段实现" class="headerlink" title="4. Compile阶段实现"></a>4. Compile阶段实现</h2><h3 id="1）关键的实现要点"><a href="#1）关键的实现要点" class="headerlink" title="1）关键的实现要点"></a>1）关键的实现要点</h3><p>自动生成依赖关系（gcc -MM）<br>自动搜索需要的文件（vpath）<br>将目标打包为静态库文件（ar crs）</p>
<h3 id="2）模块中的makefile构成"><a href="#2）模块中的makefile构成" class="headerlink" title="2）模块中的makefile构成"></a>2）模块中的makefile构成</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/10.jpg">

<h3 id="3）编程实现-1"><a href="#3）编程实现-1" class="headerlink" title="3）编程实现"></a>3）编程实现</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">DIR_BUILD := /home/delphi/project/build</span><br><span class="line">DIR_COMMON_INC := /home/delphi/project/common/inc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DIR_INC := inc</span><br><span class="line">DIR_SRC := src</span><br><span class="line"></span><br><span class="line">TYPE_INC := .h</span><br><span class="line">TYPE_SRC := .c</span><br><span class="line">TYPE_OBJ := .o</span><br><span class="line">TYPE_DEP := .dep</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf </span><br><span class="line">MKDIR := mkdir </span><br><span class="line"></span><br><span class="line">AR := ar</span><br><span class="line">ARFLAGS := csr</span><br><span class="line"></span><br><span class="line">CFLAGS := -I<span class="variable">$(DIR_INC)</span> -I<span class="variable">$(DIR_COMMON_INC)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">MODULE := <span class="variable">$(<span class="built_in">realpath</span> .)</span></span><br><span class="line">MODULE := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(MODULE)</span>)</span></span><br><span class="line">DIR_OUTPUT := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE)</span>)</span></span><br><span class="line"></span><br><span class="line">OUTPUT := <span class="variable">$(MODULE)</span>.a</span><br><span class="line">OUTPUT := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(OUTPUT)</span>)</span></span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_SRC)</span>/*<span class="variable">$(TYPE_SRC)</span>)</span></span><br><span class="line">OBJS := $(SRCS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_OBJ)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%,<span class="variable">$(DIR_OUTPUT)</span>/%,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line">DEPS := $(SRCS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_DEP)</span>)</span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%,<span class="variable">$(DIR_OUTPUT)</span>/%,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_COMMON_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_SRC)</span> <span class="variable">$(DIR_SRC)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>,<span class="string">&quot;all&quot;</span>)</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OUTPUT)</span>/%<span class="variable">$(TYPE_DEP)</span> : %<span class="variable">$(TYPE_SRC)</span></span><br><span class="line">	@echo <span class="string">&quot;Creating <span class="variable">$@</span> ...&quot;</span></span><br><span class="line">	@set -e;\</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -MM -E <span class="variable">$(<span class="built_in">filter</span> %<span class="variable">$(TYPE_SRC)</span>,<span class="variable">$^</span>)</span> | sed &#x27;s,\(.*\)\.o[ :]*,objs/\1.o <span class="variable">$@</span>: ,g&#x27; &gt; <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">all : <span class="variable">$(OUTPUT)</span></span><br><span class="line">	@echo <span class="string">&quot;Success Target ==&gt; <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(AR)</span> <span class="variable">$(ARFLAGS)</span> <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIR_OUTPUT)</span>/%<span class="variable">$(TYPE_OBJ)</span> : %<span class="variable">$(TYPE_SRC)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$(<span class="built_in">filter</span> %<span class="variable">$(TYPE_SRC)</span>,<span class="variable">$^</span>)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-Link阶段实现"><a href="#5-Link阶段实现" class="headerlink" title="5. Link阶段实现"></a>5. Link阶段实现</h2><h3 id="1）开发中的经验假设"><a href="#1）开发中的经验假设" class="headerlink" title="1）开发中的经验假设"></a>1）开发中的经验假设</h3><p>项目中各个模块在设计阶段就已经基本确定，因此在在之后的开发过程中不会频繁的随意增加或者减少</p>
<h3 id="2）设计思路"><a href="#2）设计思路" class="headerlink" title="2）设计思路"></a>2）设计思路</h3><ul>
<li><p><strong>定义变量模块名列表（模块变量名）</strong></p>
</li>
<li><p><strong>利用shell的for循环遍历模块变量名</strong> </p>
</li>
<li><p><strong>在for循环中进入模块文件夹进行编译</strong></p>
</li>
<li><p><strong>循环结束后链接所有的模块静态库文件</strong></p>
<h3 id="3）编程实现-2"><a href="#3）编程实现-2" class="headerlink" title="3）编程实现"></a>3）编程实现</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.PHONY : all compile link</span><br><span class="line"></span><br><span class="line">MODULES := common \</span><br><span class="line">           main \</span><br><span class="line">           module</span><br><span class="line">        </span><br><span class="line">CC := gcc </span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line">LFLAGS :=</span><br><span class="line"></span><br><span class="line">DIR_PROJECT := <span class="variable">$(<span class="built_in">realpath</span> .)</span></span><br><span class="line">DIR_BUILD := build</span><br><span class="line">DIR_BUILD_SUB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULES)</span>)</span></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addsuffix</span> .a,<span class="variable">$(MODULES)</span>)</span></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE_LIB)</span>)</span></span><br><span class="line"></span><br><span class="line">APP := app.out</span><br><span class="line">APP := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(APP)</span>)</span></span><br><span class="line"></span><br><span class="line">all : compile link</span><br><span class="line"></span><br><span class="line">link : <span class="variable">$(MODULE_LIB)</span></span><br><span class="line">	@echo <span class="string">&quot;Bengin to link ...&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(APP)</span> -Xlinker <span class="string">&quot;-(&quot;</span> <span class="variable">$^</span> -Xlinker <span class="string">&quot;-)&quot;</span> <span class="variable">$(LFLAGS)</span></span><br><span class="line">	@echo <span class="string">&quot;Success Target ==&gt; <span class="variable">$@</span> ...&quot;</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span></span><br><span class="line">	@echo <span class="string">&quot;Compile Begin ...&quot;</span></span><br><span class="line">	@set -e;\</span><br><span class="line">	for dir in <span class="variable">$(MODULES)</span>;\</span><br><span class="line">	do\</span><br><span class="line">		cd $$dir &amp;&amp; make all DEBUG:=<span class="variable">$(DEBUG)</span> &amp;&amp; cd ..;\</span><br><span class="line">	done</span><br><span class="line">	@echo <span class="string">&quot;Compile Success ...&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span> :</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_BUILD)</span> </span><br></pre></td></tr></table></figure>
<h2 id="6-上述makefile存在潜在问题"><a href="#6-上述makefile存在潜在问题" class="headerlink" title="6. 上述makefile存在潜在问题"></a>6. 上述makefile存在潜在问题</h2><h3 id="1）问题-1"><a href="#1）问题-1" class="headerlink" title="1）问题 1"></a>1）问题 1</h3><p>所有模块makefile中使用编译路径均为写死的绝对路径，一旦项目文件夹移动，编译必将失败</p>
<h3 id="2）解决方案"><a href="#2）解决方案" class="headerlink" title="2）解决方案"></a>2）解决方案</h3><p>在工程makefile中获取项目的源码目录<br>根据项目源码路径：<br>  拼接得到编译文件夹路径DIR_BUILD<br>  拼接得到全局头文件路径DIR_COMMON_INC<br>通过定义命令行变量将路径传递给模块makefile</p>
<h3 id="3）问题-2"><a href="#3）问题-2" class="headerlink" title="3）问题 2"></a>3）问题 2</h3><p>所有makefile模块完全相同，当模块makefile需要改动时，将涉多处相同改动</p>
</li>
</ul>
<h1 id="未完待续！！！"><a href="#未完待续！！！" class="headerlink" title="未完待续！！！"></a>未完待续！！！</h1>]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动-i2c</title>
    <url>/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本文借助mtk平台分析linux的i2c框架，mtk平台mt6765，内核版本kernel-4.9，本文只分析linux的i2c框架，不讨论i2c总线协议相关内容.</p>
<a id="more"></a>

<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><h2 id="1、i2c-client"><a href="#1、i2c-client" class="headerlink" title="1、i2c_client"></a>1、i2c_client</h2><p>具体的i2次设备的软件抽象，它拥有所有i2c次设备的信息：</p>
<ol>
<li>包括i2c总线(物理总线)的控制器的硬件描述信息，这些信息通过结构 adapter 来进行描述</li>
<li>以及具体设备的addr信息，中断，以及name，这些信息通过结构 i2c_board_info 来进行描述</li>
</ol>
<p>i2c_client这个结构被注册时候就被注册到 i2c bus 上了，因此我们可以利用 i2c bus 获取到这个结构</p>
<blockquote>
<p><font color = red>说明：i2c有两个总线的概念，一个是设备模型中虚拟的i2c总线，另一个则是实际的物理上的i2c总线，在不说明的情况下默认设备模型中的虚拟总线。</font></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> flags;      <span class="comment">//i2c通信标志位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> addr;       <span class="comment">//次设备，i2c地址7位地址位，flags+addr组成8位地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[I2C_NAME_SIZE];	  <span class="comment">//设备名称，i2c_board_info 的 type 成员，driver 匹配时会用到该名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>  <span class="comment">//指向挂接的总线上的控制器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>      <span class="comment">//设备模型dev结构</span></span><br><span class="line">    <span class="keyword">int</span> irq;                <span class="comment">//用到的中断号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">i2c_slave_cb_t</span> slave_cb; <span class="comment">/* callback for slave mode  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、i2c-adapter"><a href="#2、i2c-adapter" class="headerlink" title="2、i2c_adapter"></a>2、i2c_adapter</h2><p>i2c适配器，adapter翻译过来就是适配器的意思，这个结构描述了硬件上的i2c总线的控制器信息，<font color = red><strong>注意不是我们理解的设备模型上虚拟的i2c总线，而是实实在在的接在cpu上面的硬件i2c总线的控制器信息</strong></font></p>
<p>其中 algo 链接着该总线的i2c通信相关结构 i2c_algorithm 。 按理来讲通信方式也是总线控制器的一部分为什么要将其分离出来，这样做是为了代码的复用性，如果系统有6个i2c总线则需要写6个通信接口，而区别往往只是一些和控制器某些寄存器的值不同而已，为了提高代码的效率，于是将 i2c_algorithm 独立出来作为一个共有的模块。</p>
<p>很明显作为总线控制器的描述，i2c_adapter 不会描述具体的设备信息，具体的设备信息由中间结构 i2c_board_info 描述，并将其存入 i2c_client 结构。</p>
<p>从上面的描述可以知道 i2c 适配器的数量其实是固定的，硬件有多少个 i2c 总线，就会有多少个 i2c 适配器，例如 mt6765 有6个物理的i2c总线i2c0-i2c6，因此mt6765就有6个i2c适配器。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>       <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">//i2c通信接口</span></span><br><span class="line">    <span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices   */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     i2c总线访问（发送或者接收数据）在传输失败的时候，可以选择重试。retries表示从试的次数。</span></span><br><span class="line"><span class="comment">     另外，有些设备对结果的返回是有时间要求的，因此不能无节制的重试，</span></span><br><span class="line"><span class="comment">     timeout字段（单位为jiffies）在retries基础上，增加了时间限制，超过这个时间，就不能重试了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> timeout;	<span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">int</span> retries;    <span class="comment">//重复次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>  <span class="comment">//设备模型dev，用于在sys/生成目录结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr;	<span class="comment">//i2c总线号，例如，0代表使用i2c0，这个不是我们所说的设备模型里面的i2c总线，是cpu中的i2c物理总线号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">48</span>]; <span class="comment">//adapter的名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span> <span class="comment">//用于管理用户空间创建的i2c设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通信方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 作为主设备时的通信函数 *</span></span><br><span class="line"><span class="comment">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);</span></span><br><span class="line"><span class="comment">	/* 作为从设备时的通信函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">int</span> (*reg_slave)(struct i2c_client *client);</span><br><span class="line">    <span class="keyword">int</span> (*unreg_slave)(struct i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3、i2c-board-info"><a href="#3、i2c-board-info" class="headerlink" title="3、i2c_board_info"></a>3、i2c_board_info</h2><p>这个结构用于描述具体的i2c设备的硬件信息，设备地址，通信方式，中断号等。</p>
<ol>
<li>当使用dts创建 i2c_client 时，它作为中间结构，当他把硬件信息传递给真正的设备结构 i2c_client，它的使命也就完成了，dts中的设备信息先在内核中转换为 i2c_board_info 这个结构，然后通过这个结构传给 i2c_client 。</li>
<li>当使用老式的使用总线号创建 i2c_client时，所有的由 i2c_register_board_info 动态创建的 i2c_board_info 描述的设备信息将被链接到 __i2c_board_list 链表进行维护，在加载内核时查询 __i2c_board_list 将 i2c_board_info 描述的信息传给 i2c_client</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>        type[I2C_NAME_SIZE]; <span class="comment">//i2c设备设名称，将被设置到client-&gt;name</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  addr; <span class="comment">//设备地址</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span> <span class="comment">//设备节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span></span><br><span class="line">    <span class="keyword">int</span>     irq; <span class="comment">//中断号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4、i2c-driver"><a href="#4、i2c-driver" class="headerlink" title="4、i2c_driver"></a>4、i2c_driver</h2><p>该结构用来描述虚拟 i2c bus 总线上的 driver ，通过向 i2c bus 注册该结构进行匹配，获取对应的 i2c_client</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_driver &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">     * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;  <span class="comment">//这个方法已经被过时，不应该被使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *); <span class="comment">//当匹配到i2c_client时调用这个函数</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *); <span class="comment">//和probe相反</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">     * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">     * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">     * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">     * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">     * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">     * with the device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> device_driver driver; <span class="comment">//设备模型中的device_driver结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *id_table; <span class="comment">//指向用来和i2c总线上的i2c_client进行匹配的一组 name </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">    <span class="keyword">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *); <span class="comment">//动态扫描的方式注册i2c_client, linux并不推荐这种方式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *address_list; <span class="comment">//动态扫描时使用的一组地址</span></span><br><span class="line">    <span class="keyword">struct</span> list_head clients;  <span class="comment">//用于链接detect动态扫描生成的设备。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5、i2c-device-id"><a href="#5、i2c-device-id" class="headerlink" title="5、i2c_device_id"></a>5、i2c_device_id</h2><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">struct i2c_device_id &#123;</span><br><span class="line">    <span class="function"><span class="title">char</span> <span class="keyword">name</span>[I2C_NAME_SIZE]; //用于匹配的<span class="keyword">name</span>，这个<span class="keyword">name</span>将去匹配 i2c_client-&gt;</span><span class="keyword">name</span></span><br><span class="line">    kernel_ulong_t driver_data; <span class="comment">/* 用于保存驱动的私有数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6、i2c-msg"><a href="#6、i2c-msg" class="headerlink" title="6、i2c_msg"></a>6、i2c_msg</h2><p>linux的i2c通信是以 i2c_msg 作为操作单位</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    <span class="variable">__u16</span> addr; 	<span class="comment">//设备地址</span></span><br><span class="line">    <span class="variable">__u16</span> flags;	<span class="comment">//传输标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD        0x0001  <span class="comment">//设置了这个表示表示本次通信为接收数据，否则为发送数据。</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">//设置了这个表示从设备地址有10bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN      0x0400  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">//在读操作中不需要ack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">//当前i2cmsg忽略i2c器件的ack和nack信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">//读写标志位反过来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">//当前i2c_msg不发送start信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    <span class="variable">__u16</span> len;      <span class="comment">//数据长度，单位为byte</span></span><br><span class="line">    <span class="variable">__u8</span> *buf;      <span class="comment">//数据缓冲区指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="三、内核i2c驱动框架"><a href="#三、内核i2c驱动框架" class="headerlink" title="三、内核i2c驱动框架"></a>三、内核i2c驱动框架</h1><p>li2c总线的硬件结构一般如下图所示</p>
<div align=left> <img width=800 src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/4.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605171541;10245085141&q-key-time=1605171541;10245085141&q-header-list=&q-url-param-list=&q-signature=f24cd44d860eae2aa76aaf53aaaba7c7a9aaa151" > </div>

<p>cpu作为主设备挂接在所有总线上，而对应的设备根据硬件设计挂接在相应的总线上。图所示gsensor挂接在i2c0上，camera挂接在i2c1上，tp挂接在i2c2上。硬件结构非常简单，而linux的实现相对而言复杂度还是蛮高的，向上面的i2c设备 gsensor、camera、tp 等对于总线来讲只是地址上的不同而已，本质上都是i2c设备没有什么不同。 linux-4.9提供6种添加i2c设备的方法，参考 Documentation/i2c/instantiating-devices，下面逐一讨论。</p>
<h2 id="1、使用dts添加i2c设备"><a href="#1、使用dts添加i2c设备" class="headerlink" title="1、使用dts添加i2c设备"></a>1、使用dts添加i2c设备</h2><p>只需在dts文件中添加i2c设备相关节点，内核就会自动创建对应的  i2c_client 结构。 例如:添加两个设备 24c256、pca9532以以100kHz的速度连接到i2c1总线。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">i2c1:</span> <span class="class">i2c@400a0000 </span>&#123;</span><br><span class="line">    <span class="comment">/* ... master properties skipped ... */</span></span><br><span class="line">    clock-frequency = <span class="params">&lt;<span class="number">100000</span>&gt;</span>; <span class="comment">//100KHZ</span></span><br><span class="line"></span><br><span class="line">    <span class="class">flash@50 </span>&#123;</span><br><span class="line">        compatible = <span class="string">&quot;atmel,24c256&quot;</span>;</span><br><span class="line">        reg = <span class="params">&lt;<span class="number">0x50</span>&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">    pca9532:</span> <span class="class">gpio@60 </span>&#123;</span><br><span class="line">        compatible = <span class="string">&quot;nxp,pca9532&quot;</span>;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">        reg = <span class="params">&lt;<span class="number">0x60</span>&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样内核在加载的时候就会自动创建出 name 为 24c256 和 pca9532 的i2c_client结构并将其注册进入i2c bus。它的流程如下所示：</p>
<div align=left> <img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/i2c%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6dts.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605671309;10245584909&q-key-time=1605671309;10245584909&q-header-list=&q-url-param-list=&q-signature=6d339c3be8f9cb9e5dc2ab4b199e9f70b72450fc" > </div>

<p>上图展示了整个注册流程，对于驱动工程师来讲非常简单，只需在dts中填充对应的信息就行了。而内核却帮我我们完成了一系类注册流程。而作为驱动工程师不仅仅要做到知其然，还要知其所以然，下面以mtk平台为例分析整个注册流程。</p>
<p>源码路径drivers/i2c/busses/i2c-mtk.c，ic原厂提供i2c函数都被放在drivers/i2c/busses/这个目录</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static s32 __init mt<span class="constructor">_i2c_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_MTK_I2C_ARBITRATION</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = enable<span class="constructor">_arbitration()</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Cannot enalbe arbitration.\n&quot;</span>)</span>;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!map<span class="constructor">_dma_regs()</span>)</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Mapp dma regs successfully.\n&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mt<span class="constructor">_i2c_parse_comp_data()</span>)</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Get compatible data from dts successfully.\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_info(<span class="string">&quot; mt_i2c_init driver as platform device\n&quot;</span>)</span>;</span><br><span class="line">    return platform<span class="constructor">_driver_register(&amp;<span class="params">mt_i2c_driver</span>)</span>; <span class="comment">//向内核注册 mt_i2c_driver </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码向内核注册了一个名叫 “mt-i2c” 的 platform 驱动</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_DRV_NAME           <span class="meta-string">&quot;mt-i2c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mtk_i2c_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;mediatek,i2c&quot;</span>, .data = &amp;i2c_common_compat&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mt_i2c_driver</span> =</span> &#123;</span><br><span class="line">    .probe = mt_i2c_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = mt_i2c_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = I2C_DRV_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .pm = &amp;mt_i2c_dev_pm_ops,</span><br><span class="line">        .of_match_table = of_match_ptr(mtk_i2c_of_match),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到它 match 的设备的 compatible 字段是 “mediatek,i2c” ，于是在dts中找对应的设备节点。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">i2c0:</span> <span class="class">i2c0@11007000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">0</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c1:</span> <span class="class">i2c1@11008000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">1</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c2:</span> <span class="class">i2c2@11009000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">2</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c3:</span> <span class="class">i2c3@1100f000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">3</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c4:</span> <span class="class">i2c4@11011000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">4</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c5:</span> <span class="class">i2c5@11016000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">5</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c6:</span> <span class="class">i2c6@1100d000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">6</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>凡是在dts中具有compatible字段的节点，都会被内核注册为platform设备，例如上面的 i2c0，将会被转换为名字为”11007000.i2c0”的platform设备,再看i2c0到i2c6的节点都有相同的compatible字段”mediatek,i2c”，因此当驱动mt_i2c_driver注册的时候，会分别与之匹配调用对应的 mt_i2c_probe 函数，也就是说会调用6次mt_i2c_probe函数分别注册i2c0到i2c6, 以i2c0为例进行分析。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static int mt_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int cnt = 0;</span></span><br><span class="line">    struct mt_i2c *i2c; <span class="comment">//这个结构中包含了 i2c_adapter 结构</span></span><br><span class="line">    unsigned int clk_src_in_hz;</span><br><span class="line">    struct resource *res;</span><br><span class="line">    const struct of_device_id *of_id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(struct mt_i2c), GFP_KERNEL); </span><br><span class="line">    <span class="keyword">if</span> (i2c == NULL)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取dts中的相关数据其中包括 i2c-&gt;id </span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = mt_i2c_parse_dt(pdev-&gt;</span>dev.of_node, i2c); </span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        return -EINVAL;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev_comp</span> = of_id-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.of_node = pdev-&gt;</span>dev.of_node; <span class="comment">//设置设备节点为 i2c0 根节点</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev</span> = &amp;i2c-&gt;</span>adap.dev; </span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.parent = &amp;pdev-&gt;</span>dev;	<span class="comment">//设置父设备为传入的platform设备&quot;11007000.i2c0&quot;，有此可知所有的i2c_adapter设备都将是platform设备的子设备,都将位于 /sys/devices/110xx000.i2cx/ 之下</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo = &amp;mt_i2c_algorithm; <span class="comment">//这里始化了i2c的通信操作函数，这个函数有mtk原厂实现，这个是平台相关的寄存器操作</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo_data = NULL;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.timeout = <span class="number">2</span> * HZ; <span class="comment">//超时时间2s，从这里可知mtk的i2c超时时间为2s</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.retries = <span class="number">1</span>;	<span class="comment">//mtk平台设置，重复次数1次</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.nr = i2c-&gt;</span>id; <span class="comment">//表示使用的i2c总线号，0表示i2c0</span></span><br><span class="line">    <span class="function"><span class="title">spin_lock_init</span>(&amp;i2c-&gt;</span>cg_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(i2c-&gt;</span><span class="function"><span class="title">adap</span>.<span class="keyword">name</span>, I2C_DRV_NAME, sizeof(i2c-&gt;</span>adap.<span class="keyword">name</span>)); <span class="comment">//初始化adap的名字为mt-i2c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ret = i2c_add_adapter(&amp;i2c-&gt;adap); */</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = i2c_add_numbered_adapter(&amp;i2c-&gt;</span>adap); <span class="comment">//将adap注册进内核</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数，从dts获取相关的平台台相关的硬件信息，通信方式(mt_i2c_algorithm)、硬件总线号(adap.nr)等，以及平台相关的信息，通信超时时间、通信重复次数等，利用这些信息创建并初始化一个 i2c_adapter（包含在mt_i2c中），并将其注册进内核，来看看它的注册过程，它的代码在 drivers/i2c/i2c-core.c</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_add_numbered_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr<span class="operator"> == </span>-<span class="number">1</span>) <span class="comment">/* -1 means dynamically assign bus id */</span></span><br><span class="line">        return i2c<span class="constructor">_add_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="constructor">__i2c_add_numbered_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL_GPL(<span class="params">i2c_add_numbered_adapter</span>)</span>;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> <span class="constructor">__i2c_add_numbered_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> id;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_lock(&amp;<span class="params">core_lock</span>)</span>;</span><br><span class="line">    id = idr<span class="constructor">_alloc(&amp;<span class="params">i2c_adapter_idr</span>, <span class="params">adap</span>, <span class="params">adap</span>-&gt;<span class="params">nr</span>, <span class="params">adap</span>-&gt;<span class="params">nr</span> + 1, GFP_KERNEL)</span>;</span><br><span class="line">    mutex<span class="constructor">_unlock(&amp;<span class="params">core_lock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">WARN(<span class="params">id</span> &lt; 0, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>)</span>)</span><br><span class="line">        return id<span class="operator"> == </span>-ENOSPC ? -EBUSY : id;</span><br><span class="line"></span><br><span class="line">    return i2c<span class="constructor">_register_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到其实是调用了内核提供 i2c_register_adapter 函数来进行注册，来看看它干了什么</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    int res = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!is_registered)) &#123;	<span class="comment">//检查adap是否已经注册，防止存重复注册</span></span><br><span class="line">        res = -EAGAIN;</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity checks */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (WARN(!adap-&gt;</span><span class="keyword">name</span>[<span class="number">0</span>], <span class="string">&quot;i2c adapter has no name&quot;</span>)) <span class="comment">//检查 i2c_adapter 的名字，没有名字直接返回</span></span><br><span class="line">        goto out_list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!adap-&gt;</span>algo) &#123;	<span class="comment">// i2c_adapter检查是否有发送接收函数，没有直接返回</span></span><br><span class="line">        <span class="function"><span class="title">pr_err</span>(&quot;adapter &#x27;%s&#x27;: no algo supplied!\n&quot;, adap-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!adap-&gt;</span>lock_ops)</span><br><span class="line">        <span class="function"><span class="title">adap</span>-&gt;</span>lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">rt_mutex_init</span>(&amp;adap-&gt;</span>bus_lock);</span><br><span class="line">    <span class="function"><span class="title">rt_mutex_init</span>(&amp;adap-&gt;</span>mux_lock);</span><br><span class="line">    <span class="function"><span class="title">mutex_init</span>(&amp;adap-&gt;</span>userspace_clients_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;<span class="function"><span class="title">adap</span>-&gt;</span>userspace_clients);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (adap-&gt;</span>timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="function"><span class="title">adap</span>-&gt;</span>timeout = HZ; <span class="comment">//设置如果没设置超时时间则，默认超时时间为1s</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_set_name</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, &quot;i2c-%d&quot;, adap-&gt;</span><span class="function"><span class="title">nr</span>); // 设置 adap-&gt;</span>dev 的名字i2c-<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="title">adap</span>-&gt;</span>dev.bus = &amp;i2c_bus_type; <span class="comment">//设置总线</span></span><br><span class="line">    <span class="function"><span class="title">adap</span>-&gt;</span>dev.type = &amp;i2c_adapter_type;	<span class="comment">//设置 adapter 的设备类型</span></span><br><span class="line">    <span class="function"><span class="title">res</span> = device_register(&amp;adap-&gt;</span>dev); <span class="comment">// 向 i2c_bus_type 总线注册adapter设备 ，将生成 /sys/devices/11007000.i2c0/i2c-0 节点</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="function"><span class="title">pr_err</span>(&quot;adapter &#x27;%s&#x27;: can&#x27;t register device (%d)\n&quot;, adap-&gt;</span><span class="keyword">name</span>, res);</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, &quot;adapter [%s] registered\n&quot;, adap-&gt;</span><span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 电源相关忽略 */</span></span><br><span class="line">    <span class="function"><span class="title">pm_runtime_no_callbacks</span>(&amp;adap-&gt;</span>dev);</span><br><span class="line">    <span class="function"><span class="title">pm_suspend_ignore_children</span>(&amp;adap-&gt;</span>dev, <span class="literal">true</span>);</span><br><span class="line">    <span class="function"><span class="title">pm_runtime_enable</span>(&amp;adap-&gt;</span>dev);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    <span class="function"><span class="title">res</span> = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;</span>dev,</span><br><span class="line">                       <span class="function"><span class="title">adap</span>-&gt;</span>dev.parent);</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        <span class="function"><span class="title">dev_warn</span>(&amp;adap-&gt;</span>dev,</span><br><span class="line">             <span class="string">&quot;Failed to create compatibility class link\n&quot;</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    i2c_init_recovery(adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    of_i2c_register_devices(adap); <span class="comment">//遍历设备节点注册对应的 client</span></span><br><span class="line">    i2c_acpi_register_devices(adap); <span class="comment">//百度了一下说acpi是电源管理相关的东西，那就先不管</span></span><br><span class="line">    i2c_acpi_install_space_handler(adap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (adap-&gt;</span>nr &lt; __i2c_first_dynamic_bus_num) </span><br><span class="line">        i2c_scan_static_board_info(adap); <span class="comment">//老的方式注册adap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify drivers */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    <span class="function"><span class="title">idr_remove</span>(&amp;i2c_adapter_idr, adap-&gt;</span>nr);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数对adapte进行了一些错误检查，并进一步对它进行初始化，并将其注册进i2c总线，该函数还会调用 of_i2c_register_devices 创建 dts中对应的 i2c 设备相关的 i2c_client，看看它怎么做的。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">static void of_i2c_register_devices(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    struct device_node *bus, *<span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    struct</span> i2c_client *client;</span><br><span class="line"></span><br><span class="line">    /* Only register child devices if the adapter has a <span class="keyword">node</span> <span class="title">pointer</span> set */</span><br><span class="line">    if (!adap-&gt;dev.of_node) //检测设备节点是否存在</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: walking child nodes\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bus = of_get_child_by_name(adap-&gt;dev.of_node, <span class="string">&quot;i2c-bus&quot;</span>); //mtk平台这个i2c-bus设备节点并不存在。</span><br><span class="line">    if (!bus)</span><br><span class="line">        bus = of_node_get(adap-&gt;dev.of_node); //直接返回i2c0设备节点，在前面被初始化</span><br><span class="line"></span><br><span class="line">    for_each_available_child_of_node(bus, <span class="keyword">node</span><span class="title">) &#123; //遍历 i2c0</span>的设备节点下的子节点</span><br><span class="line">        if (of_node_test_and_set_flag(<span class="keyword">node</span><span class="title">, OF_POPULATED</span>))</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        client = of_i2c_register_device(adap, <span class="keyword">node</span><span class="title">); //对于子节点执行这个函数</span></span><br><span class="line"><span class="title">        if</span> (IS_ERR(client)) &#123;</span><br><span class="line">            dev_warn(&amp;adap-&gt;dev,</span><br><span class="line">                 <span class="string">&quot;Failed to create I2C device for %s\n&quot;</span>,</span><br><span class="line">                 <span class="keyword">node</span><span class="title">-&gt;full_name</span>);</span><br><span class="line">            of_node_clear_flag(<span class="keyword">node</span><span class="title">, OF_POPULATED</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    of_node_put(bus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就是检测adap的硬件总线控制器设备节点是否存在，如果存在则对该总线节点的每一个子节点执行 of_i2c_register_device 函数，来看看它干了什么。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i2c0的子节点</span></span><br><span class="line">&amp;i2c0 &#123;</span><br><span class="line">    cap_touch@<span class="number">24</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;mediatek,cap_touch&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x24</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;pio&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">0</span> IRQ_TYPE_EDGE_FALLING <span class="number">0</span> <span class="number">0</span>&gt;;</span><br><span class="line">        int-gpio = &lt;&amp;pio <span class="number">0</span> <span class="number">0</span>&gt;;</span><br><span class="line">        rst-gpio = &lt;&amp;pio <span class="number">174</span> <span class="number">0</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *of_i2c_register_device(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span></span> *adap,</span><br><span class="line">                         <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *result;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span></span> info = &#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span></span> dev_ad = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> __be32 *addr_be;</span><br><span class="line">    <span class="built_in">u32</span> addr;</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: register %s\n&quot;</span>, node-&gt;full_name);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取节点下的 compatible 字段逗号后面的字符串，如果没有逗号则获取 compatible 字段的字符串，</span></span><br><span class="line">    这里将返回 cap_touch 并将其存入 info.<span class="keyword">type</span></span><br><span class="line">    <span class="keyword">if</span> (of_modalias_node(node, info.<span class="keyword">type</span>, sizeof(info.<span class="keyword">type</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: modalias failure on %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取reg描述&quot;0x24&quot;，即设备地址</span></span><br><span class="line">    addr_be = of_get_property(node, <span class="string">&quot;reg&quot;</span>, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!addr_be || (len &lt; sizeof(*addr_be))) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: invalid reg on %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = be32_to_cpup(addr_be); <span class="comment">//将其转化为16进制的0x24</span></span><br><span class="line">    <span class="keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">        addr &amp;= ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">        info.flags |= I2C_CLIENT_TEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123; <span class="comment">//地址检测</span></span><br><span class="line">        addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">        info.flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i2c_check_addr_validity(addr, info.flags)) &#123; <span class="comment">//地址检测</span></span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: invalid addr=%x on %s\n&quot;</span>,</span><br><span class="line">            addr, node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.addr = addr; <span class="comment">//初始化 i2c_board_info 结构地址</span></span><br><span class="line">    info.of_node = of_node_get(node); <span class="comment">//初始化设备节点为i2c0</span></span><br><span class="line">    info.archdata = &amp;dev_ad; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_get_property(node, <span class="string">&quot;wakeup-source&quot;</span>, NULL))</span><br><span class="line">        info.flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">    result = i2c_new_device(adap, &amp;info); <span class="comment">//创建并注册一个i2c_client,即注册一个新的i2c设备。</span></span><br><span class="line">    <span class="keyword">if</span> (result == NULL) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: Failure registering %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数创建了一个局部的i2c_board_info结构，从dts中获取到i2c子设备相关信息并将其初始化之后，将作为参数用于创建i2c_client,看看i2c_new_device怎么创建一个新的i2c设备。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">struct i2c_client *</span><br><span class="line">i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client;</span><br><span class="line">    int         status;</span><br><span class="line"></span><br><span class="line">    client = kzalloc(sizeof *client, GFP_KERNEL); <span class="comment">//动态创建一个client结构</span></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>adapter = adap; <span class="comment">//初始化adapter成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.platform_data = info-&gt;</span>platform_data; <span class="comment">// 初始化platform_data成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (info-&gt;</span>archdata)</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.archdata = *info-&gt;</span>archdata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">flags</span> = info-&gt;</span>flags; <span class="comment">//初始化flag成员</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">addr</span> = info-&gt;</span>addr;	 <span class="comment">//初始化设备地址</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">irq</span> = info-&gt;</span>irq;	 <span class="comment">//初始化中断引脚，这里没有初始化，也会在i2c_device_probe中重新，获取相关的中断号。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(client-&gt;</span><span class="function"><span class="title">name</span>, info-&gt;</span><span class="function"><span class="title">type</span>, sizeof(client-&gt;</span><span class="function"><span class="title">name</span>)); //设置<span class="keyword">name</span>为info-&gt;</span>type，即设置为前面获取的cap_touch，这个名字非常重要，因为驱动匹配将使用这个名字。</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">status</span> = i2c_check_addr_validity(client-&gt;</span><span class="function"><span class="title">addr</span>, client-&gt;</span>flags);	<span class="comment">//检测i2c地址</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">            <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">flags</span> &amp; I2C_CLIENT_TEN ? 10 : 7, client-&gt;</span>addr);</span><br><span class="line">        goto out_err_silent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for address business */</span></span><br><span class="line">    status = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto out_err;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.parent = &amp;client-&gt;</span><span class="function"><span class="title">adapter</span>-&gt;</span>dev; <span class="comment">//设置设备父节点</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>dev.bus = &amp;i2c_bus_type; <span class="comment">//设置总线为i2c总线</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>dev.type = &amp;i2c_client_type; <span class="comment">//设置设备类型</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.of_node = info-&gt;</span>of_node; <span class="comment">//设置设备节点为i2c0</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.fwnode = info-&gt;</span>fwnode; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * dev_set_name(&amp;client-&gt;dev, &quot;%d-%04x&quot;, i2c_adapter_id(adap), i2c_encode_flags_to_addr(client));</span></span><br><span class="line"><span class="comment">     * 设置设备名字为 0-0024 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i2c_dev_set_name(adap, client); </span><br><span class="line">    <span class="function"><span class="title">status</span> = device_register(&amp;client-&gt;</span>dev); <span class="comment">//将设备注册进入bus总线，同时会生成节点 /sys/devices/11007000.i2c0/i2c-0/0-0024</span></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto out_err;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span>dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">name</span>, dev_name(&amp;client-&gt;</span>dev));</span><br><span class="line"></span><br><span class="line">    return client;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">    <span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev,</span><br><span class="line">        <span class="string">&quot;Failed to register i2c client %s at 0x%02x (%d)\n&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">name</span>, client-&gt;</span>addr, status);</span><br><span class="line">out_err_silent:</span><br><span class="line">    kfree(client);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止就完成了i2c0节点下的cap_touch的设备注册，of_i2c_register_devices函数会遍历i2c0节点下的子节点并依次进行注册。</p>
<p>最后在来对整个注册流程进行一个梳理，对应前面的框图，对于mtk平台对每一个i2c总线节点都会注册一个adapter，在adapter注册的时候后会遍历子节点下的每个i2c设备并创建对应的i2c设备结构client。而在创建过程中会用到一个中间结构 i2c_board_info，它用于描述i2c设备的硬件信息，在注册完成之后就被释放掉。</p>
<h2 id="2、通过总线号添加i2c设备"><a href="#2、通过总线号添加i2c设备" class="headerlink" title="2、通过总线号添加i2c设备"></a>2、通过总线号添加i2c设备</h2><p>这种方法适用于许多I2C总线是系统总线的嵌入式系统。 在这样的系统上，每个I2C总线都有一个事先已知的编号。 因此可以预先声明该总线上的I2C设备。 这是通过调用i2c_register_board_info（）注册的struct i2c_board_info数组完成的，在没有dts之前使用的就是这种方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_BOARD_INFO(dev_type, dev_addr) \</span></span><br><span class="line">    .type = dev_type, .addr = (dev_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct i2c_board_info h4_i2c_board_info[] __initdata = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;isp1301_omap&quot;</span>, <span class="number">0x2d</span>),</span><br><span class="line">        .irq        = OMAP_GPIO_IRQ(<span class="number">125</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;   <span class="comment">/* EEPROM on mainboard */</span></span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;24c01&quot;</span>, <span class="number">0x52</span>),</span><br><span class="line">        .platform_data  = &amp;m24c01,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;   <span class="comment">/* EEPROM on cpu card */</span></span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;24c01&quot;</span>, <span class="number">0x57</span>),</span><br><span class="line">        .platform_data  = &amp;m24c01,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">omap_h4_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (...)</span><br><span class="line">    i2c_register_board_info(<span class="number">1</span>, h4_i2c_board_info,</span><br><span class="line">            ARRAY_SIZE(h4_i2c_board_info));</span><br><span class="line">    (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在I2C总线1上声明了3个设备，包括它们各自的地址和其驱动程序所需的自定义数据。 注册I2C总线查询后，I2C内核将自动实例化I2C设备。以s3c2410为例进行分析,代码路径：drivers/i2c/busses/i2c-s3c2410.c</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static int s3c24xx_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c24xx_i2c *i2c;</span><br><span class="line">    struct s3c2410_platform_i2c *pdata = NULL;</span><br><span class="line">    struct resource *res;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(i2c-&gt;</span><span class="function"><span class="title">adap</span>.<span class="keyword">name</span>, &quot;s3c2410-i2c&quot;, sizeof(i2c-&gt;</span>adap.<span class="keyword">name</span>));</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo = &amp;s3c24xx_i2c_algorithm; </span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.retries = <span class="number">2</span>; <span class="comment">//初始化重复次数</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.class = I2C_CLASS_DEPRECATED; <span class="comment">//不支持自动检测</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>tx_setup = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo_data = i2c;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.parent = &amp;pdev-&gt;</span>dev; <span class="comment">//初始化父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.nr = i2c-&gt;</span><span class="function"><span class="title">pdata</span>-&gt;</span>bus_num;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.of_node = pdev-&gt;</span>dev.of_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ret</span> = i2c_add_numbered_adapter(&amp;i2c-&gt;</span>adap); <span class="comment">//注册adapter</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">pm_runtime_disable</span>(&amp;pdev-&gt;</span>dev);</span><br><span class="line">        s3c24xx_i2c_deregister_cpufreq(i2c);</span><br><span class="line">        <span class="function"><span class="title">clk_unprepare</span>(i2c-&gt;</span>clk);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>同样是初始化adapter相关参数并向内核注册adapter</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">        i2c_register_adapter</span><br></pre></td></tr></table></figure>
<p>最后还是调用 i2c_register_adapter 这个函数来看看这种方式调用的是什么函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_register_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">        i2c<span class="constructor">_scan_static_board_info(<span class="params">adap</span>)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于前面已经分析过这个函数，就直接给出关键代码，在这句代码中发现一个参数 __i2c_first_dynamic_bus_num 这是一个内核创建的全来表示当前局整型变量用的i2c总线的数量，这个机制的一个特点就是i2c总线的数量是由设备注册的时候添加的。它是什么时候添加的呢？先往下看</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">static void i2c_scan_static_board_info(<span class="name">struct</span> i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_devinfo  *devinfo<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    down_read(<span class="name">&amp;__i2c_board_lock</span>)<span class="comment">;</span></span><br><span class="line">    list_for_each_entry(<span class="name">devinfo</span>, <span class="symbol">&amp;__i2c_board_list</span>, list) &#123;</span><br><span class="line">        if (<span class="name">devinfo-&gt;busnum</span> == adapter-&gt;nr</span><br><span class="line">                <span class="symbol">&amp;&amp;</span> !i2c_new_device(<span class="name">adapter</span>,</span><br><span class="line">                        <span class="symbol">&amp;devinfo-&gt;board_info</span>))</span><br><span class="line">            dev_err(<span class="name">&amp;adapter-&gt;dev</span>,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create device at 0x%02x\n&quot;</span>,</span><br><span class="line">                devinfo-&gt;board_info.addr)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    up_read(<span class="name">&amp;__i2c_board_lock</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个函数很简单，就是遍历 __i2c_board_list 链表，找到其中挂接在 adapter-&gt;nr 上的设备, 然后使用它的设备信息调用 i2c_new_device 创建一个 i2c_client 设备。 设备信息是通过 i2c_register_board_info 注册的，来看一下这个函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_register_board_info(<span class="params">int</span> <span class="params">busnum</span>, <span class="params">struct</span> <span class="params">i2c_board_info</span> <span class="params">const</span> <span class="operator">*</span><span class="params">info</span>, <span class="params">unsigned</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line"></span><br><span class="line">    down<span class="constructor">_write(&amp;<span class="params">__i2c_board_lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;i2c_register_board_info busnum = %d\n&quot;</span>,busnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dynamic bus numbers will be assigned after the last static one */</span></span><br><span class="line">    <span class="keyword">if</span> (busnum &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">        __i2c_first_dynamic_bus_num = busnum + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (status = <span class="number">0</span>; len; len--, info++) &#123;</span><br><span class="line">        <span class="keyword">struct</span> i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">        devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!devinfo) &#123;</span><br><span class="line">            pr<span class="constructor">_debug(<span class="string">&quot;i2c-core: can&#x27;t register boardinfo!\n&quot;</span>)</span>;</span><br><span class="line">            status = -ENOMEM;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devinfo-&gt;busnum = busnum;</span><br><span class="line">        devinfo-&gt;board_info = *info;</span><br><span class="line">        <span class="built_in">list</span><span class="constructor">_add_tail(&amp;<span class="params">devinfo</span>-&gt;<span class="params">list</span>, &amp;<span class="params">__i2c_board_list</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    up<span class="constructor">_write(&amp;<span class="params">__i2c_board_lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看见这个函数的功能很简单，当前 busnum 大于 __i2c_first_dynamic_bus_num 则更新 __i2c_first_dynamic_bus_num ，总线数量其实是在添加设备信息的时候添加的。当添加了设备信息之后将该设备信息链接到 __i2c_board_list 全局链表，__i2c_board_list 维护着由 i2c_register_board_info 注册的设备信息。</p>
<blockquote>
<p><strong>整个过程分为两步：</strong></p>
<ol>
<li>首先 arch/arm/mach-xxx 文件调用 i2c_register_board_info 函数 先向 __i2c_board_list 链表添加板子上的设备信息</li>
<li>然后在调用 drivers/i2c/busses/i2c-xxx 文件向内核注册创建并初始化adapter结构并注册进内核，在内核中遍历 __i2c_board_list 使用挂接在对应adapter上的设备信息 i2c_devinfo-&gt;info 创建出对应的i2c_client,调用流程如下:</li>
</ol>
</blockquote>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span> ---&gt;</span></span><br><span class="line">        <span class="function"><span class="title">i2c_register_adapter</span> ---&gt;</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (adap-&gt;</span>nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">                <span class="function"><span class="title">i2c_scan_static_board_info</span>(adap); ---&gt;</span></span><br><span class="line">                    <span class="function"><span class="title">if</span> (devinfo-&gt;</span><span class="function"><span class="title">busnum</span> == adapter-&gt;</span><span class="function"><span class="title">nr</span> &amp;&amp; !i2c_new_device(adapter, &amp;devinfo-&gt;</span>board_info))</span><br></pre></td></tr></table></figure>
<h2 id="3、动态添加i2c设备"><a href="#3、动态添加i2c设备" class="headerlink" title="3、动态添加i2c设备"></a>3、动态添加i2c设备</h2><p>前面的两种方式都是静态的方式添加的，就是在内核加载之前先提供i2c设备信息，在加载的时候创建，而内核也提供了动态加载的方法。一个个典型的例子是电视适配器。它们通常是通过I2C总线连接到主芯片的调谐器，视频解码器，音频解码器等。 由于不会事先知道I2C总线的编号，因此无法使用上述方法1和2。 </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="keyword">struct</span> i2c_board_info sfe4001_hwmon_info = &#123;</span><br><span class="line">    <span class="constructor">I2C_BOARD_INFO(<span class="string">&quot;max6647&quot;</span>, 0x4e)</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sfe4001<span class="constructor">_init(<span class="params">struct</span> <span class="params">efx_nic</span> <span class="operator">*</span><span class="params">efx</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    efx-&gt;board_info.hwmon_client =</span><br><span class="line">        i2c<span class="constructor">_new_device(&amp;<span class="params">efx</span>-&gt;<span class="params">i2c_adap</span>, &amp;<span class="params">sfe4001_hwmon_info</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个方式自己创建出一个 i2c_board_info 结构，并直接调用函数 i2c_new_device 创建一个i2c_client.上面的代码实例化了所讨论的网络适配器上I2C总线上的1个I2C设备，这个方式是动态的添加一个 i2c_client 的方式，使用这个方式的原因是我们事先不知道，我们的设备会挂在哪个i2c总线上。这种情况下还有一种可能就是我们不知道，总线上是否存在这样一个设备，我们想在创建前先检测这个总线是否存在这个设备于是可以使用下面的方式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static const unsigned short normal_i2c<span class="literal">[]</span> = &#123; <span class="number">0x2c</span>, <span class="number">0x2d</span>, I2C_CLIENT_END &#125;;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> usb<span class="constructor">_hcd_nxp_probe(<span class="params">struct</span> <span class="params">platform_device</span> <span class="operator">*</span><span class="params">pdev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *i2c_adap;</span><br><span class="line">    <span class="keyword">struct</span> i2c_board_info i2c_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    i2c_adap = i2c<span class="constructor">_get_adapter(2)</span>;</span><br><span class="line">    memset(&amp;i2c_info, <span class="number">0</span>, sizeof(<span class="keyword">struct</span> i2c_board_info));</span><br><span class="line">    strlcpy(i2c_info.<span class="keyword">type</span>, <span class="string">&quot;isp1301_nxp&quot;</span>, I2C_NAME_SIZE);</span><br><span class="line">    isp1301_i2c_client = i2c<span class="constructor">_new_probed_device(<span class="params">i2c_adap</span>, &amp;<span class="params">i2c_info</span>, <span class="params">normal_i2c</span>, NULL)</span>;</span><br><span class="line">    i2c<span class="constructor">_put_adapter(<span class="params">i2c_adap</span>)</span>;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在所讨论的OHCI适配器上的I2C总线上最多实例化1个I2C设备。 它首先尝试在地址0x2c处进行尝试，如果在该位置未找到任何内容，则尝试在地址0x2d中进行处理，如果仍然找不到任何内容，则放弃。这里面有个关键函数 i2c_new_probed_device 来看看这个函数的实现原理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_client *</span><br><span class="line">i2c_new_probed_device(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">              <span class="keyword">struct</span> i2c_board_info *info,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">const</span> *addr_list,</span><br><span class="line">              <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> i2c_adapter *, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!probe)</span><br><span class="line">        probe = i2c_default_probe; <span class="comment">//如果没有probe则使用内核默认的i2c检测函数，这个函数检测当前总线上的设备是否存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; addr_list[i] != I2C_CLIENT_END; i++) &#123;</span><br><span class="line">        <span class="comment">/* Check address validity */</span></span><br><span class="line">        <span class="keyword">if</span> (i2c_check_7bit_addr_validity_strict(addr_list[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dev_warn(&amp;adap-&gt;dev, <span class="string">&quot;Invalid 7-bit address 0x%02x\n&quot;</span>,</span><br><span class="line">                 addr_list[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check address availability (7 bit, no need to encode flags) */</span></span><br><span class="line">        <span class="keyword">if</span> (i2c_check_addr_busy(adap, addr_list[i])) &#123;</span><br><span class="line">            dev_dbg(&amp;adap-&gt;dev,</span><br><span class="line">                <span class="string">&quot;Address 0x%02x already in use, not probing\n&quot;</span>,</span><br><span class="line">                addr_list[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Test address responsiveness */</span></span><br><span class="line">        <span class="keyword">if</span> (probe(adap, addr_list[i])) <span class="comment">//检测当前总线上的设i2c备是否存在。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr_list[i] == I2C_CLIENT_END) &#123;</span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;Probing failed, no device found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;addr = addr_list[i];</span><br><span class="line">    <span class="keyword">return</span> i2c_new_device(adap, info); <span class="comment">//创建i2c_client</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数的功能就是向当前总线上的i2c设备发送一个i2c信息，看看设备是否应答，用来判断是否存在i2c设备 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i2c_default_probe(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">union</span> i2c_smbus_data dummy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0x73</span> &amp;&amp; (adap-&gt;<span class="keyword">class</span> &amp; I2C_CLASS_HWMON)</span><br><span class="line">     &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_BYTE_DATA, &amp;dummy);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!((addr &amp; ~<span class="number">0x07</span>) == <span class="number">0x30</span> || (addr &amp; ~<span class="number">0x0f</span>) == <span class="number">0x50</span>)</span><br><span class="line">     &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_WRITE, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_QUICK, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_BYTE, &amp;dummy);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_warn(&amp;adap-&gt;dev, <span class="string">&quot;No suitable probing method supported for address 0x%02X\n&quot;</span>,</span><br><span class="line">             addr);</span><br><span class="line">        err = -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、动态探测I2C总线添加i2c设备"><a href="#4、动态探测I2C总线添加i2c设备" class="headerlink" title="4、动态探测I2C总线添加i2c设备"></a>4、动态探测I2C总线添加i2c设备</h2><p>有时没有足够的有关I2C设备的信息，甚至无法调用i2c_new_probed_device（）。典型的情况是PC主板上的硬件监视芯片。有几十种模型，它们可以存在于25个不同的地址。鉴于那里有大量的主板，几乎不可能建立一个完整的硬件监控芯片清单。幸运的是，这些芯片中的大多数都有制造商和设备ID寄存器，因此可以通过探测来识别它们。也就是我们的detect内核中的机制了。<strong>在这种情况下，既不声明也不显式实例化I2C设备。取而代之的是，i2c-core会在加载驱动程序后立即探测此类设备，如果找到了驱动程序，则会自动实例化I2C设备</strong>。<font color = red><strong>这也就是 adapter 中 class 成员变量的作用了，内核在加载驱动时会使用驱动提供的地址链表 i2c_driver-&gt;address_list，自动去具有同类 class 的 adapter 上探测这个链表上的地址，如果探测到了则实例化驱动</strong></font></p>
<p>为了防止此机制的任何不当行为，适用以下限制：</p>
<ol>
<li>I2C设备驱动程序必须实现detect（）方法，该方法通过从任意寄存器读取来识别支持的设备。</li>
<li>仅对可能具有受支持设备并同意进行探测的总线进行探测。例如，这避免了在电视适配器上探测硬盘监控芯片的麻烦。<br>例：请参阅drivers/hwmon/lm90.c中的lm90_driver和lm90_detect（）</li>
</ol>
<p>那些熟悉2.4内核和早期2.6内核的i2c子系统的人会发现，此方法本质上与此处所做的相似。两个重要区别是：</p>
<ol>
<li>探测只是现在实例化I2C设备的一种方法，而那是那时的唯一方法。<strong>在可能的情况下，应首选方法1、2、3。方法4仅应在没有其他方法的情况下使用，因为它可能会产生不良的副作用。</strong></li>
<li>I2C总线必须明确地说明哪些I2C驱动程序类可以对其进行探测（通过类位域），<strong>而所有I2C总线默认情值为空类，这意味着不进行探测。类位域的目的是限制上述不希望的副作用。</strong></li>
</ol>
<p><font color=red><strong>再一次声明，应尽可能避免使用方法4。显式设备实例化（方法1、2、3）是更可取的，因为它更安全，更快捷。</strong></font></p>
<p>由于内核不推荐使用这种方式就不详细分析了给出调用流程就行了，感兴趣跟着调用流程看看</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span> ---&gt;</span></span><br><span class="line">        <span class="function"><span class="title">i2c_register_adapter</span> ---&gt;</span></span><br><span class="line">            <span class="function"><span class="title">bus_for_each_drv</span>(&amp;i2c_bus_type, NULL, adap, __process_new_adapter); ---&gt;</span></span><br><span class="line">                <span class="function"><span class="title">i2c_do_add_adapter</span> ---&gt;</span></span><br><span class="line">                    <span class="function"><span class="title">i2c_detect</span> ---&gt;</span></span><br><span class="line">                        <span class="function"><span class="title">i2c_detect_address</span> ---&gt;</span></span><br><span class="line">                            i2c_default_probe <span class="comment">//判断设备是否在这个总线上</span></span><br><span class="line">                            <span class="function"><span class="title">driver</span>-&gt;</span>detect(temp_client, &amp;info); <span class="comment">//调用这个函数，在这个函数和设备通信，获取到设备信息，完善info中的信息。</span></span><br><span class="line">                            i2c_new_device <span class="comment">//创建i2c_client</span></span><br><span class="line">                            <span class="function"><span class="title">list_add_tail</span>(&amp;client-&gt;</span><span class="function"><span class="title">detected</span>, &amp;driver-&gt;</span>clients); <span class="comment">// 将设备链接到 clients</span></span><br></pre></td></tr></table></figure>
<p>这种方式适用于不知道设备被挂在哪个总线上的情况，通过遍历所有的总线，去判断设备是否在总线上,如果存在则调用 driver-&gt;detect 进一步获取设备信息，用于完善info结构，如果设备信息完善则创建 i2c_client。</p>
<h2 id="5、从用户空间添加i2c设备"><a href="#5、从用户空间添加i2c设备" class="headerlink" title="5、从用户空间添加i2c设备"></a>5、从用户空间添加i2c设备</h2><p>通常，内核应该知道连接了哪些I2C设备以及它们位于什么地址。但是，在某些情况下却没有，因此添加了sysfs接口以让用户提供信息。该接口由2个属性文件组成，new_device和delete_device。这两个文件都是只写的，并且必须为它们写正确的参数，以便正确地创建或删除I2C设备。</p>
<p><strong>创建一个i2c设备</strong><br>文件 new_device 用于创建一个i2c设备，具有2个参数：I2C设备的名称（字符串）和I2C设备的地址（一个数字，通常以十六进制表示，以0x开头，但也可以以十进制表示。）例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo eeprom <span class="number">0</span>x50&gt;<span class="regexp">/sys/</span>bus<span class="regexp">/i2c/</span>devices<span class="regexp">/i2c-3/</span>new_device</span><br></pre></td></tr></table></figure>
<p><strong>删除一个i2c设备</strong><br>文件delete_device，用于删除一个i2c设备，具有一个参数：I2C设备的地址。由于在给定的I2C网段上没有两个设备可以住在同一地址，因此该地址足以唯一地标识要删除的设备。例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo <span class="number">0</span>x50&gt;<span class="regexp">/sys/</span>bus<span class="regexp">/i2c/</span>devices<span class="regexp">/i2c-3/</span>delete_device</span><br></pre></td></tr></table></figure>
<p>来看看内核的实现</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> =</span> to_i2c_adapter(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *blank, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct i2c_board_info));</span><br><span class="line"></span><br><span class="line">    blank = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!blank) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Missing parameters\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blank - buf &gt; I2C_NAME_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Invalid device name\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(info.type, buf, blank - buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse remaining parameters, reject extra parameters */</span></span><br><span class="line">    res = <span class="built_in">sscanf</span>(++blank, <span class="string">&quot;%hi%c&quot;</span>, &amp;info.addr, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t parse I2C address\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; <span class="built_in">end</span> != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Extra parameters\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((info.addr &amp; I2C_ADDR_OFFSET_TEN_BIT) == I2C_ADDR_OFFSET_TEN_BIT) &#123;</span><br><span class="line">        info.addr &amp;= ~I2C_ADDR_OFFSET_TEN_BIT;</span><br><span class="line">        info.flags |= I2C_CLIENT_TEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.addr &amp; I2C_ADDR_OFFSET_SLAVE) &#123;</span><br><span class="line">        info.addr &amp;= ~I2C_ADDR_OFFSET_SLAVE;</span><br><span class="line">        info.flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client = i2c_new_device(adap, &amp;info);</span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep track of the added device */</span></span><br><span class="line">    mutex_lock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    list_add_tail(&amp;client-&gt;detected, &amp;adap-&gt;userspace_clients);</span><br><span class="line">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    dev_info(dev, <span class="string">&quot;%s: Instantiated device %s at 0x%02hx\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>,</span><br><span class="line">         info.type, info.addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(new_device, S_IWUSR, <span class="literal">NULL</span>, i2c_sysfs_new_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">i2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> =</span> to_i2c_adapter(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> addr;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse parameters, reject extra parameters */</span></span><br><span class="line">    res = <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%hi%c&quot;</span>, &amp;addr, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t parse I2C address\n&quot;</span>, <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; <span class="built_in">end</span> != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Extra parameters\n&quot;</span>, <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the device was added through sysfs */</span></span><br><span class="line">    res = -ENOENT;</span><br><span class="line">    mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class="line">              i2c_adapter_depth(adap));</span><br><span class="line">    list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class="line">                 detected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i2c_encode_flags_to_addr(client) == addr) &#123;</span><br><span class="line">            dev_info(dev, <span class="string">&quot;%s: Deleting device %s at 0x%02hx\n&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;delete_device&quot;</span>, client-&gt;name, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">            list_del(&amp;client-&gt;detected);</span><br><span class="line">            i2c_unregister_device(client);</span><br><span class="line">            res = count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t find device in list\n&quot;</span>,</span><br><span class="line">            <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR_IGNORE_LOCKDEP</span><span class="params">(delete_device, S_IWUSR, <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   i2c_sysfs_delete_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">i2c_adapter_attrs</span>[] =</span> &#123;</span><br><span class="line">    &amp;dev_attr_name.attr,</span><br><span class="line">    &amp;dev_attr_new_device.attr,</span><br><span class="line">    &amp;dev_attr_delete_device.attr,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line">ATTRIBUTE_GROUPS(i2c_adapter);</span><br></pre></td></tr></table></figure>
<p>可以看见其实很简单，就是获取初入的name和addr动态初始化一个info，然后利用 new_device 函数创建一个i2c_client ，这种方式和方式2是一样的，只是将方式2开放给用户空间一个接口。</p>
<h2 id="6、acpi方式添加"><a href="#6、acpi方式添加" class="headerlink" title="6、acpi方式添加"></a>6、acpi方式添加</h2><p>参考: kernel-4.9/Documentation/acpi/enumeration.txt.</p>
<h1 id="三、获取-i2c-client-结构"><a href="#三、获取-i2c-client-结构" class="headerlink" title="三、获取 i2c_client 结构"></a>三、获取 i2c_client 结构</h1><p>有了具体的设备结构 i2c_client, 我们要怎么用呢，比如我想向i2c0上的 cap_touch 发送数据，怎么获取到对应的 i2c_client 结构呢？很简单因为 i2c_client 被挂接到了 i2c 总线上，因此我们只需要向 i2c 总线上注册一个 i2c_driver ，并且使用要用到的 i2c_client 的name作为 i2c_driver 的 i2c_device_id-&gt;name。那么总线就会去匹配和 i2c_device_id-&gt;name 相同 name 的 i2c_client(这是i2c总线的match函数匹配规则)，匹配成功则调用driver的probe成员函数并且将i2c_client作为参数传入，这样我们就获取到了我们想要的具体的 i2c_client 设备结构。 于是想要获取到 cap_touch 的 i2c_client 的示例代码如下（代码并不完整这只是一个伪代码）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> my<span class="constructor">_i2c_probe(<span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_device_id</span> <span class="operator">*</span><span class="params">id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_probe\n&quot;</span>); </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> my<span class="constructor">_i2c_remove(<span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span> <span class="params">client</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_remove\n&quot;</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历这里数组中的 i2c_device_id.name 一个一个匹配</span></span><br><span class="line">static const <span class="keyword">struct</span> i2c_device_id my_id_table<span class="literal">[]</span> = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;cap_touch&quot;</span>, <span class="number">0</span> &#125;, <span class="comment">//通过这个名字获取到我们需要的 i2c_client 设备结构 </span></span><br><span class="line">    &#123; NULL, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">struct</span> i2c_driver my_i2c_driver = &#123;</span><br><span class="line">    .probe  = my_i2c_probe,</span><br><span class="line">    .remove = my_i2c_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">           .name = <span class="string">&quot;cap_touch&quot;</span>, <span class="comment">//驱动的name将出现在 /sys/bus/i2c/ 下</span></span><br><span class="line">           &#125;,</span><br><span class="line">	.id_table = my_id_table, <span class="comment">//匹配用到的结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> my<span class="constructor">_i2c_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i2c<span class="constructor">_add_driver(&amp;<span class="params">my_i2c_driver</span>)</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void my<span class="constructor">_i2c_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">my_i2c_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">my_i2c_exit</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>i2c_add_driver 的内部工作原理到底是怎么样的呢，看看源码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#define i2c<span class="constructor">_add_driver(<span class="params">driver</span>)</span> \</span><br><span class="line">    i2c<span class="constructor">_register_driver(THIS_MODULE, <span class="params">driver</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_register_driver(<span class="params">struct</span> <span class="params">module</span> <span class="operator">*</span><span class="params">owner</span>, <span class="params">struct</span> <span class="params">i2c_driver</span> <span class="operator">*</span><span class="params">driver</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">WARN_ON(!<span class="params">is_registered</span>)</span>)</span><br><span class="line">        return -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add the driver to the list of i2c drivers in the driver core */</span></span><br><span class="line">    driver-&gt;driver.owner = owner;</span><br><span class="line">    driver-&gt;driver.bus = &amp;i2c_bus_type; <span class="comment">//初始化总线</span></span><br><span class="line">    <span class="constructor">INIT_LIST_HEAD(&amp;<span class="params">driver</span>-&gt;<span class="params">clients</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment">     * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将驱动注册进入bus总线</span></span><br><span class="line">    res = driver<span class="constructor">_register(&amp;<span class="params">driver</span>-&gt;<span class="params">driver</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_debug(<span class="string">&quot;driver [%s] registered\n&quot;</span>, <span class="params">driver</span>-&gt;<span class="params">driver</span>.<span class="params">name</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the adapters that are already present */</span></span><br><span class="line">    <span class="comment">//对应前面提到的 动态探测I2C总线添加i2c设备 内核不推荐使用这种方式。</span></span><br><span class="line">    i2c<span class="constructor">_for_each_dev(<span class="params">driver</span>, <span class="params">__process_new_driver</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用driver_register这个函数将驱动注册进入内核时，会使用设备模型的匹配机制，和总线上的设备进行匹配。简单描述一下调用流程：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">bus_add_driver</span>----&gt;</span></span><br><span class="line">	<span class="function"><span class="title">driver_attach</span>----&gt;</span> 无论如何最终都会调用这个函数</span><br><span class="line">		<span class="function"><span class="title">bus_for_each_dev</span>----&gt;</span></span><br><span class="line">			__<span class="function"><span class="title">driver_attach</span>----&gt;</span></span><br><span class="line">				<span class="function"><span class="title">driver_match_device</span>----&gt;</span></span><br><span class="line">					<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>match(dev, drv) <span class="comment">//如果匹配成功则调用 really_probe</span></span><br><span class="line">					<span class="function"><span class="title">really_probe</span>----&gt;</span></span><br><span class="line">						<span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe(dev) <span class="comment">//默认点调用这个</span></span><br><span class="line">						<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">probe</span>(dev) //如果没有设置 dev-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe 函数，则调用这个</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终调用总线上的match函数 i2c_device_match </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_device_match(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">drv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_client   *client = i2c<span class="constructor">_verify_client(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> i2c_driver   *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">of</span><span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>) <span class="comment">//设备树方式匹配</span></span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi<span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>) <span class="comment">//先不管，后面有机会补充</span></span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    driver = <span class="keyword">to</span><span class="constructor">_i2c_driver(<span class="params">drv</span>)</span>;</span><br><span class="line">    <span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;id_table) <span class="comment">// id_table 进行匹配</span></span><br><span class="line">        return i2c<span class="constructor">_match_id(<span class="params">driver</span>-&gt;<span class="params">id_table</span>, <span class="params">client</span>)</span> != NULL;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从该函数知道，i2c总线提供了3中匹配的方式，无论是什么方式都是获取我们需要的 i2c_client 结构：</p>
<ol>
<li>使用设备树 compatible 字段进行匹配</li>
<li>acpi 方式匹配（这个用了再来补充）</li>
<li>使用 id_table方式进行匹配</li>
</ol>
<p>其中设备树方式在设备模型中已讨论，这种匹配方式只能匹配到设备树中生成的设备，而我们根本不会将 i2c_client 写到设备树中，因此这个匹配方式是匹配不到我们需要的 i2c_client 设备的，我也不知道为什么会写入这种规则，有大佬知道可以告知一下，这里讨论 id_table 方式</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *i2c_match_id(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="keyword">id</span>,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">id</span>-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strcmp(client-&gt;name, <span class="keyword">id</span>-&gt;name) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">id</span>;</span><br><span class="line">        <span class="keyword">id</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看起来很简单，就是比较 i2c_client-&gt;name 和 i2c_device_id-&gt;name 是否相同，如果相同则匹配成功，匹配成功后调用总线对应的 probe 函数 i2c_device_probe</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_device_probe(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_client   *client = i2c<span class="constructor">_verify_client(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> i2c_driver   *driver;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line">        <span class="built_in">int</span> irq = -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;of_node) &#123; <span class="comment">//更新irq</span></span><br><span class="line">            irq = <span class="keyword">of</span><span class="constructor">_irq_get_byname(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="string">&quot;irq&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (irq<span class="operator"> == </span>-EINVAL<span class="operator"> || </span>irq<span class="operator"> == </span>-ENODATA)</span><br><span class="line">                irq = <span class="keyword">of</span><span class="constructor">_irq_get(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, 0)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="constructor">ACPI_COMPANION(<span class="params">dev</span>)</span>) &#123;</span><br><span class="line">            irq = acpi<span class="constructor">_dev_gpio_irq_get(ACPI_COMPANION(<span class="params">dev</span>)</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (irq<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">            return irq;</span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">            irq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        client-&gt;irq = irq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver = <span class="keyword">to</span><span class="constructor">_i2c_driver(<span class="params">dev</span>-&gt;<span class="params">driver</span>)</span>; <span class="comment">//获取对应的 i2c_driver 结构</span></span><br><span class="line">    <span class="keyword">if</span> (!driver-&gt;probe<span class="operator"> || </span>!driver-&gt;id_table)</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_WAKE) &#123;</span><br><span class="line">        <span class="built_in">int</span> wakeirq = -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">            wakeirq = <span class="keyword">of</span><span class="constructor">_irq_get_byname(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="string">&quot;wakeup&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (wakeirq<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">                return wakeirq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        device<span class="constructor">_init_wakeup(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wakeirq &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>wakeirq != client-&gt;irq)</span><br><span class="line">            status = dev<span class="constructor">_pm_set_dedicated_wake_irq(<span class="params">dev</span>, <span class="params">wakeirq</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>)</span><br><span class="line">            status = dev<span class="constructor">_pm_set_wake_irq(<span class="params">dev</span>, <span class="params">client</span>-&gt;<span class="params">irq</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            dev<span class="constructor">_warn(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="string">&quot;failed to set up wakeup irq\n&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev<span class="constructor">_dbg(<span class="params">dev</span>, <span class="string">&quot;probe\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="keyword">of</span><span class="constructor">_clk_set_defaults(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        goto err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    status = dev<span class="constructor">_pm_domain_attach(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (status<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">        goto err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    status = driver-&gt;probe(client, i2c<span class="constructor">_match_id(<span class="params">driver</span>-&gt;<span class="params">id_table</span>, <span class="params">client</span>)</span>); <span class="comment">//最终调用i2c_driver下的probe函数，并使用 client 匹配成功的driver-&gt;id_table作为参数</span></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto err_detach_pm_domain;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_detach_pm_domain:</span><br><span class="line">    dev<span class="constructor">_pm_domain_detach(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line">err_clear_wakeup_irq:</span><br><span class="line">    dev<span class="constructor">_pm_clear_wake_irq(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>)</span>;</span><br><span class="line">    device<span class="constructor">_init_wakeup(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_device_probe 函数又根据更新了了一次 irq，并最终调用了注册的  i2c_driver 结构的 probe 成员函数。于是在 probe 函数中我们就获取到了我们需要的 i2c_client 结构。内核也提供了一个demo，参考kernel-4.9，Documentation/i2c/upgrading-clients</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span>   *client;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int example_probe(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *client,</span><br><span class="line">                 <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span></span> *id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> *state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = &amp;client-&gt;dev;</span><br><span class="line"></span><br><span class="line">    state = kzalloc(sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (state == NULL) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;failed to create our state\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;client = client;</span><br><span class="line">    i2c_set_clientdata(client, state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rest of the initialisation goes here. */</span></span><br><span class="line"></span><br><span class="line">    dev_info(dev, <span class="string">&quot;example client created\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int example_remove(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *client)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> *state = i2c_get_clientdata(client);</span><br><span class="line"></span><br><span class="line">    kfree(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span></span> example_idtable[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;example&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(i2c, example_idtable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span></span> example_driver = &#123;</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .owner      = THIS_MODULE,</span><br><span class="line">        .name       = <span class="string">&quot;example&quot;</span>,</span><br><span class="line">        .pm     = &amp;example_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table   = example_idtable,</span><br><span class="line">    .probe      = example_probe,</span><br><span class="line">    .remove     = example_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="四、使用-i2c-client-通信"><a href="#四、使用-i2c-client-通信" class="headerlink" title="四、使用 i2c_client 通信"></a>四、使用 i2c_client 通信</h1><p>获取到 i2c_client 结构之后，就可以使用它来进行i2c通信了，内核使用 i2c_msg 结构装了传输的数据，每次通讯都是以 i2c_msg 为单位的</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    <span class="variable">__u16</span> addr; 	<span class="comment">//设备地址</span></span><br><span class="line">    <span class="variable">__u16</span> flags;	<span class="comment">//传输标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD        0x0001  <span class="comment">//设置了这个表示表示本次通信为接收数据，否则为发送数据。</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">//设置了这个表示从设备地址有10bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN      0x0400  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">//在读操作中不需要ack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">//当前i2cmsg忽略i2c器件的ack和nack信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">//读写标志位反过来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">//当前i2c_msg不发送start信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    <span class="variable">__u16</span> len;      <span class="comment">//数据长度，单位为byte</span></span><br><span class="line">    <span class="variable">__u8</span> *buf;      <span class="comment">//数据缓冲区指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1、i2c-master-send"><a href="#1、i2c-master-send" class="headerlink" title="1、i2c_master_send"></a>1、i2c_master_send</h2><p>该函数用于向 i2c_client 发送buf指向的数据，数据长度为count字节</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_master_send(<span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    <span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.len = count;</span><br><span class="line">    msg.buf = (<span class="built_in">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">    ret = i2c<span class="constructor">_transfer(<span class="params">adap</span>, &amp;<span class="params">msg</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If everything went ok (i.e. 1 msg transmitted), return #bytes</span></span><br><span class="line"><span class="comment">     * transmitted, else error code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    return (ret<span class="operator"> == </span><span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL(<span class="params">i2c_master_send</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2、i2c-master-recv"><a href="#2、i2c-master-recv" class="headerlink" title="2、i2c_master_recv"></a>2、i2c_master_recv</h2><p>该函数用于向 i2c_client 接收数据长度为count字节的数据，数据被存在buf中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_master_recv(<span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    <span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.flags <span class="pattern-match">|= <span class="constructor">I2C_M_RD</span>;</span></span><br><span class="line"><span class="pattern-match">    msg.len = count;</span></span><br><span class="line"><span class="pattern-match">    msg.buf = buf;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    ret = i2c<span class="constructor">_transfer(<span class="params">adap</span>, &amp;<span class="params">msg</span>, 1)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span></span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="constructor">If</span> everything went ok (i.e. 1 msg received), return #<span class="built_in">bytes</span> received,</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="keyword">else</span> error code.</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">    return (ret <span class="operator">==</span> 1) ? count : ret;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">EXPORT_SYMBOL(<span class="params">i2c_master_recv</span>)</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、i2c-transfer"><a href="#3、i2c-transfer" class="headerlink" title="3、i2c_transfer"></a>3、i2c_transfer</h2><p>该函数向 i2c_adapter 所表示的总线上传输 num 个 msgs。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">ret</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ret</span> = 0; <span class="keyword">ret</span> &lt; num; <span class="keyword">ret</span>++) &#123;</span><br><span class="line">            dev_dbg(&amp;adap-&gt;dev,</span><br><span class="line">                <span class="string">&quot;master_xfer[%d] %c, addr=0x%02x, len=%d%s\n&quot;</span>,</span><br><span class="line">                <span class="keyword">ret</span>, (msgs[<span class="keyword">ret</span>].flags &amp; I2C_M_RD) ? &#x27;R&#x27; : &#x27;W&#x27;,</span><br><span class="line">                msgs[<span class="keyword">ret</span>].addr, msgs[<span class="keyword">ret</span>].len,</span><br><span class="line">                (msgs[<span class="keyword">ret</span>].flags &amp; I2C_M_RECV_LEN) ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_atomic() || irqs_disabled()) &#123;</span><br><span class="line">            <span class="keyword">ret</span> = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">ret</span>)</span><br><span class="line">                <span class="comment">/* I2C activity is ongoing. */</span></span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i2c_lock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ret</span> = __i2c_transfer(adap, msgs, num);</span><br><span class="line">        i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>驱动</tag>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>c++基础知识</title>
    <url>/2020/02/05/c++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>用于记录c++基础知识，后面再排版</p>
<a id="more"></a>
<h1 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a><div align=center>const 关键字</h1><h2 id="1、c-在c的基础上对const做了进化处理"><a href="#1、c-在c的基础上对const做了进化处理" class="headerlink" title="1、c++在c的基础上对const做了进化处理"></a>1、c++在c的基础上对const做了进化处理</h2><ul>
<li><strong>当碰见const声明时，在符号表中放入常量</strong></li>
<li><strong>编译过程中发现使用常量则直接以符号表中的值替换</strong></li>
<li><strong>编译过程如发现下述情况则给对应的常量分配储存空间</strong><br>&nbsp; &nbsp;&nbsp;对const全局常量使用 extern<br>&nbsp; &nbsp;&nbsp;对const常量使用 &amp; 操作符</li>
<li>*注意**<br>c++编译器虽然可能会为 const 常量分配空间，但不会使用空间中的值。<h2 id="2、符号表"><a href="#2、符号表" class="headerlink" title="2、符号表"></a>2、符号表</h2>编译器在编译的过程当中所产生的一张表，是编译器内部的数据结构<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%2B%2B/1.png" >

</li>
</ul>
<p><strong>c++中const常量类似于宏定义</strong><br>&nbsp; &nbsp;&nbsp;const int c = 5; ≈ #define c 5</p>
<h2 id="3、c-中的const与宏定义的区别"><a href="#3、c-中的const与宏定义的区别" class="headerlink" title="3、c++中的const与宏定义的区别"></a>3、c++中的const与宏定义的区别</h2><p>const 常量是<strong>被编译器处理</strong><br>编译器对const常亮进行<strong>类型检查</strong>和<strong>作用域检查</strong><br>宏定义由<strong>预处理器处理</strong>，是<strong>单纯的文本替换</strong><br>宏<strong>没有类型以及作用域的概念</strong>， const 有<strong>作用域和类型的概念</strong></p>
<h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><div align=center>布尔类型</h1><h2 id="1、占用内存"><a href="#1、占用内存" class="headerlink" title="1、占用内存"></a>1、占用内存</h2><p>一个字节</p>
<h2 id="2、取值：-true-和-false"><a href="#2、取值：-true-和-false" class="headerlink" title="2、取值： true 和 false"></a>2、取值： true 和 false</h2><p>true    ： 代表真值，编译器内部用 1 表示<br>false    ： 代表非真值，编译器内部用 0 表示<br>c++编译器会将非0值转换为 true ， 0 值转换为 false</p>
<h2 id="3、布尔类型是c-中的基础数据类型"><a href="#3、布尔类型是c-中的基础数据类型" class="headerlink" title="3、布尔类型是c++中的基础数据类型"></a>3、布尔类型是c++中的基础数据类型</h2><p>可以定义bool类型的<strong>全局变量</strong><br>可以定义bool类型的<strong>常量</strong><br>可以定义bool类型的<strong>指针</strong><br>可以定义bool类型的<strong>数组</strong><br>…</p>
<h1 id="C-中的引用"><a href="#C-中的引用" class="headerlink" title="C++中的引用"></a><div align=center>C++中的引用</h1><h2 id="1、变量名"><a href="#1、变量名" class="headerlink" title="1、变量名"></a>1、变量名</h2><p>  变量是一段实际连续存储空间的别名<br>  程序中通过变量来申请并命名存储空间<br>  通过变量的名字可以使用存储空间</p>
<h2 id="2、引用"><a href="#2、引用" class="headerlink" title="2、引用"></a>2、引用</h2><p>引用可以看作已经定义的变量的别名<br>引用的语法：type &amp; name = var ;<br>例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">int</span> &amp; b = a; 		<span class="comment">// b为a的别名</span></span><br><span class="line">b = <span class="number">5</span>;				<span class="comment">//操作b就是操作a</span></span><br></pre></td></tr></table></figure>
<p>注意：<br>&nbsp; &nbsp;普通引用在定义时必须用同类类型的变量进行初始化。</p>
<h2 id="3、引用的意义"><a href="#3、引用的意义" class="headerlink" title="3、引用的意义"></a>3、引用的意义</h2><p>引用做为变量的别名而存在,因此在一些场合可以代替指针<br>引用相对于指针了来说具有更好的可读性与实用性</p>
<p>swap函数对比</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span>					</span></span><br><span class="line"><span class="function"></span>&#123;												</span><br><span class="line">	<span class="keyword">int</span> t = a;										</span><br><span class="line">	a = b;											</span><br><span class="line">	b = t;											</span><br><span class="line">&#125;												</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = *t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：函数中的引用不需要初始化</strong></p>
<h2 id="4、特殊的引用（const引用）"><a href="#4、特殊的引用（const引用）" class="headerlink" title="4、特殊的引用（const引用）"></a>4、特殊的引用（const引用）</h2><p>在c++中可以声明const引用<br>语法：const type&amp; name = var;<br>const 引用让变量拥有只读属性</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>&amp; b = a;</span><br><span class="line"><span class="built_in">int</span>* p = (<span class="built_in">int</span>*)&amp;b;</span><br><span class="line"></span><br><span class="line">b = <span class="number">5</span>;			<span class="comment">// Error , 只读变量</span></span><br><span class="line">*p = <span class="number">5</span>;		    <span class="comment">//ok, 修改变量a的值</span></span><br></pre></td></tr></table></figure>
<p>当使用常量对const引用进行初始化时，c++编译器会为常量值分配空间，并将引用名作为这段空间的别名</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>&amp; b = <span class="number">1</span>;		<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">int</span>* p = (<span class="built_in">int</span>*) &amp;b;</span><br><span class="line">b = <span class="number">5</span>;   <span class="comment">//Error , 只读变量</span></span><br><span class="line">*p = <span class="number">5</span>;  <span class="comment">//ok , 修改变量a的值</span></span><br></pre></td></tr></table></figure>
<p>结论：使用常量对const引用初始化后将得到一个只读变量<br>思考：引用有自己的存储空间吗？(有、本质为指针)</p>
<h2 id="5、引用的本质"><a href="#5、引用的本质" class="headerlink" title="5、引用的本质"></a>5、引用的本质</h2><p>引用在c++中的内部实现是一个指针常量</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>&amp; <span class="keyword">name</span>; 	 		   </span><br><span class="line"></span><br><span class="line">void f(int&amp; a)						</span><br><span class="line"><span class="comment">&#123;											</span></span><br><span class="line"><span class="comment">	a = 5;									</span></span><br><span class="line"><span class="comment">&#125;</span>										</span><br><span class="line"></span><br><span class="line"><span class="keyword">Type</span>* <span class="keyword">const</span> <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line">void (int * <span class="keyword">const</span> a)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	*a = 5;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;1) c++编译器在编译过程中用常量指针作为内部实现，因此引用所占用的内存空间大小与指针相同。<br>&nbsp; &nbsp;&nbsp; &nbsp;2) 从使用角度，引用只是一个别名，c++为了实用性而隐藏了引用的储存空间这一细节</p>
<p>C++中的引用旨在在多数情况下代替指针<br>&nbsp; &nbsp;&nbsp; &nbsp;功能性：可以满足多数需要使用指针的场合<br>&nbsp; &nbsp;&nbsp; &nbsp;安全性：可以避开大部分由于指针操作不当而带来的内存错误<br>&nbsp; &nbsp;&nbsp; &nbsp;操作性：简单易用，又不失功能强大</p>
<p><strong>绝对不要返回动态局部变量的引用</strong></p>
<h2 id="6、三目运算符（-a-lt-b-a-b-）"><a href="#6、三目运算符（-a-lt-b-a-b-）" class="headerlink" title="6、三目运算符（ a &lt; b ? a : b ）"></a>6、三目运算符（ a &lt; b ? a : b ）</h2><p>c语言中的三目运算符返回的是变量值<strong>不能作为左值使用</strong><br>c++中三目运算符可直接返回变量本身<strong>即可作为右值，也可作为左值使用</strong></p>
<p>注意：<br>&nbsp; &nbsp;&nbsp; &nbsp;三目运算符可能返回值的值如果有一个值是常量值，则不能作为左值使用</p>
<p>总结：<br>&nbsp; &nbsp;&nbsp; &nbsp;当三目运算符的可能返回都是变量时，返回的是变量的引用<br>&nbsp; &nbsp;&nbsp; &nbsp;当三目运算符可能返回的值中有常量时，返回是变量的值</p>
<p>例子：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">int a = <span class="number">0</span>;</span><br><span class="line">int <span class="keyword">b </span>= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">( a &lt; <span class="keyword">b? </span>a : <span class="keyword">b) </span>= <span class="number">3</span><span class="comment">;	//正确，返回a或b的引用，可做左值</span></span><br><span class="line">( a &lt; <span class="keyword">b? </span>a : <span class="number">1</span>) = <span class="number">3</span><span class="comment">;	//错误，返回1或b的值，不可做左值</span></span><br></pre></td></tr></table></figure>
<h1 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a><div align=center>函数参数的默认值</h1><p>C++可以在函数声明时为参数提供一个默认值<br>当函数调用时没有提供参数的值，则使用默认值 </p>
<h2 id="1-函数默认参数的规则"><a href="#1-函数默认参数的规则" class="headerlink" title="1.函数默认参数的规则"></a>1.函数默认参数的规则</h2><p>函数默认参数指定方式</p>
<blockquote>
<p>函数参数的默认值<strong>在函数声明中指定</strong>,多使用这种方式</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数参数的默认值<strong>在函数定义中指定</strong>，很少或不建议使用</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设计函数时，参数的默认值必须从右向左提供<br>函数调用时使用了默认值，则后续参数必须使用默认值<br>调用函数时，从左向右匹配</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"> <span class="built_in">int</span> x, <span class="built_in">int</span> y = <span class="number">1</span>, <span class="built_in">int</span> z = <span class="number">2</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span>(<span class="number">0</span>);			<span class="comment">// x = 0, y = 1, z = 2</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2</span>,<span class="number">3</span>);		<span class="comment">// x = 2, y = 3, z = 2</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);		<span class="comment">// x = 3, y = 2, z = 1</span></span><br></pre></td></tr></table></figure>
<h2 id="2-函数占位参数"><a href="#2-函数占位参数" class="headerlink" title="2.函数占位参数"></a>2.函数占位参数</h2><p>在c++中可以为函数提供占位参数<br>占位参数只有参数类型声明，而没有参数申明<br>一般情况下，在函数体内部无法使用占位参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(1,2)</span>;		//<span class="title">ok</span></span></span><br></pre></td></tr></table></figure>
<p>占位参数与默认参数结合起来使用,兼容c语言程序中可能出现的不规范写法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">c: void <span class="function"><span class="title">fun</span><span class="params">()</span></span>  &lt;----&gt; c++: void <span class="function"><span class="title">fun</span><span class="params">(int = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="函数重载（Over-load）"><a href="#函数重载（Over-load）" class="headerlink" title="函数重载（Over load）"></a><div align=center>函数重载（Over load）</h1><p>同一个标识符在不同的上下文有不同的意义，高级语言无限接近自然语言，重载来自于自然语言的动词+名词。</p>
<h2 id="1-函数重载（Function-Over-load）"><a href="#1-函数重载（Function-Over-load）" class="headerlink" title="1.函数重载（Function Over load）"></a>1.函数重载（Function Over load）</h2><p>用同一个函数名定义不同的函数,当函数名和不同的参数搭配时函数的含义不同<br>函数重载必须至少满足下面一个条件;<strong>参数的个数不同、参数的类型不同、参数的顺序不同</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> char* s)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> strlen(s);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">const</span> char* s, <span class="keyword">int</span> a)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> strlen(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-函数重载可能会与使用默认参数的函数冲突（c-特性冲出）"><a href="#2-函数重载可能会与使用默认参数的函数冲突（c-特性冲出）" class="headerlink" title="2.函数重载可能会与使用默认参数的函数冲突（c++特性冲出）"></a>2.函数重载可能会与使用默认参数的函数冲突（c++特性冲出）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c = 5)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-编译器调用重载函数的的规则"><a href="#3-编译器调用重载函数的的规则" class="headerlink" title="3.编译器调用重载函数的的规则"></a>3.编译器调用重载函数的的规则</h2><p><strong>将所用同名函数作为候选者，尝试寻找可行的后选函数</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;精确匹配实参<br>&nbsp; &nbsp;&nbsp; &nbsp;通过默认参数能够匹配实参<br>&nbsp; &nbsp;&nbsp; &nbsp;通过默认类型转换匹配实参<br><strong>匹配失败</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;最终寻找到的候选函数不唯一，则出现二义性，编译失败<br>&nbsp; &nbsp;&nbsp; &nbsp;无法匹配所有候选者，函数未定义，编译失败</p>
<h2 id="4-函数重载的注意事项"><a href="#4-函数重载的注意事项" class="headerlink" title="4.函数重载的注意事项"></a>4.函数重载的注意事项</h2><p>重载函数在本质上是<strong>相互独立的不同函数</strong><br>重载函数的<strong>函数类型不同</strong><br>函数<strong>返回值</strong>不能作为函数重载的依据<br>函数重载是由<strong>函数名和参数列表决定！</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">add</span>(<span class="type">int</span> a, <span class="type">int</span> b)        // <span class="type">int</span> (<span class="type">int</span> ,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">add</span>(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span> c)  // <span class="type">int</span> (<span class="type">int</span> ,<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%p\n&quot;,( <span class="type">int</span>(*)(<span class="type">int</span> ,<span class="type">int</span>))<span class="keyword">add</span>);      // <span class="number">0x8048494</span></span><br><span class="line">	printf(&quot;%p\n&quot;,( <span class="type">int</span>(*)(<span class="type">int</span> ,<span class="type">int</span>,<span class="type">int</span>))<span class="keyword">add</span>);   //<span class="number">0x80484a2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-重载与指针"><a href="#5-重载与指针" class="headerlink" title="5.重载与指针"></a>5.重载与指针</h2><p>将重载函数名赋值给指针时<br>&nbsp; &nbsp;&nbsp; &nbsp;根据重载规则挑选与函数指针参数列表一致的候选者<br>&nbsp; &nbsp;&nbsp; &nbsp;严格匹配候选者的函数类型与函数指针的函数类型<br>注意：<br>&nbsp; &nbsp;&nbsp; &nbsp;函数重载必然发生在同一个作用域中<br>&nbsp; &nbsp;&nbsp; &nbsp;编译器需要用参数列表或函数类型进行函数选择<br>&nbsp; &nbsp;&nbsp; &nbsp;无法直接通过函数名得到重载函数的入口地址</p>
<h2 id="6-c-和c相互调用"><a href="#6-c-和c相互调用" class="headerlink" title="6.c++和c相互调用"></a>6.c++和c相互调用</h2><p>实际工程中c++和c代码相互调用是不可避免的<br>c++编译器能够兼容c语言编译方式<br>c++编译器优先使用c++编译方式<br>extern关键字强制让c++编译器进行c方式编译<br>extern 代码块中不能存在重载函数</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">extern “C”</span><br><span class="line">&#123;</span><br><span class="line">	<span class="regexp">//</span> <span class="keyword">do</span> c-style compilation here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证一段c代码只会以c的方式被编译</p>
<blockquote>
<p>__cplusplus是c++编译器内置的标准宏定义<br>__cplusplus的意义是确保c代码以统一的方式被编译成目标文件</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// C-Style Compilation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;c++编译器不能以c的方式编译重载函数<br>&nbsp; &nbsp;&nbsp; &nbsp;编译方式决定函数名被编译后的目标名<br>&nbsp; &nbsp;&nbsp; &nbsp;c++编译方式将函数名和参数列表编译成目标名<br>&nbsp; &nbsp;&nbsp; &nbsp;c编译方式只将函数名作为目标名进行编译</p>
<h1 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title=" 动态分配内存"></a><div align=center> 动态分配内存</h1><h2 id="1-c-中的动态分配内存"><a href="#1-c-中的动态分配内存" class="headerlink" title="1.c++中的动态分配内存"></a>1.c++中的动态分配内存</h2><p>c++中通过new关键字进行动态内存申请<br>c++中的动态内存申请是基于类型进行的<br>delete关键字用于释放内存</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">变量申请：								数组申请：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Type</span>* Pointer = <span class="keyword">new</span> <span class="built_in">Type</span>;				<span class="built_in">Type</span>* pointer = <span class="keyword">new</span> <span class="built_in">Type</span>[N];</span><br><span class="line"><span class="comment">//......										//......</span></span><br><span class="line"><span class="keyword">delete</span> pointer;							<span class="keyword">delete</span>[] pointer;</span><br></pre></td></tr></table></figure>
<h2 id="2-new-关键字与-mallloc-函数的区别"><a href="#2-new-关键字与-mallloc-函数的区别" class="headerlink" title="2.new 关键字与 mallloc 函数的区别"></a>2.new 关键字与 mallloc 函数的区别</h2><p>new关键字是c++的一部分<br>malloc 是由c库提供的函数<br>new 以具体类型为单位进行内存分配<br>malloc 以字节为单位进行内存分配<br>new 在申请单个类型变量时可以进行初始化<br>malloc 不具备内存初始化的特性</p>
<h2 id="3-new关键字的初始化"><a href="#3-new关键字的初始化" class="headerlink" title="3.new关键字的初始化"></a>3.new关键字的初始化</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">float</span>* f = <span class="keyword">new</span> <span class="keyword">float</span>(<span class="number">2.0f</span>);</span><br><span class="line"><span class="keyword">char</span>* pc = <span class="keyword">new</span> <span class="keyword">char</span>(‘c’);</span><br></pre></td></tr></table></figure>
<h2 id="4-c-中的命名空间"><a href="#4-c-中的命名空间" class="headerlink" title="4.c++中的命名空间"></a>4.c++中的命名空间</h2><p>在C语言中只有一个全局作用域<br>&nbsp; &nbsp;&nbsp; &nbsp;C语言中所有标识符共享一个作用域<br>&nbsp; &nbsp;&nbsp; &nbsp;标识符之间可能发生冲突<br>C++中提出了命名空间的概念<br>&nbsp; &nbsp;&nbsp; &nbsp;命名空间将全局作用域分成不同的部分<br>&nbsp; &nbsp;&nbsp; &nbsp;命名空间可以相互嵌套<br>&nbsp; &nbsp;&nbsp; &nbsp;全局作用域也叫默认命名空间<br>&nbsp; &nbsp;&nbsp; &nbsp;无论怎么划分本质还是全局作用域</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">定义</span><br><span class="line"><span class="keyword">namespace</span> <span class="symbol">Name</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> <span class="symbol">Internal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  ...  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*	...  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名空间的使用<br>&nbsp; &nbsp;&nbsp; &nbsp;使用整个命名空间：using namespace name;<br>&nbsp; &nbsp;&nbsp; &nbsp;使用命名空间中的变量：using name::variable;<br>&nbsp; &nbsp;&nbsp; &nbsp;使用默认命名空间中的变量：::variable;</p>
<h1 id="新型的类型转换方式"><a href="#新型的类型转换方式" class="headerlink" title="新型的类型转换方式"></a><div align=center>新型的类型转换方式</h1><h2 id="1-C语言中的强制类型转换"><a href="#1-C语言中的强制类型转换" class="headerlink" title="1.C语言中的强制类型转换"></a>1.C语言中的强制类型转换</h2><p>(type )( Expression )<br>type( Expression )<br>C强制类型转换存在问题<br>&nbsp; &nbsp;&nbsp; &nbsp;过于粗暴;任意类型之间都可以进行转换，编译器很难判断其正确性<br>&nbsp; &nbsp;&nbsp; &nbsp;难于定位;在源码中无法快速定位所有使用强制类型转换的语句</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">void</span>(PF)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">sturcut <span class="type">Point</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">0x12345</span>;</span><br><span class="line">PF* pf = PF* (v);</span><br><span class="line"><span class="type">char</span> c = <span class="type">char</span> (v);</span><br><span class="line"><span class="type">Point</span>* p = (<span class="type">Point</span>*) v; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-c-将强制类型转换分为4种不同的类型"><a href="#2-c-将强制类型转换分为4种不同的类型" class="headerlink" title="2.c++将强制类型转换分为4种不同的类型"></a>2.c++将强制类型转换分为4种不同的类型</h2><ul>
<li><strong>static_cast强制类型转换（静态类型转换）</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于基本类型之间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;不能用于基本类型指针间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;用于有继承关系类对象之间的转换和类指针之间的转换</li>
<li><strong>const_cast 强制类型转换</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于除去变量的只读属性<br>&nbsp; &nbsp;&nbsp; &nbsp;强制转换的目标类型必须是指针或引用</li>
<li><strong>reinterpret_cast 强制类型转换</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于指针类型间的强制转换<br>&nbsp; &nbsp;&nbsp; &nbsp;用于整数和指针类型间的强制类型转换</li>
<li><strong>dynamic_cast 强制类型转换</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于有继承关系的类指针间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;用于有交叉关系的类指针间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;具有类型检查功能<br>&nbsp; &nbsp;&nbsp; &nbsp;需要虚函数的支持<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">static_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0x12345</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;i;</span><br><span class="line">    <span class="keyword">char</span>* pc = &amp;c;</span><br><span class="line">    </span><br><span class="line">    c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br><span class="line">    pc = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(pi); <span class="comment">//ERROR 不能用于指针间的转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">const_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; k = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(j);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; y = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> z = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(x); <span class="comment">//ERROR 目标类型必须是引用或者指针</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k = %d\n&quot;</span>, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">    </span><br><span class="line">    y = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;x = %p\n&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;y = %p\n&quot;</span>, &amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinterpret_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;i;</span><br><span class="line">    <span class="keyword">char</span>* pc = &amp;c;</span><br><span class="line">    </span><br><span class="line">    pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(pi);</span><br><span class="line">    pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pc);</span><br><span class="line">    pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(i);   </span><br><span class="line">    c = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>&gt;(i); <span class="comment">// ERROR 指针与指针或指针与整数间的转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamic_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;i;</span><br><span class="line">    <span class="keyword">char</span>* pc = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">char</span>*&gt;(pi); <span class="comment">//ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    static_cast_demo();</span><br><span class="line">    const_cast_demo();</span><br><span class="line">    reinterpret_cast_demo();</span><br><span class="line">    dynamic_cast_demo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于const的疑问"><a href="#关于const的疑问" class="headerlink" title="关于const的疑问"></a><div align=center>关于const的疑问</h1><h2 id="1-const常量的辨别标准"><a href="#1-const常量的辨别标准" class="headerlink" title="1.const常量的辨别标准"></a>1.const常量的辨别标准</h2>在<strong>编译期间不能直接确定初始值的 const 标识符</strong>，都会被做只读变量处理<br>只有<strong>字面量初始化</strong>的 const常量才会进入符号表<br>使用其<strong>他变量初始化的 const常量仍然是只读变量</strong><br>被<strong>volatile修饰的 const常量</strong>不会进入符号表<br>const引用的类型与初始化变量的类型<br>&nbsp; &nbsp;&nbsp; &nbsp;相同：初始化变量成为只读变量<br>&nbsp; &nbsp;&nbsp; &nbsp;不同：生成一个新的只读变量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">1</span>;      <span class="comment">//常量值进入符号表，字面量初始化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;    <span class="comment">//只读变量，相同类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>&amp; nrx = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(rx);  <span class="comment">//普通变量</span></span><br><span class="line">    </span><br><span class="line">    nrx = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);         <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rx = %d\n&quot;</span>, rx);       <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nrx = %d\n&quot;</span>, nrx);     <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;x = %p\n&quot;</span>, &amp;x);       <span class="comment">// 0xbf8e8a88</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;rx = %p\n&quot;</span>, &amp;rx);     <span class="comment">// 0xbf8e8a88</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;nrx = %p\n&quot;</span>, &amp;nrx);   <span class="comment">// 0xbf8e8a88</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">2</span>;       <span class="comment">//只读变量</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;y);  </span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);         <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);         <span class="comment">// 0xbf8e8a7c</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> z = y;               <span class="comment">//只读变量</span></span><br><span class="line">    </span><br><span class="line">    p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;z);</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = %d\n&quot;</span>, z);        <span class="comment">// 7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);        <span class="comment">// 0xbf8e8a74</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; rc = c;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; trc = c;           <span class="comment">//新的只读变量</span></span><br><span class="line">    </span><br><span class="line">    rc = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %c\n&quot;</span>, c);        <span class="comment">// C = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rc = %c\n&quot;</span>, rc);      <span class="comment">// rc = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;trc = %c\n&quot;</span>, trc);    <span class="comment">// trc = c</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-引用与指针"><a href="#2-引用与指针" class="headerlink" title="2.引用与指针"></a>2.引用与指针</h2></li>
<li><strong>指针</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;指针是一个变量，值为一个内存地址，不需要初始化，可以保存不同的地址，通过指针可以访问对应内存地址中的值，指针可以被const修饰成为常量或者只读变量</li>
<li><strong>引用</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;引用只是一个变量的新名字，对引用的操作（赋值，取地址等）都会传递到代表的变量上；const引用使其代表的变量具有只读属性；引用必须在定义时初始化，之后无法代表其他变量</li>
<li><strong>从c++语言的角度来看</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;引用与指针没有任何关系；引用是变量的新名字，操作引用就是操作对应的变量</li>
<li><strong>从c++编译器的角度来看</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;为了支持新概念“引用”必须要有一个有效的方案；在编译器内部，使用指针常量来实现“引用”；因此，“引用”在定义时必须初始化</li>
<li><strong>在工程项目开发中</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;当c++编译时，直接站在使用的角度看待引用，与指针毫无关系，引用就是变量的别名,当对c++代码进行调试分析时，一些特殊情况，可以考虑站在c++编译器角度来看待引用</li>
<li><strong>C++不支持引用数组</strong><br>数组的本质为一段连续的内存空间，引用会打断这种连续性，c++为了更好的兼容c语言因此，c++不支持引用数组<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SV</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; x;</span><br><span class="line">    <span class="keyword">int</span>&amp; y;</span><br><span class="line">    <span class="keyword">int</span>&amp; z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>* pc = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>);</span><br><span class="line">    SV sv = &#123;a, b, *pc&#125;;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="built_in">array</span>[] = &#123;a, b, *pc&#125;; <span class="comment">// &amp;array[1] - &amp;array[0] = ?  Expected ==&gt; 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;sv.x = %p\n&quot;</span>, &amp;sv.x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;sv.y = %p\n&quot;</span>, &amp;sv.y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;sv.z = %p\n&quot;</span>, &amp;sv.z);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进阶面向对象"><a href="#进阶面向对象" class="headerlink" title="进阶面向对象"></a><div align=center>进阶面向对象</h1><h2 id="1-面向对象的基本概念"><a href="#1-面向对象的基本概念" class="headerlink" title="1.面向对象的基本概念"></a>1.面向对象的基本概念</h2>面向对象的意义在于，将日常生活中习惯的思维方式引入程序设计中，将需求中的概念直观映射到解决方案中，以模块为中心构建可复用的软件系统，提高软件产品的可维护性<h2 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2.类和对象"></a>2.类和对象</h2></li>
<li>*类：**指的一类的事物，是一个抽象的概念，类是一种模型，这种模型可以创建出不同的对象实体</li>
<li>*对象：**指的是属于某个类的具体实体，对象实体是类模型的一个具体实例<blockquote>
<p>一个类可以有很多对象，而一个 对象必然属于某个类</p>
</blockquote>
</li>
</ul>
<h2 id="3-类和对象的意义"><a href="#3-类和对象的意义" class="headerlink" title="3.类和对象的意义"></a>3.类和对象的意义</h2><p>类用于描述一类事物所特有的<font color=#DC143C size=3>属性和行为</font><br>&nbsp; &nbsp;&nbsp; &nbsp;如：电脑拥有cpu，内存和硬盘并且可以开机和运行程序<br>对象是具体的事物，拥有<font color=#DEB887 size=3>所属类中描述的一切行为和属性</font><br>&nbsp; &nbsp;&nbsp; &nbsp;如：每一只老虎都有不同的体重，不同的食量不同的性格</p>
<h2 id="4-一些有趣的问题"><a href="#4-一些有趣的问题" class="headerlink" title="4.一些有趣的问题"></a>4.一些有趣的问题</h2><p>类一定存在实际的对象吗？<br>不一定，恐龙对象不存在</p>
<p>类的对象数目是确定的吗？<br>不确定，老虎的数目不确定，皇帝类每一时期只有一个</p>
<p>类一定都是源于生活中吗？<br>不一定</p>
<p>类都是独立的吗？类之间存在关系吗？<br>不独立，类之间存在相互关系</p>
<p>对象实例一定只属于一个类吗？<br>不一定</p>
<p>对象实例可能完全相同吗？<br>不确定</p>
<h2 id="5-类之间的基本关系"><a href="#5-类之间的基本关系" class="headerlink" title="5.类之间的基本关系"></a>5.类之间的基本关系</h2><p>继承：从已存在的类细分出来的类和原类之间具有继承关系（is-a）；继承的类（子类）拥有原类（父类的所有属性和行为）<br>组合：一些类的存在必须依赖于其他的类，这种关系叫组合；组合的类在某一局部上由其他的类组成，将其他类的对象当做当前类的成员使用，当前类的对象与成员对象的生命周期相同，成员对象在用法上与普通对象完全一致</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Biology</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> living;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> :</span> Biology &#123;</span><br><span class="line">    <span class="keyword">bool</span> movable;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findFood</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span> :</span> Biology &#123;</span><br><span class="line">    <span class="keyword">bool</span> growable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Beast</span> :</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> :</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类与封装的概念"><a href="#类与封装的概念" class="headerlink" title="类与封装的概念"></a><div align=center>类与封装的概念</h1><h2 id="1-类通常分为两个部分"><a href="#1-类通常分为两个部分" class="headerlink" title="1.类通常分为两个部分"></a>1.类通常分为两个部分</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;类的实现细节，当创建类时，才需要考虑其内部实现细节；类的使用方式，当使用类时，不需要考虑其内部的实现细节</p>
<h2 id="2-类的封装"><a href="#2-类的封装" class="headerlink" title="2.类的封装"></a>2.类的封装</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;根据经验：并不是类的每个属性都是对外公开的；女孩不希望外人知道自己的体重和年龄；男孩子不希望外人知道自己的身高和收入。而一些类的属性是对外公开的；人的姓名，学历，国籍，等。因此必须在类的表示法中定义属性和行为的公开级别，类似于文件系统中的文件的权限</p>
<h2 id="3-C-中类的封装"><a href="#3-C-中类的封装" class="headerlink" title="3.C++中类的封装"></a>3.C++中类的封装</h2><p>成员变量：C++中用于表示类属性的变量<br>成员函数：C++中用于表示类行为的函数<br>C++中可以给成员变量和成员函数定义访问级别<br>&nbsp; &nbsp;&nbsp; &nbsp;Public：成员变量和成员函数可以在类的内部和外界访问调用<br>&nbsp; &nbsp;&nbsp; &nbsp;Private：成员变量和成员函数只能在类的内部被访问和调用</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Biology</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> living;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> :</span> Biology </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> movable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span> :</span> Biology </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> growable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Beast</span> :</span> Animal </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> :</span> Animal </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m sleeping...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m working...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Girl</span> :</span> Human</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        age = <span class="number">22</span>;</span><br><span class="line">        weight = <span class="number">48</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a girl, I&#x27;m %d years old.\n&quot;</span>, age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;My weight is %d kg.\n&quot;</span>, weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Boy</span> :</span> Human</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> salary;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">height</span> = <span class="number">175</span>;</span><br><span class="line">        salary = <span class="number">9000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a boy, my height is %d cm.\n&quot;</span>, <span class="built_in">height</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;My salary is %d RMB.\n&quot;</span>, salary);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Girl g;</span><br><span class="line">    Boy b;</span><br><span class="line">    </span><br><span class="line">    g.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    b.age = <span class="number">19</span>;</span><br><span class="line">    b.weight = <span class="number">120</span>;</span><br><span class="line">    <span class="comment">//b.height = 180;  //ERROR 私有成员无法访问</span></span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-类成员的作用域"><a href="#4-类成员的作用域" class="headerlink" title="4.类成员的作用域"></a>4.类成员的作用域</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;类成员的作用域都在类的内部外部无法直接访问；成员函数可以直接访问成员变量和调用成员函数；类的外部可以通过类变量访问public成员；类成员的作用域与访问级别没有关系（针对于外部访问）；C++中struct定义的类中的所有成员默认为public<br>&nbsp; &nbsp;&nbsp; &nbsp;想要访问类的成员变量或者成员函数都必须通过类的对象来进行，有了类的对像之后就可以访问类的成员变量和成员函数，是否访问成功还得看这个变量或者成员函数的访问级别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i = <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    Test test;</span><br><span class="line">    </span><br><span class="line">    test.j = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);              <span class="comment">// i = 2;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;::i = %d\n&quot;</span>, ::i);          <span class="comment">// ::i = 1;</span></span><br><span class="line">    <span class="comment">// printf(&quot;test.i = %d\n&quot;, test.i);    // Error</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test.j = %d\n&quot;</span>, test.j);    <span class="comment">// test.j = 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test.getI() = %d\n&quot;</span>, test.getI());  <span class="comment">// test.getI() = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的真正形态"><a href="#类的真正形态" class="headerlink" title="类的真正形态"></a><div align=center>类的真正形态</h1><h2 id="1-C-使用class关键字定义类"><a href="#1-C-使用class关键字定义类" class="headerlink" title="1.C++使用class关键字定义类"></a>1.C++使用class关键字定义类</h2><p>在用struct定义类时，所有成员的默认访问级别为public；在使用class定义类时，所有成员的默认访问级别为private</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// defualt to public</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// defualt to public</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// defualt to private</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// defualt to private</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    </span><br><span class="line">    a.i = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a.getI() = %d\n&quot;</span>, a.getI());</span><br><span class="line">    </span><br><span class="line">    b.i = <span class="number">4</span>;                                 <span class="comment">//ERROR</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b.getI() = %d\n&quot;</span>, b.getI());     <span class="comment">//ERROR</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-C-的类支持声明和实现的分离"><a href="#2-C-的类支持声明和实现的分离" class="headerlink" title="2.C++的类支持声明和实现的分离"></a>2.C++的类支持声明和实现的分离</h2><p>将类的实现和定义分开；.h头文件中只有类的声明，成员变量和成员函数的声明；.cpp源文件中完成类的其他实现，成员函数的具体实现</p>
<h2 id="3-类实例"><a href="#3-类实例" class="headerlink" title="3.类实例"></a>3.类实例</h2><p>需求：开发一个用于四则运算的的类<br>提供setOperator函数设置运算类型<br>提供setParamater函数设置运算参数<br>提供result函数进行运算<br>&nbsp; &nbsp;&nbsp; &nbsp;其返回值表示运算的合法性<br>&nbsp; &nbsp;&nbsp; &nbsp;通过引用参数返回结果</p>
<ul>
<li><p><strong>头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _OPERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OPERATOR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> mOp;</span><br><span class="line">    <span class="keyword">double</span> mP1;</span><br><span class="line">    <span class="keyword">double</span> mP2;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">setOperator</span><span class="params">(<span class="keyword">char</span> op)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(<span class="keyword">double</span> p1, <span class="keyword">double</span> p2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">result</span><span class="params">(<span class="keyword">double</span>&amp; r)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>类函数的具体实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Operator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Operator::setOperator</span><span class="params">(<span class="keyword">char</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>( (op == <span class="string">&#x27;+&#x27;</span>) || (op == <span class="string">&#x27;-&#x27;</span>) || (op == <span class="string">&#x27;*&#x27;</span>) || (op == <span class="string">&#x27;/&#x27;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">        mOp = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Operator::setParameter</span><span class="params">(<span class="keyword">double</span> p1, <span class="keyword">double</span> p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mP1 = p1;</span><br><span class="line">    mP2 = p2;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Operator::result</span><span class="params">(<span class="keyword">double</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">switch</span>( mOp )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>( (<span class="number">-0.000000001</span> &lt; mP2) &amp;&amp; (mP2 &lt; <span class="number">0.000000001</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = mP1 / mP2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            r = mP1 + mP2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            r = mP1 * mP2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            r = mP1 - mP2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>调用类的功能</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Operator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Operator op;</span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    op.setOperator(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    op.setParameter(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( op.result(r) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r = %lf\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calculate error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对象的构造"><a href="#对象的构造" class="headerlink" title="对象的构造"></a><div align=center>对象的构造</h1><h2 id="1、对象的本质"><a href="#1、对象的本质" class="headerlink" title="1、对象的本质"></a>1、对象的本质</h2><p>从程序设计的角度，对象只是变量，因此在<strong>栈</strong>上创建对象时，成员变量初始值为<strong>随机值</strong>、在<strong>堆</strong>上创建对象时，成员变量的初始值为<strong>随机值</strong>、在<strong>全局静态存储区</strong>创建对象时，成员变量初始值为<strong>0</strong></p>
</li>
<li><p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test gt; <span class="comment">//全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.i = %d\n&quot;</span>,gt.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.j = %d\n&quot;</span>,gt.getJ());</span><br><span class="line"></span><br><span class="line">	Test t1; <span class="comment">//局部对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d\n&quot;</span>,t1.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.j = %d\n&quot;</span>,t1.getJ());</span><br><span class="line"></span><br><span class="line">	Test *pt = <span class="keyword">new</span> Test; <span class="comment">//堆空间里面的零时对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;i = %d\n&quot;</span>,pt-&gt;getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;j = %d\n&quot;</span>,pt-&gt;getJ());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pt;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译结果：</span><br><span class="line">gt.i = <span class="number">0</span></span><br><span class="line">gt.j = <span class="number">0</span></span><br><span class="line">t1.i = <span class="number">-858993460</span></span><br><span class="line">t1.j = <span class="number">-858993460</span></span><br><span class="line">pt-&gt;i = <span class="number">-842150451</span></span><br><span class="line">pt-&gt;j = <span class="number">-842150451</span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象的初始化"><a href="#2、对象的初始化" class="headerlink" title="2、对象的初始化"></a>2、对象的初始化</h2></li>
</ul>
<p>生活中的对象都是在初始化之后上市的，初始化状态（出厂设置）是对象普遍存在的一个状态。c++中可以定义与类名相同的特殊成员函数，这种特殊的成员函数叫做构造函数。通过构造函数可以对对象进行初始化。</p>
<h2 id="3、-构造函数"><a href="#3、-构造函数" class="headerlink" title="3、 构造函数"></a>3、 构造函数</h2><p>构造函数与类名相同并且没有返回值、构造函数没有任何返回类型的声明、构造函数在对象定义时自动被调用</p>
<p><strong>编程实验</strong><br>通过构造函数初始化对象的成员变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">	Test() <span class="comment">//构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		j = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test gt; <span class="comment">//全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.i = %d\n&quot;</span>,gt.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.j = %d\n&quot;</span>,gt.getJ());</span><br><span class="line"></span><br><span class="line">	Test t1; <span class="comment">//局部对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d\n&quot;</span>,t1.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.j = %d\n&quot;</span>,t1.getJ());</span><br><span class="line"></span><br><span class="line">	Test *pt = <span class="keyword">new</span> Test; <span class="comment">//堆空间里面的零时对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;i = %d\n&quot;</span>,pt-&gt;getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;j = %d\n&quot;</span>,pt-&gt;getJ());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pt;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">gt.i = <span class="number">1</span></span><br><span class="line">gt.j = <span class="number">2</span></span><br><span class="line">t1.i = <span class="number">1</span></span><br><span class="line">t1.j = <span class="number">2</span></span><br><span class="line">pt-&gt;i = <span class="number">1</span></span><br><span class="line">pt-&gt;j = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="1）带有参数的构造函数"><a href="#1）带有参数的构造函数" class="headerlink" title="1）带有参数的构造函数"></a>1）带有参数的构造函数</h3><p>构造函数可以根据需要定义参数<br>一个类可以存在多个重载的构造函数<br>构造函数的重载遵循C++重载的规则</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(int v)</span><br><span class="line">	&#123;</span><br><span class="line">		// use v to initialize member</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象定义和对象声明不同<br>对象定义-申请对象的空间并调用构造函数<br>对象声明-告诉编译器存在这样一个对象</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test </span>t; // 定义对象并调用构造函数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//告诉编译器存在名为 t 的 Test 对象</span><br><span class="line">	extern Test t;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>编程实验</strong><br>构造函数的自动调用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Test(<span class="keyword">int</span> v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(int v)\n&quot;</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Test t;			<span class="comment">//调用Test()</span></span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">//调用Test(int v)</span></span><br><span class="line">	Test t2 = <span class="number">1</span>;	<span class="comment">//调用Test(int v)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Test()</span><br><span class="line">Test(<span class="keyword">int</span> v)</span><br><span class="line">Test(<span class="keyword">int</span> v)</span><br></pre></td></tr></table></figure>
小贴士：<br>赋值与初始化是不同的<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;	<span class="comment">//用1初始化i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">//用100初始化j</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;		<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="2）构造函数的调用"><a href="#2）构造函数的调用" class="headerlink" title="2）构造函数的调用"></a>2）构造函数的调用</h3></li>
</ul>
<p>手工调用构造函数初始化对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span><br><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">int</span> m_value;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Test()</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">		m_value = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Test(int v), v = %d\n&quot;</span>,v);</span><br><span class="line">		m_value = v;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">int</span> get<span class="constructor">Value()</span></span><br><span class="line">	&#123;</span><br><span class="line">		return m_value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	Test ta<span class="literal">[<span class="number">3</span>]</span> = &#123;<span class="constructor">Test()</span>,<span class="constructor">Test(1)</span>,<span class="constructor">Test(2)</span>&#125;; <span class="comment">// 手动调用构造函数初始化对象数组的成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;ta[%d].m_value = %d\n&quot;</span>,i,ta<span class="literal">[<span class="identifier">i</span>]</span>.get<span class="constructor">Value()</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test t = <span class="constructor">Test(3)</span>;	<span class="comment">//手动调用构造函数初始化对象</span></span><br><span class="line"></span><br><span class="line">	printf(<span class="string">&quot;t.m_value = %d\n&quot;</span>,t.get<span class="constructor">Value()</span>);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="constructor">Test()</span></span><br><span class="line"><span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span>, v = <span class="number">1</span></span><br><span class="line"><span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span>, v = <span class="number">2</span></span><br><span class="line">ta<span class="literal">[<span class="number">0</span>]</span>.m_value = <span class="number">0</span></span><br><span class="line">ta<span class="literal">[<span class="number">1</span>]</span>.m_value = <span class="number">1</span></span><br><span class="line">ta<span class="literal">[<span class="number">2</span>]</span>.m_value = <span class="number">2</span></span><br><span class="line"><span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span>, v = <span class="number">3</span></span><br><span class="line">t.m_value = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="3）小实例"><a href="#3）小实例" class="headerlink" title="3）小实例"></a>3）小实例</h3><p>开发一个数组类结局原生数组的安全性问题<br>-提供函数获取数组长度<br>-提供函数获取数组元素<br>-提供函数设置数组元素</p>
<ul>
<li><strong>头文件</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><strong>函数功能实现</strong><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;StdAfx.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;intarry.h&quot;</span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="built_in">new</span> <span class="type">int</span>[len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> IntArry::length()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> IntArry::<span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span>&amp; <span class="keyword">value</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret = ( <span class="number">0</span>&lt;= <span class="keyword">index</span>) &amp;&amp; (<span class="keyword">index</span> &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">value</span> = m_pointer[<span class="keyword">index</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> IntArry::<span class="keyword">set</span>(<span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> <span class="keyword">value</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret = ( <span class="number">0</span>&lt;= <span class="keyword">index</span>) &amp;&amp; (<span class="keyword">index</span> &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[<span class="keyword">index</span>] = <span class="keyword">value</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IntArry::free()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>主函数测试</strong><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="function">IntArry <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">set</span>(i,i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(a.<span class="built_in">get</span>(i,value))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a.<span class="built_in">free</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="4、特殊的构造函数"><a href="#4、特殊的构造函数" class="headerlink" title="4、特殊的构造函数"></a>4、特殊的构造函数</h2></li>
</ul>
<h3 id="1）无惨构造函数"><a href="#1）无惨构造函数" class="headerlink" title="1）无惨构造函数"></a>1）无惨构造函数</h3><p>没有参数的构造函数，当类中<strong>没有定义任意构造函数</strong>时，编译器<strong>默认提供一个无参拷贝构造函数</strong>，并且其函数体为空</p>
<h3 id="2）拷贝构造函数"><a href="#2）拷贝构造函数" class="headerlink" title="2）拷贝构造函数"></a>2）拷贝构造函数</h3><p>参数为 const class_name&amp; 的构造函数，当类中<strong>没有定义拷贝构造函数</strong>时，<strong>编译器默认提供一个拷贝构造函数</strong>，简单的进行成员变量的值复制(浅拷贝)。</p>
<blockquote>
<p>拷贝构造函数的意义<br>兼容C语言的初始化方式，初始化行为能够符合预期的逻辑。</p>
</blockquote>
<h4 id="a-浅拷贝"><a href="#a-浅拷贝" class="headerlink" title="a. 浅拷贝"></a>a. 浅拷贝</h4><p>拷贝后对象的物理状态相同，编译器提供的拷贝构造函数只进行浅拷贝</p>
<ul>
<li><strong>编程实验</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">getP</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line">	Test(<span class="keyword">int</span> v)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		j = <span class="number">2</span>;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">		*p = v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Test t2 = t1;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d, t1.j = %d,t1.p = %p\n&quot;</span>,t1.getI(),t1.getJ(),t1.getP());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t2.i = %d, t2.j = %d,t2.p = %p\n&quot;</span>,t2.getI(),t2.getJ(),t2.getP());</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">free</span>();</span><br><span class="line">	<span class="comment">//t2.free(); //多次释放造成内存泄漏 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">t1.i = <span class="number">1</span>, t1.j = <span class="number">2</span>,t1.p = <span class="number">01323488</span></span><br><span class="line">t2.i = <span class="number">1</span>, t2.j = <span class="number">2</span>,t2.p = <span class="number">01323488</span></span><br></pre></td></tr></table></figure>
运行结果分析，函数中没有拷贝构造函数因此，默认提供了一个拷贝构造函数如下<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Test(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	i = t.i;</span><br><span class="line">	j = t.j;</span><br><span class="line">	p = t.p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因此得到的指针t1.p 与 t2.p指向同一个内存空间，对象 t2 并没有新生成一个堆空间的int大小的内存。所以分别运行两个对象的free释放函数会造成内存空间的重复释放，导致内存泄漏，编译报错。</li>
</ul>
<h4 id="b-深拷贝"><a href="#b-深拷贝" class="headerlink" title="b. 深拷贝"></a>b. 深拷贝</h4><p>拷贝后对象的逻辑状态相同</p>
<ul>
<li><strong>编程实验</strong><br>手动提供拷贝构造函数实现深拷贝<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">getP</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line"></span><br><span class="line">	Test(<span class="keyword">int</span> v)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		j = <span class="number">2</span>;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">		*p = v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test(<span class="keyword">const</span> Test&amp; t) <span class="comment">//手动提供构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		i = t.i;</span><br><span class="line">		j = t.j;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">		*p = *t.p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Test t2 = t1;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d, t1.j = %d,t1.p = %p\n&quot;</span>,t1.getI(),t1.getJ(),t1.getP());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t2.i = %d, t2.j = %d,t2.p = %p\n&quot;</span>,t2.getI(),t2.getJ(),t2.getP());</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">free</span>();</span><br><span class="line">	t2.<span class="built_in">free</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">t1.i = <span class="number">1</span>, t1.j = <span class="number">2</span>,t1.p = <span class="number">00</span>CF3488</span><br><span class="line">t2.i = <span class="number">1</span>, t2.j = <span class="number">2</span>,t2.p = <span class="number">00</span>CF34C8</span><br></pre></td></tr></table></figure>
第24行手动提供拷贝构造函数实现深拷贝，通过28,29行操作实现深拷贝</li>
</ul>
<h3 id="3）什么时候需要深拷贝"><a href="#3）什么时候需要深拷贝" class="headerlink" title="3）什么时候需要深拷贝"></a>3）什么时候需要深拷贝</h3><p>成员指向了动态内存空间<br>成员打开了外存中的文件<br>成员使用了系统中的网络端口</p>
<h3 id="4）数组类的改进"><a href="#4）数组类的改进" class="headerlink" title="4）数组类的改进"></a>4）数组类的改进</h3><p><strong>intarry.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	IntArry(<span class="keyword">const</span> IntArry&amp; obj); <span class="comment">//添加拷贝构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>intarry.c文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">const</span> IntArry&amp; obj) <span class="comment">//手动实现深拷贝</span></span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = obj.m_pointer[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = obj.m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntArry::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		value = m_pointer[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IntArry::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试函数</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">IntArry <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">set</span>(i, i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(a.<span class="built_in">get</span>(i, value))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	IntArry b = a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; b.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(b.<span class="built_in">get</span>(i, value))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;b[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a.<span class="built_in">free</span>();</span><br><span class="line">	b.<span class="built_in">free</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h1><p>用于初始化类对象中的成员变量</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ClassName:</span>:ClassName():</span><br><span class="line">	m1(<span class="built_in">v1</span>), m2(<span class="built_in">v1</span>,<span class="built_in">v2</span>), m3(<span class="built_in">v3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// some other initialize opreration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1、初始化列表的初始顺序"><a href="#1、初始化列表的初始顺序" class="headerlink" title="1、初始化列表的初始顺序"></a>1、初始化列表的初始顺序</h2><p>-成员的初始化顺序与成员的申明顺序相同<br>-成员的初始化顺序与初始化列表中的位置无关<br>-初始化列表先于构造函数的函数体执行</p>
<p><strong>编程实验</strong><br>验证初始化列表的初始顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Value(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Value m2;  <span class="comment">//初始化列表先初始化这个变量</span></span><br><span class="line">	Value m3;</span><br><span class="line">	Value m1; <span class="comment">//初始化列表最后初始化这个变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test() : m1(<span class="number">1</span>),m2(<span class="number">2</span>),m3(<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getCI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ci;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">Test</span><br></pre></td></tr></table></figure>
<h2 id="2、类中的const成员"><a href="#2、类中的const成员" class="headerlink" title="2、类中的const成员"></a>2、类中的const成员</h2><p>类中的const成员会被分配内存空间<br>类中的const成员的本质是只读变量<br>类中的const成员只能在初始化列表中指定初始化值<br>编译器无法直接得到const成员的初始值，因此无法进入符号表成为真正意义上的常量</p>
<p><strong>编程实验</strong><br>类中的const成员变量本质为只读变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test() : ci(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getCI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ci;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCI</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;ci); <span class="comment">//通过指针修改ci的值</span></span><br><span class="line"></span><br><span class="line">		*p = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t.ci = %d\n&quot;</span>,t.getCI());</span><br><span class="line"></span><br><span class="line">	t.setCI(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t.ci = %d\n&quot;</span>,t.getCI());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">t.ci = <span class="number">0</span></span><br><span class="line">t.ci = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化与赋值不同<br>初始化：对<strong>正在创建的对象</strong>进行初始值设置<br>赋值：对<strong>已经存在的对象</strong>进行值的设置</p>
</blockquote>
<h1 id="对象的构造顺序"><a href="#对象的构造顺序" class="headerlink" title="对象的构造顺序"></a>对象的构造顺序</h1><p><strong>1. 局部对象</strong><br>当程序执行流到达对象定义的语句时进行构造<br><strong>2. 堆对象的构造顺序</strong><br>堆对象的构造与new关键字以及程序执行流有关<br><strong>3. 全局对象的构造顺序</strong><br>对象的构造顺序是不确定的，不同的编译器使用不同规则的构造顺序</p>
<blockquote>
<p>尽量避免使用全局变量与全局对象，以及全局对象之间的依赖</p>
</blockquote>
<h1 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h1><p>C++类中定义的一个特殊的清理函数，析构函数的功能与构造函数相反</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">~ClassName()</span><br></pre></td></tr></table></figure>
<p>-析构函数没有参数也没有返回值类型声明<br>-析构函数在对象销毁值自动被调用</p>
<p><strong>编程实验</strong><br>验证析构函数的自动调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#123; <span class="comment">//定义对象的作用域</span></span><br><span class="line">		Test t; <span class="comment">// 对象被销毁后自动调用析构函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>析构函数的定义准则<br>当类中定义了构造函数，并且构造函数使用了系统资源（内存申请，文件打开，等）则需要自定义析构函数<br>析构函数时对象释放系统资源的保障</p>
</blockquote>
<h1 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h1><h2 id="1、临时对象的产生"><a href="#1、临时对象的产生" class="headerlink" title="1、临时对象的产生"></a>1、临时对象的产生</h2><p>直接调用构造函数将产生一个<strong>临时对象</strong><br>临时对象的<strong>生命周期只有一条语句的时间</strong><br>临时对象的作用于<strong>只在一条语句中</strong><br>临时对象时c++中<strong>值得谨惕</strong>的灰色地带</p>
<p><strong>编程实验</strong><br>验证临时对象</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		Test(<span class="number">1</span>);<span class="comment">//直接调用构造函数产生零时对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Test t; </span><br><span class="line">	t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">mi = <span class="number">-858993460</span></span><br></pre></td></tr></table></figure>
<p>运行结果分析：本来第16行调用构造函数的目的是初始化mi，使得mi的值为1，但运行结果为一个随机值，产生的原因就是16行直接调用有参数的构造函数得到了一个临时对象。16行的临时对象的生命周期只有16行这条语句，过了这条语句之后这个临时对象就被析构。这个临时对象同时没有名字，所以临时对象的作用域也只有这一条语句。因此16行这条语句没有半毛钱作用。16行代码等价于一条空语句。</p>
<p>解决方案，提供一个私有的初始化函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//提供私有的init函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mi = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		init(<span class="number">1</span>); <span class="comment">//调用私有的init初始化函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Test t; </span><br><span class="line">	t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">mi = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>深入验证临时对象</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mi = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(int i)\n&quot;</span>);</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">		init(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main begin \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Test().<span class="built_in">print</span>();  <span class="comment">//直接调用构造函数产生临时对象 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	Test(<span class="number">3</span>).<span class="built_in">print</span>(); <span class="comment">//直接调用构造函数产生临时对象 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main end... \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">Main <span class="built_in">begin</span></span><br><span class="line">Test()</span><br><span class="line">mi = <span class="number">1</span></span><br><span class="line">~Test()</span><br><span class="line"></span><br><span class="line">Test(<span class="keyword">int</span> i)</span><br><span class="line">mi = <span class="number">3</span></span><br><span class="line">~Test()</span><br><span class="line">Main <span class="built_in">end</span>...</span><br></pre></td></tr></table></figure>
<p>运行结果分析：37行与39行直接调用构造函数产生临时对象，因此Test()/Test(3)为临时生成的对象，可以直接调用他们的成员函数print。同时也验证了临时对象的生命周期为一条语句的时间。</p>
<h2 id="2、临时对象的优化"><a href="#2、临时对象的优化" class="headerlink" title="2、临时对象的优化"></a>2、临时对象的优化</h2><p>现代C++编译器在不影响最终执行结果的前提下，会尽力减少临时对象的产生</p>
<p>代码分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mi = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(int i)\n&quot;</span>);</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">		init(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">	Test(<span class="keyword">const</span> Test&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		mi = obj.mi;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(const Test&amp; obj): %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Test(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main begin \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Test t = Test(<span class="number">1</span>);	<span class="comment">// ==&gt; Test t = 1;</span></span><br><span class="line"></span><br><span class="line">	Test t3 = func();	<span class="comment">// ==&gt; Test t3 = Test(3) ==&gt; Test t3 = 3;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main end... \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第47,49行运行个过程应该如下</p>
<ol>
<li>生成临时对象</li>
<li>用临时对象初始化t对象</li>
<li>调用拷贝构造函数</li>
</ol>
<p>但实际的运行结果发现并没有拷贝构造函数的调用，产生这个结果的原因就是编译器为了杜绝临时对象的产生因此对代47,49行码进行了优化，优化后的代码如下</p>
</blockquote>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test </span>t = 1;</span><br><span class="line"><span class="keyword">Test </span>t3 = 3;</span><br></pre></td></tr></table></figure>
<p>所以代码没有调用拷贝构造函数</p>
<p><strong>注意：</strong><br>临时对象时性能的瓶颈，也是bug的来源之一<br>实际工程开发中需要人为的避开临时对象</p>
<h1 id="经典问题分析"><a href="#经典问题分析" class="headerlink" title="经典问题分析"></a>经典问题分析</h1><h2 id="1、构造函数与析构函数的调用顺序"><a href="#1、构造函数与析构函数的调用顺序" class="headerlink" title="1、构造函数与析构函数的调用顺序"></a>1、构造函数与析构函数的调用顺序</h2><h3 id="1）单个对象创建时"><a href="#1）单个对象创建时" class="headerlink" title="1）单个对象创建时"></a>1）单个对象创建时</h3><ol>
<li>调用父类的构造过程</li>
<li>调用成员变量的构造函数（调用顺序与声明顺序相同）</li>
<li>调用自身类的构造函数</li>
</ol>
<p>析构函数与对应构造函数的调用顺序相反</p>
<p><strong>编程实验</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span><br><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Member</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	const <span class="built_in">char</span>* ms;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Member(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">s</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Member(const char* s): %s\n&quot;</span>,s);</span><br><span class="line">		ms = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="constructor">Member()</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;~Member(): %s\n&quot;</span>,ms);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Member mA;</span><br><span class="line">	Member mB;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Test()</span>: m<span class="constructor">B(<span class="string">&quot;mB&quot;</span>)</span>, m<span class="constructor">A(<span class="string">&quot;mA&quot;</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="constructor">Test()</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">	Test t;</span><br><span class="line">	&#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="constructor">Member(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">s</span>)</span>: mA</span><br><span class="line"><span class="constructor">Member(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">s</span>)</span>: mB</span><br><span class="line"><span class="constructor">Test()</span></span><br><span class="line">~<span class="constructor">Test()</span></span><br><span class="line">~<span class="constructor">Member()</span>: mB</span><br><span class="line">~<span class="constructor">Member()</span>: mA</span><br></pre></td></tr></table></figure>
<h3 id="2）栈对象和全局对象"><a href="#2）栈对象和全局对象" class="headerlink" title="2）栈对象和全局对象"></a>2）栈对象和全局对象</h3><p>对于栈对象和全局对象，类似于入栈于出栈的顺序，最后构造的对象被最先析构</p>
<h3 id="3）堆对象"><a href="#3）堆对象" class="headerlink" title="3）堆对象"></a>3）堆对象</h3><p>堆对象的构造发生在new关键字调用的时候，析构则是发生在使用delete的时候，与delete的使用顺序有关。</p>
<h2 id="2、const对象"><a href="#2、const对象" class="headerlink" title="2、const对象"></a>2、const对象</h2><p>const能够修饰对象<br>const修饰的对象为只读对象<br>只读对象的成员变量不允许改变<br>只读对象是编译阶段的概念，运行期无效</p>
<h3 id="1）C-中的const成员函数"><a href="#1）C-中的const成员函数" class="headerlink" title="1）C++中的const成员函数"></a>1）C++中的const成员函数</h3><p>const对象<strong>只能调用const的成员函数</strong><br>const成员函数中<strong>只能调用const成员函数</strong><br>const成员函数<strong>不能直接改写成员变量的值</strong></p>
<p>const成员函数的定义</p>
<blockquote>
<p>Type ClassName::function(type p) const</p>
</blockquote>
<p>类中的声明和实际的成员函数中都必须带const关键字</p>
<h2 id="3、对象的构成"><a href="#3、对象的构成" class="headerlink" title="3、对象的构成"></a>3、对象的构成</h2><p>问题：成员函数和成员变量都是隶属于具体的对象吗</p>
<p><strong>从面向对象的角度</strong><br>-对象由属性（成员变量），和方法（成员函数）构成<br><strong>从程序运行角度</strong><br>-对象有由数据和函数组成<br>*数据可以位于栈，堆和全局数据区<br>*函数只能位于代码段</p>
<blockquote>
<p>结论:<br>每一个对象拥有自己独立的属性（成员变量）<br>所有的对象共享创建他的的类的方法（成员函数）<br>方法能够直接访问对象的属性<br>方法中的隐藏参数 this用于指代当前对象</p>
</blockquote>
<ul>
<li><strong>成员函数只有一套，他能直接访问任何所属类对象的成员变量</strong></li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i);</span><br><span class="line">	Test(<span class="keyword">const</span> Test&amp; obj);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMi</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	mi = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">const</span> Test&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	mi = obj.mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test::getMi</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this = %p\n\n&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.getMi() = %d\n&quot;</span>,t1.getMi());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;t1 = %p\n&quot;</span>,&amp;t1);</span><br><span class="line">	t1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t2.getMi() = %d\n&quot;</span>,t2.getMi());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;t2 = %p\n&quot;</span>,&amp;t2);</span><br><span class="line">	t2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t3.getMi() = %d\n&quot;</span>,t3.getMi());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;t3 = %p\n&quot;</span>,&amp;t3);</span><br><span class="line">	t3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的静态成员变量与成员函数"><a href="#类的静态成员变量与成员函数" class="headerlink" title="类的静态成员变量与成员函数"></a>类的静态成员变量与成员函数</h1><h2 id="1、类的静态成员变量"><a href="#1、类的静态成员变量" class="headerlink" title="1、类的静态成员变量"></a>1、类的静态成员变量</h2><p>静态成员变量属于整个类所有<br>所有对象共享类的静态成员变量<br>静态成员变量的生命周期不依赖与任何对象<br>可以通过对象名访问公有(public)静态成员变量<br>可以通过类名直接访问公有(public)静态成员变量</p>
<ul>
<li><strong>静态成员变量的特性</strong></li>
</ul>
<p>-在定义时直接通过static关键字修饰<br>-静态成员变量需要在类外单独分配空间<br>-静态成员变量在程序内部位于全局数据区</p>
<ul>
<li><strong>定义静态成员变量的语法规则</strong><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Type</span> <span class="type">ClassName::VarName </span>= value;</span><br></pre></td></tr></table></figure>
<h2 id="2、类的静态成员函数"><a href="#2、类的静态成员函数" class="headerlink" title="2、类的静态成员函数"></a>2、类的静态成员函数</h2></li>
</ul>
<p>静态成员函数是类中特殊的成员函数<br>静态成员函数属于整个类所有<br>可以通过类名直接访问共有静态成员函数<br>可以通过对象名访问公有静态成员函数</p>
<h3 id="1）静态成员函数的定义"><a href="#1）静态成员函数的定义" class="headerlink" title="1）静态成员函数的定义"></a>1）静态成员函数的定义</h3><p>直接通过static关键字修饰生源函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test::func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编程体验</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticSetI</span><span class="params">(Demo&amp; d,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Demo::getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Demo::staticFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;staticFunc: %s\n&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Demo::staticSetI</span><span class="params">(Demo&amp; d,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	d.i = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Demo::staticFunc(<span class="string">&quot;main begin...&quot;</span>); <span class="comment">//直接通过类名调用静态成员函数</span></span><br><span class="line"></span><br><span class="line">	Demo d;</span><br><span class="line">	d.staticSetI(d,<span class="number">1</span>); <span class="comment">//通过对象名访问静态成员函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;d.i = %d\n&quot;</span>,d.getI());</span><br><span class="line"></span><br><span class="line">	Demo::staticFunc(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">staticFunc: main <span class="built_in">begin</span>...</span><br><span class="line">d.i = <span class="number">1</span></span><br><span class="line">staticFunc: main <span class="built_in">end</span>...</span><br></pre></td></tr></table></figure>
<h3 id="2）普通与静态成员函数对比"><a href="#2）普通与静态成员函数对比" class="headerlink" title="2）普通与静态成员函数对比"></a>2）普通与静态成员函数对比</h3><table>
<thead>
<tr>
<th>静态成员函数vs普通成员函数</th>
<th>静态成员函数</th>
<th>普通成员函数</th>
</tr>
</thead>
<tbody><tr>
<td>所有对象共享</td>
<td><div align=center>Yes</td>
<td><div align=center>Yes</td>
</tr>
<tr>
<td>隐含this指针(函数)</td>
<td><div align=center>No</td>
<td><div align=center>Yes</td>
</tr>
<tr>
<td>访问普通成员变量(函数)</td>
<td><div align=center>No</td>
<td><div align=center>Yes</td>
</tr>
<tr>
<td>通过类名直接调用</td>
<td><div align=center>Yes</td>
<td><div align=center>No</td>
</tr>
<tr>
<td>通过对象名直接调用</td>
<td><div align=center>Yes</td>
<td><div align=center>Yes</td>
</tr>
</tbody></table>
<h2 id="3、小实例"><a href="#3、小实例" class="headerlink" title="3、小实例"></a>3、小实例</h2><p>需求：统计在程序运行期间某个类的对象数目，保证程序的安全性（不能使用全局变量），随时可以获取当前对象的数目</p>
<p><strong>编程实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> mCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		mCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		mCount--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test::mCount = <span class="number">0</span>; <span class="comment">//定义静态成员变量，并初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t0;</span><br><span class="line">	Test t1;</span><br><span class="line">	Test t2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test::mCount = %d\n&quot;</span>,Test::getCount()); <span class="comment">//通过类名访问静态函数得到mCount</span></span><br><span class="line">	</span><br><span class="line">	Test* pt = <span class="keyword">new</span> Test;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test::mCount = %d\n&quot;</span>,Test::getCount());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pt;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test::mCount = %d\n&quot;</span>,Test::getCount());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Test::mCount = <span class="number">3</span></span><br><span class="line">Test::mCount = <span class="number">4</span></span><br><span class="line">Test::mCount = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h1 id="二阶构造模式"><a href="#二阶构造模式" class="headerlink" title="二阶构造模式"></a>二阶构造模式</h1><h2 id="1、半成品对象"><a href="#1、半成品对象" class="headerlink" title="1、半成品对象"></a>1、半成品对象</h2><p>-初始化操作不能按照预期完成而得到的对象<br>-半成品对象是合法的C++对象，也是Bug重要来源</p>
<blockquote>
<p>构造函数能决定的知识对象的初始状态，而不是对象的诞生</p>
</blockquote>
<h2 id="2、划分构造过程"><a href="#2、划分构造过程" class="headerlink" title="2、划分构造过程"></a>2、划分构造过程</h2><ul>
<li><strong>资源无关的初始化操作</strong><br>不可能出现异常情况的操作</li>
<li><strong>需要使用系统资源的操作</strong><br>可能出现异常情况，如：内存申请，访问文件</li>
</ul>
<p>二阶构造能够确保创建的对象都是完整初始化的</p>
<h2 id="4、二阶构造示例"><a href="#4、二阶构造示例" class="headerlink" title="4、二阶构造示例"></a>4、二阶构造示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseCons</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TwoPhaseCons()&#123;  <span class="comment">//第一阶段构造函数</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">construct</span><span class="params">()</span></span>&#123; <span class="comment">//第二阶段构造函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> TwoPhaseCons* <span class="title">NewInstance</span><span class="params">()</span></span>; <span class="comment">//对象创建函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TwoPhaseCons* <span class="title">TwoPhaseCons::NewInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TwoPhaseCons* ret = <span class="keyword">new</span> TwoPhaseCons;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若二阶构造失败，返回NULL</span></span><br><span class="line">	<span class="keyword">if</span>(!(ret &amp;&amp; ret-&gt;construct()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> ret;</span><br><span class="line">		ret = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TwoPhaseCons* p = TwoPhaseCons::NewInstance();</span><br><span class="line">	TwoPhaseCons* p1 = TwoPhaseCons::NewInstance();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p1 = %p\n&quot;</span>,p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化数组类的实现"><a href="#优化数组类的实现" class="headerlink" title="优化数组类的实现"></a>优化数组类的实现</h2><p><strong>intarry.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">construct</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> IntArry* <span class="title">NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span>; <span class="comment">//</span></span><br><span class="line">	IntArry(<span class="keyword">const</span> IntArry&amp; obj);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>intarry.c文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">int</span> len) <span class="comment">//一阶构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::construct</span><span class="params">()</span> <span class="comment">//二阶构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( m_pointer )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">const</span> IntArry&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = obj.m_pointer[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = obj.m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IntArry* <span class="title">IntArry::NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArry* ret = <span class="keyword">new</span> IntArry(len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(ret &amp;&amp; ret-&gt;construct()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] ret;</span><br><span class="line">		ret = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntArry::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		value = m_pointer[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IntArry::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试c文件</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArry* a = IntArry::NewIntArry(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		a-&gt;<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;a-&gt;length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">			a-&gt;<span class="built_in">get</span>(i,value);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="被遗弃的友元"><a href="#被遗弃的友元" class="headerlink" title="被遗弃的友元"></a>被遗弃的友元</h1><p>友元是C++中的一种关系<br>友元关系发生在函数与类之间或者类与类之间<br>友元关系是单项的，不能传递</p>
<ul>
<li><p><strong>友元的用法</strong><br>在类中以friend关键字声明友元<br>类的友元可以是其他类或者具体函数<br>友元不是类的一部分<br>友元不收类中访问级别的限制<br>友元可以直接访问具体类的所有成员</p>
</li>
<li><p><strong>友元的语法</strong><br>在类中用friend关键字对函数或类进行声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Piont</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Point&amp; p)</span></span>; <span class="comment">//声明了友元关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Point&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.x = <span class="number">1</span>; <span class="comment">//可以直接访问类的私有成员变量</span></span><br><span class="line">	p.y = <span class="number">2</span>; <span class="comment">//可以直接访问类的私有成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>友元的尴尬</strong><br>友元是为了兼顾C语言的高效而诞生的<br>友元直接破坏了面向对象的封装特性<br>友元在实际产品中的高效是得不偿失的<br>友元在现代软件工程中已经逐渐被遗弃（对比c语言的goto语句）</p>
</li>
</ul>
<blockquote>
<p>注意事项：<br>友元不具备传递性<br>类的友元可以是其他类的成员函数<br>类的友元可以是某个完整的类：所有的成员函数都是友元</p>
</blockquote>
<p>插图</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClassC(<span class="keyword">const</span> <span class="keyword">char</span>* n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClassB(<span class="keyword">const</span> <span class="keyword">char</span>* n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getClassCName</span><span class="params">(ClassC&amp; c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;c.n = %s\n&quot;</span>,c.n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClassA(<span class="keyword">const</span> <span class="keyword">char</span>* n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getClassBName</span><span class="params">(ClassB&amp; b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;b.n = %s\n&quot;</span>,b.n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    //友元没有传递性，无法直接访问 c 的成员函数</span></span><br><span class="line"><span class="comment">	void getClassCName(ClassC&amp; c)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		//友元没有传递性，无法直接访问 c 的成员变量</span></span><br><span class="line"><span class="comment">		printf(c.n = %s\n&quot;,c.n);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ClassC <span class="title">c</span><span class="params">(<span class="string">&quot;C&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">ClassB <span class="title">b</span><span class="params">(<span class="string">&quot;B&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">ClassA <span class="title">a</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	b.getClassCName(c);</span><br><span class="line">	a.getClassBName(b);</span><br><span class="line">	<span class="comment">//a.getClassCName(c); </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类中的重载"><a href="#类中的重载" class="headerlink" title="类中的重载"></a>类中的重载</h1><p>类中成员函数可以进行重载<br>-构造函数的重载<br>-普通成员函数的重载<br>-静态成员函数的重载</p>
<p>重载函数的本质为多个不同的函数<br>函数名和参数列表是唯一表示<br>函数重载必须发生在同一个作用域中</p>
<p>重载的意义<br>-通过函数名对函数功能进行提示<br>-通过参数列表对函数用法进行提示<br>-扩展系统中已经存在的函数功能</p>
<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>通过operator关键字可以定义特殊的函数<br>operator的本质是通过函数重载操作符</p>
<p>语法</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Type</span> <span class="type">operatorSign(const </span><span class="keyword">Type</span> <span class="type">p1, </span>const <span class="keyword">Type</span> <span class="type">p2)</span></span><br><span class="line"><span class="type">&#123;</span></span><br><span class="line"><span class="type">	</span><span class="keyword">Type</span> <span class="type">ret;</span></span><br><span class="line"><span class="type"></span></span><br><span class="line"><span class="type">	</span><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sign: 为系统中预定义的操作符，如：+，-，*，/,等</span><br></pre></td></tr></table></figure>
<p>编程实验</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	ret.a = p1.a + p2.a;</span><br><span class="line">	ret.b = p1.b + p2.b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Complex c = a + b; <span class="comment">// operator+(a,b)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.a = %d, c.b = %d\n&quot;</span>,c.getA(),c.getB());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">c.a = <span class="number">2</span>, c.b = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>将操作符重载函数定义为类的成员函数<br>-比全局操作符重载函数少一个参数（左操作数）<br>-不需要依赖友元就可以完成操作符重载<br>-编译器有限在成员函数中寻找操作符重载函数</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Type</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="keyword">Type</span> operator <span class="built_in">Sign</span>(<span class="keyword">const</span> <span class="keyword">Type</span>&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">Type</span> <span class="keyword">ret</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	ret.a = <span class="keyword">this</span>-&gt;a + p.a;</span><br><span class="line">	ret.b = <span class="keyword">this</span>-&gt;b + p.b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Complex c = a+b; <span class="comment">// a.operator+(b)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.a = %d, c.b = %d\n&quot;</span>,c.getA(),c.getB());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">c.a = <span class="number">2</span>, c.b = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="实现一个复数类"><a href="#实现一个复数类" class="headerlink" title="实现一个复数类"></a>实现一个复数类</h2><p>复数类应该有的操作<br>-运算：+,-,*,/<br>-比较：==，！=<br>-赋值：=<br>-求模：modulus</p>
<p><strong>编程实现</strong><br>利用操作符重载<br>统一复数与实数的运算方式<br>统一复数与实数的比较方式</p>
<p><strong>complex.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMPLEX_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMPLEX_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>);</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getB</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getModulus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">operator</span> + (Complex&amp; c);</span><br><span class="line">	Complex <span class="keyword">operator</span> - (Complex&amp; c);</span><br><span class="line">	Complex <span class="keyword">operator</span> * (Complex&amp; c);</span><br><span class="line">	Complex <span class="keyword">operator</span> / (Complex&amp; c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (Complex&amp; c);</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> != (Complex&amp; c);</span><br><span class="line"></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>complex.c文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Complex::Complex(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Complex::getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Complex::getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Complex::getModulus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> + (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> na = a + c.a;</span><br><span class="line">	<span class="keyword">double</span> nb = b + c.b;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> - (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> na = a - c.a;</span><br><span class="line">	<span class="keyword">double</span> nb = b - c.b;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> * (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> na = a * c.a - b * c.b;</span><br><span class="line">	<span class="keyword">double</span> nb = a * c.b + b * c.a;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> / (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> cm = c.a*c.a + c.b+c.b;</span><br><span class="line">	<span class="keyword">double</span> na = (a * c.a - b * c.b) / cm;</span><br><span class="line">	<span class="keyword">double</span> nb = (b * c.a - a * c.b) / cm;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Complex::<span class="keyword">operator</span> == (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (a==c.a) &amp;&amp; (b==c.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Complex::<span class="keyword">operator</span> != (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex&amp;  Complex::<span class="keyword">operator</span> = (<span class="keyword">const</span> Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> != &amp;c)</span><br><span class="line">	&#123;</span><br><span class="line">		a = c.a;</span><br><span class="line">		b = c.b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试主程序</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">#include <span class="string">&quot;stdafx.h&quot;</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include <span class="string">&quot;complex.h&quot;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">1</span>(<span class="number">1</span><span class="punctuation">,</span><span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">2</span>(<span class="number">3</span><span class="punctuation">,</span><span class="number">6</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">3</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> + <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">4</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> - <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">5</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> * <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">6</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> / <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	printf(<span class="string">&quot;c3.a = %f, c3.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">3</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">3</span>.getB())<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c4.a = %f, c4.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span>.getB())<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c5.a = %f, c5.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">5</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">5</span>.getB())<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c6.a = %f, c6.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">6</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">6</span>.getB())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">7</span>(<span class="number">1</span><span class="punctuation">,</span><span class="number">-4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	printf(<span class="string">&quot;c4 == c7: %d\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span> <span class="operator">=</span><span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>)<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c4 != c7: %d\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span> !<span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">c</span><span class="number">3</span>.a <span class="operator">=</span> <span class="number">4.000000</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">3</span>.b <span class="operator">=</span> <span class="number">8.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">4</span>.a <span class="operator">=</span> <span class="number">-2.000000</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">4</span>.b <span class="operator">=</span> <span class="number">-4.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">5</span>.a <span class="operator">=</span> <span class="number">-9.000000</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">5</span>.b <span class="operator">=</span> <span class="number">12.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">6</span>.a <span class="operator">=</span> <span class="number">-0.428571</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">6</span>.b <span class="operator">=</span> <span class="number">0.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">4</span> <span class="operator">=</span><span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>: <span class="number">0</span></span><br><span class="line"><span class="keyword">c</span><span class="number">4</span> !<span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意事项：<br>C++规定赋值操作符（=）只能重载为成员函数<br>操作符重载不能改变原操作符的优先级<br>操作符重载不能改变操作数的个数<br>操作符重载不应改变操作符的原有语义</p>
<p><strong>有趣的重载</strong><br>重载左移操作符，将变量或常量左移到一个对象中！<br><strong>手动通过重载简单实现cout</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">endl</span> = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Console</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">char</span> c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">char</span>* c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">double</span> f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,f);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Console</span> <span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;123\n&quot;</span> &lt;&lt; <span class="number">1.25</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h1><p>C++标准库并不是C++语言的一部分<br>C++标准库是由类库和函数库组成的集合<br>C++标准库中定义的类和对象都位于std命名空间中<br>C++标准库的头文件都不带.h后缀<br>C++标准库涵盖了C库的功能</p>
<h2 id="1、C-编译环境的组成"><a href="#1、C-编译环境的组成" class="headerlink" title="1、C++编译环境的组成"></a>1、C++编译环境的组成</h2><p>插图</p>
<h2 id="2、C-标准库预定义了多数常用的数据结构"><a href="#2、C-标准库预定义了多数常用的数据结构" class="headerlink" title="2、C++标准库预定义了多数常用的数据结构"></a>2、C++标准库预定义了多数常用的数据结构</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><bitset></td>
<td><set></td>
<td><cstdio></td>
</tr>
</tbody></table>
<p><strong>编程体验c++标准库</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello Word！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;input a: &quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;input b: &quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> c = <span class="built_in">sqrt</span>(a*a + b*b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-中的字符串类"><a href="#C-中的字符串类" class="headerlink" title="C++中的字符串类"></a>C++中的字符串类</h1><p>C++ 语言直接支持C语言所有的概念<br>C++ 语言中没有原生的字符串类型<br>C++ 标准库提供了string类型<br>string 直接支持字符串连接<br>string 直接支持字符串的大小比较<br>string 直接支持子串查找和提取<br>string 直接支持字符串的插入和替换</p>
<p>字符串与数字的转换<br>标准库中提供了相关类对字符串和数字的转换<br>字符串流类（sstream）用于string的转换</p>
<ul>
<li><sstream> -相关头文件</li>
<li>istringstream -字符串输入流</li>
<li>ostringstream -字符串输出流</li>
</ul>
<p>使用方法<br>string-&gt;数字</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">istringstream iss(<span class="string">&quot;123.45&quot;</span>)<span class="comment">;</span></span><br><span class="line">double num<span class="comment">;</span></span><br><span class="line">iss &gt;&gt; num<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>数字-&gt;string</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ostringstream oss<span class="comment">;</span></span><br><span class="line">oss &lt;&lt; <span class="number">562.63</span><span class="comment">;</span></span><br><span class="line">string s = oss.str()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>编程实现</strong><br>字符串转换为数字与数字转换为字符串的功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_NUMBER(str,n) (istringstream(str) &gt;&gt; n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING(n) (((ostringstream&amp;)(ostringstream() &lt;&lt; n)).str())</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">double</span> n;</span><br><span class="line">	TO_NUMBER(<span class="string">&quot;1.23&quot;</span>,n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; TO_STRING(<span class="number">12.34</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1.23</span></span><br><span class="line"><span class="number">12.34</span></span><br></pre></td></tr></table></figure>
<p>字符串循环右移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">right_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">	n = n % s.length();</span><br><span class="line">	pos = s.length() - n;</span><br><span class="line"></span><br><span class="line">	ret = s.substr(pos);</span><br><span class="line">	ret += s.substr(<span class="number">0</span>,pos);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">string</span> r = right_func(<span class="string">&quot;123456&quot;</span>,<span class="number">8</span>); <span class="comment">//循环右移8位</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">561234</span></span><br></pre></td></tr></table></figure>
<h1 id="数组操作符的重载"><a href="#数组操作符的重载" class="headerlink" title="数组操作符的重载"></a>数组操作符的重载</h1><p><strong>字符串类的兼容性</strong><br>string类最大限度的考虑了C字符串的兼容性<br>可以按照使用C字符串的方式使用string对象<br><strong>被忽略的事实</strong><br>-数组访问符是C/C++中的内置操作符<br>数组访问符的原生意义是数组访问和指针运算</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">a[n] &lt;--&gt; *(a + n) &lt;--&gt; *(n + a) &lt;--&gt; n[a]</span><br></pre></td></tr></table></figure>
<p><strong>优化数组类</strong><br><strong>interry.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">construct</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> IntArry* <span class="title">NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line">	IntArry(<span class="keyword">const</span> IntArry&amp; obj);</span><br><span class="line">	~IntArry();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">IntArry&amp; <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>interry.cpp文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( m_pointer )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">const</span> IntArry&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = obj.m_pointer[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = obj.m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IntArry* <span class="title">IntArry::NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArry* ret = <span class="keyword">new</span> IntArry(len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(ret &amp;&amp; ret-&gt;construct()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] ret;</span><br><span class="line">		ret = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntArry::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		value = m_pointer[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::~IntArry()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; IntArry::<span class="keyword">operator</span> [] (<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_pointer[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IntArry&amp; <span class="title">IntArry::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试主函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	IntArry* a = IntArry::NewIntArry(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(a != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IntArry&amp; arry = a-&gt;self();</span><br><span class="line"></span><br><span class="line">		arry[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arry.length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; arry[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="经典问题解析"><a href="#经典问题解析" class="headerlink" title="经典问题解析"></a>经典问题解析</h1><h2 id="1、关于赋值的疑问"><a href="#1、关于赋值的疑问" class="headerlink" title="1、关于赋值的疑问"></a>1、关于赋值的疑问</h2><p>编译器为每个类默认重载了赋值操作符<br>默认的赋值操作符仅完成浅拷贝<br>当需要进行深拷贝时必须重载赋值操作符<br>赋值操作符与拷贝构造函数有相同的存在意义</p>
<blockquote>
<p>一般性原则<br>重载赋值操作符，必然需要实现深拷贝</p>
</blockquote>
<p>编译器默认提供的函数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Test</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数体等价于</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Test</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="keyword">Test</span>();</span><br><span class="line">	<span class="keyword">Test</span>(<span class="keyword">const</span> <span class="keyword">Test</span>&amp; );</span><br><span class="line">	<span class="keyword">Test</span> operator = (<span class="keyword">const</span> <span class="keyword">Test</span>&amp;);</span><br><span class="line">	~<span class="keyword">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、关于string的疑问"><a href="#2、关于string的疑问" class="headerlink" title="2、关于string的疑问"></a>2、关于string的疑问</h2><p>string 类通过一个数据空间保存字符数据<br>string 类通过一个成员变量保存当前字符串长度<br>C++开发时尽量避开C语言中惯用的编程思想</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>一个特殊的指针，指针生命周期结束时主动释放堆空间，一片堆空间最多智能由一个指针标识，杜绝指针运算和指针比较</p>
<blockquote>
<p>智能用来指向堆空间中的对象或者变量</p>
</blockquote>
<p><strong>编程实现</strong><br>通过重载指针操作符(-&gt;和*)，使用对象代替指针 </p>
<h1 id="逻辑操作符的陷阱"><a href="#逻辑操作符的陷阱" class="headerlink" title="逻辑操作符的陷阱"></a>逻辑操作符的陷阱</h1><p>C++通过函数调用扩展操作符的功能，进入函数体前必须完成所有参数的计算，函数参数的计算次序是不定的，短路法则则完全失效</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &amp;&amp; (<span class="keyword">const</span> Test&amp; l,<span class="keyword">const</span> Test&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> l.getValue() &amp;&amp; r.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> || (<span class="keyword">const</span> Test&amp; l,<span class="keyword">const</span> Test&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> l.getValue() || r.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test func(Test t): t.value = &quot;</span> &lt;&lt; t.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="function">Test <span class="title">t0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(func(t0) &amp;&amp; func(t1)) <span class="comment">// 等价于调用 operator &amp;&amp;( func(t0), func(t1)) 函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is true!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is false!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(func(t0) || func(t1)) <span class="comment">// 等价于调用 operator ||( func(t0), func(t1)) 函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is true!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is false!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">1</span></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">0</span></span><br><span class="line">Result is <span class="literal">false</span>!</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">1</span></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">0</span></span><br><span class="line">Result is <span class="literal">true</span>!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不推荐重载逻辑与或 ，逻辑操作符重载后无法实现原生的语义<br>通过重载比较操作符代替逻辑操作符重载<br>直接使用成员函数代替逻辑操作符重载<br>使用全局函数对对逻辑操作符进行重载</p>
</blockquote>
<h1 id="逗号表达式的重载"><a href="#逗号表达式的重载" class="headerlink" title="逗号表达式的重载"></a>逗号表达式的重载</h1><p>逗号表达式用于将多个字表达式连接为一个表达式,逗号表达式的值为最后一个子表达式的值,逗号表达式,的前N-1个子表达式可以没有返回值,逗号表达式按照从左向右的顺序计算每个子表达式的值</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">exp1 , exp2 , exp3 , ... , expN</span><br></pre></td></tr></table></figure>
<p>在C++中使用全局函数对逗号操作符进行重载，重载函数的参数必须有一个是类类型，重载函数的返回值必须是引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class&amp; , (<span class="keyword">const</span> Class&amp; a, <span class="keyword">const</span> Class&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Class&amp;&gt;(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议使用全局函数重载逗号操作符</p>
<p>存在问题<br>C++通过函数调用扩展操作符的功能，进入函数体前必须完成所有参数的计算，函数参数的计算次序是不定的，重载后无法严格从左向右计算表达式，工程开发中不要重载逗号操作符</p>
<h1 id="前置操作符与后置操作符的重载"><a href="#前置操作符与后置操作符的重载" class="headerlink" title="前置操作符与后置操作符的重载"></a>前置操作符与后置操作符的重载</h1><p>++ 操作符可以被重载，全局函数和成员函数均可以进行重载，重载前置++操作符不需要额外的参数，重载后置 ++ 操作符需要一个 int 类型的占位参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test&amp; <span class="keyword">operator</span> ++ () <span class="comment">// 前置++实现</span></span><br><span class="line">	&#123;</span><br><span class="line">		++value;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> ++ (<span class="keyword">int</span>) <span class="comment">//后置++实现</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value)</span></span>;</span><br><span class="line"></span><br><span class="line">		value++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="function">Test <span class="title">t0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	Test t1 = t0++;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t0.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t1.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Test t2 = ++t0;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t0.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t2.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h1><p>构造函数可以定义不同类型的参数，参数满足下列条件时称为<strong>转换构造函数</strong>：有且仅有一个参数、参数是基本类型、参数是其他类类型</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test </span>t;</span><br><span class="line">t = 100;</span><br></pre></td></tr></table></figure>
<p>编译器会尽量尝试让源码通过编译，当将100赋值给对象t时，编译器首先看看有没有转换构造函数，如果有转换构造函数则进行转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		value = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Test(<span class="keyword">int</span> i)   <span class="comment">//转换构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Test t ;</span><br><span class="line"></span><br><span class="line">	t = <span class="number">5</span>; <span class="comment">//进行隐式类型转换，调用转换构造函数，==&gt; t = Test(5)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器尽量尝试的结果是隐式类型转换：会让程序以意想不到的方式进行工作，是工程中bug的重要来源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()&#123;&#125;;</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; obj) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value+ obj.value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Test t ;</span><br><span class="line"></span><br><span class="line">	t = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	Test r;</span><br><span class="line"></span><br><span class="line">	r = t + <span class="number">5</span>; <span class="comment">// ==&gt; r = t + Test(5); 编译器自作聪明的编译通过，容易产生bug</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++编译器通过explicit关键字杜绝编译器的转换尝试，转换构造函数被explicit修饰时只能进行显示转换<br>转换方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;ClassName&gt;(value)</span><br><span class="line">ClassName(value)</span><br><span class="line">(ClassName)value <span class="comment">//不推荐</span></span><br></pre></td></tr></table></figure>
<p>手动进行转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; obj) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value+ obj.value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Test t ;</span><br><span class="line">	</span><br><span class="line">	t = <span class="keyword">static_cast</span>&lt;Test&gt;(<span class="number">5</span>); <span class="comment">// 手动类型转换</span></span><br><span class="line">	Test r;</span><br><span class="line"></span><br><span class="line">	r = t + Test(<span class="number">5</span>) + (Test)<span class="number">3</span>; <span class="comment">// 手动类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++中可以定义<strong>类型转换函数</strong>，类型转换函数用于将类对象转化为其他类型</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">operator <span class="keyword">Type</span> <span class="type">()</span></span><br><span class="line"><span class="type">&#123;</span></span><br><span class="line"><span class="type">	</span><span class="keyword">Type</span> <span class="type">ret;</span></span><br><span class="line"><span class="type"></span></span><br><span class="line"><span class="type">	</span><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型转换函数与转换构造函数具有同等的地位、使得编译器有能力将类对象转化为其他类型，编译器能够隐式使用类型转换函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; obj) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value+ obj.value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> <span class="comment">//类型转换函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function">Test <span class="title">t</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	i = t; <span class="comment">//编译器隐式调用类型转换函数 == &gt; t.operator int()</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>谨慎使用隐式类型转换，非常容易引入bug</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tmp(<span class="keyword">int</span>) <span class="comment">//类型转换函数</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		value = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Tmp</span> <span class="params">()</span> <span class="comment">//转换构造函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">Tmp <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Tmp i = <span class="number">0</span>;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">	Tmp = t; <span class="comment">// 转换构造函数与类型转换函数相互冲突</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过在转换构造函数前加explicit关键字解决，在实际工程中通常不使用转换构造函数而采用普通构造函数的方式实现转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tmp(<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		value = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">Tmp <span class="title">toTmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">Tmp <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Tmp i = <span class="number">0</span>;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">	i = t.toTmp(); <span class="comment">// 通过构造函数实现类的类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承的概念和意义"><a href="#继承的概念和意义" class="headerlink" title="继承的概念和意义"></a>继承的概念和意义</h1><p>面向对象中的继承指类之间的父子关系：子类拥有父类的所有属性和行为、子类就是一种特殊的父类、子类对象可以当做父类对象使用、子类中可以添加父类没有的方法和属性</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Child</span> : <span class="symbol">public</span> <span class="symbol">Parent</span> //描述继承关系</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>子类是一个特殊的父类，子类对象可以直接初始化父类对象，子类对象可以直接赋值给父类对象。</p>
<p>继承是C++中代码复用的重要手段。通过继承可以获得父类所有功能，并且可以在子类中重写已有功能，或者添加新功能。</p>
<h2 id="继承中的访问级别"><a href="#继承中的访问级别" class="headerlink" title="继承中的访问级别"></a>继承中的访问级别</h2><p>面向对象中的访问级别不知是public和private，可以定义protected访问级别：protected修饰的成员不能被外界直接访问、修饰的成员可以被子类直接访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span> :  <span class="comment">//protected访问级别</span></span><br><span class="line">		<span class="keyword">int</span> mv;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Parent()</span><br><span class="line">	&#123;</span><br><span class="line">		mv = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">addValue</span><span class="params">(<span class="keyword">int</span> mv)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Parent::mv = Parent::mv + mv; <span class="comment">//子类直接访问父类私有成员</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.addValue(<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义类时访问级别的选择"><a href="#定义类时访问级别的选择" class="headerlink" title="定义类时访问级别的选择"></a>定义类时访问级别的选择</h2><p>插图44课</p>
<h1 id="不同的继承方式"><a href="#不同的继承方式" class="headerlink" title="不同的继承方式"></a>不同的继承方式</h1><p>public继承<br>父类成员在子类中保持原有的访问级别<br>private继承<br>父类成员在子类中变为私有成员<br>protected继承<br>父类中的公有成员变为保护成员，其他成员保持不变</p>
<p>插图44课</p>
<p>继承成员的访问属性<br> = Max{继承方式，父类成员访问属性}</p>
<p>C++中的默认继承方式为private</p>
<p>一般而言，C++工程项目中只使用public继承，C++的派生语言只支持一种继承方式（public继承），protected和private继承带来的复杂性远大于使用性</p>
<h1 id="继承中的构造与析构"><a href="#继承中的构造与析构" class="headerlink" title="继承中的构造与析构"></a>继承中的构造与析构</h1><p>子类可以定义构造函数，子类的构造函数必须对继承而来的成员进行初始化：直接通过初始化列表或者赋值的方式进行初始化、调用父类的构造函数进行初始化</p>
<p>父类构造函数在子类中的调用方式：默认调用，适用于无参构造函数和使用默认参数的构造函数、显示调用，通过初始化列表进行调用，适用于所有父类构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Parent()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Parent(<span class="built_in">string</span> s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent(string s) : &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Child() <span class="comment">//隐式调用父类构造函数Parent()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Child(<span class="built_in">string</span> s)</span><br><span class="line">		: Parent(<span class="string">&quot;Parameter to Parent&quot;</span>) <span class="comment">//显示调用父类构造函数Parent(string s)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child() : &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Child <span class="title">cc</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Parent()</span><br><span class="line">Child()</span><br><span class="line"></span><br><span class="line">Parent(<span class="built_in">string</span> s) : Parameter to Parent</span><br><span class="line">Child() : hello</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造规则：子类对象在创建时会首先调用父类的构造函数、先执行父类构造函数<br>再执行子类的构造函数、父类构造函数可以被隐式调用或者显示调用</p>
</blockquote>
<p>对象创建时构造函数的调用顺序</p>
<ol>
<li>调用父类的构造函数</li>
<li>调用成员变量的构造函数</li>
<li>调用类自身的构造函数</li>
</ol>
<p><strong>口诀心法：</strong><br><strong>先父母、后客人、再自己</strong></p>
<p>析构函数的调用顺序与构造函数相反</p>
<ol>
<li>执行自身的析构函数</li>
<li>执行成员变量的析构函数</li>
<li>执行父类的析构函数</li>
</ol>
<h1 id="父子间的冲突"><a href="#父子间的冲突" class="headerlink" title="父子间的冲突"></a>父子间的冲突</h1><p>子类可以定义父类中的同名成员，子类中的成员将隐藏父类中的同名成员，父类中的同名成员依然存在于子类中，子类可以定义父类中的同名函数，使用作用域分辨符::访问父类中的同名成员和同名函数</p>
<p><strong>特殊的同名函数</strong><br>子类中可以定义父类中已经存在的成员函数，这种定义发生在继承中，叫函数重写，函数重写是同名覆盖的一种特殊情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child c;</span><br><span class="line"></span><br><span class="line">	c.mi = <span class="number">100</span>;</span><br><span class="line">	c.Parent::mi = <span class="number">10</span>; <span class="comment">//调用父类中的成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.Get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.Parent::Get() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//调用父类同名的函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>父子间的赋值兼容</strong><br>子类对象可以当做父类对象使用（兼容性）：子类对象可以直接赋值给父类对象使用、子类对象可以直接初始化父类对象、父类指针可以直接指向子类对象、父类引用可以直接引用子类对象</p>
<p>当使用父类指针（引用）指向子类对象时，子类对象退化为父类对象，只能访问父类中定义的成员，可以访问被子类覆盖的同名成员</p>
<h1 id="多态的概念和意义"><a href="#多态的概念和意义" class="headerlink" title="多态的概念和意义"></a>多态的概念和意义</h1><p>根据实际的对象类型决定函数调用的具体目标，同样的语句在实际运行时有多种不同的表现形式</p>
<p>C++语言直接支持多态的概念，通过使用virtual关键字对多态进行支持，被virtual声明的函数被重写后具有多态特性，被virtual声明的函数叫做<strong>虚函数</strong>。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandfather</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//通过关键字virtual实现多态</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Grandfather&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> :</span> Grandfather</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//通过关键字virtual实现多态</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Parent&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_A</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Child A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_B</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Child B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child_A a;</span><br><span class="line">	Child_B b;</span><br><span class="line"></span><br><span class="line">	Parent* pa = &amp;a;</span><br><span class="line">	pa-&gt;<span class="built_in">print</span>();	</span><br><span class="line"></span><br><span class="line">	Parent&amp; A = a;</span><br><span class="line">	A.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Parent* pb = &amp;b;</span><br><span class="line">	pb-&gt;<span class="built_in">print</span>();	</span><br><span class="line"></span><br><span class="line">	Parent&amp; B = b;</span><br><span class="line">	B.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">I<span class="number">&#x27;</span>m Child A</span><br><span class="line">I<span class="number">&#x27;</span>m Child A</span><br><span class="line"></span><br><span class="line">I<span class="number">&#x27;</span>m Child B</span><br><span class="line">I<span class="number">&#x27;</span>m Child B</span><br></pre></td></tr></table></figure>
<p>多态的意义<br>在程序运行中展现出动态特性、函数重写必须多态实现，否则没有意义、多态是面向对象组件化和程序设计的基础特性</p>
<p>理论中的概念<br>静态联编，在程序编译期间就能确定具体的函数调用，如函数重载<br>动态联编，在程序实际运行后才能确定具体的函数调用，如函数重写</p>
<h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><p>class是一种特殊的struct，在内存中class依旧可以看做变量的集合，class与struct遵循相同的内存对齐规则，class中的成员函数与成员变量是分开存放的：每个对象有独立的成员变量、所有类对象共享类中的成员函数</p>
<p>运行时的对象退化为结构体的形式，所有的成员变量在内存中依次排布，成员变量间可能存在内存空隙，可以通过内存地址直接访问成员变量，访问权限关键字在运行时失效</p>
<p>继承对象模型<br>在C++编译器的内部类可以理解为结构体，子类是由父类成员叠加子类新成员得到的</p>
<p>C++多态的实现原理<br>当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数地址的数据结构，虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续….."></a>未完待续…..</h1>]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言基础知识</title>
    <url>/2020/01/03/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>用于记录c语言基础知识,如果没有特别说明本文的所有代码编译环境为gcc编译器编译</p>
<a id="more"></a>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><div align=center>基本数据类型</h1><h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><ul>
<li><strong>含义</strong><br>&nbsp; &nbsp;&nbsp;固定内存大小的别名</li>
<li><strong>作用</strong><br>&nbsp; &nbsp;&nbsp;创建变量</li>
</ul>
<table>
<thead>
<tr>
<th>c语言数据类型表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>Storage size</td>
<td>Value range Precision</td>
</tr>
<tr>
<td>char</td>
<td>1 byte</td>
<td>-128 to 127 or 0 to 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 byte</td>
<td>0 to 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 byte</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>int</td>
<td>2 or 4 bytes</td>
<td>-32,768to32,767 or -2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 or 4 bytes</td>
<td>0 to 65,535 or 0 to 4,294,967,295</td>
</tr>
<tr>
<td>short</td>
<td>2 bytes</td>
<td>-32,768 to 32,767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 bytes</td>
<td>0 to 65,535</td>
</tr>
<tr>
<td>long</td>
<td>4 bytes</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 bytes</td>
<td>0 to 4,294,967,295</td>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>1.2E-38 to 3.4E+38 6 decimal places</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>2.3E-308 to 1.7E+308 15 decimal places</td>
</tr>
<tr>
<td>long double</td>
<td>10 byte</td>
<td>3.4E-4932 to 1.1E+4932 19 decimal places</td>
</tr>
</tbody></table>
<h2 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h2><ul>
<li><strong>本质</strong><br>&nbsp; &nbsp;&nbsp;一段连续存储空间的别名，大小由创建的数据类型定。</li>
<li><strong>作用</strong><br>&nbsp; &nbsp;&nbsp;程序通过变量申请储存空间<br>&nbsp; &nbsp;&nbsp;通过变量名使用储存空间<br>&nbsp; &nbsp;&nbsp;通过变量名区分相同大小相同类型的内存空间</li>
<li><strong>补充</strong><br>&nbsp; &nbsp;&nbsp;sizeof关键字用来计算变量，类型，字符串，数组，或结构体等所占内存空间大小</li>
<li><strong>定义新的数据类型</strong><br>&nbsp; &nbsp;&nbsp;通过 typedef 关键字重新命名一个数据类型</li>
</ul>
<h2 id="3、编程实验"><a href="#3、编程实验" class="headerlink" title="3、编程实验"></a>3、编程实验</h2><h3 id="编程实验1：数据类型与变量"><a href="#编程实验1：数据类型与变量" class="headerlink" title="编程实验1：数据类型与变量"></a>编程实验1：数据类型与变量</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/1.png" >

<h3 id="编程实验2：typedef自定义数据类型"><a href="#编程实验2：typedef自定义数据类型" class="headerlink" title="编程实验2：typedef自定义数据类型"></a>编程实验2：typedef自定义数据类型</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/2.png" >

<h1 id="有符号数与无符号数"><a href="#有符号数与无符号数" class="headerlink" title="有符号数与无符号数"></a><div align=center>有符号数与无符号数</h1><h2 id="1、有符号数"><a href="#1、有符号数" class="headerlink" title="1、有符号数"></a>1、有符号数</h2><ul>
<li><p><strong>声明</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;默认为有符号数，用 signed 关键字声明</p>
</li>
<li><p><strong>数据类型的最高位用来标识数据的符号</strong><br>&nbsp; &nbsp;&nbsp;最高位为1表示这个数为负数<br>&nbsp; &nbsp;&nbsp;最高位为0表示这个数为正数</p>
</li>
<li><p><strong>有符号数的表示方法：在计算机内部用补码表示有符号数</strong><br>&nbsp; &nbsp;&nbsp;正数的补码为正数本身<br>&nbsp; &nbsp;&nbsp;负数的补码为对应的正数的反码加1</p>
<h2 id="2、无符号数"><a href="#2、无符号数" class="headerlink" title="2、无符号数"></a>2、无符号数</h2></li>
<li><p><strong>声明</strong><br>&nbsp; &nbsp;用 unsigned 关键字声明，不能声明浮点型 float double</p>
</li>
<li><p><strong>特点</strong><br>&nbsp; &nbsp;&nbsp;默认为正数<br>&nbsp; &nbsp;&nbsp;没有符号位<br>&nbsp; &nbsp;&nbsp;最大值 + 1 = 最小值<br>&nbsp; &nbsp;&nbsp;最小值 - 1 = 最大值<br>&nbsp; &nbsp;&nbsp;有符号数与无符号整形数（unsigned int）混合运算，有符号会被转换为无符号数，结果为无符号数</p>
<h2 id="3、编程实验-1"><a href="#3、编程实验-1" class="headerlink" title="3、编程实验"></a>3、编程实验</h2><h3 id="编程实验1：证明有符号数的表示方法"><a href="#编程实验1：证明有符号数的表示方法" class="headerlink" title="编程实验1：证明有符号数的表示方法"></a>编程实验1：证明有符号数的表示方法</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/3.png" >

</li>
</ul>
<h3 id="编程实验2：有符号数与无符号数的混合运算"><a href="#编程实验2：有符号数与无符号数的混合运算" class="headerlink" title="编程实验2：有符号数与无符号数的混合运算"></a>编程实验2：有符号数与无符号数的混合运算</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/4.png" >

<h3 id="编程实验3：无符号数（最小值-1-最大值）"><a href="#编程实验3：无符号数（最小值-1-最大值）" class="headerlink" title="编程实验3：无符号数（最小值 - 1 = 最大值）"></a>编程实验3：无符号数（最小值 - 1 = 最大值）</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/5.png" >

<h1 id="内存中的浮点数（float-double）"><a href="#内存中的浮点数（float-double）" class="headerlink" title="内存中的浮点数（float double）"></a><div align=center>内存中的浮点数（float double）</h1><h2 id="1、存储方式"><a href="#1、存储方式" class="headerlink" title="1、存储方式"></a>1、存储方式</h2><p>符号位，指数，尾数</p>
<table>
<thead>
<tr>
<th>存储表</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>符号</td>
<td>指数</td>
<td>尾数</td>
</tr>
<tr>
<td>float</td>
<td>1位（第31位）</td>
<td>8位（第23-30位）</td>
<td>23位（第0-22位）</td>
</tr>
<tr>
<td>double</td>
<td>1位（第63位）</td>
<td>11位（第52-62位）</td>
<td>52位（第0-51位）</td>
</tr>
</tbody></table>
<h2 id="2、浮点数转换（十进制）"><a href="#2、浮点数转换（十进制）" class="headerlink" title="2、浮点数转换（十进制）"></a>2、浮点数转换（十进制）</h2><p>&nbsp; &nbsp; 1）将浮点数转换为二进制<br>&nbsp; &nbsp; 2）用科学计数法表示二进制浮点数<br>&nbsp; &nbsp; 3）计算指数偏移后的值 （指数+偏移量）<br>&nbsp; &nbsp; 4）偏移量：   float     127<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;double     1023</p>
<h2 id="3、8-25的float的表示"><a href="#3、8-25的float的表示" class="headerlink" title="3、8.25的float的表示"></a>3、8.25的float的表示</h2><ul>
<li><p><strong>转换为二进制数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;8.25   ==》 1000.01</p>
</li>
<li><p><strong>用科学计数法表示二进制浮点数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;100.01 ==》 1.00001 *2^3</p>
</li>
<li><p><strong>计算指数偏移后的值</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;3 + 127 = 130  ==》 1000 0010</p>
</li>
<li><p><strong>小数部分</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;00001</p>
</li>
<li><p><strong>内存中的表示</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;0x41040000<br>&nbsp;&nbsp;&nbsp;&nbsp;0（符号） 1000 0010（指数） 00001 0000000000000000（小数）</p>
</li>
<li><p><strong>补充知识点：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;二进制转换为十进制（乘2取整）<br>&nbsp;&nbsp;&nbsp;&nbsp;例子：0.25<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.25 x 2 = 0.5      取整是0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 x 2  = 1.0      取整是1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即0.25的二进制表示方法为0.01</p>
<h2 id="4、浮点型的秘密（重点）"><a href="#4、浮点型的秘密（重点）" class="headerlink" title="4、浮点型的秘密（重点）"></a>4、浮点型的秘密（重点）</h2></li>
<li><p><strong>float可以表示的具体数值个数与int类型相同</strong></p>
</li>
<li><p><strong>flaot可表示的数字之间是不连续的，存在间隙</strong></p>
</li>
<li><p><strong>float只是一种近似的表示法，不能作为精确数使用</strong></p>
</li>
<li><p><strong>float的运算速度比int慢的多</strong></p>
<h2 id="5、编程实验"><a href="#5、编程实验" class="headerlink" title="5、编程实验"></a>5、编程实验</h2><h3 id="编程实验1：8-25-float的表示"><a href="#编程实验1：8-25-float的表示" class="headerlink" title="编程实验1：8.25 float的表示"></a>编程实验1：8.25 float的表示</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/6.png" >

</li>
</ul>
<h3 id="编程实验2：float-类型的不精确性，与不连续性"><a href="#编程实验2：float-类型的不精确性，与不连续性" class="headerlink" title="编程实验2：float 类型的不精确性，与不连续性"></a>编程实验2：float 类型的不精确性，与不连续性</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/7.png" >

<h1 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a><div align=center>数据类型之间的转换</h1><h2 id="1、强制类型转换"><a href="#1、强制类型转换" class="headerlink" title="1、强制类型转换"></a>1、强制类型转换</h2><p><strong>(type)var_name</strong><br><strong>(type)vale</strong><br>转换结果：<br>&nbsp;&nbsp;1）目标类型能够容纳目标值:结果不变<br>&nbsp;&nbsp;2）目标类型不能容纳目标值:结果将产生截断保留低位丢掉高位<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：float转换为 int ,直接丢掉小数部分<br>&nbsp;&nbsp;3）不是所有的强制类型转换都能成功，不能转换编译器报错<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：结构体转换为 int 类型</p>
<h2 id="2、隐式类型转换"><a href="#2、隐式类型转换" class="headerlink" title="2、隐式类型转换"></a>2、隐式类型转换</h2><p>编译器主动进行的转换<br>低类型：占用字节数相对较小的变量<br>高类型：占用字节数相对较高的变量<br>1）转换的安全性<br>&nbsp;&nbsp;&nbsp;&nbsp;a）低类型到高类型的转换时是安全的，不会产生截断<br>&nbsp;&nbsp;&nbsp;&nbsp;b）高类型到低类型的转换时是不安全的，会产生截断，产生不正确的结果<br>2）转换发生点：<br>&nbsp;&nbsp;&nbsp;&nbsp;a）算数运算，低类型转换为高类型<br>&nbsp;&nbsp;&nbsp;&nbsp;b）赋值表达式中，表达式中的右值类型转换为左值的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;c）函数调用时，形参转换为实参的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;d）函数返回值，return表达式后面的返回值转换为返回值类型</p>
<img width=700 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/8.png" >

<h2 id="3、编程实验-2"><a href="#3、编程实验-2" class="headerlink" title="3、编程实验"></a>3、编程实验</h2><h3 id="编程实验1：强制类型转换"><a href="#编程实验1：强制类型转换" class="headerlink" title="编程实验1：强制类型转换"></a>编程实验1：强制类型转换</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/9.png" >

<h3 id="编程实验2：隐式类型转换"><a href="#编程实验2：隐式类型转换" class="headerlink" title="编程实验2：隐式类型转换"></a>编程实验2：隐式类型转换</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/10.png" >

<h1 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a><div align=center>分支语句</h1><h2 id="1、if-语句分析"><a href="#1、if-语句分析" class="headerlink" title="1、if 语句分析"></a>1、if 语句分析</h2><ul>
<li><strong>多用于复杂逻辑进行判断</strong></li>
<li><strong>与零值比较注意点</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）bool型变量应该直接出现在条件中，不要进行比较<br>&nbsp;&nbsp;&nbsp;&nbsp;2）变量和0/字面常量比较,0/字面常量应该出现在比较符的左边<br>&nbsp;&nbsp;&nbsp;&nbsp;3）float不能直接和0进行比较，需要定义精度</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (<span class="number">6</span> &lt;= i) &amp;&amp; (i &lt;= <span class="number">8</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Perfect!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f1(<span class="number">5</span>);	<span class="comment">// Failed!</span></span><br><span class="line">    f1(<span class="number">9</span>);	<span class="comment">// Perfect!</span></span><br><span class="line">    f1(<span class="number">7</span>);  <span class="comment">// Good!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	Failed!</span><br><span class="line">	Perfect!</span><br><span class="line">	Good!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2、switch-语句分析"><a href="#2、switch-语句分析" class="headerlink" title="2、switch 语句分析"></a>2、switch 语句分析</h2><ul>
<li><strong>多用于多分支判断</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）必须要有 break ，否则会导致分支重叠<br>&nbsp;&nbsp;&nbsp;&nbsp;2）case 语句中的值只能是整形或者字符型<br>&nbsp;&nbsp;&nbsp;&nbsp;3）按字母或者数字顺序排列各条语句<br>&nbsp;&nbsp;&nbsp;&nbsp;4）正常的放在前面，异常的放在后面<br>&nbsp;&nbsp;&nbsp;&nbsp;5）default 必须加上，只用于处理正真异常的情况</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">char</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Compile\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Debug\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Object\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Run\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f2(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// Object</span></span><br><span class="line">    f2(<span class="string">&#x27;d&#x27;</span>); <span class="comment">// Debug</span></span><br><span class="line">    f2(<span class="string">&#x27;e&#x27;</span>); <span class="comment">// Unknown</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	Object</span><br><span class="line">	Debug</span><br><span class="line">	Unknown</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3、循环语句"><a href="#3、循环语句" class="headerlink" title="3、循环语句"></a>3、循环语句</h2><ul>
<li><p><strong>for 先判断，适用于循环次数固定的循环</strong></p>
</li>
<li><p><strong>while 先判断，适用于循环次数不固定的场合</strong></p>
</li>
<li><p><strong>do while 循环至少执行一次循环体</strong></p>
</li>
<li><p><strong>break 和 continue 的区别</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;break 表示终止循环<br>&nbsp;&nbsp;&nbsp;&nbsp;continue 表示终止本次循环，进入下次循环</p>
</li>
<li><p><strong>do while(0) 巧妙使用，释放内存空间，避开内存泄漏</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        dosomething...;</span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dosomething...;</span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dosomething...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c语言变量属性"><a href="#c语言变量属性" class="headerlink" title="c语言变量属性"></a><div align=center>c语言变量属性</h1><h2 id="1、auto-关键字"><a href="#1、auto-关键字" class="headerlink" title="1、auto 关键字"></a>1、auto 关键字</h2></li>
<li><p><strong>C语言中局部变量的默认属性</strong></p>
</li>
<li><p><strong>表明被修饰的变量处于栈上</strong></p>
</li>
<li><p><strong>编译器默认所有的局部变量都是auto</strong></p>
<h2 id="2、register-关键字"><a href="#2、register-关键字" class="headerlink" title="2、register 关键字"></a>2、register 关键字</h2></li>
<li><p><strong>请求编译器将这个局部变量变量存储在寄存器中</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）如果申明具有全局属性的变量则编译器error<br>&nbsp;&nbsp;&nbsp;&nbsp;2）cpu寄存器有限不能长时间占用</p>
</li>
<li><p><strong>只是请求寄存器变量，不一定成功</strong></p>
</li>
<li><p><strong>变量必须是cpu可以接受的值</strong></p>
</li>
<li><p><strong>不能用&amp;运算符获取register变量的值，否则会报错</strong></p>
<blockquote>
<p>存在意义：当时为了解决效率问题，在尽可能需要效率的方，给你效率</p>
</blockquote>
</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>;   <span class="comment">// 向编译器申请将 j 存储于寄存器中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;j);   <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">	a.c:<span class="number">7</span>: error: address of <span class="keyword">register</span> variable ‘j’ requested</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3、static-关键字"><a href="#3、static-关键字" class="headerlink" title="3、static 关键字"></a>3、static 关键字</h2><ul>
<li><strong>指明”静态“属性</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1)被修饰的局部变量存储在程序的静态区</li>
<li><strong>具有”作用域限定符“作用</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1)修饰的全局变量作用域只是声明文件中<br>&nbsp;&nbsp;&nbsp;&nbsp;2)修饰函数的作用域只是声明的文件中</li>
</ul>
<p><strong>编程实验1，修饰局部变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    r++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    r++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> i = <span class="number">0</span>;       <span class="comment">// 显示声明 auto 属性，i 为栈变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;     <span class="comment">// 局部变量 k 的存储区位于静态区，作用域位于 main 中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>, &amp;i);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;j = %p\n&quot;</span>, &amp;k); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f1()); <span class="comment">// 1,1,1,1,1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f2()); <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">&amp;i = <span class="number">0xbfa141cc</span></span><br><span class="line">&amp;k = <span class="number">0x804a020</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>编程实验2，修饰全局变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件 a.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span>  <span class="comment">//使用是这个方式获得static声明的全局变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_j);     <span class="comment">// ERROR</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, getI());  <span class="comment">// 0   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	<span class="number">5</span><span class="number">-2.</span>c:(.<span class="built_in">text</span>+<span class="number">0xb</span>): undefined reference to `g_j<span class="number">&#x27;</span></span><br><span class="line">说明：</span><br><span class="line">	注释掉<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_j);正常运行输出<span class="number">0</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="4、extern-关键字"><a href="#4、extern-关键字" class="headerlink" title="4、extern 关键字"></a>4、extern 关键字</h2><ul>
<li><strong>用于声明“外部”定义的变量或函数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）变量在文件的其它地方分配空间<br>&nbsp;&nbsp;&nbsp;&nbsp;2）函数在文件其它地方定义</li>
</ul>
<p><strong>编程实验，函数定义部分参考static关键字编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	i = <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>“告诉”c++编译器用c方式编译</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5、goto-关键字"><a href="#5、goto-关键字" class="headerlink" title="5、goto 关键字"></a>5、goto 关键字</h2></li>
<li><strong>高手潜规则 禁用 goto</strong></li>
<li><strong>项目经验 程序的质量与 goto 出现的次数成反比</strong></li>
<li><strong>c语言是一种面向过程的结构性语言（顺序 选择 循环三种结构组合而成），goto 破坏了程序的结构性</strong><h2 id="6、const-只读变量"><a href="#6、const-只读变量" class="headerlink" title="6、const 只读变量"></a>6、const 只读变量</h2><h3 id="const-只读变量基本属性"><a href="#const-只读变量基本属性" class="headerlink" title="const 只读变量基本属性"></a>const 只读变量基本属性</h3></li>
<li><strong>const 变量是只读的，本质还是变量</strong></li>
<li><strong>const 修饰的局部变量在栈上分配空间</strong></li>
<li><strong>const 修饰的全局变量在全局数据区分配空间</strong></li>
<li><strong>const 只在编译期有用，在运行期无用</strong><blockquote>
<p>注意：<br>const 不能声明正真意义的常量，它只告诉编译器， const 修饰的变量不能出现在赋值符号的左边即不能只作为左值使用。现代c编译器将 const 修饰的具有全局生命的变量（全局变量/静态变量）储存于只读存储区，修改（指针） const 全局变量将导致程序崩溃,标准c语言编译器 const 修饰的全局变量在全局数据区分配空间，其值依然可以修改(指针)</p>
</blockquote>
</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_cc = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cc = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;cc;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cc = %d\n&quot;</span>, cc); <span class="comment">// cc = 1</span></span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">3</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cc = %d\n&quot;</span>, cc); <span class="comment">// cc = 3</span></span><br><span class="line">    </span><br><span class="line">    p = (<span class="keyword">int</span>*)&amp;g_cc;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc); <span class="comment">// g_cc = 2</span></span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">4</span>;					<span class="comment">// error</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	cc = <span class="number">1</span></span><br><span class="line">	cc = <span class="number">3</span></span><br><span class="line">	g_cc = <span class="number">2</span></span><br><span class="line">	段错误</span><br></pre></td></tr></table></figure>
<h3 id="const-变量常用区域"><a href="#const-变量常用区域" class="headerlink" title="const 变量常用区域"></a>const 变量常用区域</h3><ul>
<li><strong>const 修饰函数参数和函数返回值</strong></li>
<li><strong>const 修饰函数参数表示在函数体内不希望改变参数的值</strong></li>
<li><strong>const 修饰函数返回值表示返回值不可改变，多用于返回指针的情形</strong><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3></li>
<li>*<em>c语言中的字符串字面量存储于只读存储区中，在程序中需要使用 const char</em> 指针**<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* s = ”hello <span class="keyword">word</span>”; 	<span class="comment">//字符串字面量</span></span><br></pre></td></tr></table></figure>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/11.jpg" >
## 7、volatile 关键字
### 编译器警告指示字</li>
<li><strong>volatile 关键字告诉编译器每次必须去内存中取变量值</strong></li>
<li><strong>volatile 关键字主要修饰可能被多个线程访问的变量</strong></li>
<li><strong>volatile 也可修饰可能被未知因数更改的变量</strong>    <h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3>&nbsp;&nbsp;&nbsp;&nbsp;当变量在多线程的程序中被其他线程中改变（内存中的值被改变），或者在中断中被改变（内存中的值被改变），而在线程（中断）外部不会改变变量的值（不从内存中取值），volatile 会降低程序的效率（需要访存）即在需要的时候使用，不需要的不使用，多用于嵌入式驱动开发中，当我们直接访问某个内存地址时需要加上这个关键字。<h1 id="void-的意义"><a href="#void-的意义" class="headerlink" title="void 的意义"></a><div align=center>void 的意义</h1><h2 id="1、void修饰函数参数和返回值"><a href="#1、void修饰函数参数和返回值" class="headerlink" title="1、void修饰函数参数和返回值"></a>1、void修饰函数参数和返回值</h2></li>
<li><strong>如果函数没有返回值，那么应将其申明为 void</strong></li>
<li><strong>如果函数没有参数，那么应将其参数申明为 void</strong></li>
<li><strong>没有函数返回值类型，默认返回值类型为int</strong></li>
<li><strong>函数f()没有参数，f默认为参数为任意的参数</strong></li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f();</span><br><span class="line">	f(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;f() = %d\n&quot;</span>,f());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">	f() = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="2、void-修饰函数返回值和参数是为了表示“无”"><a href="#2、void-修饰函数返回值和参数是为了表示“无”" class="headerlink" title="2、void 修饰函数返回值和参数是为了表示“无”"></a>2、void 修饰函数返回值和参数是为了表示“无”</h2><ul>
<li><strong>void 为抽象类型(概念上的类型没有大小)</strong>        </li>
<li><strong>不能用于定义变量</strong></li>
<li><strong>不能用于定义数组</strong></li>
<li><strong>可以定义 void 类型的指针</strong></li>
<li><strong>任意的指针都是4个或者8个字节的指针</strong><blockquote>
<p>知识延伸<br>ANSIC:标准c语言规范，扩展c在ANSIC上进行扩充<br>gcc 对 void 进行了扩展，void 的大小为 1 </p>
</blockquote>
<h2 id="3、void指针的意义"><a href="#3、void指针的意义" class="headerlink" title="3、void指针的意义"></a>3、void指针的意义</h2></li>
<li><strong>c语言规定只有相同类型的指针才能相互赋值</strong></li>
<li>*<em>void</em> 指针作为左值用于“接受”任意类型的指针**</li>
<li>*<em>void</em> 指针作为右值使用时需要进行强制类型转换**    </li>
</ul>
<p>*<em>编程实验，void</em> 的使用**</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 函数名：MemSet</span></span><br><span class="line"><span class="comment"> * 功能说明：设置一片内存的每个字节为相同的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemSet</span><span class="params">(<span class="keyword">void</span>* src, <span class="keyword">int</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)src;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    MemSet(a, <span class="keyword">sizeof</span>(a), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]); <span class="comment">// 0,0,0,0,0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="struct-结构体"><a href="#struct-结构体" class="headerlink" title="struct 结构体"></a><div align=center>struct 结构体</h1><h2 id="1，定义与声明"><a href="#1，定义与声明" class="headerlink" title="1，定义与声明"></a>1，定义与声明</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">tag</span> <span class="title"></span></span><br><span class="line"><span class="title">&#123; </span></span><br><span class="line"><span class="title">member-list</span>;</span><br><span class="line"></span><br><span class="line">&#125;variable-list，*p_tag ;</span><br><span class="line">说明：</span><br><span class="line">struct 			  结构体关键字</span><br><span class="line"><span class="keyword">tag</span> 	 		  <span class="title">结构体标志</span></span><br><span class="line"><span class="title">variable-list</span>     定义此结构体时声明的变量</span><br><span class="line">member-list		  结构体成员变量</span><br><span class="line">struct <span class="keyword">tag</span>		  <span class="title">结构体的类型</span></span><br><span class="line"><span class="title">p_tag</span>             定义此结构体时声明的指针</span><br><span class="line">此结构体在声明的时候创建了两个变量，分别是结构体变量variable-list和结构体指针p_tag指向NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">member-<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">&#125;variable-<span class="built_in">list</span>，*p_tag ;</span><br><span class="line">与不用<span class="keyword">typedef</span> 的区别</span><br><span class="line">  a）variable-<span class="built_in">list</span> 定义此结构体时声明的结构体类型，等效于 <span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">  <span class="title">b</span>）<span class="title">p_tag</span>         定义此结构体时声明的结构体指针类型，等效于<span class="keyword">struct</span> <span class="title">tag</span>*</span></span><br></pre></td></tr></table></figure>
<h2 id="2，空结构体"><a href="#2，空结构体" class="headerlink" title="2，空结构体"></a>2，空结构体</h2><p>灰色地带，没有对错。实际开发没有人会定义空结构体<br>gcc  编译器空结构体占用的内存为0<br>bcc，vc10.0 编译器不允许空结构体的存在于c语言里面</p>
<h2 id="3，结构体与柔性数组"><a href="#3，结构体与柔性数组" class="headerlink" title="3，结构体与柔性数组"></a>3，结构体与柔性数组</h2><h3 id="柔性数组即大小待定的数组"><a href="#柔性数组即大小待定的数组" class="headerlink" title="柔性数组即大小待定的数组"></a>柔性数组即大小待定的数组</h3><p>c语言可以由结构体产生柔性数组<br>c语言中结构体中当最后一个元素是大小未知的数组时,不占内存空间（结构体中大小未知的数组不能单独存在，或存在多个）</p>
<h3 id="柔性数组的使用"><a href="#柔性数组的使用" class="headerlink" title="柔性数组的使用"></a>柔性数组的使用</h3><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/12.png" >

<p><strong>编程实验</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoftArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct SoftArray* <span class="title">create_soft_array</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SoftArray</span>* <span class="title">ret</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">size</span> &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = (struct SoftArray*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SoftArray) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="built_in">size</span>);</span><br><span class="line">        </span><br><span class="line">        ret-&gt;len = <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_soft_array</span><span class="params">(struct SoftArray* sa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(sa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(struct SoftArray* sa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != sa )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sa-&gt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sa-&gt;<span class="built_in">array</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SoftArray</span>* <span class="title">sa</span> =</span> create_soft_array(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    func(sa);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sa-&gt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sa-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    delete_soft_array(sa);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="union-联合体"><a href="#union-联合体" class="headerlink" title="union 联合体"></a><div align=center>union 联合体</h1><p>语法上与 struct 相似<br>union 只会分配最大成员空间，所有成员共享这个空间<br>注意： union 的使用受系统大小端的影响</p>
<pre><code>int i = 1;
0x01    0x00    0x00    0x00
——————————————————&gt;  高地址
小端模式    //低地址存储低位数据

int i = 1;
0x00    0x00    0x00    0x01
——————————————————&gt;  高地址
大端模式    //低地址存储高位数据

取地址规则：取值从低地址开始取值</code></pre>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">SM</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">SM</span> <span class="title">sm</span>;</span></span><br><span class="line">    </span><br><span class="line">    sm.i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sm.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;System Mode: %d\n&quot;</span>, system_mode()); <span class="comment">//返回1小端模式，返回0大端模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：System Mode: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>运行结果说明gcc编译器下的编译环境为小端模式，低地址存放低字节</p>
<h1 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a><div align=center>enum 枚举类型</h1><p>enum 是c语言的一种自定义类型<br>enum 值是可以根据需要自定义的整型值</p>
<h2 id="1、定义与声明"><a href="#1、定义与声明" class="headerlink" title="1、定义与声明"></a>1、定义与声明</h2><pre><code>enum enu_name            
&#123;
val1 = -1,
val2 = 3,
val3,
...
&#125;enum_val,...;
说明：
enum              枚举关键字
enu_name          枚举名
val1              标识符1 = 整型常数-1
val2              标识符1 = 整型常数3
val3              标识符1 = 整型常数4
enum_val          枚举变量
enum enu_name     枚举类型</code></pre>
<blockquote>
<p>注意：<br>1）枚举中每个成员（标识符）结束符是’,’最后一个可以省略<br>2）第一个定义未初始化的标识符默认为0<br>3）初始化可以赋负数<br>4）连续未赋值的的标识符的值是在前一个标识符的值基础上加1<br>5）enum 类型的变量只能取定义时的离散值<br>6）在c语言中可以定义正真意义上的常量<br>7）本质上枚举类型就是整型</p>
</blockquote>
<h1 id="sizeof-关键字"><a href="#sizeof-关键字" class="headerlink" title="sizeof 关键字"></a><div align=center>sizeof 关键字</h1><p>sizeof 用于计算类型或变量所占内存大小<br>用于类型 sizeof （type）<br>用于变量 sizeof （var） 或者 sizeof var </p>
<blockquote>
<p>注意：<br>1）sizeof 是编译器内置指示符(关键字)而不是函数<br>2）sizeof 在编译期就已经确定，在编译过程中所有的 sizeof 将    被具体的数值所替换，程序的执行过程与 sizeof 没有任何关系</p>
</blockquote>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">size</span> = sizeof(<span class="keyword">var</span>++);</span><br><span class="line">Printf(“<span class="keyword">var</span> = %d，<span class="built_in">size</span> = %d”，<span class="keyword">var</span>，<span class="built_in">size</span>); </span><br><span class="line"><span class="comment">//输出结果： 0  ， 4</span></span><br></pre></td></tr></table></figure>
<h1 id="typedef-关键字"><a href="#typedef-关键字" class="headerlink" title="typedef 关键字"></a><div align=center>typedef 关键字</h1><p>C语言中用于给已经存在的数据类型重命名<br>语法： typedef  type  new_neme;</p>
<blockquote>
<p>注意：<br>1）本质上不能产生新的类型<br>2）重命名的类型： a）可以在 typedef 语句之后定义； b）不能被 unsigned 和 signed 修饰</p>
</blockquote>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a><div align=center>注释</h1><p>编译器在编译过程中使用空格替换整个注释<br>字符串字面量中的//和/<em>…</em>/ 不代表注释符号<br>/<em>…</em>/不能被嵌套<br>在编译器看来注释和其他程序元素是平等的</p>
<blockquote>
<p>注意：<br>1）注释是对代码的提示，避免臃肿和喧宾夺主<br>2）一目了然的代码避免注释<br>3）不要用缩写来注释代码，这样可能会产生误解<br>4）注释用于阐述原因和意图而不是描述程序的运行过程<br>5）注释应该准确易懂，防止二义性，错误的注释有害无利</p>
</blockquote>
<h1 id="接续符"><a href="#接续符" class="headerlink" title="\ 接续符"></a><div align=center>\ 接续符</h1><p>编译器会将反斜杠剔除，跟在反斜杠后面的字符自动接续到前一行<br>在接续单词时，反斜杠不能有空格，反斜杠下一行也不能有空格<br>接续符适合在定义宏代码块时使用</p>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="\ 转义字符"></a><div align=center>\ 转义字符</h1><p>\n        换行回车<br>\t        横向跳到下一制表位置<br>\v        竖向挑格<br>\b        退格<br>\r        回车，回到行首<br>\f        走纸换页<br>\        反斜杠“\”<br>&#39;        单引号<br>\a        呜铃<br>\ddd      1<del>3 位8进制数所代表的字符<br>\xhh      1</del>2 位16进制数所代表的字符</p>
<blockquote>
<p>小结：a) \ 作为接续符使用可以出现在程序中间; b) \ 作为转义字符使用时需出现单引号或者双引号    之间</p>
</blockquote>
<h1 id="单引号双引号"><a href="#单引号双引号" class="headerlink" title="单引号双引号"></a><div align=center>单引号双引号</h1><p>c语言中的单引号用来表示字符字面量<br>‘a’占1个字节<br>‘a’ + 1 代表’a’的ascll码+1 ，结果为’b’<br>字符字面量被编译为对应的ascll码</p>
<p>c语言中的双引号用来表示字符串字面量<br>“a”占两个字节<br>“a” + 1 表示指针运算，结果指向”a”的结束符’/0’<br>字符串字面量被编译为对应的内存地址</p>
<blockquote>
<p>知识拓展<br>printf的第一个参数被当成字符串内存地址<br>内存的低地址空间不能在程序中随意访问即小于0x08048000的地址，随意访问会产生段错误</p>
</blockquote>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><div align=center>逻辑运算符</h1><h2 id="1、逻辑-和-amp-amp"><a href="#1、逻辑-和-amp-amp" class="headerlink" title="1、逻辑||和&amp;&amp;"></a>1、逻辑||和&amp;&amp;</h2><p>程序中的短路<br>||从左向右开始计算：（或）<br>&nbsp;&nbsp;&nbsp;&nbsp;当遇到为真的条件时停止计算，整个表达式为真<br>&nbsp;&nbsp;&nbsp;&nbsp;所有条件为假时表达式才为假<br>&amp;&amp;从左到右开始计算：（且）<br>&nbsp;&nbsp;&nbsp;&nbsp;当遇到为假的条件时停止计算，整个表达式为假<br>&nbsp;&nbsp;&nbsp;&nbsp;所有条件为真时表达式才为真</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ++i || ++j &amp;&amp; ++k;  <span class="comment">//  ==&gt; (true &amp;&amp; ++i) || (++j &amp;&amp; ++k)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k); <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/13.png" >

<h2 id="2、逻辑-！"><a href="#2、逻辑-！" class="headerlink" title="2、逻辑 ！"></a>2、逻辑 ！</h2><p>！0      返回1<br>！非0     返回0</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">0</span>);			<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">1</span>);			<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">100</span>);		<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">-1000</span>);		<span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="位运算符分析"><a href="#位运算符分析" class="headerlink" title="位运算符分析"></a><div align=center>位运算符分析</h1><p>c语言中的位运算符<br>    &amp;    按位与<br>    |    按位或<br>    ^    按位异或<br>    ~    按位取反<br>    &lt;&lt;    左移<br>    &gt;&gt;    右移</p>
<h2 id="1、左移右移"><a href="#1、左移右移" class="headerlink" title="1、左移右移"></a>1、左移右移</h2><p>1）左移<br>左移运算符 &lt;&lt; 将运算数的二进位左移<br>&nbsp;&nbsp;&nbsp;&nbsp;规则：高位丢弃，低位补0<br>&nbsp;&nbsp;&nbsp;&nbsp;移动一次相当于相当于乘2，运算效率更高<br>2）右移<br>右移运算符 &gt;&gt; 把运算数的二进制数右移<br>&nbsp;&nbsp;&nbsp;&nbsp;规则：高位补符号位，低位丢弃<br>&nbsp;&nbsp;&nbsp;&nbsp;移动一次相当于除二，运算效率更高<br>&nbsp;&nbsp;&nbsp;&nbsp;正数：有余舍弃<br>&nbsp;&nbsp;&nbsp;&nbsp;负数：有余进位</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> &lt;&lt; <span class="number">2</span>);      		<span class="comment">//12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> &gt;&gt; <span class="number">1</span>); 			<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span> &gt;&gt; <span class="number">1</span>); 			<span class="comment">//-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0x01</span> &lt;&lt; <span class="number">2</span> + <span class="number">3</span>);		<span class="comment">//32</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> &lt;&lt; <span class="number">-1</span>); <span class="comment">// oops!	</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>1）左操作数必须为整数类型<br>2）char 和 short 被隐式类型转换为了 int 后进行位移操作<br>3）右操作数的范围必须为[0,31]，如果操作数的值超出范围，则根据编译器的不同而不同，不能得到准确结果</p>
</blockquote>
<blockquote>
<p>扩充：<br>四则算符的优先级高于位运算符，容易出错<br>防错措施： 1）尽量避免位运算符，逻辑运算符，和数学运算符出现在同一个表达式中；2）需要时，尽量使用括号来表达运算次序</p>
</blockquote>
<h2 id="2、位运算与逻辑运算的不同"><a href="#2、位运算与逻辑运算的不同" class="headerlink" title="2、位运算与逻辑运算的不同"></a>2、位运算与逻辑运算的不同</h2><p>位运算没有短路规则，每个操作数都参与运算<br>位运算结果为整数，而不是0或1<br>位运算优先级高于逻辑运算</p>
<h2 id="3、常用技巧"><a href="#3、常用技巧" class="headerlink" title="3、常用技巧"></a>3、常用技巧</h2><p>1.操作一任意一个数据位,将一个char数据中的第三位置位</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">unsigned</span> char a;</span><br><span class="line"><span class="attribute">a</span> &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);  //将该位清零</span><br><span class="line"><span class="attribute">a</span> |= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;     //将该为置位</span><br></pre></td></tr></table></figure>
<p>2.操作一任意一个数据位,将一个int数据中的第3，4位置位</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">unsigned</span> char a;</span><br><span class="line"><span class="attribute">a</span> &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">3</span>);  //将该位清零</span><br><span class="line"><span class="attribute">a</span> |= <span class="number">3</span>&lt;&lt;<span class="number">3</span>;     //将该为置位</span><br></pre></td></tr></table></figure>
<p>运算优先级： 四则运算&gt;位运算&gt;逻辑运算</p>
<h1 id="、-操作符的本质"><a href="#、-操作符的本质" class="headerlink" title=" ++、- -操作符的本质"></a><div align=center> ++、- -操作符的本质</h1><h2 id="1、基本规则"><a href="#1、基本规则" class="headerlink" title="1、基本规则"></a>1、基本规则</h2><p>前置：变量自增（减），取变量值<br>后置：取变量值，变量自增（减）</p>
<p><strong>编程实验</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attr">i</span> = <span class="number">0</span>;</span><br><span class="line">    int <span class="attr">r</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">r</span> = (i++) + (i++) + (i++);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    printf(<span class="string">&quot;r = %d\n&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="attr">r</span> = (++i) + (++i) + (++i);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    printf(<span class="string">&quot;r = %d\n&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc运行结果：</span><br><span class="line"><span class="attr">i</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">i</span> = <span class="number">6</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">vs2010运行结果：</span><br><span class="line"><span class="attr">i</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">i</span> = <span class="number">6</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">java运行结果：</span><br><span class="line"><span class="attr">i</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">i</span> = <span class="number">6</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>C语言中只规定了++和—对应指令的相对执行顺序<br>++和—对应的汇编指令不一定连续运行<br>在混合运算中，++和—的汇编指令可能被打断执行<br>++和—参与混合运算结果是不确定的</p>
<h2 id="2、贪心法：-、-表达式的阅读技巧"><a href="#2、贪心法：-、-表达式的阅读技巧" class="headerlink" title="2、贪心法：++、- -表达式的阅读技巧"></a>2、贪心法：++、- -表达式的阅读技巧</h2><p>编译器处理的每个符号应尽可能的多包含字符<br>编译器以从左向右的顺序一个一个尽可能多的读入字符<br>当读入的字符不可能和已读入的字符组成合法符号为止</p>
<p><strong>编程实验</strong></p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = ++i+++i+++i;<span class="regexp">//</span>根据贪心发编译器读入++i++后才运算，==》<span class="number">1</span>++ ==》ERROR</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a+++b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    </span><br><span class="line">    b = b /*p;  <span class="regexp">//</span>根据贪心法，读入b/*之后便认为/*为注释符号，后面的内容全部为注释</span><br><span class="line"></span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">6</span>: error: lvalue required as increment operand</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">14</span>: error: unterminated comment</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">14</span>: error: expected ‘;’ at end of input</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">14</span>: error: expected declaration <span class="keyword">or</span> statement at end of input</span><br></pre></td></tr></table></figure>
<p>空格可以作为c语言中一个完整的休止符<br>编译器读入空格后立即对之前读入的符号进行处理</p>
<p><strong>编程实验，修改上面代码使它运行通过</strong></p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = ++i + ++i + ++i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a+++b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    </span><br><span class="line">    b = b / *p;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三目运算符（a-b-c）"><a href="#三目运算符（a-b-c）" class="headerlink" title="三目运算符（a?b:c）"></a><div align=center>三目运算符（a?b:c）</h1><p>可以作为逻辑运算的载体（为if条件句的简化形式）<br>规则<br>&nbsp;&nbsp;&nbsp;&nbsp;当a为真的时，返回b的值；否则返回c的值<br>三目运算符（a?b:c）的返回类型<br>&nbsp;&nbsp;&nbsp;&nbsp;1）通过隐式类型转换规则返回b和c中较高的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;2）当b和c不能隐式类型转换到同一类型将出错</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    m = a &lt; b ? a : b;   <span class="comment">// m = a ==&gt; m = 1</span></span><br><span class="line">    </span><br><span class="line">    (a &lt; b ? a : b) = <span class="number">3</span>; <span class="comment">// error</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);	 <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>, m); <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(c ? c : s) );  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(i ? i : d) );  <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(d ? d : p) );  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">5</span><span class="number">-2.</span>c:<span class="number">18</span>: error: lvalue required as left operand of assignment</span><br><span class="line"><span class="number">5</span><span class="number">-2.</span>c:<span class="number">26</span>: error: type mismatch in conditional expression</span><br></pre></td></tr></table></figure>
<h1 id="，逗号表达式"><a href="#，逗号表达式" class="headerlink" title="，逗号表达式"></a><div align=center>，逗号表达式</h1><p>用于将多个式子连接为一个表达式<br>逗号表达式的值为最后一个表达式的值<br>逗号表达式中前 N-1 表达式的值可以没有返回值<br>逗号表达式按照从左向右的顺序计算每个表达式的值:exp1,exp2,exp3,exp4…expN</p>
<p><strong>编程实验，使用逗号表达式检查输入指针的合法性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> assert(s), (*s ? <span class="built_in">strlen</span>(s + <span class="number">1</span>) + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Delphi&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, <span class="built_in">strlen</span>(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">len = <span class="number">6</span></span><br><span class="line">a.out: <span class="number">5</span><span class="number">-2.</span>c:<span class="number">6</span>: <span class="built_in">strlen</span>: Assertion `s<span class="number">&#x27;</span> failed.</span><br><span class="line">已放弃</span><br></pre></td></tr></table></figure>
<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a><div align=center>编译过程</h1><p>编译器的组成：预处理器，编译器，汇编器，链接器<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/14.png" ></p>
<h2 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h2><p>处理所有的注释<br>将所有的#define删除，并且展开所有的宏定义<br>处理条件预编译指令 #if，#ifdef，#elseif，#else，#endif<br>处理#inlude，展开被包含的文件<br>保留编译器需要使用的#pragma指令<br>linux预处理指令示例：<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc -E a.c -o a.i</p>
<h2 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h2><p>对于处理文件进行 词法分析，语法分析，和语义分析<br>&nbsp;&nbsp;&nbsp;&nbsp;a，词法分析：分析关键字，标识符，立即数是否合法<br>&nbsp;&nbsp;&nbsp;&nbsp;b，语法分析：分析表达式是否遵循语法规则<br>&nbsp;&nbsp;&nbsp;&nbsp;c，语义分析：在语法分析的基础上进一步分析表达式是否合法<br>&nbsp;&nbsp;&nbsp;&nbsp;d，分析结束后进行代码优化生成相应的汇编代码文件<br>linux编译指令示例：<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc -S a.c -o a.s </p>
<h2 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h2><p>汇编将源代码转变为机器可执行的二进制语言<br>每条汇编代码语句几乎都对应一条机器指令<br>linux汇编指令示例：<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc -c a.c -o a.o            </p>
<h2 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h2><p>静态链接<br>&nbsp;&nbsp;&nbsp;&nbsp;a）目标文件直接进入可执行程序<br>&nbsp;&nbsp;&nbsp;&nbsp;b）由链接器在链接时将库的内容直接加入到可执行程序中<br>&nbsp;&nbsp;&nbsp;&nbsp;c）Linux 下静态库的创建和使用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i）编译静态库源码：  gcc -c a.c -o a.o<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii）生成静态库文件： ar -q a.a a.o<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii）使用静态库编译：gcc main.c a.a -o main.out<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/15.png" ></p>
<p>动态链接<br>&nbsp;&nbsp;&nbsp;&nbsp;a）在程序启动后才加载目标文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i）可执行程序运行时才动态加载库进行链接<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii）库的内容不会进入可执行程序中<br>&nbsp;&nbsp;&nbsp;&nbsp;b）Linux 下动态库的创建和使用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译动态库源码：gcc -shares a.c -o a.so<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用动态库编译：gcc a.c -ldl -o a.out<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/16.png" ></p>
<blockquote>
<p>知识扩展：关键系统调用<br>dlopen:   打开动态库文件<br>dlsym:     查找动态库中的函数并返回调用地址<br>dlclose:     关闭动态库文件<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/17.png" ></p>
</blockquote>
<h1 id="程序中的宏定义-define"><a href="#程序中的宏定义-define" class="headerlink" title="程序中的宏定义#define"></a><div align=center>程序中的宏定义#define</h1><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><p>1）简单宏定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  宏名  替换文本</span></span><br></pre></td></tr></table></figure>
<p>2）带参宏定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	宏名(参数表)  宏体</span></span><br></pre></td></tr></table></figure>
<h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h2><p>1） 是预处理器的单元的实体之一<br>2） 定义的宏可以出现在程序中的任意位置<br>3） 定义的宏常量可以直接使用<br>4） 定义之后的代码都可以使用这个宏,没有作用域<br>5） 定义宏常量本质为字面量，不占内存空间<br>6） #define 表达式的使用类似于函数<br>7） #define 表达式可以比函数更强大<br>8） #define 表达式比函数更容易出错<br>9） 宏表达式被预处理器处理，编译器不知道宏表达式的存在<br>10）宏表达式用”实参”完全代替形参，不进行任何运算<br>11）宏表达式没有任何调用的开销<br>12）宏表达式中不能出现递归定义<br>13）宏定义效率高于函数<br>14）预处理器不会对宏定义进行语法检测<br>15）宏的使用会带来一定的副作用</p>
<h2 id="3、强大的内置宏"><a href="#3、强大的内置宏" class="headerlink" title="3、强大的内置宏"></a>3、强大的内置宏</h2><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/18.png" >

<p><strong>编程实验</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">MALLOC(<span class="params">type</span>, <span class="params">x</span>)</span> (<span class="keyword">type</span>*)malloc(sizeof(<span class="keyword">type</span>)*x)</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">FREE(<span class="params">p</span>)</span> (free(p), p=NULL)</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">LOG(<span class="params">s</span>)</span> printf(<span class="string">&quot;[%s] &#123;%s:%d&#125; %s \n&quot;</span>, __DATE__, __FILE__, __LINE__, s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span>* p = <span class="constructor">MALLOC(<span class="params">int</span>, 5)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">LOG(<span class="string">&quot;Begin to run main code...&quot;</span>)</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        p<span class="literal">[<span class="identifier">i</span>]</span> = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;%d\n&quot;</span>, p<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">FREE(<span class="params">p</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">LOG(<span class="string">&quot;End&quot;</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="literal">[A<span class="identifier">ug</span> <span class="number">13</span> <span class="number">2019</span>]</span> &#123;<span class="number">5</span>-<span class="number">2.</span>c:<span class="number">15</span>&#125; Begin <span class="keyword">to</span> run main code... </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="literal">[A<span class="identifier">ug</span> <span class="number">13</span> <span class="number">2019</span>]</span> &#123;<span class="number">5</span>-<span class="number">2.</span>c:<span class="number">29</span>&#125; End </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="条件编译使用分析"><a href="#条件编译使用分析" class="headerlink" title="条件编译使用分析"></a><div align=center>条件编译使用分析</h1><p>类似于c语言中的条件语句 if…else…<br>用于控制是否编译某段代码 </p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> 的本质是将已经存在的文件内容嵌入到当前文件中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> 的间接包含同样会产生嵌入文件内容的操作</span></span><br><span class="line"></span><br><span class="line">条件编译可以解决头文件重复包含的编译错误</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADER_FILE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADER_FILE_H_</span></span><br><span class="line">	<span class="comment">//	source code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>...#<span class="meta-keyword">else</span>...#<span class="meta-keyword">endif</span>被预编译处理，而 <span class="meta-keyword">if</span>...<span class="meta-keyword">else</span>...语句被编译器处理必然被编译进目标代码</span></span><br><span class="line">条件编译使我们可以按不同的条件编译不同的代码段，因而可以产生不同的目标代码</span><br></pre></td></tr></table></figure>
<p>实际工作中的条件编译主要用于以下两种情况<br>&nbsp;&nbsp;&nbsp;&nbsp;不同的产品线共用一份代码<br>&nbsp;&nbsp;&nbsp;&nbsp;编译产品的调试版和发布版</p>
<h1 id="error编译分析"><a href="#error编译分析" class="headerlink" title="#error编译分析"></a><div align=center>#error编译分析</h1><p>用于生成一个编译错误消息<br>是一种预编译器指示字<br>用法    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">error</span> message</span></span><br><span class="line">	注：message不需要用引号包围</span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>编译指示字用于自定义程序员特有的编译错误消息,类似#<span class="meta-keyword">warning</span>用于生成编译警告</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> 可用于提示预编译条件是否满足</span></span><br><span class="line">例子：</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span>  __cplusplus</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">error</span>	This file shoud be processed with c++ compiler.</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注：编译过程中的任意错误信息意味着无法生成最终可执行程序。</strong><h1 id="line指示字"><a href="#line指示字" class="headerlink" title="#line指示字"></a><div align=center>#line指示字</h1>用于强制指定新的行号和编译文件名，并对源程序的代码重新编号<br>用法<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="meta">#line  number  filename</span></span><br><span class="line">filename可以省略</span><br><span class="line"><span class="meta">#line的本质是重定义__LINE__和__FILE__</span></span><br></pre></td></tr></table></figure>
<h1 id="pragma指示字"><a href="#pragma指示字" class="headerlink" title="#pragma指示字"></a><div align=center>#pragma指示字</h1><h2 id="1、一般用法："><a href="#1、一般用法：" class="headerlink" title="1、一般用法："></a>1、一般用法：</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> parameter</span></span><br></pre></td></tr></table></figure>
注：不同的 parameter 参数语法各不相同<h2 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h2>1）用于指示编译器完成一些特定的动作<br>2）所定义的很多指示字是编译器特有的<br>3）在不同的编译器间是不可移植的<br>4）预处理器将忽略他不认识的 #pragma 指令<br>5）不同的编译器可能以不同的方式解释同一条#pragma指令<h2 id="3、-pragma-message-“内容”"><a href="#3、-pragma-message-“内容”" class="headerlink" title="3、#pragma message(“内容”)"></a>3、#pragma message(“内容”)</h2>1）message参数在大多数编译器中都有相同的实现<br>2）message参数在编译时输出编译消息到编译窗口中<br>3）message用于条件编译中可提示代码的版本信息<br>例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ANDROID20</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">pragma</span> message(<span class="meta-string">&quot;Complite Android SDK 2.0...&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">注：与<span class="meta">#<span class="meta-keyword">error</span>和#<span class="meta-keyword">warning</span>不同 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> message 不代表程序错误，仅代表一条编译信息</span></span><br></pre></td></tr></table></figure>
<h2 id="4、-pragma-once-关键字"><a href="#4、-pragma-once-关键字" class="headerlink" title="4、#pragma once 关键字"></a>4、#pragma once 关键字</h2>1）用于保证头文件只被编译一次<br>2）是与编译器相关的，不一定被支持<br>3）与#ifdef … #define … #endif的区别<br>&nbsp;&nbsp;&nbsp;&nbsp;a）效率不如#pragma once<br>&nbsp;&nbsp;&nbsp;&nbsp;b）支持性比#pragma once好<br>4）使用时两者结合<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _FLIE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _FLIE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码块</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="5、-pragma-pack关键字（用于指定内存的对齐方式）"><a href="#5、-pragma-pack关键字（用于指定内存的对齐方式）" class="headerlink" title="5、#pragma pack关键字（用于指定内存的对齐方式）"></a>5、#pragma pack关键字（用于指定内存的对齐方式）</h2>1）内存对齐<br>&nbsp;&nbsp;&nbsp;&nbsp;a）不同类型的数据在内存中按照一定的规则排列<br>&nbsp;&nbsp;&nbsp;&nbsp;b）而不是一定的顺的一个接一个的排列<br>2）内存对齐的原因<br>&nbsp;&nbsp;&nbsp;&nbsp;a）CPU对内存的读取不是连续的，而是分块读取的，块的大小只能是 1,2,4,8,16… 字节<br>&nbsp;&nbsp;&nbsp;&nbsp;b）当读取操作的数据未对齐，则需要两次总线周期来访问内存，因此性能会大打折扣<br>&nbsp;&nbsp;&nbsp;&nbsp;c）某些硬件平台只能从规定的相对地址处读取特定类型数据，否则产生硬件异常<br>3）struct 占用的内存大小<br>&nbsp;&nbsp;&nbsp;&nbsp;a）第一个成员起始于0偏移处<br>&nbsp;&nbsp;&nbsp;&nbsp;b）每个成员按其类型大小和pack参数中较小的一个进行对齐<br>&nbsp;&nbsp;&nbsp;&nbsp;c）偏移地址必须能够被对齐参数整除<br>&nbsp;&nbsp;&nbsp;&nbsp;d）结构体成员的大小取其内部长度最大的数据成员作为其大小<br>&nbsp;&nbsp;&nbsp;&nbsp;e）结构体的总长度必须为所有对齐参数的整数倍<br>&nbsp;&nbsp;&nbsp;&nbsp;f）编译器在默认情况下按照4字节对齐<br>例子：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">未使用 <span class="comment">#pragma pack </span></span><br><span class="line">	struct test1		<span class="regexp">//</span>		 内存计算</span><br><span class="line">	&#123;				<span class="regexp">//</span>对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>			<span class="number">1</span></span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">2</span>		  <span class="number">2</span>			<span class="number">2</span></span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">4</span>			<span class="number">1</span></span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">4</span>		  <span class="number">8</span>			<span class="number">4</span> ==&gt; <span class="number">12</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test1) = <span class="number">12</span>;</span><br><span class="line">	struct test1		<span class="regexp">//</span>		 内存计算</span><br><span class="line">	&#123;				<span class="regexp">//</span>对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>		   <span class="number">1</span> </span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">1</span>		   <span class="number">1</span></span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">2</span>		  <span class="number">2</span>		   <span class="number">2</span></span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">4</span>		  <span class="number">4</span>		   <span class="number">4</span>  ==&gt; <span class="number">8</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test2) = <span class="number">8</span>;	</span><br><span class="line">	</span><br><span class="line">使用 <span class="comment">#pragma pack</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#pragma pack(1)												</span></span><br><span class="line">	struct test1		<span class="regexp">//</span>		 内存计算	</span><br><span class="line">	&#123;				<span class="regexp">//</span>对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>		 <span class="number">1</span>				</span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">1</span>		 <span class="number">2</span>				</span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">3</span>		 <span class="number">1</span>				</span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">4</span>		 <span class="number">4</span>	==&gt; <span class="number">8</span>	</span><br><span class="line">	&#125;;	</span><br><span class="line"><span class="comment">#pragma pack()</span></span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test1) = <span class="number">8</span>;			</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">#pragma pack(1)</span></span><br><span class="line">	struct test1		<span class="regexp">//</span>		内存计算</span><br><span class="line">	&#123;				<span class="regexp">//</span>		对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>		  <span class="number">1</span>				</span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">1</span>		  <span class="number">1</span>			</span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">2</span>		  <span class="number">2</span>			</span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">4</span>		  <span class="number">4</span>	==&gt; <span class="number">8</span>		</span><br><span class="line">	&#125;;														</span><br><span class="line">	<span class="comment">#pragma pack()</span></span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test2) = <span class="number">8</span>;	</span><br></pre></td></tr></table></figure>
<p>例子：微软面试题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>			//		内存计算</span></span><br><span class="line"><span class="class">&#123;</span>					<span class="comment">//		对齐参数		偏移地址		大小</span></span><br><span class="line">	<span class="keyword">short</span> a;	    <span class="comment">//		2			0		 2</span></span><br><span class="line">	<span class="keyword">long</span> b;	    	<span class="comment">//		4			4		 4	 ==&gt; 8</span></span><br><span class="line">&#125;;														</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span>			//			内存计算							</span></span><br><span class="line"><span class="class">&#123;</span>				<span class="comment">//对齐参数	 偏移地址  	大小</span></span><br><span class="line">	<span class="keyword">char</span> c;			<span class="comment">//	1			0		 1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">d</span>;</span>	<span class="comment">//	4			4		 4</span></span><br><span class="line">	<span class="keyword">double</span> e;		<span class="comment">//	8			16		 8	==&gt; 24</span></span><br><span class="line">&#125;;			         </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p>注：gcc编译器暂时不支持 #pragma pack(8) 所以计算结果为20;在不同的编译器可能会有不同的结果</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="# 运算符"></a><div align=center># 运算符</h1><h2 id="1、含义作用"><a href="#1、含义作用" class="headerlink" title="1、含义作用"></a>1、含义作用</h2><p>1）用于在预处理期将宏参数转换为字符串<br>2）作用是在预处理期完成的，因此只在宏定义中有效<br>3）编译器不知道#的转换作用</p>
<h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  STRING(X)  #X</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,STRING(hello <span class="keyword">word</span>));</span><br></pre></td></tr></table></figure>
<h1 id="运算符-1"><a href="#运算符-1" class="headerlink" title="## 运算符"></a><div align=center>## 运算符</h1><h2 id="1、含义作用-1"><a href="#1、含义作用-1" class="headerlink" title="1、含义作用"></a>1、含义作用</h2><p>1）用于在预处理期粘连两个标识符<br>2）##的连接作用是在预处理期完成的<br>3）只在宏定义中有效<br>4）编译器不知道##的连接作用</p>
<h2 id="2、用法-1"><a href="#2、用法-1" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">CONNECT(<span class="params">a</span>,<span class="params">b</span>)</span> a##b</span><br><span class="line"><span class="built_in">int</span> <span class="constructor">CONNECT(<span class="params">a</span>,1)</span>;</span><br><span class="line">a1 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3、-巧妙使用"><a href="#3、-巧妙使用" class="headerlink" title="3、##巧妙使用"></a>3、##巧妙使用</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define STRUCT(type) typedef struct _tag_##type type;\</span></span><br><span class="line">                     struct _tag_<span class="comment">##type</span></span><br><span class="line"></span><br><span class="line">STRUCT(Student)</span><br><span class="line">&#123;</span><br><span class="line">    char* <span class="built_in">name</span>;</span><br><span class="line">    int <span class="built_in">id</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    Student s1;</span><br><span class="line">    Student s2;</span><br><span class="line">    </span><br><span class="line">    s1.<span class="built_in">name</span> = <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">    s1.<span class="built_in">id</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    s2.<span class="built_in">name</span> = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    s2.<span class="built_in">id</span> = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">&quot;s1.name = %s\n&quot;</span>, s1.<span class="built_in">name</span>);</span><br><span class="line">    printf(<span class="string">&quot;s1.id = %d\n&quot;</span>, s1.<span class="built_in">id</span>);</span><br><span class="line">    printf(<span class="string">&quot;s2.name = %s\n&quot;</span>, s2.<span class="built_in">name</span>);</span><br><span class="line">    printf(<span class="string">&quot;s2.id = %d\n&quot;</span>, s2.<span class="built_in">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">    return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针，数组与字符串"><a href="#指针，数组与字符串" class="headerlink" title="指针，数组与字符串"></a><div align=center>指针，数组与字符串</h1><h2 id="1、指针的本质分析"><a href="#1、指针的本质分析" class="headerlink" title="1、指针的本质分析"></a>1、指针的本质分析</h2><h3 id="1-申明"><a href="#1-申明" class="headerlink" title="1) 申明"></a>1) 申明</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">int</span>* p = &amp;i;</span><br></pre></td></tr></table></figure>
<p>p中保存着i的地址<br>指针是变量保存的是所指向的变量的地址</p>
<h3 id="2-号的意义"><a href="#2-号的意义" class="headerlink" title="2) *号的意义"></a>2) *号的意义</h3><p>a）在指针申明时，*表示所申明的变量为指针<br>b）在指针使用时，*表示取指针所指向的内存空间的值<br>c）*类似于一把钥匙，通过这把钥匙可以打开内存，读取内存中的值</p>
<h3 id="3-传值调用与传址调用"><a href="#3-传值调用与传址调用" class="headerlink" title="3)传值调用与传址调用"></a>3)传值调用与传址调用</h3><p>a）当一个函数体内部需要改变实参的值，则需要使用指针参数<br>b）函数调用时实参将复制到形参<br>c）指针适用于复杂数据类型作为参数的函数中</p>
<h3 id="4-指针与常量"><a href="#4-指针与常量" class="headerlink" title="4)指针与常量"></a>4)指针与常量</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>*  p;					<span class="comment">//p可变，  p指向的内容不可变</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">const</span>*  p;					<span class="comment">//p可变，  p指向的内容不可变</span></span><br><span class="line"><span class="built_in">int</span>* <span class="keyword">const</span>  p;					<span class="comment">//p不可变，p指向的内容可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>* <span class="keyword">const</span>  p;		   <span class="comment">//p不可变，p指向的内容不可变  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> 在*p之前，p指向的内容不可变</span><br><span class="line"><span class="keyword">const</span> 在p之前，p不可变</span><br></pre></td></tr></table></figure>
<h2 id="2、数组的概念"><a href="#2、数组的概念" class="headerlink" title="2、数组的概念"></a>2、数组的概念</h2><h2 id="1）声明"><a href="#1）声明" class="headerlink" title="1）声明"></a>1）声明</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int a[x]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）说明"><a href="#2）说明" class="headerlink" title="2）说明"></a>2）说明</h3><p>a）数组是相同类型变量的有序集合<br>b）a 代表数组第一个元素的起始地址<br>c）数组包含x个int类型的数据<br>d）这x*4个字节空间的名字为a</p>
<blockquote>
<p>注：a[0],a[1],都是数组中的元素，并非数组元素的名字。数组中的元素没有名字</p>
</blockquote>
<h3 id="3）数组的大小"><a href="#3）数组的大小" class="headerlink" title="3）数组的大小"></a>3）数组的大小</h3><p>a）数组在一片连续内存空间中存储元素<br>b）数组元素的个数可以显示或隐式指定</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> a[<span class="number">5</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;	//显式指定</span><br><span class="line"><span class="attribute">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;	//隐式指定</span><br></pre></td></tr></table></figure>
<h3 id="4）数组的本质"><a href="#4）数组的本质" class="headerlink" title="4）数组的本质"></a>4）数组的本质</h3><p>a）数组是一段连续的内存空间<br>b）数组的空间大小为 *<em>sizeof(arry_type)<em>arry_size</em></em><br>c）数组名可以看做指向数组第一个元素的常量指针<br>d）数组元素的地址和数组元素第一个元素的地址的地址值相同但表示的意义不同</p>
<h3 id="5）编程实验"><a href="#5）编程实验" class="headerlink" title="5）编程实验"></a>5）编程实验</h3><p>a）验证数组名本质不是常量指针</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c 文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span>* a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d\n&quot;</span>, *a);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc环境下编译运行：gcc main.c test.c</span><br><span class="line">运行结果：</span><br><span class="line">&amp;a = <span class="number">0x804a014</span></span><br><span class="line">a = <span class="number">0x1</span></span><br><span class="line">段错误</span><br></pre></td></tr></table></figure>
<p>b）数组名遇到sizeof表示整个数组的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a));   <span class="comment">// 整个数组元素大小 20</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="3、指针的运算"><a href="#3、指针的运算" class="headerlink" title="3、指针的运算"></a>3、指针的运算</h2><h3 id="1）指针与整数的运算规则为"><a href="#1）指针与整数的运算规则为" class="headerlink" title="1）指针与整数的运算规则为"></a>1）指针与整数的运算规则为</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p + n; &lt;——&gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)p + <span class="function">n*<span class="title">sizeof</span><span class="params">(*p)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：<br>当指针p指向一个同类型的数组元素时：<br>p + 1 将指向当前元素的下一个元素<br>p - 1 将指向当前元素的上一个元素</p>
</blockquote>
<h3 id="2）指针与指针之间的运算"><a href="#2）指针与指针之间的运算" class="headerlink" title="2）指针与指针之间的运算"></a>2）指针与指针之间的运算</h3><p>a)指针之间只支持减法运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p1 - p2 ; &lt;——&gt; ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)p1 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)p2)/<span class="keyword">sizeof</span>(*p1)</span><br></pre></td></tr></table></figure>
<p>b）参与减法运算的指针类型必须相同<br>c）当两个指针指向的元素不在同一个数组中时，结果未定义<br>d）只有当两个指针指向同一个数组中的元素时，指针相减才有意义，其意义为指针所指元素的下标差</p>
<h3 id="3）指针之间的比较运算"><a href="#3）指针之间的比较运算" class="headerlink" title="3）指针之间的比较运算"></a>3）指针之间的比较运算</h3><p>a）指针也可以进行比较运算(&lt;, &lt;= ,&gt;, &gt;=)<br>b）指针关系运算的前提是同时指向同一个数组中的元素<br>c）任意两个指针之间的比较运算( ==, != )无限制<br>d）参与运算的两个指针类型必须相同</p>
<h3 id="4）编程实验"><a href="#4）编程实验" class="headerlink" title="4）编程实验"></a>4）编程实验</h3><p>a）指针运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* p0 = s1;				</span><br><span class="line">    <span class="keyword">char</span>* p1 = &amp;s1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span>* p2 = s2;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;i;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 - p1);   <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 + p2);   <span class="comment">// ERROR</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 - p2);   <span class="comment">// Unknown value</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 - p);	   <span class="comment">// ERROR</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 * p2);   <span class="comment">// ERROR</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 / p2);   <span class="comment">// REEOR</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b）指针+数组边界访问数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIM(a) (sizeof(a) / sizeof(*a))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* pBegin = s;</span><br><span class="line">    <span class="keyword">char</span>* pEnd = s + DIM(s); <span class="comment">// Key point</span></span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pBegin = %p\n&quot;</span>, pBegin);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pEnd = %p\n&quot;</span>, pEnd);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size: %d\n&quot;</span>, pEnd - pBegin);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(p=pBegin; p&lt;pEnd; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、数组的访问方式"><a href="#4、数组的访问方式" class="headerlink" title="4、数组的访问方式"></a>4、数组的访问方式</h2><h3 id="1）访问方式"><a href="#1）访问方式" class="headerlink" title="1）访问方式"></a>1）访问方式</h3><p><strong>下标的形式访问数组 a[1];</strong><br>*<em>指针的形式访问数组 <em>(a+1);</em></em></p>
<h3 id="2）下标形式与指针形式的转换"><a href="#2）下标形式与指针形式的转换" class="headerlink" title="2）下标形式与指针形式的转换"></a>2）下标形式与指针形式的转换</h3><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">a[<span class="built_in">n</span>] &lt;——&gt; *(a + <span class="built_in">n</span>) &lt;——&gt; *(<span class="built_in">n</span> + a) &lt;——&gt; <span class="built_in">n</span>[a]</span><br></pre></td></tr></table></figure>
<h3 id="3）两者的优缺点"><a href="#3）两者的优缺点" class="headerlink" title="3）两者的优缺点"></a>3）两者的优缺点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;a）指针以固定增量在数组中移动时，效率高于下标形式。<br>&nbsp;&nbsp;&nbsp;&nbsp;b）指针增量为 1 且硬件具有硬件增量模型时，效率更高</p>
<blockquote>
<p>注意：现代编译器的生成代码优化率已经大大提高，在固定增量时，下标形式的效率已经和指针形式相当；但从可读性和代码维护的角度看，下标形式更优。</p>
</blockquote>
<h3 id="4）编程实验-1"><a href="#4）编程实验-1" class="headerlink" title="4）编程实验"></a>4）编程实验</h3><p>a）指针与数组的访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p = a;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, *(a + i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        i[a] = i + <span class="number">10</span>;  <span class="comment">// ==&gt; *(i+a) ==&gt; *(a+i) ==&gt; a[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p[%d] = %d\n&quot;</span>, i, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b）指针与数组的混合运算练习</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p1 = (<span class="keyword">int</span>*)(&amp;a + <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">int</span>* p2 = (<span class="keyword">int</span>*)((<span class="keyword">int</span>)a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>* p3 = (<span class="keyword">int</span>*)(a + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %x, %d\n&quot;</span>, p1[<span class="number">-1</span>], p2[<span class="number">0</span>], p3[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// p[-1] ==&gt; *( p + (-1) ) ==&gt; *(p-1)  ==&gt;  a[5] ==&gt; 5</span></span><br><span class="line">	<span class="comment">/* 10 00 00 00 20 00 00 00 30 00 00 00 40 00 00 00 50 00 00 00  小端模式存储数据</span></span><br><span class="line"><span class="comment">	   ==&gt; p2[0] ==&gt; 0x02000000</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// p3[1] ==&gt; 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">运行结果： <span class="number">5</span>, <span class="number">2000000</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、a和-amp-a的区别"><a href="#5、a和-amp-a的区别" class="headerlink" title="5、a和&amp;a的区别"></a>5、a和&amp;a的区别</h2><p>a  为数组首元素的地址<br>&amp;a 为整个数组的地址<br>a 和 &amp;a 的区别在于指针运算</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">a<span class="number">+1</span>	==&gt; <span class="comment">(unsigned int)</span>a + sizeof<span class="comment">(*a)</span></span><br><span class="line"></span><br><span class="line">&amp;a + <span class="number">1</span>	==&gt; <span class="comment">(unsigned int)</span><span class="comment">(&amp;a)</span> + sizeof<span class="comment">(*(&amp;a)</span>)  ==&gt; <span class="comment">(unsigned int)</span><span class="comment">(&amp;a)</span> + sizeof<span class="comment">(a)</span></span><br></pre></td></tr></table></figure>
<h2 id="6、数组参数"><a href="#6、数组参数" class="headerlink" title="6、数组参数"></a>6、数组参数</h2><h3 id="a）数组作为参数时，编译器将其编译成对应的指针"><a href="#a）数组作为参数时，编译器将其编译成对应的指针" class="headerlink" title="a）数组作为参数时，编译器将其编译成对应的指针"></a>a）数组作为参数时，编译器将其编译成对应的指针</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;   &lt;==&gt;  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="number">5</span>])</span></span>;  &lt;==&gt;  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：一般情况下，当定义的函数中数组参数时，需要定义另一个参数来表示数组大小。</p>
</blockquote>
<h3 id="b）编程实验"><a href="#b）编程实验" class="headerlink" title="b）编程实验"></a>b）编程实验</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">char</span> a[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func1: sizeof(a) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a));  <span class="comment">// 数组退化为指针 ==&gt; In func1: sizeof(a) = 4</span></span><br><span class="line">    </span><br><span class="line">    *a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    a = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func2: sizeof(b) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(b)); <span class="comment">// 数组退化为指针 ==&gt; In func1: sizeof(a) = 4</span></span><br><span class="line">    </span><br><span class="line">    *b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    func1(<span class="built_in">array</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %c\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// array[0] = a</span></span><br><span class="line">    </span><br><span class="line">    func2(<span class="built_in">array</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %c\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// array[0] = b</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">In func1: <span class="keyword">sizeof</span>(a) = <span class="number">4</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = a</span><br><span class="line">In func2: <span class="keyword">sizeof</span>(b) = <span class="number">4</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = b</span><br></pre></td></tr></table></figure>
<h2 id="7、数组类型"><a href="#7、数组类型" class="headerlink" title="7、数组类型"></a>7、数组类型</h2><h3 id="1）c语言中的数组有自己特定的类型"><a href="#1）c语言中的数组有自己特定的类型" class="headerlink" title="1）c语言中的数组有自己特定的类型"></a>1）c语言中的数组有自己特定的类型</h3><p>数组的类型由元素类型和数组大小共同决定<br>例： int arry[5] 的类型为 int[5]</p>
<h3 id="2）定义数组类型"><a href="#2）定义数组类型" class="headerlink" title="2）定义数组类型"></a>2）定义数组类型</h3><p>c语言通过 typedef 为数组类型重命名</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">type</span>(name)[size];</span><br></pre></td></tr></table></figure>
<p>重定义数组类型：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef int(<span class="type">AINT5</span>)[5];</span><br><span class="line">typedef float(<span class="type">AFLOAT</span>)[10];</span><br></pre></td></tr></table></figure>
<p>数组定义：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">AINT5 iArry<span class="comment">;</span></span><br><span class="line">AFLOAT farry<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="8、数组指针"><a href="#8、数组指针" class="headerlink" title="8、数组指针"></a>8、数组指针</h2><h3 id="1）声明-1"><a href="#1）声明-1" class="headerlink" title="1）声明"></a>1）声明</h3><p>可以通过数组类型定义数组指针：<strong>ArryType* pointer;**<br>也可以直接定义：    **type(*pointer)[n];</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;pointer    为数组指针变量名<br>&nbsp;&nbsp;&nbsp;&nbsp;type    为指向的数组的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;n        为指向的数组的大小</p>
<h3 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h3><p>a）数组指针用于指向一个数组<br>b）数组名是数组首元素的起始地址，但并不是数组的起始地址<br>c）通过将取地址符&amp;作用于数组名可以得到数组的起始地址</p>
<h2 id="9、指针数组"><a href="#9、指针数组" class="headerlink" title="9、指针数组"></a>9、指针数组</h2><p>指针数组是一个普通的数组<br>指针数组中的每一个元素为指针<br>指针数组的定义：<strong>type* pArry[n];**<br>&nbsp;&nbsp;&nbsp;&nbsp;*<em>type</em> 为数组中每个元素的类型</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>PArry 为数组名</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>n      为数组大小</strong></p>
<h2 id="10、二维指针"><a href="#10、二维指针" class="headerlink" title="10、二维指针"></a>10、二维指针</h2><p>指向指针的指针<br>指针会占用一定的内存空间<br>可以定义指针的指针来保存指针的地址</p>
<h3 id="1）二维数组与二级指针"><a href="#1）二维数组与二级指针" class="headerlink" title="1）二维数组与二级指针"></a>1）二维数组与二级指针</h3><p>二维数组在数内存中以一维的方式排布<br>二维数组中的第一维是一维数组<br>二维维数组中的第二维才是具体的值<br>二维数组的数组名可以看做常量指针</p>
<h3 id="2）数组名"><a href="#2）数组名" class="headerlink" title="2）数组名"></a>2）数组名</h3><p>一维数组名代表数组首元素的地址</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a[];     <span class="comment">//a的类型为 int*;</span></span><br></pre></td></tr></table></figure>
<p>二维数组名同样代表数组元素的地址</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> m[<span class="number">2</span>][<span class="number">5</span>]; //m的类型为 int(*)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：1. 二维数组名可以看做是指向一维数组的常量数组指针; 2. 二维数组可以看做是一维数组; 3. 二维数组中的每个元素都是同类型的一维数组; 4. c语言中的数组在函数参数中会退化成指针</p>
</blockquote>
<h3 id="3-二维数组参数"><a href="#3-二维数组参数" class="headerlink" title="3)二维数组参数"></a>3)二维数组参数</h3><p>二维数组参数同样存在退化的问题<br>二维数组可以看做是一维数组<br>二维数组中的每个元素是一维数组<br>二维数组的第一个参数可以省略</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> f(<span class="built_in">int</span> a[<span class="number">5</span>])    &lt;——&gt; <span class="built_in">void</span> f(<span class="built_in">int</span> a[])    &lt;——&gt; <span class="built_in">void</span> f(<span class="built_in">int</span> *a)</span><br><span class="line"><span class="built_in">void</span> g(<span class="built_in">int</span> a[<span class="number">3</span>][<span class="number">3</span>]) &lt;——&gt; <span class="built_in">void</span> g(<span class="built_in">int</span> a[][<span class="number">3</span>]) &lt;——&gt; <span class="built_in">void</span> g(<span class="built_in">int</span> (*a)[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/19.png" >

<h2 id="11、指针阅读技巧解析"><a href="#11、指针阅读技巧解析" class="headerlink" title="11、指针阅读技巧解析"></a>11、指针阅读技巧解析</h2><h3 id="1）基本规则"><a href="#1）基本规则" class="headerlink" title="1）基本规则"></a>1）基本规则</h3><ol>
<li>从最里层的圆括号中未定义的标识符看起</li>
<li>首先往右看，再往左看</li>
<li>遇到圆括号或方括号时可以确定部分类型，并调整方向</li>
<li>重复2，3步骤，直到阅读结束<h3 id="2）实例分析"><a href="#2）实例分析" class="headerlink" title="2）实例分析"></a>2）实例分析</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">int</span> (*p1)(<span class="built_in">int</span>*, <span class="built_in">int</span> (*f)(<span class="built_in">int</span>*)); // ==&gt; P1是一个指针，指向一个函数 ，该函数的类型为 <span class="built_in">int</span> (<span class="built_in">int</span>*,<span class="built_in">int</span>,<span class="built_in">int</span> (*f)(<span class="built_in">int</span>*))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p2[<span class="number">5</span>])(<span class="built_in">int</span>*);				//  ==&gt; p2是一个数组有<span class="number">5</span>个数组元素，每个数组元素都是函数指针，指向的函数类型为 <span class="built_in">int</span>(<span class="built_in">int</span>*)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*(*p3)[<span class="number">5</span>])(<span class="built_in">int</span>*);			//  ==&gt; p3是一个数组指针，指向的数组有<span class="number">5</span>个元素，每个元素的类型为函数指针，指向的函数类型为 <span class="built_in">int</span>(<span class="built_in">int</span>*)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span>*(*(*p4)(<span class="built_in">int</span>*))(<span class="built_in">int</span>*);		//  ==&gt; p4是一个函数指针，该函函数的参数为(<span class="built_in">int</span>*)，返回值为一个函数指针指向的函数类型为 <span class="built_in">int</span>*(<span class="built_in">int</span>*)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*(*p5)(<span class="built_in">int</span>*))[<span class="number">5</span>];			//  ==&gt; p5是一个函数指针，该函数的参数为(<span class="built_in">int</span>*)，函数的返回值为一个数组指针指向的数组类型为<span class="built_in">int</span>[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">	//将p5用typedef简写</span><br><span class="line">	typedef <span class="built_in">int</span>(ArryType)[<span class="number">5</span>];</span><br><span class="line">	typedef ArryType*(FuncType)(<span class="built_in">int</span>*);</span><br><span class="line">	</span><br><span class="line">	FuncType p5;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a><div align=center>野指针</h1><h2 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h2>指针变量中的值是非法的内存地址，进而形成野指针<br>野指针不是 NULL 指针，是指向不可用内存地址的指针<br>NULL 指针并无危害，很好判断也很好调试<br>c语言无法判断一个指针保存的地址是否合法<h2 id="2、野指针的由来"><a href="#2、野指针的由来" class="headerlink" title="2、野指针的由来"></a>2、野指针的由来</h2>1）局部指针变量没有初始化，保存随机值<br>2）指针所指变量在指针之前被销毁<br>3）使用已经释放过得指针<br>4）进行了错误的指针运算，内存越界<br>5）进行了错误的强制类型转换<h2 id="3、怎么避免野指针"><a href="#3、怎么避免野指针" class="headerlink" title="3、怎么避免野指针"></a>3、怎么避免野指针</h2>1）绝不返回局部变量和局部数组地址<br>2）任何变量在定义后必须0初始化<br>3）字符数组必须确认 0 结束符后才能成为字符串<h1 id="常见内存错误"><a href="#常见内存错误" class="headerlink" title="常见内存错误"></a><div align=center>常见内存错误</h1><h2 id="1、常见内存错误"><a href="#1、常见内存错误" class="headerlink" title="1、常见内存错误"></a>1、常见内存错误</h2>1）结构体成员指针未初始化<br>2）结构体指针未分配足够的内存<br>3）内存分配成功但为初始化<br>4）内存操作越界<h2 id="2、怎么避免内存操作错误"><a href="#2、怎么避免内存操作错误" class="headerlink" title="2、怎么避免内存操作错误"></a>2、怎么避免内存操作错误</h2>1）动态内存申请后，应立即检查指针,值是否为NULL<br>2）free 指针过后必须立即赋值为NULL<br>3）任何与内存操作相关的函数都必须带长度信息<br>5）malloc 操作和 free 操作必须匹配，防止内存泄漏和多次释放<br>6）在哪个函数中malloc就要在哪个函数中free<h1 id="C语言中的字符串"><a href="#C语言中的字符串" class="headerlink" title="C语言中的字符串"></a><div align=center>C语言中的字符串</h1><h2 id="1、字符串的概念"><a href="#1、字符串的概念" class="headerlink" title="1、字符串的概念"></a>1、字符串的概念</h2><h3 id="1-字符串是程序中的基本元素之一"><a href="#1-字符串是程序中的基本元素之一" class="headerlink" title="1)字符串是程序中的基本元素之一"></a>1)字符串是程序中的基本元素之一</h3>字符串是有序字符的集合<br>c语言中没有字符串的概念,c语言通过特殊的字符数组模拟字符串<br>c语言中的字符串是以 ‘\0’ 结尾的字符数组<h3 id="2-字符数组与字符串"><a href="#2-字符数组与字符串" class="headerlink" title="2)字符数组与字符串"></a>2)字符数组与字符串</h3>在c语言中，双引号引用的单个或者多个字符是一种特殊的字面量<br>储存于程序的全局只读存储区<br>本质为字符数组，编译器自动在结尾加上’\0’字符<br>字符串字面量可以看做一个常量指针<br>字符串字面量中的字符不可改变<br>字符串字面量至少包含一个字符<br>字符串相关函数均以第一个出现的’\0’作为结束符<br>编译器总是会在字符串字面量的末尾添加’\0’<h3 id="3）编程实验"><a href="#3）编程实验" class="headerlink" title="3）编程实验"></a>3）编程实验</h3>a）验证字符串的本质<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ca[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> sa[] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ss[] = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ca); <span class="comment">// Unknown result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sa); <span class="comment">// world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss); <span class="comment">// hello world!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, str);<span class="comment">// hello world!</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ca = %p\n&quot;</span>, ca); <span class="comment">// Unknown result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sa = %p\n&quot;</span>, sa); <span class="comment">// world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ss = %p\n&quot;</span>, ss); <span class="comment">// hello world!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str = %p\n&quot;</span>, str);<span class="comment">// hello world! </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Hello ����Hello world!</span><br><span class="line">World</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line"></span><br><span class="line">ca = <span class="number">0xbfa1e5d3</span></span><br><span class="line">sa = <span class="number">0xbfa1e5cd</span></span><br><span class="line">ss = <span class="number">0xbfa1e5df</span></span><br><span class="line">str = <span class="number">0x8048620</span>  </span><br><span class="line"></span><br><span class="line">结果分析：str地址明显区别于ca sa ss，因为字符串字面量为常量，而ca sa ss为栈上零时分配空间的字符数组</span><br></pre></td></tr></table></figure>
a）字符串编程练习<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">&quot;abc&quot;</span>[<span class="number">0</span>];       <span class="comment">// b = &#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> c = *(<span class="string">&quot;123&quot;</span> + <span class="number">1</span>);   <span class="comment">// c = &#x27;2&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> t = *<span class="string">&quot;&quot;</span>;            <span class="comment">// t = &#x27;\0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="2、符串的长度"><a href="#2、符串的长度" class="headerlink" title="2、符串的长度"></a>2、符串的长度</h2>字符串的长度就是字符串所包含的字符的个数<br>字符串长度指的是第一个’\0’前出现的字符个数<br>通过’\0’结束符来确定字符串的长度<br>函数 strlen 用于返回字符串的长度<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure>
字符串之间的相等比较需要用 strcmp 完成<br>不可直接用 == 进行字符串直接的比较<br>完全相同的字符串字面量 == 比较结果为false<blockquote>
<p>注意：一些现代编译器能够将相同的字符串字面量映射到同一个无名数组，因此 == 比较结果为true<br>编程时：不编写依赖特殊编译器的代码</p>
</blockquote>
<h2 id="3、snprintf函数"><a href="#3、snprintf函数" class="headerlink" title="3、snprintf函数"></a>3、snprintf函数</h2>snprintf函数本身是可变参数函数，原形如下<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> snprintf(<span class="keyword">char</span>* buffer, <span class="keyword">int</span> buff_size ,<span class="keyword">const</span> <span class="keyword">char</span>* fomart,...)；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：    当函数只有3个参数时，如果第三个参数没有包含格式化信息，函数调用没有问题；相反，如果第三个参数包含了<strong>格式化信息</strong>（%d, %s , %p ,…），但缺少后续对应参数，则程序为不确定</p>
</blockquote>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a><div align=center>动态内存分配</h1><h2 id="1、动态内存分配的意义"><a href="#1、动态内存分配的意义" class="headerlink" title="1、动态内存分配的意义"></a>1、动态内存分配的意义</h2>c语言的一切操作都是基于内存的<br>变量和数组都是内存的别名<br>内存分配由编译器在编译期间决定<br>定义数组的时候必须指定数组的长度<br>数组长度是在编译期就必须确定的<br>需求：<br>&nbsp;&nbsp;&nbsp;&nbsp;程序运行过程中，可能你需要使用一些额外的内存空间<h2 id="2、malloc-和-free"><a href="#2、malloc-和-free" class="headerlink" title="2、malloc 和 free"></a>2、malloc 和 free</h2>1）malloc 和 free 用于执行动态内存的分配和释放<br>&nbsp;&nbsp;&nbsp;&nbsp;a）malloc 分配的是一块连续的内存<br>&nbsp;&nbsp;&nbsp;&nbsp;b）malloc 以字节为单位，并且不带任何类型的信息<br>&nbsp;&nbsp;&nbsp;&nbsp;c）free 用于将动态内存归还系统<br>2）函数原型<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* pointer)</span></span>;</span><br></pre></td></tr></table></figure>
3）使用<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">malloc</span></span>(sizoef(<span class="class"><span class="keyword">type</span>)*<span class="title">size</span>);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>malloc 和 free 是库函数，不是系统调用<br>malloc 实际分配的内存可能比请求的多<br>不能依赖不同平台下的 malloc 行为<br>当请求的动态内存无法满足时，malloc 返回NULL<br>当 free 的参数为 NULL 时，函数直接返回</p>
</blockquote>
<h2 id="3、calloc-和-realloc"><a href="#3、calloc-和-realloc" class="headerlink" title="3、calloc 和 realloc"></a>3、calloc 和 realloc</h2><h3 id="1）calloc"><a href="#1）calloc" class="headerlink" title="1）calloc"></a>1）calloc</h3>calloc 在内存中动态地址分配num个长度为size的连续空间，并且将每一个字节都初始化为0</li>
</ol>
<p><strong>calloc 函数原型</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num ,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">calloc</span></span>(num,sizeof(<span class="class"><span class="keyword">type</span>))</span></span><br></pre></td></tr></table></figure>
<h3 id="2）realloc"><a href="#2）realloc" class="headerlink" title="2）realloc"></a>2）realloc</h3><p>a）realloc 用于修改一个原先已经分配的内存块大小<br>b）在使用realloc之后应该使用其返回值<br>c）当pointer的第一参数为NULL时，等价于malloc<br><strong>函数原型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* pointer,<span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p1</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">malloc</span></span>(sizoef(<span class="class"><span class="keyword">type</span>)*<span class="title">size</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p2</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">realloc</span></span>(p1,new_size);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小知识：内存包含两个信息地址，长度</p>
</blockquote>
<h1 id="程序中栈"><a href="#程序中栈" class="headerlink" title="程序中栈"></a><div align=center>程序中栈</h1><h2 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h2><p>栈是现代计算机程序里最为重要的概念之一<br>栈在程序中用于维护函数调用上下文<br>函数中的参数和局部变量储存在栈上<br>栈保存了一个函数调用所需的维护信息<br>&nbsp;&nbsp;&nbsp;&nbsp;参数<br>&nbsp;&nbsp;&nbsp;&nbsp;返回值<br>&nbsp;&nbsp;&nbsp;&nbsp;局部变量<br>&nbsp;&nbsp;&nbsp;&nbsp;调用上下文<br>&nbsp;&nbsp;&nbsp;&nbsp;…    </p>
<h2 id="2、函数调用的过程使用栈"><a href="#2、函数调用的过程使用栈" class="headerlink" title="2、函数调用的过程使用栈"></a>2、函数调用的过程使用栈</h2><p>调用函数的活动记录位于栈的中部<br>被调用的函数活动记录位于栈的顶部</p>
<h2 id="3、函数调用栈上的数据"><a href="#3、函数调用栈上的数据" class="headerlink" title="3、函数调用栈上的数据"></a>3、函数调用栈上的数据</h2><p>函数调用时,对应的栈空间在函数返回前是专用的<br>函数调用结束后，栈空间将被释放，数据不再有效,无法传递到函数外部</p>
<h1 id="程序中栈程序中的堆"><a href="#程序中栈程序中的堆" class="headerlink" title="程序中栈程序中的堆"></a><div align=center>程序中栈程序中的堆</h1><p>堆是程序中一块预留的内存空间，可由程序自由使用<br>堆中被程序申请使用的内存在被主动释放前一直有效<br>c语言程序中通过函数的调用获得堆空间<br>头文件： malloc.h<br>free:将堆空间返还给系统<br>系统对堆空间的管理方式： 空间链表法，位图法，对象池法等等。</p>
<h1 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a><div align=center>程序与进程</h1><p>程序和进程不同<br>程序是静态概念，变现形式为一个可执行文件<br>进程是动态概念，程序由操作系统加载运行后得到进程<br>每个程序可以对应多个进程<br>每个进程只能对应一个程序<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/20.png" ></p>
<h1 id="程序中的静态存储器"><a href="#程序中的静态存储器" class="headerlink" title="程序中的静态存储器"></a><div align=center>程序中的静态存储器</h1><p>静态储存区随着程序的运行而分配空间<br>静态存储区的生命周期直到程序运行结束<br>在程序的编译期静态存储区的大小就已经确定<br>静态存储区主要用于保存全局变量和静态局部变量<br>静态存储区的信息最终会保存到可执行程序中去</p>
<h1 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a><div align=center>程序的内存布局</h1><p>堆栈段在程序运行后在正式存在，是程序运行的基础</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.text段     存放的是程序中的可执行代码</span></span><br><span class="line"><span class="title">.rodata段   存放着程序中的常量值，如：字符串常量</span></span><br><span class="line"><span class="title">.data段     存放的是已经初始化的全局变量和静态变量</span></span><br><span class="line"><span class="title">.bss段      存放的是未初始化或初始化为0的全局变量和静态变量</span></span><br><span class="line"><span class="title">.comment段  存放注释，不被烧写进程序</span></span><br></pre></td></tr></table></figure>
<h1 id="程序术语对的对应关系"><a href="#程序术语对的对应关系" class="headerlink" title="程序术语对的对应关系"></a><div align=center>程序术语对的对应关系</h1><p>静态存储区通常指程序中的 .bss 和 .data 段<br>只读存储区通常指程序中的 .rodata 段<br>局部变量所占的空间为栈上的空间<br>动态空间为堆的空间<br>程序可执行代码存放与 .text 段</p>
<h1 id="c语言中的函数"><a href="#c语言中的函数" class="headerlink" title="c语言中的函数"></a><div align=center>c语言中的函数</h1><h2 id="1、函数的由来"><a href="#1、函数的由来" class="headerlink" title="1、函数的由来"></a>1、函数的由来</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;程序     =  数据 + 算法<br>&nbsp;&nbsp;&nbsp;&nbsp;c程序 =  数据 + 函数</p>
<h2 id="2、面向过程的程序化设计"><a href="#2、面向过程的程序化设计" class="headerlink" title="2、面向过程的程序化设计"></a>2、面向过程的程序化设计</h2><p>1）面向过程是一种以过程为中心的编程思想<br>2）首先将复杂的问题分解为一个个容易解决的问题<br>3）分解过后的问题可以按照步骤一步步完成<br>4）函数面向过程在c语言中体现<br>5）解决问题的每一个步骤可以用函数来实现<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/21.png" ></p>
<h2 id="3、声明和定义"><a href="#3、声明和定义" class="headerlink" title="3、声明和定义"></a>3、声明和定义</h2><p>1）声明的意义在于告诉编译器程序单元的存在<br>2）定义则明确与指示程序单元的意义<br>3）c语言中通过 extern 进行程序单元的声明<br>4）一些程序单元在申明是可以省略 extern<br>5）严格意义上的声明和定义并不相同</p>
<h2 id="4、函数参数"><a href="#4、函数参数" class="headerlink" title="4、函数参数"></a>4、函数参数</h2><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/22.png" >

<p>函数参数在本质上与局部变量相同在栈上分配空间<br>函数参数的初始值是函数调用时的实参值<br>函数参数求值顺序依赖于编译器的实现</p>
<h2 id="5、程序中的顺序点"><a href="#5、程序中的顺序点" class="headerlink" title="5、程序中的顺序点"></a>5、程序中的顺序点</h2><p>1）程序中存在一定的顺序点<br>&nbsp;&nbsp;&nbsp;&nbsp;a）顺序点指的是程序执行过程中修改变量值的最晚时刻<br>&nbsp;&nbsp;&nbsp;&nbsp;b）在程序达到顺序点的时候，之前所做的一切操作必须完场<br>2）c语言中的顺序点<br>&nbsp;&nbsp;&nbsp;&nbsp;a）每个完整表达式结束时，即分号处<br>&nbsp;&nbsp;&nbsp;&nbsp;b）&amp;&amp; 、|| 、?: 、 以及逗号表达式的每个参数计算后<br>&nbsp;&nbsp;&nbsp;&nbsp;c）函数调用时所有实参求值完成后（进入函数体前）    </p>
<h2 id="6、参数入栈顺序"><a href="#6、参数入栈顺序" class="headerlink" title="6、参数入栈顺序"></a>6、参数入栈顺序</h2><p>1）调用约定<br>&nbsp;&nbsp;&nbsp;&nbsp;a）当函数调用发生时<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数会传递给被调用的函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而返回值会被返回给函数调用者<br>&nbsp;&nbsp;&nbsp;&nbsp;b）调用约定描述参数如何传递到栈中以及栈的维护方式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数传递顺序<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用栈清理<br>&nbsp;&nbsp;&nbsp;&nbsp;c）调用约定是预定义的可以理解为调用协议<br>&nbsp;&nbsp;&nbsp;&nbsp;d）调用约定通常用于库调用和库开发的时候<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从右到左依次入栈： _stdcall , _cdecl , thiscall<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从左到右依次入栈： _pascal , _fastcall<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/23.png" ></p>
<blockquote>
<p>A编译器 ==&gt; 主程序 ==&gt; 库文件 &lt;== B编译器</p>
</blockquote>
<h1 id="c语言中的函数进阶"><a href="#c语言中的函数进阶" class="headerlink" title="c语言中的函数进阶"></a><div align=center>c语言中的函数进阶</h1><h2 id="1、main函数的概念"><a href="#1、main函数的概念" class="headerlink" title="1、main函数的概念"></a>1、main函数的概念</h2><h3 id="1）说明"><a href="#1）说明" class="headerlink" title="1）说明"></a>1）说明</h3><p>c语言中main函数称为主函数<br>一个c程序是从main函数开始执行的</p>
<h3 id="2）mian函数的本质"><a href="#2）mian函数的本质" class="headerlink" title="2）mian函数的本质"></a>2）mian函数的本质</h3><p>main函数是操作系统调用的函数<br>操作系统总是将main函数作为应用程序的开始<br>操作系统将main函数的返回值作为程序退出状态</p>
<h3 id="3）main函数的参数"><a href="#3）main函数的参数" class="headerlink" title="3）main函数的参数"></a>3）main函数的参数</h3><p>程序执行时可以向main函数传递参数</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[],<span class="keyword">char</span>* env[])</span></span>;</span><br><span class="line">argc ——命令行参数个数</span><br><span class="line">argv ——命令行参数数组</span><br><span class="line">env  ——环境变量数组</span><br></pre></td></tr></table></figure>
<h3 id="4-函数参数传递"><a href="#4-函数参数传递" class="headerlink" title="4)函数参数传递"></a>4)函数参数传递</h3><p>c语言中只会以值拷贝的方式传递参数<br>当函数传递数组时:<br>&nbsp;&nbsp;&nbsp;&nbsp;将怎个数组拷贝一份传入数组（错误）<br>&nbsp;&nbsp;&nbsp;&nbsp;将数组名看做常量指针传数组首元素的地址<br>c语言以高效作为最初的设计目标<br>&nbsp;&nbsp;&nbsp;&nbsp;a）参数传递的时候如果拷贝整个数组执行效率将大大下降<br>&nbsp;&nbsp;&nbsp;&nbsp;b）参数位于栈上，太大的数组拷贝将导致栈的溢出<br>现代编译器支持在main函数函数之前调用其他函数</p>
<h2 id="2、函数类型"><a href="#2、函数类型" class="headerlink" title="2、函数类型"></a>2、函数类型</h2><p>c语言中的函数有自己特定的类型<br>函数的类型由返回值，参数类型和参数个数共同决定</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">add</span>(<span class="type">int</span> i, <span class="type">int</span> j) 的类型为 <span class="type">int</span>(<span class="type">int</span> ,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>c语言通过 typedef 为函数类型重命名</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">type</span> name(parameter list)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="3、函数指针"><a href="#3、函数指针" class="headerlink" title="3、函数指针"></a>3、函数指针</h2><p>函数指针用于指向一个函数<br>函数名是执行函数体的入口地址<br>可以通过类型定义函数指针： <strong>FuncType* pointer;**<br>也可以直接定义： **type (*pointer)(parameter list);</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;pointer为函数指针变量名<br>&nbsp;&nbsp;&nbsp;&nbsp;type 为所指函数的返回值类型<br>&nbsp;&nbsp;&nbsp;&nbsp;parameter list 为所指函数的参数类型列表</p>
<h2 id="4、回调函数"><a href="#4、回调函数" class="headerlink" title="4、回调函数"></a>4、回调函数</h2><p>回调函数是利用函数指针实现的一种调用机制<br>回调机制的原理<br>&nbsp;&nbsp;&nbsp;&nbsp;调用者不知道具体时间发生时需要调用的具体函数<br>&nbsp;&nbsp;&nbsp;&nbsp;被调用函数不知道何时被调用，只知道需要完成的任务<br>&nbsp;&nbsp;&nbsp;&nbsp;当具体事件发生时，调用者通过函数指针调用具体函数<br>回调机制中的调用者和被调函数互不依赖</p>
<h1 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a><div align=center>函数可变参数</h1><h2 id="1、c语言中可以定义参数可变的函数"><a href="#1、c语言中可以定义参数可变的函数" class="headerlink" title="1、c语言中可以定义参数可变的函数"></a>1、c语言中可以定义参数可变的函数</h2><p>参数可变函数的实现依赖于 stdarg.h 头文件<br>va_list    参数集合<br>va_start表示参数访问的开始<br>va_arg取具体参数值<br>va_end标识参数访问结束<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/24.png" ></p>
<h2 id="2、可变参数的限制"><a href="#2、可变参数的限制" class="headerlink" title="2、可变参数的限制"></a>2、可变参数的限制</h2><p>1）可变参数必须从头到尾按照顺序逐个访问<br>2）参数列表中至少要存在一个确定的命名参数<br>3）可变参数函数无法确定实际存在的参数的数量<br>4）可变参数函数无法确定参数的实际类型</p>
<blockquote>
<p>注意：    va_arg 中如果指定了错误的类型，那么结果是不可预测的; 可变参数必须顺序访问，无法直接访问中间的参数值</p>
</blockquote>
<h1 id="函数与宏分析"><a href="#函数与宏分析" class="headerlink" title="函数与宏分析"></a><div align=center>函数与宏分析</h1><p>宏是由预处理器直接替换展开的，编译器不知道宏的存在<br>函数是由编译器直接编译的实体，调用行为由编译器决定<br>多次使用宏会导致最终的可执行程序的体积增大<br>函数是跳转执行，内存中只有一份函数体存在<br>宏的效率比函数要高，因为是直接展开，无调用开销<br>函数调用会创建活动记录，效率不如宏<br>可以用函数完成的绝对不用宏<br>宏的定义中不能出现递归定义</p>
<h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a><div align=center>递归函数</h1><h2 id="1、递归的数学思想"><a href="#1、递归的数学思想" class="headerlink" title="1、递归的数学思想"></a>1、递归的数学思想</h2><p>1）递归是一种数学上分而自治的思想<br>2）递归将大型复杂问题转化为与原问题相同但规模较小的问题进行处理<br>3）递归需要有边界条件<br>&nbsp;&nbsp;&nbsp;&nbsp;a）当边界条件不满足时，递归继续进行<br>&nbsp;&nbsp;&nbsp;&nbsp;b）当边界条件满足时，递归停止</p>
<h2 id="2、递归函数"><a href="#2、递归函数" class="headerlink" title="2、递归函数"></a>2、递归函数</h2><p>1）函数体中存在自我调用的函数<br>2）递归函数是递归的数学思想在程序设计中的应用<br>&nbsp;&nbsp;&nbsp;&nbsp;a）递归函数必须有递归出口<br>&nbsp;&nbsp;&nbsp;&nbsp;b）函数的无限递归将导致程序栈溢出而崩溃    </p>
<h2 id="3、递归函数设计技巧"><a href="#3、递归函数设计技巧" class="headerlink" title="3、递归函数设计技巧"></a>3、递归函数设计技巧</h2><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/25.png" >

<h2 id="4、斐波拉契数列递归解法"><a href="#4、斐波拉契数列递归解法" class="headerlink" title="4、斐波拉契数列递归解法"></a>4、斐波拉契数列递归解法</h2><p>1,1,2,3,5,8,13,21,…<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/26.png" ></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int fac(int n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>==n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span>==n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span>&lt;n)</span><br><span class="line">		<span class="keyword">return</span> fac(n-<span class="number">1</span>) + fac(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、汉诺塔问题"><a href="#5、汉诺塔问题" class="headerlink" title="5、汉诺塔问题"></a>5、汉诺塔问题</h2><p>1）将木块借助    B由A柱移动到c柱<br>2）每次只能移动一个木块<br>3）只能出现小木块在大木块之上<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/27.png" ></p>
<p>问题分解<br>&nbsp;&nbsp;&nbsp;&nbsp;将n-1个木块借助C柱移动到B柱<br>&nbsp;&nbsp;&nbsp;&nbsp;将最底层的唯一木块直接移动到C柱<br>&nbsp;&nbsp;&nbsp;&nbsp;将n-1个木块借助A柱由B柱移动到C柱<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/28.png" ></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void han<span class="constructor">_move(<span class="params">int</span> <span class="params">n</span>,<span class="params">char</span> <span class="params">a</span>, <span class="params">char</span> <span class="params">b</span>, <span class="params">char</span> <span class="params">c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n<span class="operator"> == </span><span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;%c--&gt;%c\n&quot;</span>,a,c);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		han<span class="constructor">_move(<span class="params">n</span>-1,<span class="params">a</span>,<span class="params">c</span>,<span class="params">b</span>)</span>;</span><br><span class="line">		han<span class="constructor">_move(1,<span class="params">a</span>,<span class="params">b</span>,<span class="params">c</span>)</span>;</span><br><span class="line">		han<span class="constructor">_move(<span class="params">n</span>-1,<span class="params">b</span>,<span class="params">a</span>,<span class="params">c</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数设计原则"><a href="#函数设计原则" class="headerlink" title="函数设计原则"></a><div align=center>函数设计原则</h1><p>函数从意义上应该是一个独立的功能模块<br>函数名要在一定程度上反映函数功能<br>函数参数名要能体现参数的意义<br>尽量避免在函数中使用全局变量</p>
<p>当函数参数不应该在函数内部被修改时，应该加上 const 申明修饰<br>如果参数是指针，且仅作为输入参数，则应该加上 const 申明</p>
<p>不能省略返回值的类型<br>如果函数没有返回值，那么应该声明为 void 类型<br>对函数参数检查有效性<br>对于指针参数的检查尤为重要<br>不要返回指向”栈内存”的指针<br>栈内存在函数结束时会被自动释放</p>
<p>函数体的规模要小，尽量控制在”80”行代码之内<br>相同的输入对应相同的输出，避免函数带有”记忆”功能<br>避免函数有过多的参数，参数尽量控制在”4”个以内</p>
<p>有时候函数不需要返回值，但为了支持灵活性，如支持链式表达，可以附加返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="built_in">strcpy</span>(,<span class="string">&quot;android&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>函数名与返回值类型在语意上不可冲突</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> c = getchar();   //getchar 返回值为 <span class="built_in">int</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">EOR</span> == c)			</span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文来自狄泰软件视频自学记录，有兴趣学习可以淘宝搜索“狄泰软件学院”购买视频学习</strong></p>
<h1 id="优秀的代码具有自注性，直接可以读出函数的功能"><a href="#优秀的代码具有自注性，直接可以读出函数的功能" class="headerlink" title="优秀的代码具有自注性，直接可以读出函数的功能"></a>优秀的代码具有自注性，直接可以读出函数的功能</h1>]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>linux设备模型</title>
    <url>/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;Linux设备模型的核心是使用<font color=red>Bus、Class、Device、Driver</font>四个核心数据结构，将大量的、不同功能的硬件设备（以及驱动该硬件设备的方法），以树状结构的形式，进行归纳、抽象，从而方便Kernel的统一管理。<font color = red><strong>学习平台mt8768，内核版本kernel-4.9</strong> </font></p>
<a id="more"></a>

<h1 id="一、kobject"><a href="#一、kobject" class="headerlink" title="一、kobject"></a>一、kobject</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 它是构建设备模型的根基，它使设备模型下能在 /sys/ 下以目录层次的形式呈现、 动态管理着所属对象的生命周期，以及提供了与用户空间进行信息交互的属性文件(attribute).</p>
<blockquote>
<p><strong>温馨提示</strong>目录文件是两个不同的概念，别搞混了。</p>
</blockquote>
<h2 id="1、相关数据结构"><a href="#1、相关数据结构" class="headerlink" title="1、相关数据结构"></a>1、相关数据结构</h2><h3 id="1-kobject"><a href="#1-kobject" class="headerlink" title="1) kobject"></a>1) kobject</h3><p>核心结构kobject，牢牢记住每一个注册到内核的kobject就是一个目录</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Kobject: include/linux/kobject.h line 60 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                  <span class="comment">//该Kobject的名称，同时也是sys/中的目录名称。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>         <span class="comment">//用于将该Kobject加入到Kset中的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span>       <span class="comment">//kobject以此形成层次目录结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>         *<span class="title">kset</span>;</span>         <span class="comment">//该kobject所属的Kset，可以为NULL，如果存在且没有指定parent，则会把Kset.kobj做为parent。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>        <span class="comment">//该Kobject属于的kobj_type，只有拥有ktye的kobj才能创建属性文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span> *<span class="title">sd</span>;</span>           <span class="comment">//该Kobject在sysfs中的表示</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>          <span class="title">kref</span>;</span>         <span class="comment">//用于原子操作的引用计数（在include/linux/kref.h中定义）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;  <span class="comment">//指示该Kobject是否已经初始化，在Kobject的Init，Put，Add等操作时进行异常校验。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;     <span class="comment">//指示该Kobject是否已经在sysfs中呈现，以便在自动注销时在从sysfs中移除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 记录是否已经向用户空间发送add uevent，如果有，且没有发送remove uevent，</span></span><br><span class="line"><span class="comment">     * 则在自动注销时，补发remove uevent，以便让用户空间正确处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>; <span class="comment">//如果该字段为1，则表示忽略所有上报的uevent事件。</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobj-type"><a href="#2-kobj-type" class="headerlink" title="2) kobj_type"></a>2) kobj_type</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用户空间怎么和内核进行交互，就是通过这个结构中包含的属性链表，指向的属性文件和属性操作函数进行交互。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/kobject.h, line 108 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">release</span>)(struct kobject *kobj);    <span class="comment">//当引用计数为0时自动调用，将包含该种类型kobject的数据结构的内存空间释放掉</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span>        <span class="comment">//kobject属性操作函数指针，上层在open属性文件时获取这个指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>         <span class="comment">//属性链表指针，指向attribute *数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-attribute"><a href="#3-attribute" class="headerlink" title="3) attribute"></a>3) attribute</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;牢牢记住，每一个注册到内核的 attribute 都是它所属的 kobj 目录下的一个属性文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">--include/linux/sysfs.h</span><br><span class="line"><span class="comment">/* FIXME</span></span><br><span class="line"><span class="comment"> * The *owner field is no longer used.</span></span><br><span class="line"><span class="comment"> * x86 tree has been cleaned up. The owner</span></span><br><span class="line"><span class="comment"> * attribute is still left for other arches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>    *name;        <span class="comment">/* 属性的名字,即sys目录中的属性文件名称 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>       <span class="comment">/* 属性的拥有者，已不再使用 */</span></span><br><span class="line">        <span class="keyword">mode_t</span> mode;                <span class="comment">/* 属性的读写权限，定义在include/linux/stat.h*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>读写权限</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/stat.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &quot;0&quot; 表示没有权限</span></span><br><span class="line"><span class="comment"> * &quot;1&quot; 表示可执行权限</span></span><br><span class="line"><span class="comment"> * &quot;2&quot; 表示可写权限</span></span><br><span class="line"><span class="comment"> * &quot;4&quot; 表示可读权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXU 00700 <span class="comment">//用户所有者拥有执行、写、读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUSR 00400 <span class="comment">//用户所有者拥有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUSR 00200 <span class="comment">//用户所有者拥有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUSR 00100 <span class="comment">//用户所有者拥有执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXG 00070 <span class="comment">//用户组拥有xxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRGRP 00040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWGRP 00020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXGRP 00010</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXO 00007 <span class="comment">//其他人拥有xxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IROTH 00004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWOTH 00002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXOTH 00001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/stat.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXUGO   (S_IRWXU|S_IRWXG|S_IRWXO) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IALLUGO   (S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUGO     (S_IRUSR|S_IRGRP|S_IROTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUGO     (S_IWUSR|S_IWGRP|S_IWOTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUGO     (S_IXUSR|S_IXGRP|S_IXOTH)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：kobject是目录，attribute是文件。</strong></p>
</blockquote>
<h3 id="4-sysfs-ops"><a href="#4-sysfs-ops" class="headerlink" title="4) sysfs_ops"></a>4) sysfs_ops</h3><p>属性文件操作函数，当 cat 属性文件时，会调用 kobj-&gt;ktype-&gt;sysfs_ops-&gt;show，当 echo 属性文件时调用 kobj-&gt;ktype-&gt;sysfs_ops-&gt;store 函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">--include/linux/sysfs.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span></span> &#123;                                                                     <span class="comment">/* 对属性的操作函数 */</span></span><br><span class="line">        ssize_t (*show)(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *,<span class="built_in">char</span> *);                  <span class="comment">/* 读属性操作函数 */</span></span><br><span class="line">        ssize_t (*store)(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *,<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *,<span class="keyword">const</span> <span class="built_in">char</span> *, size_t);    <span class="comment">/* 写属性操作函数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、kobject-的创建与初始化"><a href="#2、kobject-的创建与初始化" class="headerlink" title="2、kobject 的创建与初始化"></a>2、kobject 的创建与初始化</h2><h3 id="1-kobject-create"><a href="#1-kobject-create" class="headerlink" title="1) kobject_create"></a>1) kobject_create</h3><p>该函数动态申请一个kobject结构，然后调用kobject_init对内部成员进行初始化,并且使用 dynamic_kobj_ktype 作为默认的 ktype</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">kernel<span class="number">-4.9</span>/lib/kobject.c</span><br><span class="line"></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line"></span><br><span class="line">    kobj = kzalloc(<span class="keyword">sizeof</span>(*kobj), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kobject_init(kobj, &amp;dynamic_kobj_ktype);</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-init"><a href="#2-kobject-init" class="headerlink" title="2) kobject_init"></a>2) kobject_init</h3><p>该函数初始化kobj的ktype以及内部成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_init</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *err_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj) &#123;   <span class="comment">/* 检测kobj是否为NULL */</span></span><br><span class="line">        err_str = <span class="string">&quot;invalid kobject pointer!&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ktype) &#123;  <span class="comment">/* 检测ktype是否为NULL */</span></span><br><span class="line">        err_str = <span class="string">&quot;must have a ktype to be initialized properly!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_initialized) &#123; <span class="comment">/* 判断kobject是否已经被初始化过，如果初始化过给出警告 */</span></span><br><span class="line">        <span class="comment">/* do not error out as sometimes we can recover */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;kobject (%p): tried to init an initialized &quot;</span></span><br><span class="line">               <span class="string">&quot;object, something is seriously wrong.\n&quot;</span>, kobj);</span><br><span class="line">        dump_stack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kobject_init_internal(kobj);   <span class="comment">/* 初始化kobject内部成员 */</span></span><br><span class="line">    kobj-&gt;ktype = ktype;           <span class="comment">/* 设置ktype */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">error:</span><br><span class="line"></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;kobject (%p): %s\n&quot;</span>, kobj, err_str);</span><br><span class="line">    dump_stack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kobject-init-internal"><a href="#3-kobject-init-internal" class="headerlink" title="3) kobject_init_internal"></a>3) kobject_init_internal</h3><p>该函数初始化引用计数，entry链表以及状态位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_init_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj)	                         <span class="comment">/* 参数检测,确保kobj不为空 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    kref_init(&amp;kobj-&gt;kref);              <span class="comment">/* 引用计数初始化，初始化为1 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;kobj-&gt;entry);        <span class="comment">/* 初始化kobject链表 */</span></span><br><span class="line">    kobj-&gt;state_in_sysfs = <span class="number">0</span>;            <span class="comment">/* 状态位设置:未导出到sys中 */</span></span><br><span class="line">    kobj-&gt;state_add_uevent_sent = <span class="number">0</span>;     <span class="comment">/* 状态位设置:未添加uevent */</span> </span><br><span class="line">    kobj-&gt;state_remove_uevent_sent = <span class="number">0</span>;  <span class="comment">/* 状态位设置:未移除uevent */</span></span><br><span class="line">    kobj-&gt;state_initialized = <span class="number">1</span>;         <span class="comment">/* 状态位设置:已完成初始化 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kobject的创建与初始化基本也就反复用这三个接口了。</p>
</blockquote>
<h2 id="3、kobject-的注册"><a href="#3、kobject-的注册" class="headerlink" title="3、kobject 的注册"></a>3、kobject 的注册</h2><h3 id="1-kobject-add"><a href="#1-kobject-add" class="headerlink" title="1) kobject_add"></a>1) kobject_add</h3><p>设置 kobj 的 name 以及 parent 并将 kobject 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_add</span><span class="params">(struct kobject *kobj, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list vargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name_vargs(kobj, fmt, vargs); <span class="comment">//设置kobject的name</span></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;kobject: can not set name properly!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    kobj-&gt;parent = parent;			<span class="comment">//设置kobject的parent</span></span><br><span class="line">    <span class="keyword">return</span> kobject_add_internal(kobj);		<span class="comment">//在sys/中添加kobject的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-add-internal"><a href="#2-kobject-add-internal" class="headerlink" title="2) kobject_add_internal"></a>2) kobject_add_internal</h3><p>将 kobject 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_add_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj-&gt;name || !kobj-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        WARN(<span class="number">1</span>, <span class="string">&quot;kobject: (%p): attempted to be registered with empty &quot;</span></span><br><span class="line">             <span class="string">&quot;name!\n&quot;</span>, kobj);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent = kobject_get(kobj-&gt;parent); <span class="comment">//如果父节点存在，则增加父节点引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* join kset if set, use it as parent if we do not already have one */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;kset) &#123; <span class="comment">//判断是否存在 kset</span></span><br><span class="line">        <span class="keyword">if</span> (!parent)</span><br><span class="line">            parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj); <span class="comment">//如果父节点不存在则使用Kset-&gt;kobj作为父节点，并增加引用计数</span></span><br><span class="line">        kobj_kset_kobj_kset_leavejoin(kobj);  <span class="comment">//将kobject中的entry链接进入kset中的list链表。</span></span><br><span class="line">        kobj-&gt;parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: parent: &#x27;%s&#x27;, set: &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">         kobject_name(kobj), kobj, __func__,</span><br><span class="line">         parent ? kobject_name(parent) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>,</span><br><span class="line">         kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    error = create_dir(kobj); <span class="comment">//使用kobj创建目录和属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123; <span class="comment">//如果创建失败减少引用计数</span></span><br><span class="line">        kobj_kset_leave(kobj);</span><br><span class="line">        kobject_put(parent);</span><br><span class="line">        kobj-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* be noisy on error issues */</span></span><br><span class="line">        <span class="keyword">if</span> (error == -EEXIST)</span><br><span class="line">            pr_err(<span class="string">&quot;%s failed for %s with -EEXIST, don&#x27;t try to register things with the same name in the same directory.\n&quot;</span>,</span><br><span class="line">                   __func__, kobject_name(kobj));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pr_err(<span class="string">&quot;%s failed for %s (error: %d parent: %s)\n&quot;</span>,</span><br><span class="line">                   __func__, kobject_name(kobj), error,</span><br><span class="line">                   parent ? kobject_name(parent) : <span class="string">&quot;&#x27;none&#x27;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        kobj-&gt;state_in_sysfs = <span class="number">1</span>; <span class="comment">//如果创建成功。将state_in_sysfs建为1。表示该object已经在sysfs中了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便理解我在这里附上 create_dir 、 sysfs_create_dir_ns 以及 populate_dir 的源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_dir</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); <span class="comment">//创建kobj目录</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    error = populate_dir(kobj); <span class="comment">//创建kobj默认属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        sysfs_remove_dir(kobj);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分代码***/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_dir_ns</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> <span class="keyword">void</span> *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">parent</span>, *<span class="title">kn</span>;</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(!kobj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;parent) <span class="comment">//判断parent是否存在，如果不存在则在sys/下创建目录</span></span><br><span class="line">        parent = kobj-&gt;parent-&gt;sd; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent = sysfs_root_kn; <span class="comment">// sys/ 所在目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!parent)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    kn = kernfs_create_dir_ns(parent, kobject_name(kobj),</span><br><span class="line">                  S_IRWXU | S_IRUGO | S_IXUGO, kobj, ns); <span class="comment">//创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kn)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(kn) == -EEXIST)</span><br><span class="line">            sysfs_warn_dup(parent, kobject_name(kobj));</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(kn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kobj-&gt;sd = kn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">populate_dir</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> =</span> get_ktype(kobj);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; t-&gt;default_attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; (attr = t-&gt;default_attrs[i]) != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">            error = sysfs_create_file(kobj, attr); <span class="comment">//遍历default_attrs，创建存在的属性文件</span></span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kobjcet的注册主要完成了下面三件事情</p>
<ol>
<li>判断父节点是否存在，如果存在增加父节点引用计数，判断是否存在 kset 如果存在则链接进 kset ，如果 kset 存在且父节点不存在则使用 Kset-&gt;kobj 作为父节点，增加 kset 点引用计数</li>
<li>调用 create_dir 为kobj创建目录和属性文件，在 create_dir 中调用 sysfs_create_dir_ns 为 kobject 创建目录，创建时会判断如果父节点为NULL则使用 sysfs_root_kn 作为父节点，即直接在 sys/ 目录下创建当前目录，在 create_dir 中调用 populate_dir 遍历属性文件链表创建默认属性文件</li>
<li>创建成功则设置 state_in_sysfs 为 1</li>
</ol>
</blockquote>
<p>内核也提供了一些组合API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就是将kobject_creat 函数和 kobject_add 函数组合在一起的函数，创建并注册一个 kobject 到内核。</span></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, struct kobject *parent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//就是将 kobject_init 函数和 kobject_add 函数组合在一起的函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_init_and_add</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>》上面的api这么多，可以根据需要灵活选择来创建并注册kobj，我也总结了一条很简单的原则：</p>
<blockquote>
<ul>
<li><font color=red><strong>如果你的 kobject 不需要嵌入到更大的数据结构则使用 kobject_create_and_add</strong></font></li>
<li><font color=red><strong>反之如果你的 kobject 需要嵌入到更大的数据结构则使用 kobject_init_and_add</strong></font></li>
</ul>
</blockquote>
<p>为什么这么选择呢这涉及到后文提到的对对象生命周期管理的内容，这里只需记住这两条规则就行了。</p>
<h3 id="3-编程实验-1"><a href="#3-编程实验-1" class="headerlink" title="3) 编程实验 1"></a>3) 编程实验 1</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;光说不练假把式，这个实验很简单，我们只需要再内核中创建一个名为 my_kobject 的目录，并不需要将 kobject 嵌入到其他数据结构因此选择使用 kobject_create_and_add</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>)<span class="comment">;</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct kobject *my_kobj<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> my_kobject_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    my_kobj = kobject_create_and_add(<span class="string">&quot;my_kobject&quot;</span>, <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void my_kobject_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    kobject_del(my_kobj)<span class="comment">;</span></span><br><span class="line">    kfree(my_kobj)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_kobject_init)<span class="comment">;</span></span><br><span class="line">module_exit(my_kobject_exit)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_kobject</span> <span class="title">power</span> //加载后生成 <span class="title">my_kobject</span> 目录</span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># rmmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span> //卸载后移除 <span class="title">my_kobject</span> 目录</span></span><br></pre></td></tr></table></figure>
<p>上面这种方式内核也用的挺多的，例如我们熟悉的 /sys/dev 、/sys/dev/char 、/sys/dev/block 等都是用这个方式创建的。</p>
<h3 id="4-编程实验-2"><a href="#4-编程实验-2" class="headerlink" title="4) 编程实验 2"></a>4) 编程实验 2</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在sys/下创建一个叫做 my_dir 的目录，这里我们将 kobject 嵌入到我们自己创建的结构中，于是选择 kobject_init_and_add 来创建目录。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_del(&amp;my_dirp-&gt;kobj);</span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">k85v1_64:<span class="regexp">/ # ls sys/</span></span><br><span class="line">block<span class="regexp">/     bus/</span>       dev<span class="regexp">/       firmware/</span>  kernel<span class="regexp">/    mtk_rgu/</span></span><br><span class="line">bootinfo<span class="regexp">/  class/</span>     devices<span class="regexp">/   fs/</span>        module<span class="regexp">/    power/</span></span><br><span class="line">k85v1_64:<span class="regexp">/ # ls sys/</span></span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu power</span><br><span class="line">k85v1_64:/ <span class="comment">#</span></span><br><span class="line">k85v1_64:<span class="regexp">/ # cd cache/</span></span><br><span class="line">k85v1_64:/cache <span class="comment"># insmod my_kobject.ko </span></span><br><span class="line">k85v1_64:<span class="regexp">/cache # ls /</span>sys/</span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu my_dir power <span class="regexp">//</span>加载后生成 my_dir 目录</span><br><span class="line">k85v1_64:/cache <span class="comment"># </span></span><br><span class="line"><span class="number">2</span>|k85v1_64:<span class="regexp">/cache # cd /</span>sys<span class="regexp">/my_dir/</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment"># ls</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment">#</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment"># cd ..</span></span><br><span class="line">k85v1_64:/sys <span class="comment"># rmmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/sys <span class="comment"># ls</span></span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu power <span class="regexp">//</span>卸载后移除 my_dir 目录</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;看起来这种方式更加复杂，但实际上我们的 bus、 device、 device_driver 等都是使用这个方式，使用这个方式的优点见后文 “对象生命周期管理”以及”用户空间与内核信息交互”。</p>
<h2 id="4、在-sys-下组织出目录层次"><a href="#4、在-sys-下组织出目录层次" class="headerlink" title="4、在 sys/ 下组织出目录层次"></a>4、在 sys/ 下组织出目录层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;object的核心功能之一，利用 kobject.parent 组织出文件的目录层次，前面 kobject 的注册已经分析的很清楚了这里就不再赘述了，内核还提供了链接文件的创建接口。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在kobj目录下创建指向target目录的软链接，name 为软链接文件名称</span></span><br><span class="line"><span class="built_in">int</span> __must_check sysfs<span class="constructor">_create_link(<span class="params">struct</span> <span class="params">kobject</span> <span class="operator">*</span><span class="params">kobj</span>, <span class="params">struct</span> <span class="params">kobject</span> <span class="operator">*</span><span class="params">target</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">name</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>编程实验</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个实验很简单，在/sys/目录下创建一个目录 father 然后在这个目录下创建两个子文件 son1 和 son2，再在 son1 下创建一个链接到 son2 的链接文件 link_to_son2。 只是单纯的展示层次目录关系，因此无需将kobject嵌入到更大的数据结构，采用 kobject_create_and_add 来注册</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">father</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">son1</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">son2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_kobject_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在 /sys/ 目录下创建一个目录 father</span></span><br><span class="line">    father = kobject_create_and_add(<span class="string">&quot;father&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 father 目录下创建两个子文件 son1 和 son2</span></span><br><span class="line">    son1 = kobject_create_and_add(<span class="string">&quot;son1&quot;</span>, father);</span><br><span class="line">    son2 = kobject_create_and_add(<span class="string">&quot;son2&quot;</span>, father);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 son1 下创建一个链接到son2的链接文件 link_to_son2</span></span><br><span class="line">    sysfs_create_link(son1, son2, <span class="string">&quot;link_to_son2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_kobject_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_del(father);</span><br><span class="line">    kfree(father);</span><br><span class="line"></span><br><span class="line">    kobject_del(son1);</span><br><span class="line">    kfree(son1);</span><br><span class="line"></span><br><span class="line">    kobject_del(son2);</span><br><span class="line">    kfree(son2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_kobject_init);</span><br><span class="line">module_exit(my_kobject_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">k85v1_64</span>:/cache # insmod my_kobject.ko</span><br><span class="line"><span class="attribute">k85v1_64</span>:/cache #</span><br><span class="line"><span class="attribute">k85v1_64</span>:/cache # cd /sys/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys # ls</span><br><span class="line"><span class="attribute">block</span> bootinfo bus class dev devices father firmware fs kernel module mtk_rgu power  //创建出的 father</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys # cd father/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father # ls</span><br><span class="line"><span class="attribute">son1</span> son<span class="number">2</span> //创建出的 son<span class="number">1</span> son<span class="number">2</span></span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father # cd son<span class="number">1</span>/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> # ls</span><br><span class="line"><span class="attribute">link_to_son2</span></span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> # ls -la</span><br><span class="line"><span class="attribute">total</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">drwxr</span>-xr-x <span class="number">2</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">40</span> .</span><br><span class="line"><span class="attribute">drwxr</span>-xr-x <span class="number">4</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">40</span> ..</span><br><span class="line"><span class="attribute">lrwxrwxrwx</span> <span class="number">1</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">41</span> link_to_son<span class="number">2</span> -&gt; ../son<span class="number">2</span> //创建出的链接文件</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> #</span><br></pre></td></tr></table></figure>
<h2 id="5、kobj-对象生命周期管理"><a href="#5、kobj-对象生命周期管理" class="headerlink" title="5、kobj 对象生命周期管理"></a>5、kobj 对象生命周期管理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 还有一个非常强大的功能就是管理所嵌入的对象的生命周期，而引用计数 kref 则是它管理所嵌入对象生命周期的核心。对于kerf内核提供了两个下面函数来进行操作。</p>
<h3 id="1-kobject-get"><a href="#1-kobject-get" class="headerlink" title="1) kobject_get"></a>1) kobject_get</h3><p>增加kobj引用计数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_get - increment refcount for object.</span></span><br><span class="line"><span class="comment"> * @kobj: object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_get</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">                   <span class="string">&quot;initialized, yet kobject_get() is being &quot;</span></span><br><span class="line">                   <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">        kref_get(&amp;kobj-&gt;kref); <span class="comment">//增加引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-put"><a href="#2-kobject-put" class="headerlink" title="2) kobject_put"></a>2) kobject_put</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_put</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">                   <span class="string">&quot;initialized, yet kobject_put() is being &quot;</span></span><br><span class="line">                   <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">        kref_put(&amp;kobj-&gt;kref, kobject_release); <span class="comment">//调用kref_put减少引用计数，同时传入回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 kref_put 减少引用计数，同时传入回调函数 kobject_release，该回调函数在引用计数为0时调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kref_put</span><span class="params">(struct kref *kref, <span class="keyword">void</span> (*release)(struct kref *kref))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        WARN_ON(release == <span class="literal">NULL</span>);</span><br><span class="line">        WARN_ON(release == (<span class="keyword">void</span> (*)(struct kref *))kfree);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (atomic_dec_and_test(&amp;kref-&gt;refcount)) &#123;   <span class="comment">/* 当引用计数为0时，调用 release 函数进行资源的释放  */</span></span><br><span class="line">                release(kref);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少引用计数，当 kref 为 0 时调用传入的 release 回调函数，即前面的 kobject_release 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_release</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        kobject_cleanup(container_of(kref, struct kobject, kref)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kobject_put 传入的回调函数，使用 container_of 函数获取到包含 kref 的 kobjec 结构地址，并传入 kobject_cleanup</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kobject_cleanup - free kobject resources.</span></span><br><span class="line"><span class="comment"> * @kobj: object to cleanup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_cleanup</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> =</span> get_ktype(kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = kobj-&gt;name;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s, parent %p\n&quot;</span>,</span><br><span class="line">         kobject_name(kobj), kobj, __func__, kobj-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; !t-&gt;release) <span class="comment">// 判断 release 函数是否存在</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): does not have a release() &quot;</span></span><br><span class="line">             <span class="string">&quot;function, it is broken and must be fixed.\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send &quot;remove&quot; if the caller did not do it but sent &quot;add&quot; */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_add_uevent_sent &amp;&amp; !kobj-&gt;state_remove_uevent_sent) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): auto cleanup &#x27;remove&#x27; event\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        kobject_uevent(kobj, KOBJ_REMOVE); <span class="comment">//发送 uevent 事件 KOBJ_REMOVE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove from sysfs if the caller did not do it */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_in_sysfs) &#123; <span class="comment">// 如果在sys中存在kobj则调用kobject_del删除kobj</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): auto cleanup kobject_del\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        kobject_del(kobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; t-&gt;release) &#123; <span class="comment">//如果release存在则调用release函数</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): calling ktype release\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        t-&gt;release(kobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free name if we allocated it */</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123; <span class="comment">// 释放name空间</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27;: free name\n&quot;</span>, name);</span><br><span class="line">        kfree_const(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;判断 kobj 的 release 函数是否存在，如果在 sys 中存在 kobj 则调用 kobject_del 删除 kobj, 如果 release 存在则调用 release 函数，该函数需要自己实现，如果是用  kobject_create 创建的 kobj，则会使用默认 dynamic_kobj_ktype 中的 release。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_del - unlink kobject from hierarchy.</span></span><br><span class="line"><span class="comment"> * @kobj: object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_del</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    sd = kobj-&gt;sd;</span><br><span class="line">    sysfs_remove_dir(kobj); <span class="comment">//删除sys目录相关文件</span></span><br><span class="line">    sysfs_put(sd);</span><br><span class="line"></span><br><span class="line">    kobj-&gt;state_in_sysfs = <span class="number">0</span>;</span><br><span class="line">    kobj_kset_leave(kobj);  	<span class="comment">//删除所属的kset链表中的kobj成员，减少该kset引用计数 </span></span><br><span class="line">    kobject_put(kobj-&gt;parent);  <span class="comment">//减少parent计数</span></span><br><span class="line">    kobj-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除sys目录相关文件，减少parent引用计数，并调用 kobj_kset_leave函数从 kset list 中移除这个kobject</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove the kobject from its kset&#x27;s list */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobj_kset_leave</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj-&gt;kset)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">    list_del_init(&amp;kobj-&gt;entry);</span><br><span class="line">    spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">    kset_put(kobj-&gt;kset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到 kobject_put 的实现比较复杂，但总的来说它也就完成了下面几件事情</p>
<ol>
<li>减少 kobject 引用计数，当 kobject 引用计数为 0 时调用 kobject-&gt;ktype-&gt;release 函数。</li>
<li>向用户空间发送 uevent 事件 KOBJ_REMOVE</li>
<li>调用 kobject_del 删除 sys 目录相关文件，从属于的kset链表中删除该 kobj 成员，减少 kset 引用计数，减少 parent 的引用计数(这里分别减少了parent的和所属的kset的引用计数) </li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中我们需要实现的也就是这个回调函数 kobject-&gt;ktype-&gt;release ，但实际上内核提供的设备模型已经都实现好了，例如 bus 总线</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bus_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span> =</span> to_subsys_private(kobj);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> priv-&gt;bus;</span><br><span class="line"></span><br><span class="line">    kfree(priv);</span><br><span class="line">    bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">bus_ktype</span> =</span> &#123;</span><br><span class="line">    .sysfs_ops  = &amp;bus_sysfs_ops,</span><br><span class="line">    .release    = bus_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其他的device，device_driver，等凡是内核提供的结构基本内核都帮我们设计好了它的relase函数</p>
<h3 id="3-优化-my-dir"><a href="#3-优化-my-dir" class="headerlink" title="3) 优化 my_dir"></a>3) 优化 my_dir</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;有了上面知识了之后我们也可以用其来优化我们前面创建的 my_dir, 给我们的 my_dir 增加自动释放自身数据结构的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit); </span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_dir</span> <span class="title">power</span> //这里创建出 <span class="title">my_dir</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache <span class="meta"># rmmod my_kobject.ko</span></span><br><span class="line">于此同时内核打印出下面<span class="built_in">log</span></span><br><span class="line">[   <span class="number">52.897412</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">2526</span>:rmmod] my dir release</span><br><span class="line"></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span> //<span class="title">mydir</span> 被移除</span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache # </span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里用了一个非常巧妙的方式实现了，利用 kobject 释放其所嵌入的更大的数据结构的功能，从而实现对 my_dir 生命周期的管理，于是可以得到下面这个结论： <strong><font color = red>凡是需要做对象生命周期管理的对象，都可以通过内嵌kobject来实现需求</font></strong> </p>
<p>该结论来自窝窝科技的文章 <a href="http://www.wowotech.net/device_model/421.html">http://www.wowotech.net/device_model/421.html</a></p>
<h2 id="6、用户空间与内核信息交互"><a href="#6、用户空间与内核信息交互" class="headerlink" title="6、用户空间与内核信息交互"></a>6、用户空间与内核信息交互</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 的另一个核心功能就是能实现用户空间与内核空间的信息交互，我们知道每一个注册的 kobject 都会在 /sys 中以目录的形式呈现，也就是 bus 等数据结构可以利用嵌入 kobject 可以使它显示在 /sys 中。内核为我们提供了快速修改获取内核中 bus 相关的信息(这些信息可以是变量，字符串等)的方法”属性文件(attribute)”。属性文件就是内核空间和用户空间交互信息的一种方法。在Linux内核中，attribute分为普通的attribute和二进制attribute，这里只记录普通的，二进制的没研究，后面有机会研究了再补充(希望渺茫)</p>
<h3 id="1-属性文件调用逻辑"><a href="#1-属性文件调用逻辑" class="headerlink" title="1) 属性文件调用逻辑"></a>1) 属性文件调用逻辑</h3><p>在 fs/sysfs/file.c 文件下查看相关的逻辑代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct sysfs_ops *<span class="title">sysfs_file_ops</span><span class="params">(struct kernfs_node *kn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> kn-&gt;parent-&gt;priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kn-&gt;flags &amp; KERNFS_LOCKDEP)</span><br><span class="line">        lockdep_assert_held(kn);</span><br><span class="line">    <span class="keyword">return</span> kobj-&gt;ktype ? kobj-&gt;ktype-&gt;sysfs_ops : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kernfs read callback for regular sysfs files with pre-alloc */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">sysfs_kf_read</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">	...</span><br><span class="line">    len = ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">min_t</span>(<span class="keyword">ssize_t</span>, count, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">sysfs_kf_write</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!count)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ops-&gt;store(kobj, of-&gt;kn-&gt;priv, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;代码很简单就不注释了，看起来处理过程很简单在 cat/echo 属性文件时(读/写属性文件写数据时)，先调用 sysfs_file_ops 获取到 kobj-&gt;ktype-&gt;sysfs_ops 指针，在调用对应内核的 show/store 函数。从这里可以看出对于用户空间来讲，只负责把数据丢给内核的store以及从内核的show获取数据，至于store的数据用来做什么和show获取到什么数据则由内核决定。这里还可以得出结论：<font color=red>如果从属的 kobject（就是 attribute 文件所在的目录）没有 ktype，或者没有 ktype-&gt;sysfs_ops 指针，是不允许它注册任何 attribute 的</font></p>
<h3 id="2-属性文件的创建以及删除"><a href="#2-属性文件的创建以及删除" class="headerlink" title="2) 属性文件的创建以及删除"></a>2) 属性文件的创建以及删除</h3><p>内核也提供了创建属性文件的api</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include/linux/sysfs.h</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_file</span><span class="params">(struct kobject *kobj, struct attribute *attr)</span></span>; <span class="comment">//在传入的kobj下创建attr属性文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sysfs_remove_file</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute *attr)</span> <span class="comment">//在传入的kobj下移除attr属性文件</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_files</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute **ptr)</span> <span class="comment">//在kobj下创建传入的prt指向的一组属性文件</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sysfs_remove_files</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute **attr)</span></span>;<span class="comment">//在kobj下移除传入的prt指向的一组属性文件</span></span><br></pre></td></tr></table></figure>
<h3 id="3-在-my-dir-下创建属性文件"><a href="#3-在-my-dir-下创建属性文件" class="headerlink" title="3) 在 my_dir 下创建属性文件"></a>3) 在 my_dir 下创建属性文件</h3><p>动手实践一下，在 my_dir 下创建两个属性文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读属性操作函数, cat 属性文件时调用这个函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_show</span><span class="params">(struct kobject *kobj, struct attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir show  attr-&gt;name : %s\n&quot;</span>, attr-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s\n&quot;</span>, attr-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>((<span class="keyword">char</span>*)attr-&gt;name) +<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写属性操作文件, echo 属性文件时调用这个函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_store</span><span class="params">(struct kobject *kobj,struct attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my dir store : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有 kobj_type 同时还要存在 my_sysfs_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">my_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show  = my_dir_show,</span><br><span class="line">    .store = my_dir_store,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要创建属性文件首先要有 kobj_type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">    .sysfs_ops = &amp;my_sysfs_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个注册的 attribute 结构都是一个属性文件，这里创建两个属性文件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">my_dir_attr1</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_dir_attr1&quot;</span>,</span><br><span class="line">    .mode = S_IRWXUGO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">my_dir_attr2</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_dir_attr2&quot;</span>,</span><br><span class="line">    .mode = S_IRWXUGO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr1 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr2 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko <span class="comment">//加载模块</span></span></span><br><span class="line">k85v1_64:/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># cd /sys/</span></span><br><span class="line">k85v1_64:/sys <span class="meta"># ls</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_dir</span> <span class="title">power</span> //查看生成了 <span class="title">my_dir</span></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/sys <span class="meta"># cd my_dir/  <span class="comment">//进入 my_dir</span></span></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># ls</span></span><br><span class="line">my_dir_attr1 my_dir_attr2   <span class="comment">//查看生成了  my_dir_attr1 my_dir_attr2</span></span><br><span class="line">k85v1_64:/sys/my_dir #</span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># echo 123 &gt; my_dir_attr1 <span class="comment">//写入123</span></span></span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[  <span class="number">848.043148</span>] &lt;<span class="number">0</span>&gt;.(<span class="number">0</span>)[<span class="number">5617</span>:sh]my dir store : <span class="number">123</span></span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># cat my_dir_attr1  <span class="comment">//读取数据</span></span></span><br><span class="line">my_dir_attr1</span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1002.452204</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">8065</span>:cat]my dir show  attr-&gt;name : my_dir_attr1</span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir #</span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># echo 222 &gt; my_dir_attr2</span></span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1028.696923</span>] &lt;<span class="number">1</span>&gt;.(<span class="number">1</span>)[<span class="number">5617</span>:sh]my dir store : <span class="number">222</span></span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># cat my_dir_attr2</span></span><br><span class="line">my_dir_attr2</span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1033.116307</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">8397</span>:cat]my dir show  attr-&gt;name : my_dir_attr2</span><br></pre></td></tr></table></figure>
<h3 id="4-优化属性文件操作"><a href="#4-优化属性文件操作" class="headerlink" title="4) 优化属性文件操作"></a>4) 优化属性文件操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子我们虽然创建了属性文件，也能操作属性文件，但是两个属性文件最终都是调用的同一个 show/store 函数，即这种方式的属性文件拥有共用的属性操作函数。而这样明显属性文件就失去了它的独立性。 </p>
<blockquote>
<p>怎么实现属性文件自己的 show/store ？<br>我们可以将 attribute 嵌入到更大的数据结构中，该数据结构包含真正的 show/store 函数然后使用 my_dir_type 中的 show/store 函数作为中转函数，利用 container_of 调用属性文件真正的 show/store 函数</p>
</blockquote>
<p>于是我们调整代码架构将通用的部分提取出来作为 my_kobject_core.c 这部分代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_kobject_core.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构 struct my_dir</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读属性文件操作函数中间层 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_show</span><span class="params">(struct kobject *kobj, struct attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> *<span class="title">my_attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">    my_attr = container_of(attr, struct my_attribute, attr);</span><br><span class="line">    <span class="keyword">if</span> (my_attr-&gt;show)</span><br><span class="line">        ret = my_attr-&gt;show(kobj, my_attr, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写属性文件操作函数中间层 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_store</span><span class="params">(struct kobject *kobj,struct attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> *<span class="title">my_attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">    my_attr = container_of(attr, struct my_attribute, attr);</span><br><span class="line">    <span class="keyword">if</span> (my_attr-&gt;store)</span><br><span class="line">        ret = my_attr-&gt;store(kobj, my_attr, buf, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有 kobj_type 同时还要存在 my_sysfs_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">my_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show  = my_dir_show,</span><br><span class="line">    .store = my_dir_store,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要创建属性文件首先要有 kobj_type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">    .sysfs_ops = &amp;my_sysfs_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 /sys/ 下创建一个名为 name dir */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_regiseter</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(my_dir_regiseter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 移除注册的 my_dir */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_unregiseter</span><span class="params">(struct my_dir* my_dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(my_dirp)</span><br><span class="line">        kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(my_dir_unregiseter);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们将公共的部分放在头文件my_kobject_core.h中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _KOBJECT_CORE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _KOBJECT_CORE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span>  date;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span> <span class="comment">//将 attribute 嵌入到更大的数据结构中</span></span><br><span class="line">    <span class="comment">//真正的 show/store函数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> struct my_dir* <span class="title">my_dir_regiseter</span><span class="params">(<span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">my_dir_unregiseter</span><span class="params">(struct my_dir* my_dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在我们想要创建目录的时候就调用 my_dir_regiseter 来创建 my_dir，想要创建属性文件的时候调用 sysfs_create_file 来创建。 于是在我们真正在 my_kobject.c 中创建 my_dir 以及其属性文件如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_kobject_core.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr1 自己的 show 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_attr1_show</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s : %d\n&quot;</span>, attr-&gt;attr.name, my_dirp-&gt;date);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr1 自己的 store 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span>  <span class="title">my_dir_attr1_store</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于输入的是字符串这里做一个简单的转换，并不严谨仅用于展示功能</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; buf[i] &lt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            tmp = <span class="number">10</span> *tmp + (buf[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;date = tmp;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s store :  my_dirp-&gt;date = %d, buf = %s\n&quot;</span>,attr-&gt;attr.name, my_dirp-&gt;date, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr2 自己的 show 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_attr2_show</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s : %d\n&quot;</span>, attr-&gt;attr.name, my_dirp-&gt;date);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr2 自己的 store 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span>  <span class="title">my_dir_attr2_store</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于输入的是字符串这里做一个简单的转换，并不严谨仅用于展示功能</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; buf[i] &lt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            tmp = <span class="number">10</span> *tmp + (buf[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;date = tmp;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s store :  my_dirp-&gt;date = %d, buf = %s\n&quot;</span>,attr-&gt;attr.name, my_dirp-&gt;date, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里创建两个属性文件 my_dir_attr1、my_dir_attr2 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> <span class="title">my_dir_attr1</span> =</span> &#123;</span><br><span class="line">    .attr =&#123;</span><br><span class="line">        .name = <span class="string">&quot;my_dir_attr1&quot;</span>,</span><br><span class="line">        .mode = S_IRWXUGO,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    .show  = my_dir_attr1_show,</span><br><span class="line">    .store = my_dir_attr1_store,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> <span class="title">my_dir_attr2</span> =</span> &#123;</span><br><span class="line">    .attr =&#123;</span><br><span class="line">        .name = <span class="string">&quot;my_dir_attr2&quot;</span>,</span><br><span class="line">        .mode = S_IRWXUGO,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    .show  = my_dir_attr2_show,</span><br><span class="line">    .store = my_dir_attr2_store,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_dirp = my_dir_regiseter(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr1 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr1.attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr2 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr2.attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_dir_unregiseter(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>验证结果：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># insmod my_kobject_core.ko</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># cd /sys/my_dir/</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># ls</span></span><br><span class="line">my_dir_attr1 my_dir_attr2</span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># echo 11 &gt; my_dir_attr1</span></span><br><span class="line"><span class="comment">//同时内核打印出</span></span><br><span class="line">[ <span class="number">5223.566440</span>] <span class="params">&lt;<span class="number">2</span>&gt;</span>.(<span class="number">2</span>)[<span class="number">23263</span>:sh]my_dir_attr1 store :  my_dirp-&gt;date = <span class="number">11</span>, buf = <span class="number">11</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># cat my_dir_attr1</span></span><br><span class="line">my_dir_attr1 : <span class="number">11</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># echo 22 &gt; my_dir_attr2</span></span><br><span class="line"><span class="comment">//同时内核打印出</span></span><br><span class="line">[ <span class="number">5248.493173</span>] <span class="params">&lt;<span class="number">3</span>&gt;</span>.(<span class="number">3</span>)[<span class="number">23263</span>:sh]my_dir_attr2 store :  my_dirp-&gt;date = <span class="number">22</span>, buf = <span class="number">22</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># cat my_dir_attr2</span></span><br><span class="line">my_dir_attr2 : <span class="number">22</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面的逻辑实现比前面的代码要复杂一点点，可以花点时间看一下，这个方式的牛逼之处在于通过 kobject 我们将我们自己创建的数据结构 struct my_dir 开放到用户空间，以目录的形式呈现出来，同时通过属性文件用户空间能够获取和修改 my_dir.date 这个属于my_dir的成员变量。内核的bus、device、device_driver 等设备模型不过是在这个基础之上增加了一些其他功能，如设备和驱动的匹配等。</p>
<blockquote>
<p><strong><font color=red>错误纠正</font></strong><br><strong><font color=red>前面的代码里面有一处错误，MODULE_AUTHOR(“baron”); MODULE_LICENSE(“GPL”); 这两句代码一定要放在代码最后！！！ ，因为前面没有用 EXPORT_SYMBOL_GPL 模块导出符所以不会有什么影响。</font></strong></p>
</blockquote>
<h1 id="二、kset"><a href="#二、kset" class="headerlink" title="二、kset"></a>二、kset</h1><p>kset的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/kobject.h, line 159 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 该Kset下所有的Kobject都被链接进入该节点               </span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>  <span class="comment">// kset也是kobj的一种，因为c语言无法向面向对象一样继承，因此只能使用这种方式。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 该kset的uevent操作函数集。</span></span><br><span class="line"><span class="comment">    * 当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，</span></span><br><span class="line"><span class="comment">    * 添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。</span></span><br><span class="line"><span class="comment">    * 因此，如果一个kobject不属于任何kset时，是不允许发送uevent的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;因为 kset 本身包含 kobject 结构，因此拥有上述 kobject 的所有特性，而 kset 除了上述的 kobject 的所有功能之外，同时也和它有所区别。要想知道区别是什么就得知道，它多出来的数据结构是干啥的。可以看出主要多出了两个数据结构 list 和 kset_uevent_ops，在前面的 kobject_add 分析中可以知道,只要是 kobject 属于某个 kset 那么都会被链接到所属的 kset 中的 list 链表。 <strong>也就是 kset 具有管理 kobject 的功能</strong>，举个栗子，例如： 当 kernel 关机时， 会在 device_shutdown  中利用 devices_kset-&gt;list 找到该链表上的所有设备，并做相应的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_shutdown</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>, *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过 kset-&gt;list 链表找到链表上的所有设备</span></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;devices_kset-&gt;<span class="built_in">list</span>)) &#123;</span><br><span class="line">        dev = list_entry(devices_kset-&gt;<span class="built_in">list</span>.prev, struct device,  kobj.entry);</span><br><span class="line">	</span><br><span class="line">		...... <span class="comment">//对所有的设备做相关操作</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;除此之外，我们所熟知的热插拔机制的功能也是由 kset 提供的，热插拔指的是当一个设备加入系统，内核如何通知用户空间。感兴趣可以看看这篇文章：<a href="http://bbs.chinaunix.net/thread-3678367-1-1.html">http://bbs.chinaunix.net/thread-3678367-1-1.html</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;热插拔大致的可以分为两个部分组成，内核部分和用户空间部分，而 kset则负责将事件发送到用户空间，而发送的方式则是 uevent。 大致的流程如下</p>
<blockquote>
<p>外设接入设备，设备产生中断<br>内核响应中断，调用 device_add 添加新设备<br>在device_add中会调用 kobject_uevent 将事件通知给用户空间</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于热插拔的内容相对复杂可以单独成文，而且也不影响对设备模型的理解，因此这里只提一下它的功能，关于热插拔更加详细的内容后面认真学习之后再整理出一篇文章。</p>
<h2 id="1、-kset的创建与注册"><a href="#1、-kset的创建与注册" class="headerlink" title="1、 kset的创建与注册"></a>1、 kset的创建与注册</h2><h3 id="1-kset-create"><a href="#1-kset-create" class="headerlink" title="1) kset_create"></a>1) kset_create</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;动态获取一个 kset 内存空间,初始化 uevent_ops ,初始化 parent_kobj ,<strong>初始化一个内核默认的 kset_ktype</strong> ,初始化 kset 中的 kset 为NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kset *<span class="title">kset_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct kset_uevent_ops *uevent_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    kset = kzalloc(<span class="keyword">sizeof</span>(*kset), GFP_KERNEL); <span class="comment">//动态获得一个 kset 内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (!kset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name(&amp;kset-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name); <span class="comment">//初始化 name</span></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        kfree(kset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kset-&gt;uevent_ops = uevent_ops; 	<span class="comment">//初始化 uenent_ops</span></span><br><span class="line">    kset-&gt;kobj.parent = parent_kobj;    <span class="comment">//初始化 parent_kobj</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The kobject of this kset will have a type of kset_ktype and belong to</span></span><br><span class="line"><span class="comment">     * no kset itself.  That way we can properly free it when it is</span></span><br><span class="line"><span class="comment">     * finished being used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kset-&gt;kobj.ktype = &amp;kset_ktype;  <span class="comment">//初始化该 kset 的 ktype</span></span><br><span class="line">    kset-&gt;kobj.kset = <span class="literal">NULL</span>;	     <span class="comment">//kset 的 kset 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kset-init"><a href="#2-kset-init" class="headerlink" title="2) kset_init"></a>2) kset_init</h3><p>初始化kset的kobj成员，初始化list链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_init - initialize a kset for use</span></span><br><span class="line"><span class="comment"> * @k: kset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_init</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_init_internal(&amp;k-&gt;kobj); <span class="comment">//初始化kobj成员</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;k-&gt;<span class="built_in">list</span>); <span class="comment">//初始化list链表</span></span><br><span class="line">    spin_lock_init(&amp;k-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kset-register"><a href="#3-kset-register" class="headerlink" title="3) kset_register"></a>3) kset_register</h3><p>将 kset 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_register - initialize and add a kset.</span></span><br><span class="line"><span class="comment"> * @k: kset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_register</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    kset_init(k); <span class="comment">//调用kset_init初始化kobj成员，初始化list链表</span></span><br><span class="line">    err = kobject_add_internal(&amp;k-&gt;kobj); <span class="comment">//注册kobj即生成kset对应的目录</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD); <span class="comment">//发送uevent事件，KOBJ_ADD</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kset-create-and-add"><a href="#3-kset-create-and-add" class="headerlink" title="3) kset_create_and_add"></a>3) kset_create_and_add</h3><p>动态创建一个kset结构，并将其注册,其实就是 kset_create 和 kset_register 的组合</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct kset *<span class="title">kset_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> struct kset_uevent_ops *uevent_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    kset = kset_create(name, uevent_ops, parent_kobj); <span class="comment">//动态创建 kset</span></span><br><span class="line">    <span class="keyword">if</span> (!kset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    error = kset_register(kset); <span class="comment">//注册kset</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(kset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kset 的创建与注册的函数的选择和前面的kobject一样:</p>
<blockquote>
<p><font color=red>当 kset 需要嵌入到更大的数据结构时使用 kset_register</font><br><font color=red>当 kset 不需嵌入到更大的数据结构时使用 kset_create_and_add</font></p>
</blockquote>
<h2 id="2、卸载kset"><a href="#2、卸载kset" class="headerlink" title="2、卸载kset"></a>2、卸载kset</h2><h3 id="1-kset-unregister"><a href="#1-kset-unregister" class="headerlink" title="1) kset_unregister"></a>1) kset_unregister</h3><p>从卸载一个keset</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_unregister - remove a kset.</span></span><br><span class="line"><span class="comment"> * @k: kset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    kobject_del(&amp;k-&gt;kobj);</span><br><span class="line">    kobject_put(&amp;k-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kset-put"><a href="#2-kset-put" class="headerlink" title="2) kset_put"></a>2) kset_put</h3><p>减少kset的kobj成员引用计数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kset_put</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;k-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、bus总线"><a href="#三、bus总线" class="headerlink" title="三、bus总线"></a>三、bus总线</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux 认为<font color=red>总线是CPU和一个或多个设备之间信息交互的通道</font>。就设备模型而言，所有设备都是通过总线连接的，<strong>这样的总线有两类</strong>：</p>
<blockquote>
<ul>
<li>第一类是i2c、spi、usb 等这类总线，这类总线有实际的物理总线，它本身就有总线这个概念，我们直接根据功能将其抽象出来成一个个单独的总线。</li>
<li>第二类就是虚拟总线，如i2c控制器、GPIO控制器、UART控制器等，cpu 直接通过寄存器或地址与之进行通信。但是呢我们又想将他们统一到设备模型，因此 platform 这个虚拟总线就诞生了。</li>
</ul>
</blockquote>
<h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-bus-type"><a href="#1-bus-type" class="headerlink" title="1) bus_type"></a>1) bus_type</h3><p>每一个 bus_type 都代表一个 bus</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;		<span class="comment">//总线类型的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *dev_name;		<span class="comment">//当 dev-&gt;init_name 为空时，使用&quot;bus-&gt;dev_name+device ID”的形式，为的设备生成一个名称。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   *<span class="title">dev_root</span>;</span> 		<span class="comment">//bus总线上的设备默认的根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span> <span class="comment">//总线所属设备的默认的属性文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span>	<span class="comment">//默认总线属性文件(一组)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span>	<span class="comment">//该总线下的所有设备的默认属性文件(一组)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span>	<span class="comment">//该总线下的驱动的默认属性文件(一组)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);	<span class="comment">//匹配函数，当任何属于该 bus 的 device 和 device_driver 注册到bus时，调用该接口</span></span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);	<span class="comment">//用于 bus 的 device 对环境变量的添加</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);	<span class="comment">//match成功之后调用这个函数</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);	<span class="comment">//和probe相反</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span> <span class="comment">//描述 bus 在 /sys 中的层次结构，也管理着该总线上的dev和driver以及总线的一些属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-subsys-private"><a href="#2-subsys-private" class="headerlink" title="2) subsys_private"></a>2) subsys_private</h3><p>这个结构被用在两个地方 class 和 bus，在不同的位置有不同的含义，当它出现在 bus下用它描述 bus 在 /sys 中的层次结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span>	 	  <span class="comment">// 该bus 在sysfs中的目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span>	  <span class="comment">// bus目录下的device子目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span>  <span class="comment">// 保存该bus下所有的interface</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span>	<span class="comment">//bus目录下的driver子目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span>	<span class="comment">//bus的设备链表,该bus下的所有device挂接在该节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span>	<span class="comment">//bus的驱动链表,该bus下的所有drivers挂接在该节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;	<span class="comment">//用于控制该bus下的drivers或者device是否自动probe</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">//保存该subsys_private结构所属bus</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span>	<span class="comment">// 在 device_add 中使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">// 当用在class时，保存该subsys_private结构所属的class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、bus-根目录的初始化"><a href="#2、bus-根目录的初始化" class="headerlink" title="2、bus 根目录的初始化"></a>2、bus 根目录的初始化</h2><p>buses_init 在 driver_init 中被调用，用于初始化 bus 的根目录，以后所有的 bus 总线均为该目录的子目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">buses_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_kset = kset_create_and_add(<span class="string">&quot;bus&quot;</span>, &amp;bus_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bus_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    system_kset = kset_create_and_add(<span class="string">&quot;system&quot;</span>, <span class="literal">NULL</span>, &amp;devices_kset-&gt;kobj);</span><br><span class="line">    <span class="keyword">if</span> (!system_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buses_init 会创建以下目录</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">sys/bus</span><br><span class="line">sys/<span class="keyword">system</span></span><br></pre></td></tr></table></figure>
<h2 id="3、bus-总线的注册"><a href="#3、bus-总线的注册" class="headerlink" title="3、bus 总线的注册"></a>3、bus 总线的注册</h2><p>该函数向内核注册一个 bus 总线</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//动态创建一个subsys_private结构priv</span></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    priv-&gt;bus = bus; 	<span class="comment">//初始化priv-&gt;bus</span></span><br><span class="line">    bus-&gt;p = priv;	<span class="comment">//初始化bus-&gt;p</span></span><br><span class="line"></span><br><span class="line">    BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 priv-&gt;subsys.kobj-&gt;name = bus-&gt;name</span></span><br><span class="line">    retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">	</span><br><span class="line">    priv-&gt;subsys.kobj.kset = bus_kset; <span class="comment">//初始化kset</span></span><br><span class="line">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype; <span class="comment">//初始化ktype </span></span><br><span class="line">    priv-&gt;drivers_autoprobe = <span class="number">1</span>; <span class="comment">//设置默认可以自动匹配probe</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里我们发现并没有设置parent，因此使用bus_kset作为parent，创建sys/bus/bus-&gt;name文件夹</span></span><br><span class="line">    retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在总线所在目录创建 uevent 属性文件</span></span><br><span class="line">    retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在总线所在目录创建 devices 目录</span></span><br><span class="line">    priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    <span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在总线所在目录创建 drivers 目录</span></span><br><span class="line">    priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    <span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">    __mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">    <span class="comment">//初始化设备链表 klist_devices，该总线上的所有设备将被链入该链表</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">    <span class="comment">//初始化驱动链表 klist_drivers，该总线上的所有驱动将被链入该链表</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在当前总线所在目录创建 drivers_probe 属性文件</span></span><br><span class="line"><span class="comment">    * 在当前总线所在目录创建 drivers_autoprobe 属性文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    retval = add_probe_files(bus);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在当前总线所在目录创建 bus_groups 属性文件(一组)</span></span><br><span class="line">    retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_groups_fail;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">    remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">    bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">    kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">    kfree(bus-&gt;p);</span><br><span class="line">    bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus_register 会创建以下节点：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>bus/xxx</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/u</span>event</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>devices ----- bus下注册的dev将出现在这个目录</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers ----- bus下注册的drv将出现在这个目录</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers_probe</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers_autoprobe</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;bus_register 创建并初始化 priv-&gt;klist_devices 和 priv-&gt;klist_drivers 这两条由该总线维护的非常重要的两条链表，该总线下的 dev 和 drv 会分别链入这两条链表。</p>
<p><strong>编程实验创建自己的总线</strong><br>在内核中创建一个名为 my_bus 的总线</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_match\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_remove</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_bus&quot;</span>,</span><br><span class="line">    .probe = my_bus_probe,</span><br><span class="line">    .match = my_bus_match,</span><br><span class="line">    .remove = my_bus_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_register(&amp;my_bus); <span class="comment">//注册bus总线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_bus_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_unregister(&amp;my_bus); <span class="comment">//卸载bus总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_bus_init);</span><br><span class="line">module_exit(my_bus_exit);</span><br></pre></td></tr></table></figure>
<p><strong>模块验证</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># ls</span></span><br><span class="line">amba        container    gpio iio      scsi    spi</span><br><span class="line">clockevents cpu          hid  mmc      sdio    usb</span><br><span class="line">clocksource event_source i2c  platform snd_seq workqueue</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta">#</span></span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># insmod /cache/my_bus.ko</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta">#</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># ls  <span class="comment">//查看生成了新的总线 my_bus</span></span></span><br><span class="line">amba        container    gpio iio    platform snd_seq workqueue</span><br><span class="line">clockevents cpu          hid  mmc    scsi     spi</span><br><span class="line">clocksource event_source i2c  my_bus sdio     usb</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># cd my_bus/ </span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus/my_bus <span class="meta"># ls <span class="comment">//查看 my_bus 下生成节点</span></span></span><br><span class="line">devices drivers drivers_autoprobe drivers_probe uevent</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus/my_bus <span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>该模块创建下面节点</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>bus/my_bus</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/u</span>event</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers_probe</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers_autoprobe</span><br></pre></td></tr></table></figure>
<h2 id="4、创建属性文件"><a href="#4、创建属性文件" class="headerlink" title="4、创建属性文件"></a>4、创建属性文件</h2><p>内核也提供了在 bus 总线下创建属性文件的接口</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于在bus所在目录创建属性文件</span></span><br><span class="line"><span class="built_in">int</span> bus<span class="constructor">_create_file(<span class="params">struct</span> <span class="params">bus_type</span> <span class="operator">*</span><span class="params">bus</span>, <span class="params">struct</span> <span class="params">bus_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br><span class="line"><span class="comment">//删除在bus所在目录创建的属性文件</span></span><br><span class="line">void bus<span class="constructor">_remove_file(<span class="params">struct</span> <span class="params">bus_type</span> <span class="operator">*</span><span class="params">bus</span>, <span class="params">struct</span> <span class="params">bus_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="二、device设备"><a href="#二、device设备" class="headerlink" title="二、device设备"></a>二、device设备</h1><p>抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。</p>
<h2 id="1、数据结构-1"><a href="#1、数据结构-1" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-device"><a href="#1-device" class="headerlink" title="1) device"></a>1) device</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>    *<span class="title">parent</span>;</span>	 <span class="comment">//父设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>    *<span class="title">p</span>;</span>  <span class="comment">//保存设备链表</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	  <span class="comment">//对应的kobj用于创建dev目录</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *init_name;   <span class="comment">//设备的名称，非常重要，如果不存在则使用&quot;bus-&gt;name + device ID&quot; 如果都不存在则不允许创建设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span> <span class="comment">//设备类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">mutex</span>;</span>  <span class="comment">/* mutex to synchronize calls toits driver. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span>       	<span class="comment">/* 设备挂接的总线 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>       <span class="comment">/* 匹配成功后，链接匹配到的driver */</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data; 	<span class="comment">/* 用于保存私有数据。 */</span></span><br><span class="line">    <span class="keyword">void</span>        *driver_data;   	<span class="comment">/* Driver data, set and get with dev_set get_drvdata */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span>   <span class="title">links</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span>  <span class="title">power</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>    *<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>   *<span class="title">msi_domain</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> *<span class="title">pins</span>;</span> <span class="comment">//pinctrl对应的接口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">msi_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="keyword">int</span>     numa_node;  <span class="comment">/* NUMA node this device is close to */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_map_ops</span> *<span class="title">dma_ops</span>;</span></span><br><span class="line">    u64     *dma_mask;  <span class="comment">/* dma mask (if dma&#x27;able device) */</span></span><br><span class="line">    u64     coherent_dma_mask;<span class="comment">/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   dma_pfn_offset;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">dma_pools</span>;</span>  <span class="comment">/* dma pools (if dma&#x27;ble) */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span> *<span class="title">dma_mem</span>;</span> <span class="comment">/* internal for coherent mem override */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_CMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">cma_area</span>;</span>       <span class="comment">/* contiguous memory area for dma allocations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>  *<span class="title">of_node</span>;</span> <span class="comment">/* associated device tree node */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span>    *<span class="title">fwnode</span>;</span> <span class="comment">/* firmware device node */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">dev_t</span>           devt;   <span class="comment">/* 设备号 */</span></span><br><span class="line">    u32         id; <span class="comment">/* device instance */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span>      devres_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">devres_head</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span>   <span class="title">knode_class</span>;</span> <span class="comment">//链接到dev-&gt;class-&gt;p-&gt;klist_devices节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>        *<span class="keyword">class</span>;</span>		<span class="comment">//所属的class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span>  <span class="comment">/* optional groups */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>    (*release)(struct device *dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iommu_group</span>  *<span class="title">iommu_group</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iommu_fwspec</span> *<span class="title">iommu_fwspec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>            offline_disabled:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span>            offline:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span>            of_node_reused:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-device-private"><a href="#2-device-private" class="headerlink" title="2) device_private"></a>2) device_private</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_children</span>;</span> 	<span class="comment">//用于挂接子设备的 knode_parent</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_parent</span>;</span> 	<span class="comment">//挂接到父设备的 klist_children</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_driver</span>;</span>     <span class="comment">//链入连接的 driver 的 klist_devices 链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span> 	<span class="comment">//链接进入 bus-&gt;p-&gt;klist_devices 链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_probe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>		<span class="comment">//指向所属的 dev</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、device-根目录的初始化"><a href="#2、device-根目录的初始化" class="headerlink" title="2、device 根目录的初始化"></a>2、device 根目录的初始化</h2><p>device文件目录初始化函数，在driver_init中被调用，内核初始化时被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">devices_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在 sys/ 下创建一个名为 devices 目录，deices_kset</span></span><br><span class="line"><span class="comment">    * 在 sys/ 下创建一个名为 dev 的目录，dev_kobj</span></span><br><span class="line"><span class="comment">    * 在 sys/dev/ 下创建一个名为 block 的目录，sysfs_dev_block_kobj</span></span><br><span class="line"><span class="comment">    * 在 sys/dev/ 下创建一个名为 char 的目录，sysfs_dev_char_kobj</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, &amp;device_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!devices_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    dev_kobj = kobject_create_and_add(<span class="string">&quot;dev&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dev_kobj)</span><br><span class="line">        <span class="keyword">goto</span> dev_kobj_err;</span><br><span class="line">    sysfs_dev_block_kobj = kobject_create_and_add(<span class="string">&quot;block&quot;</span>, dev_kobj);</span><br><span class="line">    <span class="keyword">if</span> (!sysfs_dev_block_kobj)</span><br><span class="line">        <span class="keyword">goto</span> block_kobj_err;</span><br><span class="line">    sysfs_dev_char_kobj = kobject_create_and_add(<span class="string">&quot;char&quot;</span>, dev_kobj);</span><br><span class="line">    <span class="keyword">if</span> (!sysfs_dev_char_kobj)</span><br><span class="line">        <span class="keyword">goto</span> char_kobj_err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> char_kobj_err:</span><br><span class="line">    kobject_put(sysfs_dev_block_kobj);</span><br><span class="line"> block_kobj_err:</span><br><span class="line">    kobject_put(dev_kobj);</span><br><span class="line"> dev_kobj_err:</span><br><span class="line">    kset_unregister(devices_kset);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>devices_init 初始化了 device 的基本根目录，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices</span><br><span class="line">/sys/dev</span><br><span class="line">/sys/dev/block</span><br><span class="line">/sys/dev/<span class="keyword">char</span></span><br></pre></td></tr></table></figure>
<p>bus总线管理着该总线下的所有设备和驱动，他们分别位于 /sys/bus/xxx/device 和 /sys/bus/xxx/driver 下</p>
<h2 id="3、device的注册"><a href="#3、device的注册" class="headerlink" title="3、device的注册"></a>3、device的注册</h2><h3 id="1-device-register"><a href="#1-device-register" class="headerlink" title="1) device_register"></a>1) device_register</h3><p>使用 device_regster 注册 device ，这里以源码的形式分析。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_initialize(dev); <span class="comment">//对dev进行一些初始化</span></span><br><span class="line">    <span class="keyword">return</span> device_add(dev); <span class="comment">//将dev注册进bus</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-device-initialize"><a href="#2-device-initialize" class="headerlink" title="2) device_initialize"></a>2) device_initialize</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_initialize</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dev-&gt;kobj.kset = devices_kset; <span class="comment">//初始化kset</span></span><br><span class="line">    kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype); <span class="comment">//初始化ktypoe</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对一些链表进行初始化</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">    mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">    lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class="line">    spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line">    device_pm_init(dev);</span><br><span class="line">    set_dev_node(dev, <span class="number">-1</span>); 	<span class="comment">//设置该设备节点为-1，一般未注册前默认为-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的初始化可以看出,<font color=green>所有通过device_register注册的dev的dev-&gt;kobj-&gt;list，都将挂接在 devices_kset-&gt;list上</font>(在kobj_add注册时链接) ,<font color=blue>如果没有父设备则设备将使用 devices_kset 作为父设备目录节点</font>，因此可以得出下面结论：</p>
<blockquote>
<ul>
<li><font color=red><strong>所有通过 device_regster 创建的设备都应该是/sys/devices/的子目录</strong></font>
</li>
</ul>
</blockquote>
<h3 id="3-device-add"><a href="#3-device-add" class="headerlink" title="3) device_add"></a>3) device_add</h3><p>这个函数将device注册进bus，同时它也做了很多事情非常多的事情，具体做了什么事情我们跟着源码来看一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_add</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_interface</span> *<span class="title">class_intf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">glue_dir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    dev = get_device(dev); <span class="comment">//增加dev引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (!dev)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">        <span class="comment">/* 动态分配一个 device_private 并且初始化 dev成员*/</span></span><br><span class="line">        error = device_private_init(dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for statically allocated devices, which should all be converted</span></span><br><span class="line"><span class="comment">     * some day, we need to initialize the name. We prevent reading back</span></span><br><span class="line"><span class="comment">     * the name, and force the use of dev_name()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;init_name) &#123;	<span class="comment">// 如果有init_name则设置，设置dev-&gt;kobj-&gt;name 为 init_name</span></span><br><span class="line">        dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, dev-&gt;init_name);</span><br><span class="line">        dev-&gt;init_name = <span class="literal">NULL</span>; <span class="comment">//这里需要注意的是，这个 init_name 被设置为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subsystems can specify simple device enumeration */</span></span><br><span class="line">    <span class="comment">//如果 dev-&gt;kobj-&gt;name 为空且对应的bus设置了dev_name 则使用这个名字+dev-&gt;id作为设备名</span></span><br><span class="line">    <span class="keyword">if</span> (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">        dev_set_name(dev, <span class="string">&quot;%s%u&quot;</span>, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果这没有设置dev-&gt;kobj-name 则直接返回error</span></span><br><span class="line">    <span class="keyword">if</span> (!dev_name(dev)) &#123;</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> name_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;device: &#x27;%s&#x27;: %s\n&quot;</span>, dev_name(dev), __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加 dev-parent 的kobj引用计数</span></span><br><span class="line">    parent = get_device(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回parent-&gt;kobj</span></span><br><span class="line">    kobj = get_device_parent(dev, parent);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kobj)) &#123;</span><br><span class="line">        error = PTR_ERR(kobj);</span><br><span class="line">        <span class="keyword">goto</span> parent_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kobj)</span><br><span class="line">        dev-&gt;kobj.parent = kobj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use parent numa_node */</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE)) <span class="comment">// 一般未注册前默认为-1</span></span><br><span class="line">        set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first, register with generic layer. */</span></span><br><span class="line">    <span class="comment">/* we require the name to be set before, and pass NULL */</span></span><br><span class="line">    <span class="comment">// 注册 dev-&gt;kobj，在 sys/ 下创建相关目录</span></span><br><span class="line">    error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        glue_dir = get_glue_dir(dev);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* notify platform of device entry */</span></span><br><span class="line">    <span class="keyword">if</span> (platform_notify)</span><br><span class="line">        platform_notify(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在dev目录下创建属性文件uevent</span></span><br><span class="line">    error = device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> attrError;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在dev所在目录创建三个链接文件</span></span><br><span class="line"><span class="comment">    * of_node     ---&gt; 设备树生成的节点</span></span><br><span class="line"><span class="comment">    * subsystem   ---&gt; dev-&gt;class</span></span><br><span class="line"><span class="comment">    * device      ---&gt; 父设备目录</span></span><br><span class="line"><span class="comment">    * 同时在所属的class目录下创建指向 dev 目录的链接文件，dev-&gt;init_name</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    error = device_add_class_symlinks(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> SymlinkError;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//该函数用于在 dev下创建所属的 class-&gt;dev_groups, 所属的 type-&gt;groups 和 dev-&gt;groups 指向的属性文件以及属性文件 online</span></span><br><span class="line">    error = device_add_attrs(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> AttrsError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将设备注册进bus，详细分析见后文</span></span><br><span class="line">    error = bus_add_device(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> BusError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电源相关暂时忽略</span></span><br><span class="line">    error = dpm_sysfs_add(dev); </span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> DPMError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电源相关暂时忽略</span></span><br><span class="line">    device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">        <span class="comment">//在设备所在目录下创建属性文件 dev</span></span><br><span class="line">        error = device_create_file(dev, &amp;dev_attr_dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> DevAttrError;</span><br><span class="line">        <span class="comment">//如果存在class则在class所在目录下创建指向dev-&gt;kobj的链接文件&quot;major+minor&quot;,否则在 /sys/char 下创建</span></span><br><span class="line">        error = device_create_sys_dev_entry(dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> SysEntryError;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建设备文件节点 /dev/dev-&gt;init_name</span></span><br><span class="line">        devtmpfs_create_node(dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify clients of device addition.  This call must come</span></span><br><span class="line"><span class="comment">     * after dpm_sysfs_add() and before kobject_uevent().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line">    <span class="comment">//向用户空间发送 uevent 事件 KOBJ_ADD</span></span><br><span class="line">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所挂接的bus上的所有drv，对所有的drv进行匹配，匹配成功则调用相对应的probe函数，详细分析见后文</span></span><br><span class="line">    bus_probe_device(dev);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (parent) <span class="comment">//将 dev-&gt;p-&gt;knode_parent 节点加入 parent-&gt;p-&gt;klist_children</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">                   &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;class) &#123;</span><br><span class="line">        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">        <span class="comment">/* tie the class to the device */</span></span><br><span class="line">        <span class="comment">// 绑定device和class，将dev-&gt;knode_class 节点链接到dev-&gt;class-&gt;p-&gt;klist_devices</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">                   &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* notify any interfaces that the device is here */</span></span><br><span class="line">        list_for_each_entry(class_intf,</span><br><span class="line">                    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">            <span class="keyword">if</span> (class_intf-&gt;add_dev)</span><br><span class="line">                class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"> SysEntryError:</span><br><span class="line">    <span class="keyword">if</span> (MAJOR(dev-&gt;devt))</span><br><span class="line">        device_remove_file(dev, &amp;dev_attr_dev);</span><br><span class="line"> DevAttrError:</span><br><span class="line">    device_pm_remove(dev);</span><br><span class="line">    dpm_sysfs_remove(dev);</span><br><span class="line"> DPMError:</span><br><span class="line">    bus_remove_device(dev);</span><br><span class="line"> BusError:</span><br><span class="line">    device_remove_attrs(dev);</span><br><span class="line"> AttrsError:</span><br><span class="line">    device_remove_class_symlinks(dev);</span><br><span class="line"> SymlinkError:</span><br><span class="line">    device_remove_file(dev, &amp;dev_attr_uevent);</span><br><span class="line"> attrError:</span><br><span class="line">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);</span><br><span class="line">    glue_dir = get_glue_dir(dev);</span><br><span class="line">    kobject_del(&amp;dev-&gt;kobj);</span><br><span class="line"> Error:</span><br><span class="line">    cleanup_glue_dir(dev, glue_dir);</span><br><span class="line">parent_error:</span><br><span class="line">    put_device(parent);</span><br><span class="line">name_error:</span><br><span class="line">    kfree(dev-&gt;p);</span><br><span class="line">    dev-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-get-device-parent"><a href="#4-get-device-parent" class="headerlink" title="4) get_device_parent"></a>4) get_device_parent</h3><p>这个函数用于获取 dev-&gt;kobj-&gt;parent</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject *<span class="title">get_device_parent</span><span class="params">(struct device *dev, struct device *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;class) &#123;	<span class="comment">//是否设置class</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent_kobj</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">k</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">        <span class="comment">/* block disks show up in /sys/block */</span></span><br><span class="line">        <span class="keyword">if</span> (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent &amp;&amp; parent-&gt;class == &amp;block_class)</span><br><span class="line">                <span class="keyword">return</span> &amp;parent-&gt;kobj;</span><br><span class="line">            <span class="keyword">return</span> &amp;block_class.p-&gt;subsys.kobj;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we have no parent, we live in &quot;virtual&quot;.</span></span><br><span class="line"><span class="comment">         * Class-devices with a non class-device as parent, live</span></span><br><span class="line"><span class="comment">         * in a &quot;glue&quot; directory to prevent namespace collisions.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) <span class="comment">//parent为空</span></span><br><span class="line">            parent_kobj = virtual_device_parent(dev); <span class="comment">//在/sys/devices/目录下创建 virtual 目录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;class &amp;&amp; !dev-&gt;class-&gt;ns_type) <span class="comment">//dev-&gt;class-&gt;ns_type</span></span><br><span class="line">            <span class="keyword">return</span> &amp;parent-&gt;kobj;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent_kobj = &amp;parent-&gt;kobj; <span class="comment">//设置parent_kobj</span></span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;gdp_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find our class-directory at the parent and reference it */</span></span><br><span class="line">        <span class="comment">//如果已经在dev-&gt;class-&gt;p-&gt;glue_dirs下注册了 parent_kobj 则增加它的引用计数，并直接返回</span></span><br><span class="line">        spin_lock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);</span><br><span class="line">        list_for_each_entry(k, &amp;dev-&gt;class-&gt;p-&gt;glue_dirs.<span class="built_in">list</span>, entry)</span><br><span class="line">            <span class="keyword">if</span> (k-&gt;parent == parent_kobj) &#123;</span><br><span class="line">                kobj = kobject_get(k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        spin_unlock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);</span><br><span class="line">        <span class="keyword">if</span> (kobj) &#123; <span class="comment">//直接返回</span></span><br><span class="line">            mutex_unlock(&amp;gdp_mutex);</span><br><span class="line">            <span class="keyword">return</span> kobj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* or create a new class-directory at the parent device */</span></span><br><span class="line">        <span class="comment">/* 在 parent_kobj 并没有在 dev-&gt;class-&gt;p-&gt;glue_dirs 中，</span></span><br><span class="line"><span class="comment">         * 则在父目录下创建一个名为 dev-&gt;class-&gt;name 的目录，</span></span><br><span class="line"><span class="comment">         * 并将 class-&gt;p-&gt;glue_dirs 作为其kset。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        k = class_dir_create_and_add(dev-&gt;class, parent_kobj);</span><br><span class="line">        <span class="comment">/* do not emit an uevent for this simple &quot;glue&quot; directory */</span></span><br><span class="line">        mutex_unlock(&amp;gdp_mutex);</span><br><span class="line">        <span class="keyword">return</span> k; <span class="comment">//返回dir-&gt;kobj</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subsystems can specify a default root directory for their devices */</span></span><br><span class="line">	<span class="comment">//如果parent为空则且dev-&gt;bus-&gt;dev_root不为空则使用dev-&gt;bus-&gt;dev_root-&gt;kobj作为父节点</span></span><br><span class="line">    <span class="keyword">if</span> (!parent &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_root)</span><br><span class="line">        <span class="keyword">return</span> &amp;dev-&gt;bus-&gt;dev_root-&gt;kobj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)</span><br><span class="line">        <span class="keyword">return</span> &amp;parent-&gt;kobj; <span class="comment">//返回父节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>class_dir_create_and_add</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject* <span class="title">class_dir_create_and_add</span><span class="params">(struct class *class, struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_dir</span> *<span class="title">dir</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    dir = kzalloc(<span class="keyword">sizeof</span>(*dir), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dir)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    dir-&gt;<span class="class"><span class="keyword">class</span> =</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    kobject_init(&amp;dir-&gt;kobj, &amp;class_dir_ktype);</span><br><span class="line"></span><br><span class="line">    dir-&gt;kobj.kset = &amp;class-&gt;p-&gt;glue_dirs;</span><br><span class="line"></span><br><span class="line">    retval = kobject_add(&amp;dir-&gt;kobj, parent_kobj, <span class="string">&quot;%s&quot;</span>, class-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kobject_put(&amp;dir-&gt;kobj);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;dir-&gt;kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get_device_parent函数需要分为情况讨论<br><strong>设备属于某个class且parent为空</strong></p>
<ol>
<li>创建 /sys/devices/virtual目录，并将其作为父目录parent_kobj </li>
<li>遍历 dev-&gt;class-&gt;p-&gt;glue_dirs 下的所有kobj， 如果存在 parent_kobj，则增加其引用计数并直接返回 parent_kobj</li>
<li>否则在parent_kobj下创建一个dir-&gt;kobj (/sys/dev/vitual/dir-&gt;kobj-&gt;name)，使用传入的class-&gt;name 作为其dir-&gt;kobj-&gt;name, 并将class-&gt;p-&gt;glue_dirs作为其kset。并返回dir-&gt;kobj作为parent_kobj，这种情况会曾加如下目录</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/<span class="keyword">virtual</span> </span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/<span class="class"><span class="keyword">class</span>-&gt;</span>name <span class="comment">//dev-&gt;class-&gt;p-&gt;glue_dirs 下不存在 parent_kobj 则创建这个节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>设备属于某个class且parent不为空</strong></p>
<ol>
<li>如果存在 dev-&gt;class-&gt;ns_type 则直接返回 parent_kobj (这种情况不增加目录)</li>
<li>如果上述不存在，则遍历 dev-&gt;class-&gt;p-&gt;glue_dirs 下的所有kobj， 如果存在parent_kobj，则增加其引用计数并直接返回 parent_kobj</li>
<li>否则在 parent_kobj 下创建一个dir-&gt;kobj，使用传入的class-&gt;name 作为其dir-&gt;kobj-&gt;name, 并将class-&gt;p-&gt;glue_dirs作为其kset。并返回dir-&gt;kobj作为parent_kobj，这种情况会增加如下目录</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">..../parent_kobj-&gt;name/<span class="class"><span class="keyword">class</span>-&gt;</span>name</span><br></pre></td></tr></table></figure>
<p><strong>设备属不属于某个class</strong><br>如果 parent 为空则且 dev-&gt;bus-&gt;dev_root 不为空则使用 dev-&gt;bus-&gt;dev_root-&gt;kobj 作为父节点，否则直接返回 parent-&gt;kobj</p>
<h3 id="5-device-add-class-symlinks"><a href="#5-device-add-class-symlinks" class="headerlink" title="5) device_add_class_symlinks"></a>5) device_add_class_symlinks</h3><p>该函数会创建class与dev之间的连接，首先在传入的dev所在目录创建三个链接文件，of_node、subsystem、device，同时在所属的class目录下创建指向dev目录的链接文件，dev-&gt;init_name</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_add_class_symlinks</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span> =</span> dev_of_node(dev);</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_node) &#123; <span class="comment">//设备树生成的节点</span></span><br><span class="line">        <span class="comment">//在 dev-&gt;kobj 下创建指向of_node-&gt;kobj的链接文件of_node</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;of_node-&gt;kobj,<span class="string">&quot;of_node&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            dev_warn(dev, <span class="string">&quot;Error %d creating of_node link\n&quot;</span>,error);</span><br><span class="line">        <span class="comment">/* An error here doesn&#x27;t warrant bringing down the device */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;class)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在 dev-&gt;kobj 下创建指向 dev-&gt;class-&gt;p-&gt;subsys.kobj 的链接文件&quot;subsystem&quot;</span></span><br><span class="line">    error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">                  &amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,</span><br><span class="line">                  <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_devnode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 dev-&gt;kobj 下创建指向 dev-&gt;parent-&gt;kobj 的链接文件 device</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent &amp;&amp; device_is_not_partition(dev)) &#123; <span class="comment">//默认情况满足条件</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;parent-&gt;kobj,</span><br><span class="line">                      <span class="string">&quot;device&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_subsys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">    <span class="comment">/* /sys/block has directories and does not need symlinks */</span></span><br><span class="line">    <span class="keyword">if</span> (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link in the class directory pointing to the device */</span></span><br><span class="line">	<span class="comment">//在 dev-&gt;class-&gt;p-&gt;subsys.kobj 下创建指向 dev-&gt;kobj 链接文件 &quot;dev-&gt;init_name&quot;</span></span><br><span class="line">    error = sysfs_create_link(&amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,</span><br><span class="line">                  &amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_device;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_device:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;device&quot;</span>);</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">out_devnode:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;of_node&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-device-add-attrs"><a href="#6-device-add-attrs" class="headerlink" title="6) device_add_attrs"></a>6) device_add_attrs</h3><p>该函数用于在dev下创建所属的 class-&gt;dev_groups, 所属的 type-&gt;groups 和 dev-&gt;groups 指向的属性文件以及属性文件 online</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_add_attrs</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span> =</span> dev-&gt;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span> =</span> dev-&gt;type;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (class) &#123;</span><br><span class="line">        <span class="comment">//创建 class-&gt;dev_groups 属性文件</span></span><br><span class="line">        error = device_add_groups(dev, class-&gt;dev_groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type) &#123;</span><br><span class="line">        <span class="comment">//创建 type-&gt;groups 属性文件</span></span><br><span class="line">        error = device_add_groups(dev, type-&gt;groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> err_remove_class_groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 dev-&gt;groups 属性文件</span></span><br><span class="line">    error = device_add_groups(dev, dev-&gt;groups);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> err_remove_type_groups;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建属性文件 online</span></span><br><span class="line">    <span class="keyword">if</span> (device_supports_offline(dev) &amp;&amp; !dev-&gt;offline_disabled) &#123;</span><br><span class="line">        error = device_create_file(dev, &amp;dev_attr_online);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> err_remove_dev_groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_remove_dev_groups:</span><br><span class="line">    device_remove_groups(dev, dev-&gt;groups);</span><br><span class="line"> err_remove_type_groups:</span><br><span class="line">    <span class="keyword">if</span> (type)</span><br><span class="line">        device_remove_groups(dev, type-&gt;groups);</span><br><span class="line"> err_remove_class_groups:</span><br><span class="line">    <span class="keyword">if</span> (class)</span><br><span class="line">        device_remove_groups(dev, class-&gt;dev_groups);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-bus-add-device"><a href="#7-bus-add-device" class="headerlink" title="7) bus_add_device"></a>7) bus_add_device</h3><p>这个函数将 device 注册进入bus</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_device</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> bus_get(dev-&gt;bus);</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;</span>, bus-&gt;name, dev_name(dev));</span><br><span class="line">        <span class="comment">/* 在当前设备所在目录下创建 dev-&gt;dev_attrs 默认属性文件(有就创建没有就不创建) */</span></span><br><span class="line">        error = device_add_attrs(bus, dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_put;</span><br><span class="line">        <span class="comment">/* 在当前设备所在目录下创建属性文件  bus-&gt;dev_groups */</span></span><br><span class="line">        error = device_add_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_id;</span><br><span class="line">        <span class="comment">/* 在设备所在bus的devices目录下创建指向设备所在目录的软链接，名字为dev-&gt;name */</span></span><br><span class="line">        error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">                        &amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_groups;</span><br><span class="line">        <span class="comment">/* 在设备所在目录下创建指向设备所在总线的的软链接名为 subsystem */</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">                &amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_subsys;</span><br><span class="line">        <span class="comment">/* 将设备链入 bus-&gt;p-&gt;klist_devices 链表 */</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">    sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));</span><br><span class="line">out_groups:</span><br><span class="line">    device_remove_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">out_id:</span><br><span class="line">    device_remove_attrs(bus, dev);</span><br><span class="line">out_put:</span><br><span class="line">    bus_put(dev-&gt;bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus_add_device 会创建以下节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/bus/xxx/devices/dev-&gt;name ----&gt; ..../dev-&gt;name</span><br><span class="line">..../dev-&gt;name/subsystem ----&gt; /sys/bus/xxx</span><br></pre></td></tr></table></figure>
<h3 id="8-bus-probe-device"><a href="#8-bus-probe-device" class="headerlink" title="8) bus_probe_device"></a>8) bus_probe_device</h3><p>如果drivers_autoprobe为1,即可以自动匹配则调用 device_initial_probe(dev)</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void bus<span class="constructor">_probe_device(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> bus_type *bus = dev-&gt;bus;</span><br><span class="line">    <span class="keyword">struct</span> subsys_interface *sif;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        return;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果设置了 bus-&gt;p-&gt;drivers_autoprobe 则进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (bus-&gt;p-&gt;drivers_autoprobe) </span><br><span class="line">        device<span class="constructor">_initial_probe(<span class="params">dev</span>)</span>;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_lock(&amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">    <span class="built_in">list</span><span class="constructor">_for_each_entry(<span class="params">sif</span>, &amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">interfaces</span>, <span class="params">node</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (sif-&gt;add_dev)</span><br><span class="line">            sif-&gt;add<span class="constructor">_dev(<span class="params">dev</span>, <span class="params">sif</span>)</span>;</span><br><span class="line">    mutex<span class="constructor">_unlock(&amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>device_initial_probe</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_initial_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __device_attach(dev, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__device_attach</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach(struct device *dev, <span class="keyword">bool</span> allow_async)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    device_lock(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver) &#123; <span class="comment">//在初始化dev的时候手动指定了driver，则在这里进行绑定</span></span><br><span class="line">        <span class="keyword">if</span> (device_is_bound(dev)) &#123;  <span class="comment">//判断设备和驱动是否已经绑定</span></span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 手动绑定设备和驱动</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">        ret = device_bind_driver(dev); </span></span><br><span class="line"><span class="comment">        if (ret == 0)</span></span><br><span class="line"><span class="comment">            ret = 1;</span></span><br><span class="line"><span class="comment">        else &#123;</span></span><br><span class="line"><span class="comment">            dev-&gt;driver = NULL;</span></span><br><span class="line"><span class="comment">            ret = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        struct device_attach_data data = &#123;</span></span><br><span class="line"><span class="comment">            .dev = dev,</span></span><br><span class="line"><span class="comment">            .check_async = allow_async,</span></span><br><span class="line"><span class="comment">            .want_async = false,</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (dev-&gt;parent)</span></span><br><span class="line"><span class="comment">            pm_runtime_get_sync(dev-&gt;parent);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">        //遍历 dev-&gt;bus 上所有的 drv ，对每一个drv 调用 __device_attach_driver 函数</span></span><br><span class="line"><span class="comment">        ret = bus_for_each_drv(dev-&gt;bus, NULL, &amp;data,</span></span><br><span class="line"><span class="comment">                    __device_attach_driver);</span></span><br><span class="line"><span class="comment">        if (!ret &amp;&amp; allow_async &amp;&amp; data.have_async) &#123;</span></span><br><span class="line"><span class="comment">            /*</span></span><br><span class="line"><span class="comment">             * If we could not find appropriate driver</span></span><br><span class="line"><span class="comment">             * synchronously and we are allowed to do</span></span><br><span class="line"><span class="comment">             * async probes and there are drivers that</span></span><br><span class="line"><span class="comment">             * want to probe asynchronously, we&#x27;ll</span></span><br><span class="line"><span class="comment">             * try them.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dev_dbg(dev, <span class="string">&quot;scheduling asynchronous probe\n&quot;</span>);</span><br><span class="line">            get_device(dev);</span><br><span class="line">            async_schedule(__device_attach_async_helper, dev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pm_request_idle(dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">            pm_runtime_put(dev-&gt;parent);</span><br><span class="line">    &#125;</span><br><span class="line">out_unlock:</span><br><span class="line">    device_unlock(dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>device_bind_driver</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_bind_driver</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建链接文件 .../dev-&gt;driver-&gt;p-&gt;kobj/dev-&gt;kobj-&gt;name</span></span><br><span class="line"><span class="comment">    * 创建链接文件 .../dev-&gt;kobj/driver</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = driver_sysfs_add(dev);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        driver_bound(dev); <span class="comment">//手动绑定</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__device_attach_driver</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach_driver(struct device_driver *drv, <span class="keyword">void</span> *_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attach_data</span> *<span class="title">data</span> =</span> _data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> data-&gt;dev;</span><br><span class="line">    <span class="keyword">bool</span> async_allowed;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check if device has already been claimed. This may</span></span><br><span class="line"><span class="comment">     * happen with driver loading, device discovery/registration,</span></span><br><span class="line"><span class="comment">     * and deferred probe processing happens all at once with</span></span><br><span class="line"><span class="comment">     * multiple threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 调用 drv 所属的 bus 的 match 函数，这里可以看出来如果不初始化 drv-&gt;bus-&gt;match 函数则默认匹配成功。</span></span><br><span class="line"><span class="comment">      static inline int driver_match_device(struct device_driver *drv, struct device *dev)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">          return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = driver_match_device(drv, dev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* no match */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Device match requests probe deferral\n&quot;</span>);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Bus failed to match device: %d&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="comment">/* ret &gt; 0 means positive match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取驱动加载方式是同步加载还是异步加载</span></span><br><span class="line">    async_allowed = driver_allows_async_probing(drv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (async_allowed)</span><br><span class="line">        data-&gt;have_async = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;check_async &amp;&amp; async_allowed != data-&gt;want_async)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用 driver_probe_device</span></span><br><span class="line">    <span class="keyword">return</span> driver_probe_device(drv, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>driver_probe_device</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_probe_device</span><span class="params">(struct device_driver *drv, struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!device_is_registered(dev))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: matched device %s with driver %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">        pm_runtime_get_sync(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    pm_runtime_barrier(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 really_probe 函数</span></span><br><span class="line">    ret = really_probe(dev, drv);</span><br><span class="line">    pm_request_idle(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">        pm_runtime_put(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>really_probe</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -EPROBE_DEFER;</span><br><span class="line">    <span class="keyword">int</span> local_trigger_count = atomic_read(&amp;deferred_trigger_count);</span><br><span class="line">    <span class="keyword">bool</span> test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;</span><br><span class="line">               !drv-&gt;suppress_bind_attrs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTPROF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ts = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (defer_all_probes) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Value of defer_all_probes can be set only by</span></span><br><span class="line"><span class="comment">         * device_defer_all_probes_enable() which, in turn, will call</span></span><br><span class="line"><span class="comment">         * wait_for_device_probe() right after that to avoid any races.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Driver %s force probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atomic_inc(&amp;probe_count);</span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line">    WARN_ON(!list_empty(&amp;dev-&gt;devres_head));</span><br><span class="line"></span><br><span class="line">re_probe:</span><br><span class="line">    dev-&gt;driver = drv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    <span class="comment">// 如果使用了 pinctrl 则会在这里先加载一次，如果 dts 写错了但能编译过了，就是不probe</span></span><br><span class="line">    <span class="comment">// 当移植代码的时候，当我们注册的驱动无法 prob e到设备的时候记得检查一下是否是 dts 的问题，</span></span><br><span class="line">    <span class="comment">// 因为不同个平台的 dts 可能由微小的差别，我就踩过这个坑 =_=</span></span><br><span class="line">    ret = pinctrl_bind_pins(dev);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> pinctrl_bind_failed;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在drv所在目录创建指向dev目录的链接文件，名字使用 dev-&gt;kobj-&gt;name</span></span><br><span class="line"><span class="comment">    * 在dev所在目录创建指向drv目录的连接文件，名字使用 &quot;driver&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, dev_name(dev));</span><br><span class="line">        <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">        ret = dev-&gt;pm_domain-&gt;activate(dev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用 dev-&gt;bus-&gt;probe</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">        TIME_LOG_START();</span><br><span class="line">        ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">        TIME_LOG_END();</span><br><span class="line">        bootprof_probe(ts, dev, drv, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev-&gt;bus-&gt;probe);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123; <span class="comment">//如果 dev-&gt;bus-&gt;probe 不存在则调用 drv-&gt;probe</span></span><br><span class="line">       TIME_LOG_START();</span><br><span class="line">        ret = drv-&gt;probe(dev);</span><br><span class="line">        TIME_LOG_END();</span><br><span class="line">        bootprof_probe(ts, dev, drv, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)drv-&gt;probe);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test_remove) &#123;</span><br><span class="line">        test_remove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">            dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">            drv-&gt;remove(dev);</span><br><span class="line"></span><br><span class="line">        devres_release_all(dev);</span><br><span class="line">        driver_sysfs_remove(dev);</span><br><span class="line">        dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">        dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">            dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">        pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> re_probe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pinctrl_init_done(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">        dev-&gt;pm_domain-&gt;sync(dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立设备与驱动的连接</span></span><br><span class="line">    driver_bound(dev);</span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">probe_failed:</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">pinctrl_bind_failed:</span><br><span class="line">    devres_release_all(dev);</span><br><span class="line">    driver_sysfs_remove(dev);</span><br><span class="line">    dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">    dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">        dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">    pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">        <span class="comment">/* Driver requested deferred probing */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">        <span class="comment">/* Did a trigger occur while probing? Need to re-trigger if yes */</span></span><br><span class="line">        <span class="keyword">if</span> (local_trigger_count != atomic_read(&amp;deferred_trigger_count))</span><br><span class="line">            driver_deferred_probe_trigger();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -ENODEV:</span><br><span class="line">    <span class="keyword">case</span> -ENXIO:</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line">             drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* driver matched but the probe failed */</span></span><br><span class="line">        printk(KERN_WARNING</span><br><span class="line">               <span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">               drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ignore errors returned by -&gt;probe so that the next driver can try</span></span><br><span class="line"><span class="comment">     * its luck.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">    atomic_dec(&amp;probe_count);</span><br><span class="line">    wake_up(&amp;probe_waitqueue);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、device-register总结"><a href="#4、device-register总结" class="headerlink" title="4、device_register总结"></a>4、device_register总结</h2><h3 id="1-检查设备名的合法性"><a href="#1-检查设备名的合法性" class="headerlink" title="1) 检查设备名的合法性"></a>1) 检查设备名的合法性</h3><p>从代码可以看出对于dev来说名字是一个非常重要的参数，首先使用 init_name 作为dev-&gt;kobj的名字同时将init_name设置为空，如果 init_name 初始为空则使用 “bus-&gt;dev_nam + dev-&gt;id” 作为dev-&gt;kobj的名字，<font color=color>如果设备没有设置名字则直接返回错误。</font></p>
<h3 id="2）在sys-创建文件目录的层次关系的创建"><a href="#2）在sys-创建文件目录的层次关系的创建" class="headerlink" title="2）在sys/创建文件目录的层次关系的创建"></a>2）在sys/创建文件目录的层次关系的创建</h3><p>下面列出所有可能出现的情况<br><strong>设备的bus为空，class为空，parent为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/xxx</span><br><span class="line">/sys/devices/xxx/power</span><br><span class="line">/sys/devices/xxx/uevent</span><br><span class="line">/sys/devices/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的bus为空，class为空，parent不为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/.../xxx-&gt;parent/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/power</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/dev <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/.../xxx-&gt;parent/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的bus不为空，class为空，parent为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/xxx</span><br><span class="line">/sys/devices/xxx/power</span><br><span class="line">/sys/devices/xxx/uevent</span><br><span class="line">/sys/devices/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* bus_add_device 创建下面目录 */</span></span><br><span class="line">/sys/bus/xxx-&gt;bus/devices/xxx ---&gt;/sys/devices/xxx	 <span class="comment">//指向设备</span></span><br><span class="line">/sys/devices/xxx/subsystem ---&gt; /sys/bus/xxx-&gt;bus <span class="comment">//指向所挂接的bus总线</span></span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和drv匹配成功创建下面目录</span></span><br><span class="line">/sys/devices/xxx/driver ---&gt; /sys/bus/drivers/xxx-&gt;driver/</span><br><span class="line">/sys/bus/drivers/xxx-&gt;driver/xxx ---&gt; /sys/devices/xxx</span><br></pre></td></tr></table></figure>
<p><strong>设备的bus不为空，class为空，parent不为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/.../xxx-&gt;parent/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/power</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* bus_add_device 创建下面目录 */</span></span><br><span class="line">/sys/bus/xxx-&gt;bus/devices/xxx ---&gt;/sys/devices/.../xxx-&gt;parent/xxx	 <span class="comment">//指向设备</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/subsystem ---&gt; /sys/bus/xxx-&gt;bus <span class="comment">//指向所挂接的bus总线</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/.../xxx-&gt;parent/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和drv匹配成功创建下面目录</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/driver ---&gt; /sys/bus/drivers/xxx-&gt;driver/</span><br><span class="line">/sys/bus/drivers/xxx-&gt;driver/xxx ---&gt; /sys/devices/.../xxx-&gt;parent/xxx</span><br></pre></td></tr></table></figure>
<p><strong>设备的 bus 为空，class 不为空，parent 为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dir-&gt;kobj使用xxx-&gt;class-&gt;name做名字</span></span><br><span class="line"></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/uevent</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/of_node <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device_add_class_symlinks 创建下面目录 */</span></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/subsystem ---&gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">xxx</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span></span></span><br><span class="line"><span class="class">/<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">dev</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span> ---&gt;</span> /sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx</span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * .../dev-&gt;class-&gt;dev_kobj/&quot;major+minor&quot; ---&gt; /sys/devices/virtual/dir-&gt;kobj/xxx 有dev-&gt;class-&gt;dev_kobj和设备号的设备会创建这个节点</span></span><br><span class="line"><span class="comment"> * dev-&gt;class-&gt;dev_kobj 这个属性在class被注册的时候一般被默认设置为 sysfs_dev_char_kobj,即 /sys/dev/char节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx <span class="comment">//有设备号会默认创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的 bus 为空，class 不为空，parent 不为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dir-&gt;kobj使用xxx-&gt;class-&gt;name做名字</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/of_node <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device_add_class_symlinks 创建下面目录 */</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/subsystem ---&gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">xxx</span>-&gt;</span><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">/<span class="title">sys</span>/<span class="title">devices</span>/<span class="title">xxx</span>-&gt;</span>parent/dir-&gt;kobj/xxx/device ---&gt; dev-&gt;parent-&gt;kobj </span><br><span class="line">/sys/<span class="class"><span class="keyword">class</span>/<span class="title">dev</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span> ---&gt;</span> /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx</span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * .../dev-&gt;class-&gt;dev_kobj/&quot;major+minor&quot; ---&gt; /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx 有dev-&gt;class-&gt;dev_kobj和设备号的设备会创建这个节点</span></span><br><span class="line"><span class="comment"> * dev-&gt;class-&gt;dev_kobj 这个属性在class被注册的时候一般被默认设置为 sysfs_dev_char_kobj,即 /sys/dev/char节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx <span class="comment">//有设备号会默认创建这个节点</span></span><br><span class="line"></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么没有同时出现一个设备同时属于bus和class的情况，通过整理 device_add 创建的目录层次可以发现，bus(class)下的设备都会在注册的的时候在设备目录创建 subsystem ，这个链接文件指向bus(class)，同时也会在bus(class)目录创建指向设备的链接文件。在 <font color = blue>device_add_class_symlinks 函数和 bus_add_device 函数中都会在当前设备下创建 “subsystem” 这个属性文件</font>，很明显存在着冲突，这得出一个结论：<font color = red>内核在向bus注册设备的时候，如果设备同属于class和bus时，设备是无法注册的</font></p>
<h3 id="3）和挂接的bus上的所有drv进行匹配"><a href="#3）和挂接的bus上的所有drv进行匹配" class="headerlink" title="3）和挂接的bus上的所有drv进行匹配"></a>3）和挂接的bus上的所有drv进行匹配</h3><p>匹配流程如下</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">bus_probe_device</span>---&gt;</span></span><br><span class="line">   <span class="function"><span class="title">device_initial_probe</span>(dev) ---&gt;</span> <span class="comment">//如果bus-&gt;p-&gt;drivers_autoprobe被置位则调用这个函数</span></span><br><span class="line">      ---&gt; __device_attach(dev, <span class="literal">true</span>);</span><br><span class="line">               ---&gt; <span class="function"><span class="title">bus_for_each_drv</span>(dev-&gt;</span>bus, NULL, &amp;<span class="keyword">data</span>, __device_attach_driver); <span class="comment">//对于该bus上的每一个drv都调用__device_attach_driver函数</span></span><br><span class="line">                        ---&gt; __device_attach_driver(drv, <span class="keyword">data</span>) </span><br><span class="line">                                ---&gt; driver_match_device(drv, dev);</span><br><span class="line">                                         ---&gt; <span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>match(dev, drv)</span><br><span class="line">                                         ---&gt; driver_probe_device(drv, dev) <span class="comment">//如果匹配成功则调用这个函数</span></span><br><span class="line">                                                 ---&gt; really_probe(dev, drv);</span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">dev</span>-&gt;</span>driver = drv; <span class="comment">//将匹配成功的驱动赋值给对应的设备</span></span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe(dev) <span class="comment">//默认调用这个</span></span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">probe</span>(dev) //如果没有设置 dev-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe 函数，则调用这</span><br></pre></td></tr></table></figure>
<p><font color = red> dev在注册的时候会和所挂接bus上的所有drv进行匹配，即调用 drv-&gt;bus-&gt;match(dev, drv) 函数，如果匹配成功则调用所在总线上的probe函数，即 dev-&gt;bus-&gt;probe(dev) 函数 </font>, 从这里也可以看出匹配的规则是灵活的，它由总线决定，<font color = blue>由总线来决定设备和驱动的匹配规则</font>, 比如 platform 总线就规定了5种匹配规则，这里只是提一下，后面的platform设备详述。</p>
<h2 id="5、创建我们自己的设备"><a href="#5、创建我们自己的设备" class="headerlink" title="5、创建我们自己的设备"></a>5、创建我们自己的设备</h2><p>我们之前已经创建了一个my_bus总线，现在在这个基础之上再创建一个my_dev</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">my_dev</span> =</span> &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;my_dev&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_device_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_register(&amp;my_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_device_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_unregister(&amp;my_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_device_init);</span><br><span class="line">module_exit(my_device_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># ls</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># insmod /cache/my_device.ko</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># ls</span></span><br><span class="line">my_dev</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># cd my_dev/</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># ls</span></span><br><span class="line">power subsystem uevent</span><br></pre></td></tr></table></figure>
<h2 id="6、在dev下创建属性文件"><a href="#6、在dev下创建属性文件" class="headerlink" title="6、在dev下创建属性文件"></a>6、在dev下创建属性文件</h2><p>属性文件作为用户空间和内核空间交互的常用手段之一，它的重要性不言而喻。 device_register 在 device_initialize 中会将 ktype 初始化为 device_ktype </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">device_ktype</span> =</span> &#123;</span><br><span class="line">    .<span class="built_in">release</span>    = device_release,</span><br><span class="line">    .sysfs_ops  = &amp;dev_sysfs_ops,</span><br><span class="line">    .<span class="keyword">namespace</span>  = device_namespace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">dev_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show   = dev_attr_show,</span><br><span class="line">    .store  = dev_attr_store,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到内核已经实现了 device_release 函数当dev引用计数为0时会自动释放掉自己。同样的内核也实现了属性文件中间层的函数 dev_attr_show 和 dev_attr_store</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ssize_t dev_attr_show(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *kobj, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *attr,</span><br><span class="line">                 <span class="built_in">char</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *dev_attr = to_dev_attr(attr); <span class="comment">//获取到更大的结构 device_attribute</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = kobj_to_dev(kobj);</span><br><span class="line">    ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev_attr-&gt;show)</span><br><span class="line">        ret = dev_attr-&gt;show(dev, dev_attr, buf); <span class="comment">//调用 device_attribute 的成员 show 函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= (ssize_t)PAGE_SIZE) &#123;</span><br><span class="line">        print_symbol(<span class="string">&quot;dev_attr_show: %s returned bad count\n&quot;</span>,</span><br><span class="line">                (unsigned long)dev_attr-&gt;show);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ssize_t dev_attr_store(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *kobj, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *attr,</span><br><span class="line">                  <span class="keyword">const</span> <span class="built_in">char</span> *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *dev_attr = to_dev_attr(attr); <span class="comment">//获取到更大的结构 device_attribute</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = kobj_to_dev(kobj);</span><br><span class="line">    ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev_attr-&gt;store)</span><br><span class="line">        ret = dev_attr-&gt;store(dev, dev_attr, buf, count);<span class="comment">//调用 device_attribute 的成员 store 函数</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span>    attr;</span><br><span class="line">    ssize_t (*show)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *attr,</span><br><span class="line">            <span class="built_in">char</span> *buf);</span><br><span class="line">    ssize_t (*store)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="built_in">char</span> *buf, size_t count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个框架看起来是不是很熟悉，其实前面我们自己在my_dir就已经实现了这个框架了，这里只是换了个壳而已，像前面的 bus，以及后面的 driver 等模型，内核已经帮我们实现了相关框架，我们只需要直接用就行了。创建属性结构的方法太麻烦了，没关系内核也为我们封装了快速创建并初始化 device_attribute 结构的宏了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个可读可写的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_show、name_store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个只读的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_show</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个只写的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_WO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_WO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_ULONG_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_ulong</span>, <span class="params">device_store_ulong</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_INT_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_int</span>, <span class="params">device_store_int</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_BOOL_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_bool</span>, <span class="params">device_store_bool</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_IGNORE_LOCKDEP(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name =      \</span><br><span class="line">        <span class="constructor">__ATTR_IGNORE_LOCKDEP(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br></pre></td></tr></table></figure>
<p>创建出了 device_attribute 结构，再调用 device_attribute 函数就可以在当前设备下快速创建属性文件。</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> device_create_file(struct device *<span class="built_in">dev</span>,</span><br><span class="line">               const struct device_attribute *<span class="built_in">attr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    if (<span class="built_in">dev</span>) &#123;</span><br><span class="line">        WARN(((<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.mode &amp; S_IWUGO) &amp;&amp; !<span class="built_in">attr</span>-&gt;store),</span><br><span class="line">            <span class="string">&quot;Attribute %s: write permission without &#x27;store&#x27;\n&quot;</span>,</span><br><span class="line">            <span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.name);</span><br><span class="line">        WARN(((<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.mode &amp; S_IRUGO) &amp;&amp; !<span class="built_in">attr</span>-&gt;<span class="built_in">show</span>),</span><br><span class="line">            <span class="string">&quot;Attribute %s: read permission without &#x27;show&#x27;\n&quot;</span>,</span><br><span class="line">            <span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.name);</span><br><span class="line">        error = sysfs_create_file(&amp;<span class="built_in">dev</span>-&gt;kobj, &amp;<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>); <span class="comment">//注册属性文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create_file);</span><br></pre></td></tr></table></figure>
<p><strong>编程实现</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;linux/device.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/<span class="keyword">module</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/kernel.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/init.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/<span class="built_in">string</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/sysfs.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/stat.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="constructor">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">extern <span class="keyword">struct</span> bus_type my_bus;</span><br><span class="line">extern <span class="keyword">struct</span> <span class="keyword">class</span> *my_class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> device my_dev = &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;my_dev&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ssize_t my<span class="constructor">_attr_show(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_attribute</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    sprintf(buf, <span class="string">&quot;%s\n&quot;</span>, attr-&gt;attr.name);</span><br><span class="line">    return strlen((<span class="built_in">char</span>*)attr-&gt;attr.name) +<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t my<span class="constructor">_attr_store(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_attribute</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">size_t</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s store : %s\n&quot;</span>,attr-&gt;attr.name, buf);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="constructor">DEVICE_ATTR(<span class="params">my_attr_test</span>, 0664, <span class="params">my_attr_show</span>, <span class="params">my_attr_store</span>)</span>;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> my<span class="constructor">_device_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device<span class="constructor">_register(&amp;<span class="params">my_dev</span>)</span>;</span><br><span class="line">    device<span class="constructor">_create_file(&amp;<span class="params">my_dev</span>,&amp;<span class="params">dev_attr_my_attr_test</span>)</span>; <span class="comment">//注意这里需要添加自己的前缀 dev_attr_</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void my<span class="constructor">_device_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device<span class="constructor">_unregister(&amp;<span class="params">my_dev</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">my_device_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">my_device_exit</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>cat自己创建出的设备节点</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># cat my_attr_test</span></span><br><span class="line">my_attr_test</span><br><span class="line">[  <span class="number">501.905519</span>] &lt;<span class="number">6</span>&gt;.(<span class="number">6</span>)[<span class="number">2845</span>:cat]my_attr_test <span class="regexp">//</span>内核打印</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>ehco自己创建的设备节点</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># echo 123&gt;my_attr_test</span></span><br><span class="line">[  <span class="number">545.227562</span>] &lt;<span class="number">4</span>&gt;.(<span class="number">4</span>)[<span class="number">2821</span>:sh]my_attr_test store : <span class="number">123</span> <span class="regexp">//</span>内核打印</span><br></pre></td></tr></table></figure>
<h1 id="三、driver驱动"><a href="#三、driver驱动" class="headerlink" title="三、driver驱动"></a>三、driver驱动</h1><p>Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。而Linux内核中的驱动开发，基本都围绕该抽象进行（实现所规定的接口函数）。</p>
<h2 id="1、数据结构-2"><a href="#1、数据结构-2" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-device-driver"><a href="#1-device-driver" class="headerlink" title="1) device_driver"></a>1) device_driver</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *name;   <span class="comment">//名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span></span>     *bus; <span class="comment">//挂接的总线</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span></span>       *owner; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *mod_name;  <span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> suppress_bind_attrs;   <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span></span> probe_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span></span>   *of_match_table; <span class="comment">//用设备树匹配时，用于匹配设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span></span> *acpi_match_table;</span><br><span class="line"></span><br><span class="line">    int (*probe) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*remove) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    void (*shutdown) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*suspend) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, pm_message_t state);</span><br><span class="line">    int (*resume) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span></span> **groups;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span></span> *pm;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span></span> *p; <span class="comment">//保存相关链表，也保存了kobj</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-driver-private"><a href="#2-driver-private" class="headerlink" title="2) driver_private"></a>2) driver_private</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span> <span class="comment">//链接到bus-&gt;p-&gt;klist_drivers</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module_kobject</span> *<span class="title">mkobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、driver的注册"><a href="#2、driver的注册" class="headerlink" title="2、driver的注册"></a>2、driver的注册</h2><p>相较于device的注册，driver的注册就比较简单</p>
<ol>
<li>在总线上查找drv，判断drv是否已经注册进bus，防止重复注册</li>
<li>调用bus_add_driver将drv注册进入bus</li>
<li>创建属性文件 drv-&gt;groups</li>
<li>向上层发送uevent事件，KOBJ_ADD</li>
</ol>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">int driver_register(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct device_driver *other;</span><br><span class="line"></span><br><span class="line">    BUG_ON(!<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>p);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> ((drv-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">probe</span> &amp;&amp; drv-&gt;</span>probe) ||</span><br><span class="line">        (<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">remove</span> &amp;&amp; drv-&gt;</span>remove) ||</span><br><span class="line">        (<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">shutdown</span> &amp;&amp; drv-&gt;</span>shutdown))</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">            <span class="string">&quot;bus_type methods\n&quot;</span>, <span class="function"><span class="title">drv</span>-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在总线上查找drv，判断drv是否已经注册进bus，防止重复注册</span></span><br><span class="line">    <span class="function"><span class="title">other</span> = driver_find(drv-&gt;</span><span class="function"><span class="title">name</span>, drv-&gt;</span>bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, <span class="function"><span class="title">drv</span>-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        return -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用bus_add_driver将drv注册进入bus</span></span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建属性文件 drv-&gt;groups</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = driver_add_groups(drv, drv-&gt;</span>groups);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向上层发送uevent事件，KOBJ_ADD</span></span><br><span class="line">    <span class="function"><span class="title">kobject_uevent</span>(&amp;drv-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bus_add_driver</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bus = bus_get(drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out_put_bus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化klist_devices</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    priv-&gt;driver = drv; </span><br><span class="line">    drv-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">    priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset; <span class="comment">//初始化kest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于没有设置 parent 因此使用 bus-&gt;p-&gt;drivers_kset 做父节点，并在这里创建drv目录,</span></span><br><span class="line">    <span class="comment">// 从这里可以知道drv的根目录为 /sys/bus/drv-&gt;bus/drivers/</span></span><br><span class="line">    error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">                     <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_unregister;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将priv-&gt;knode_bus 链接进入priv-&gt;bus-&gt;p-&gt;klist_drivers</span></span><br><span class="line">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否可以自动probe,如果可以，则遍历klist_devices，对其中的每一个dev都调用drv-&gt;bus-&gt;match(dev, drv)函数</span></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123; </span><br><span class="line">        <span class="keyword">if</span> (driver_allows_async_probing(drv)) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: probing driver %s asynchronously\n&quot;</span>,</span><br><span class="line">                drv-&gt;bus-&gt;name, drv-&gt;name);</span><br><span class="line">            async_schedule(driver_attach_async, drv);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            error = driver_attach(drv);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">goto</span> out_unregister;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在drv所在目录创建属性文件 uevent</span></span><br><span class="line">    error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在drv所在目录创建属性文件 drv_groups</span></span><br><span class="line">    error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果支持 bind 则在 drv 所在目录创建属性文件 bind 和 unbind</span></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">        error = add_bind_files(drv);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">/* Ditto */</span></span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">                __func__, drv-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">    kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">    <span class="comment">/* drv-&gt;p is freed in driver_release()  */</span></span><br><span class="line">    drv-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">out_put_bus:</span><br><span class="line">    bus_put(bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、driver-register-总结"><a href="#3、driver-register-总结" class="headerlink" title="3、driver_register 总结"></a>3、driver_register 总结</h2><h3 id="1-在sys-创建对应节点"><a href="#1-在sys-创建对应节点" class="headerlink" title="1) 在sys/创建对应节点"></a>1) 在sys/创建对应节点</h3><p>bus_add_driver 会创建下面节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/bus/xxx/drivers/drv-&gt;name</span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/uevent</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 支持 suppress_bind_attrs */</span></span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/unbind</span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/bind</span><br></pre></td></tr></table></figure>
<h3 id="2-匹配-bus-总线上的设备"><a href="#2-匹配-bus-总线上的设备" class="headerlink" title="2) 匹配 bus 总线上的设备"></a>2) 匹配 bus 总线上的设备</h3><p>除了创建节点之外，如果可以自动probe,如果可以，则遍历klist_devices，对其中的每一个dev都调用drv-&gt;bus-&gt;match(dev, drv)函数，如果匹配成功则调用really_probe(drv),在这个函数中默认先调用函数 dev-&gt;bus-&gt;probe(dev)，如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用 drv-&gt;probe(dev),调用流程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bus_add_driver----&gt;</span><br><span class="line">	driver_attach----&gt; 无论如何最终都会调用这个函数</span><br><span class="line">		bus_for_each_dev----&gt;</span><br><span class="line">			__driver_attach----&gt;</span><br><span class="line">				driver_match_device----&gt;</span><br><span class="line">					drv-&gt;bus-&gt;match(dev, drv) <span class="comment">//如果匹配成功则调用 really_probe</span></span><br><span class="line">					really_probe----&gt;</span><br><span class="line">						dev-&gt;bus-&gt;probe(dev) <span class="comment">//默认点调用这个</span></span><br><span class="line">						drv-&gt;probe(dev) <span class="comment">//如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用这个</span></span><br></pre></td></tr></table></figure>
<h2 id="4、注册我们自己的驱动"><a href="#4、注册我们自己的驱动" class="headerlink" title="4、注册我们自己的驱动"></a>4、注册我们自己的驱动</h2><p>在我们创建的bus上注册我们自己的驱动</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_drv_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_drv_remove</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">my_drv</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_drv&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">    .probe = my_drv_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_drv_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    driver_register(&amp;my_drv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    driver_unregister(&amp;my_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_drv_init);</span><br><span class="line">module_exit(my_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># ls</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># insmod /cache/my</span></span><br><span class="line">my_bus.ko       my_device.ko    my_driver.ko</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># insmod /cache/my_driver.ko</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># ls</span></span><br><span class="line">my_drv</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># cd my_drv/</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers/my_drv <span class="comment"># ls</span></span><br><span class="line">bind uevent unbind</span><br></pre></td></tr></table></figure>
<h2 id="5、在driver目录下创建属性文件"><a href="#5、在driver目录下创建属性文件" class="headerlink" title="5、在driver目录下创建属性文件"></a>5、在driver目录下创建属性文件</h2><p>和前面的device下创建属性文件相同，这里只给接口不再赘述</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> driver_attribute &#123;</span><br><span class="line">    <span class="keyword">struct</span> attribute attr;</span><br><span class="line">    ssize_t (*show)(<span class="keyword">struct</span> device_driver *driver, <span class="built_in">char</span> *buf);</span><br><span class="line">    ssize_t (*store)(<span class="keyword">struct</span> device_driver *driver, const <span class="built_in">char</span> *buf,</span><br><span class="line">             size_t count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_WO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_WO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于在当前 driver 下创建属性文件</span></span><br><span class="line">extern <span class="built_in">int</span> __must_check driver<span class="constructor">_create_file(<span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">driver</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">driver_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除属性文件</span></span><br><span class="line">extern void driver<span class="constructor">_remove_file(<span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">driver</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">driver_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="四、class总线"><a href="#四、class总线" class="headerlink" title="四、class总线"></a>四、class总线</h1><p>用于管理同类的设备，常常被我们用来给上层开辟一个属性节点，多用于查看，修改对应的设备信息。</p>
<h2 id="1、数据结构-3"><a href="#1、数据结构-3" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *name; <span class="comment">//class名称，用来初始化 subsys_private-&gt;susbus.kobj</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span></span>       *owner;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_attribute</span></span>      *class_attrs;   	<span class="comment">//默然属性文件指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span></span>    **dev_groups; <span class="comment">//class管理设备的体现之一，默认的设备属性文件，当注册设备到该class上时，会自动在改设备下创建，即该class下的所有设备都会注册这个属性文件。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span>          *dev_kobj; <span class="comment">//表示class下的设备在/sys/dev下的哪个目录，现在有两个目录char和block，默认选择char。</span></span><br><span class="line"></span><br><span class="line">    int (*dev_uevent)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">kobj_uevent_env</span></span> *env);<span class="comment">//当class下的设备发生变化时，会调用class的uevent函数</span></span><br><span class="line">    <span class="built_in">char</span> *(*devnode)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, umode_t *mode);</span><br><span class="line"></span><br><span class="line">    void (*class_release)(<span class="class"><span class="keyword">struct</span> <span class="title">class</span></span> *class);</span><br><span class="line">    void (*dev_release)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    int (*suspend)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, pm_message_t state);</span><br><span class="line">    int (*resume)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*shutdown)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span></span> *ns_type;</span><br><span class="line">    <span class="keyword">const</span> void *(*namespace)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span></span> *pm;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span></span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-subsys-private-1"><a href="#2-subsys-private-1" class="headerlink" title="2) subsys_private"></a>2) subsys_private</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span>	 	  <span class="comment">// 该 class 在sysfs中的目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span>	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">// 保存上层的class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、函数接口"><a href="#2、函数接口" class="headerlink" title="2、函数接口"></a>2、函数接口</h2><h3 id="1-classes-init"><a href="#1-classes-init" class="headerlink" title="1) classes_init"></a>1) classes_init</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">classes_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    class_kset = kset_create_and_add(<span class="string">&quot;class&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//创建 /sys/class 节点</span></span><br><span class="line">    <span class="keyword">if</span> (!class_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2）class-create"><a href="#2）class-create" class="headerlink" title="2）class_create"></a>2）class_create</h2><p>用于在内核中创建一个 class</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> class_create(owner, name)       \</span></span><br><span class="line">(&#123;                      \</span><br><span class="line">    static <span class="keyword">struct</span> <span class="type">lock_class_key</span> __key; \</span><br><span class="line">    <span class="built_in">__class_create</span>(owner, name, &amp;__key);    \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">class</span> *<span class="built_in">__class_create</span>(struct module *owner, const char *name,</span><br><span class="line">                 struct lock_class_key *<span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">class</span> *<span class="keyword">cls</span>;</span><br><span class="line">    int retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态创建 class 结构</span></span><br><span class="line">    cls = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*cls), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">error</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cls</span>-&gt;name = name; <span class="comment">//初始化 name</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;owner = owner; <span class="comment">//初始化 owner</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;class_release = class_create_release; <span class="comment">//初始化 默认release函数</span></span><br><span class="line"></span><br><span class="line">    retval = <span class="built_in">__class_register</span>(cls, <span class="built_in">key</span>); <span class="comment">//注册class</span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">cls</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">error</span>:</span><br><span class="line">    <span class="built_in">kfree</span>(cls);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(retval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(__class_create);</span><br></pre></td></tr></table></figure>
<h3 id="2-class-register"><a href="#2-class-register" class="headerlink" title="2) __class_register"></a>2) __class_register</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">__class_register(<span class="params">struct</span> <span class="params">class</span> <span class="operator">*</span><span class="params">cls</span>, <span class="params">struct</span> <span class="params">lock_class_key</span> <span class="operator">*</span><span class="params">key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> subsys_private *cp;</span><br><span class="line">    <span class="built_in">int</span> error;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_debug(<span class="string">&quot;device class &#x27;%s&#x27;: registering\n&quot;</span>, <span class="params">cls</span>-&gt;<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="comment">//动态创建一个 subsys_private 结构</span></span><br><span class="line">    cp = kzalloc(sizeof(*cp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!cp)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    klist<span class="constructor">_init(&amp;<span class="params">cp</span>-&gt;<span class="params">klist_devices</span>, <span class="params">klist_class_dev_get</span>, <span class="params">klist_class_dev_put</span>)</span>;</span><br><span class="line">    <span class="constructor">INIT_LIST_HEAD(&amp;<span class="params">cp</span>-&gt;<span class="params">interfaces</span>)</span>;</span><br><span class="line">    kset<span class="constructor">_init(&amp;<span class="params">cp</span>-&gt;<span class="params">glue_dirs</span>)</span>;</span><br><span class="line">    <span class="constructor">__mutex_init(&amp;<span class="params">cp</span>-&gt;<span class="params">mutex</span>, <span class="string">&quot;subsys mutex&quot;</span>, <span class="params">key</span>)</span>;</span><br><span class="line">    error = kobject<span class="constructor">_set_name(&amp;<span class="params">cp</span>-&gt;<span class="params">subsys</span>.<span class="params">kobj</span>, <span class="string">&quot;%s&quot;</span>, <span class="params">cls</span>-&gt;<span class="params">name</span>)</span>; <span class="comment">//初始化 class 目录名</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(cp);</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the default /sys/dev directory for devices of this class */</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;dev_kobj)</span><br><span class="line">        cls-&gt;dev_kobj = sysfs_dev_char_kobj; <span class="comment">//设置子设备的默认类型为char</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_BLOCK)</span><br><span class="line">    <span class="comment">/* let the block class directory show up in the root of sysfs */</span></span><br><span class="line">    <span class="keyword">if</span> (!sysfs_deprecated<span class="operator"> || </span>cls != &amp;block_class)</span><br><span class="line">        cp-&gt;subsys.kobj.kset = class_kset;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    cp-&gt;subsys.kobj.kset = class_kset; <span class="comment">//设置kset为class_kset 即出现在 /sys/class/目录下 (一般是不会设置class的父kobj的，因此默认使用kset作为父kobj)</span></span><br><span class="line">#endif</span><br><span class="line">    cp-&gt;subsys.kobj.ktype = &amp;class_ktype; <span class="comment">//初始化class的默认ktype</span></span><br><span class="line">    cp-&gt;<span class="keyword">class</span> = cls; </span><br><span class="line">    cls-&gt;p = cp;</span><br><span class="line"></span><br><span class="line">    error = kset<span class="constructor">_register(&amp;<span class="params">cp</span>-&gt;<span class="params">subsys</span>)</span>; <span class="comment">//注册kset创建对应的class节点，/sys/class/xxx</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(cp);</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line">    error = add<span class="constructor">_class_attrs(<span class="params">class_get</span>(<span class="params">cls</span>)</span>); <span class="comment">//增加引用计数，创建默认属性文件</span></span><br><span class="line">    <span class="keyword">class</span><span class="constructor">_put(<span class="params">cls</span>)</span>;</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL_GPL(<span class="params">__class_register</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-device-create"><a href="#3-device-create" class="headerlink" title="3) device_create"></a>3) device_create</h3><p>在 class 下创建对应的设备，返回创建的设备结构。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">struct device *device_create(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">                 dev_t devt, void *drvdata, <span class="keyword">const</span> char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list vargs;</span><br><span class="line">    struct device *dev;</span><br><span class="line"></span><br><span class="line">    va_start(vargs, fmt);</span><br><span class="line">    dev = device_create_vargs(<span class="class"><span class="keyword">class</span>, <span class="type">parent</span>, <span class="type">devt</span>, <span class="type">drvdata</span>, <span class="type">fmt</span>, <span class="type">vargs);</span></span></span><br><span class="line">    va_end(vargs);</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create);</span><br><span class="line"></span><br><span class="line">struct device *device_create_vargs(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">                   dev_t devt, void *drvdata, <span class="keyword">const</span> char *fmt,</span><br><span class="line">                   va_list args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> device_create_groups_vargs(<span class="class"><span class="keyword">class</span>, <span class="type">parent</span>, <span class="type">devt</span>, <span class="type">drvdata</span>, <span class="type">NULL</span>,<span class="type"></span></span></span><br><span class="line">                      fmt, args);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create_vargs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct device *</span><br><span class="line">device_create_groups_vargs(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">               dev_t devt, void *drvdata,</span><br><span class="line">               <span class="keyword">const</span> struct attribute_group **groups,</span><br><span class="line">               <span class="keyword">const</span> char *fmt, va_list args)</span><br><span class="line">&#123;</span><br><span class="line">    struct device *dev = NULL;</span><br><span class="line">    int retval = -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">class</span> == <span class="title">NULL</span> || <span class="title">IS_ERR</span></span>(<span class="class"><span class="keyword">class</span>))</span></span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        goto error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    dev-&gt;devt = devt; <span class="comment">//设置设备号</span></span><br><span class="line">    dev-&gt;<span class="class"><span class="keyword">class</span> = <span class="title">class</span>; //设置设备所属的类</span></span><br><span class="line">    dev-&gt;parent = parent; <span class="comment">//设备的父节点</span></span><br><span class="line">    dev-&gt;groups = groups; <span class="comment">//设置设备的默认</span></span><br><span class="line">    dev-&gt;release = device_create_release;</span><br><span class="line">    dev_set_drvdata(dev, drvdata); <span class="comment">//设置设备的私有数据</span></span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    retval = device_add(dev); <span class="comment">//注册设备 </span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>device_add 函数在前面已经有很详细的分析，这里不赘述，不过这里再补充说明一点，device_create 会在 /dev/ 目录下创建设备节点是因为设备有设备号，只要是<strong>调用 device_add 注册的设备，只要有设备号就会在 /dev/ 下创建设备节点</strong>,如果忘记的可以搜一搜 devtmpfs_create_node 这个函数，文章前面有提到这个函数</p>
<h3 id="4-属性操作接口"><a href="#4-属性操作接口" class="headerlink" title="4) 属性操作接口"></a>4) 属性操作接口</h3><p>属性文件是 class 重点内容，我们多用 class 来给上层提供接口，属性文件创建接口如下。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速创建 class_attribute</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">CLASS_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line">#define <span class="constructor">CLASS_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">CLASS_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline <span class="built_in">int</span> __must_check <span class="keyword">class</span><span class="constructor">_create_file(<span class="params">struct</span> <span class="params">class</span> <span class="operator">*</span><span class="params">class</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">class_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="五、platform设备"><a href="#五、platform设备" class="headerlink" title="五、platform设备"></a>五、platform设备</h1><p>在计算机中有这样一类设备，它们通过各自的设备控制器，直接和CPU连接，CPU可以通过常规的寻址操作访问它们（或者说访问它们的控制器）。这种连接方式，并不属于传统意义上的总线连接。但设备模型应该具备普适性，因此Linux就虚构了一条Platform Bus，供这些设备挂靠。</p>
<h2 id="1、数据结构-4"><a href="#1、数据结构-4" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-platform-device"><a href="#1-platform-device" class="headerlink" title="1) platform_device"></a>1) platform_device</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *name; <span class="comment">//设备名称</span></span><br><span class="line">    <span class="keyword">int</span>     id;</span><br><span class="line">    <span class="keyword">bool</span>        id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   <span class="title">dev</span>;</span> <span class="comment">//真正的设备，嵌入在platform_device中</span></span><br><span class="line">    u32     num_resources; <span class="comment">//设备资源</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver_override; <span class="comment">/* 如果设置了这个名字，这用这个名字匹配驱动，它的优先级最高 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>    <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-platform-driver"><a href="#2-platform-driver" class="headerlink" title="2) platform_driver"></a>2) platform_driver</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span></span> &#123;</span><br><span class="line">    int (*probe)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    int (*remove)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    void (*shutdown)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    int (*suspend)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *, pm_message_t state);</span><br><span class="line">    int (*resume)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span></span> driver;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span></span> *id_table;</span><br><span class="line">    <span class="built_in">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-resource"><a href="#3-resource" class="headerlink" title="3) resource"></a>3) resource</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、platform总线的构建"><a href="#2、platform总线的构建" class="headerlink" title="2、platform总线的构建"></a>2、platform总线的构建</h2><p>platform总线是内核提供的虚拟总线，它个构建依赖于前面的，bus，device，driver设备模型。首先内核提供了一个名字叫”platform”的默认总线，它是一个全局结构并且被EXPORT_SYMBOL_GPL导出，如下</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">struct bus_type <span class="attr">platform_bus_type</span> = &#123;</span><br><span class="line">    .<span class="attr">name</span>       = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .<span class="attr">dev_groups</span> = platform_dev_groups,</span><br><span class="line">    .<span class="attr">match</span>      = platform_match,</span><br><span class="line">    .<span class="attr">uevent</span>     = platform_uevent,</span><br><span class="line">    .<span class="attr">pm</span>     = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus_type);</span><br></pre></td></tr></table></figure>
<p>除此之外内核也提供了该总线下的一个设备，名字叫做”platform_bus”</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> platform_bus = </span>&#123;</span><br><span class="line">    .init_name  = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus);</span><br></pre></td></tr></table></figure>
<p><font color=red>这是一个设备结构，并不是bus，虽然他的名字叫做 platform_bus</font>, 我也不知道为啥叫这个名字，第一次读我就以为这是个bus。它作为基本设备，在device_register函数中将使用devices_kset作为它的父目录(没有设置父kobj时自动使用devices_kset作为父节点)，内核将会创建如下节点</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>devices/platform</span><br></pre></td></tr></table></figure>
<p>platform_bus 的结构只初始化了一个名字，为什么要注册一个只有名字的设备在这里，我想是为了方便管理，将它作为以后platform设备的父设备，以后只要是platform设备，都将出现在/sys/devices/platform下，一眼就能找出那些事platform设备。<br>上述的 platform_bus_type 和 platform_bus 是在platform_bus_init 中被注册的，它被driver_init调用，即在内核启动的时候被创建。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __init platform_bus_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">error</span>;</span><br><span class="line"></span><br><span class="line">    early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">error</span> = device_register(&amp;platform_bus); <span class="comment">//创建platform总线</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">error</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">    <span class="keyword">error</span> =  bus_register(&amp;platform_bus_type); <span class="comment">//创建一个名为&quot;platform&quot;的设备</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">error</span>)</span><br><span class="line">        device_unregister(&amp;platform_bus);</span><br><span class="line">    of_platform_register_reconfig_notifier();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后但凡是注册在platform总线上的设备都叫做platform设备，注册在该总线上的驱动叫做platform驱动</p>
<h2 id="3、platform-设备接口"><a href="#3、platform-设备接口" class="headerlink" title="3、platform 设备接口"></a>3、platform 设备接口</h2><p>内核在开机时创建了platform总线，同时也提供了该总线相关操作函数</p>
<h3 id="1-platform-device-register"><a href="#1-platform-device-register" class="headerlink" title="1) platform_device_register"></a>1) platform_device_register</h3><p>使用这个函数注册一个platform设备</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> platform<span class="constructor">_device_register(<span class="params">struct</span> <span class="params">platform_device</span> <span class="operator">*</span><span class="params">pdev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line">#ifdef CONFIG_MTPROF</span><br><span class="line">    unsigned long long ts = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line">    <span class="constructor">TIME_LOG_START()</span>;</span><br><span class="line">	<span class="comment">//对pdev-&gt;dev做一些初始化</span></span><br><span class="line">    device<span class="constructor">_initialize(&amp;<span class="params">pdev</span>-&gt;<span class="params">dev</span>)</span>;</span><br><span class="line">	<span class="comment">// 空函数，啥也没干</span></span><br><span class="line">    arch<span class="constructor">_setup_pdev_archdata(<span class="params">pdev</span>)</span>;</span><br><span class="line">	<span class="comment">//真正的注册函数</span></span><br><span class="line">    ret = platform<span class="constructor">_device_add(<span class="params">pdev</span>)</span>;</span><br><span class="line">    <span class="constructor">TIME_LOG_END()</span>;</span><br><span class="line">    bootprof<span class="constructor">_pdev_register(<span class="params">ts</span>, <span class="params">pdev</span>)</span>;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的注册函数是 platform_device_add</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">int platform_device_add(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    int i, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pdev)</span><br><span class="line">        return -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!pdev-&gt;</span>dev.parent)</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>dev.parent = &amp;platform_bus; <span class="comment">//设置设备的父设备为platform_bus</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">pdev</span>-&gt;</span>dev.bus = &amp;platform_bus_type; <span class="comment">//设置bus为platform_bus_type</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">switch</span> (pdev-&gt;</span><span class="function"><span class="title">id</span>) &#123; 设置 pdev-&gt;</span><span class="function"><span class="title">dev</span>-&gt;</span>init_name </span><br><span class="line">    default:</span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s.%d&quot;, pdev-&gt;</span><span class="function"><span class="title">name</span>,  pdev-&gt;</span>id);</span><br><span class="line">        break;</span><br><span class="line">    case PLATFORM_DEVID_NONE:	<span class="comment">// -1</span></span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s&quot;, pdev-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        break;</span><br><span class="line">    case PLATFORM_DEVID_AUTO: 	<span class="comment">// -2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Automatically allocated device ID. We mark it as such so</span></span><br><span class="line"><span class="comment">         * that we remember it must be freed, and we append a suffix</span></span><br><span class="line"><span class="comment">         * to avoid namespace collision with explicit IDs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ret = ida_simple_get(&amp;platform_devid_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            goto err_out;</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id = ret;</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id_auto = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s.%d.auto&quot;, pdev-&gt;</span><span class="function"><span class="title">name</span>, pdev-&gt;</span>id);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span> (i = 0; i &lt; pdev-&gt;</span>num_resources; i++) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> resource *p, *r = &amp;pdev-&gt;</span>resource[i];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (r-&gt;</span><span class="keyword">name</span> == NULL)</span><br><span class="line">            <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">name</span> = dev_name(&amp;pdev-&gt;</span>dev);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">p</span> = r-&gt;</span>parent;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resource_type(r) == IORESOURCE_MEM)</span><br><span class="line">                p = &amp;iomem_resource;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (resource_type(r) == IORESOURCE_IO)</span><br><span class="line">                p = &amp;ioport_resource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &amp;&amp; insert_resource(p, r)) &#123;</span><br><span class="line">            <span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">&quot;failed to claim resource %d\n&quot;</span>, i);</span><br><span class="line">            ret = -EBUSY;</span><br><span class="line">            goto failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;Registering platform device &#x27;%s&#x27;. Parent at %s\n&quot;</span>,</span><br><span class="line">         <span class="function"><span class="title">dev_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>), dev_name(pdev-&gt;</span>dev.parent));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向内核注册这个设备</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = device_add(&amp;pdev-&gt;</span>dev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line"> failed:</span><br><span class="line">    <span class="function"><span class="title">if</span> (pdev-&gt;</span>id_auto) &#123;</span><br><span class="line">        <span class="function"><span class="title">ida_simple_remove</span>(&amp;platform_devid_ida, pdev-&gt;</span>id);</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id = PLATFORM_DEVID_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> resource *r = &amp;pdev-&gt;</span>resource[i];</span><br><span class="line">        <span class="function"><span class="title">if</span> (r-&gt;</span>parent)</span><br><span class="line">            release_resource(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> err_out:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数设置设备的父设备为platform_bus，以后凡是挂接在 platform 总线上的设备都将使用 platform_bus作为它的父设备。即所有的设备都将在下面目录生成</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>devices<span class="regexp">/platform/</span>xxx</span><br></pre></td></tr></table></figure>
<h3 id="2-platform-driver-register"><a href="#2-platform-driver-register" class="headerlink" title="2) platform_driver_register"></a>2) platform_driver_register</h3><p>同样内核也提供了platform驱动的注册函数</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line">    <span class="variable">__platform_driver_register</span>(drv, THIS_MODULE)</span><br><span class="line"></span><br><span class="line">int <span class="variable">__platform_driver_register</span>(struct platform_driver *drv,</span><br><span class="line">                struct module *<span class="built_in">owner</span>)</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.<span class="built_in">owner</span> = <span class="built_in">owner</span>;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.bus = &amp;platform_bus_type;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.probe = platform_drv_probe;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.remove = platform_drv_remove;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将驱动注册进总线</span></span><br><span class="line">    return driver_register(&amp;drv-&gt;<span class="built_in">driver</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(<span class="variable">__platform_driver_register</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出drv的，probe，rmove函数被分别初始化为platform_drv_probe，platform_drv_remove。最后调用driver_register将驱动注册进总线</p>
<p>对于platform设备的注册最后会调用，device_add，它最终会遍历platform_bus_type上所有的drv，并对每一个drv调用platform_match函数。</p>
<p>而对于platform_driver的注册会调用driver_register，它最终会遍历platform_bus_type上左右的dev，对每一个dev都调用platform_match函数。</p>
<p>像这种交叉遍历的方式在内核中很常见，input子系统中也使用这样的方式。也就是无论如何只要总线上有设备，驱动注册的时候就会去与之匹配，同理总线上有驱动，设备注册时就会去与之匹配。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> platform<span class="constructor">_match(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">drv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> platform_device *pdev = <span class="keyword">to</span><span class="constructor">_platform_device(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> platform_driver *pdrv = <span class="keyword">to</span><span class="constructor">_platform_driver(<span class="params">drv</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* when driver_override is set, only bind to the matching driver */</span></span><br><span class="line">	<span class="comment">/* 如果设置了driver_override，则匹配和driver_override相同名字的驱动 */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        return !strcmp(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attempt an of style match first，使用设备树方式匹配 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">of</span><span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then try acpi style match */</span></span><br><span class="line">	<span class="comment">/* 电源相关，跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi<span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then try to match against the id table */</span></span><br><span class="line">	<span class="comment">/* 如果设置了id_table, 则与id_table中的名字进行匹配 */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        return platform<span class="constructor">_match_id(<span class="params">pdrv</span>-&gt;<span class="params">id_table</span>, <span class="params">pdev</span>)</span> != null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">	<span class="comment">/* 比较驱动和设备的名称 */</span></span><br><span class="line">    return (strcmp(pdev-&gt;name, drv-&gt;name)<span class="operator"> == </span><span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个函数可以看出platform设备的匹配方式有 5 种，按照优先级如下：</p>
<ol>
<li>如果设置了driver_override，则匹配和driver_override相同名字的设备，它的优先级最高</li>
<li>使用设备树方式匹配，这是目前比较常用的方式之一</li>
<li>电源相关方式匹配</li>
<li>如果设置了id_table, 则与id_table中的名字进行匹配</li>
<li>最后比较驱动和设备的名称，也是比较常用的方式之一</li>
</ol>
<p>其中比较常用的是设备树和设备驱动名称进行匹配，下面详细分析一下设备树匹配流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">of_driver_match_device</span><span class="params">(struct device *dev, <span class="keyword">const</span> struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of_match_device(drv-&gt;of_match_table, dev) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> struct of_device_id *<span class="title">of_match_device</span><span class="params">(<span class="keyword">const</span> struct of_device_id *matches, <span class="keyword">const</span> struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!matches) || (!dev-&gt;of_node))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> of_match_node(matches, dev-&gt;of_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *__<span class="title">of_match_node</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">matches</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> <span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">best_match</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> score, best_score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!matches)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; matches-&gt;name[<span class="number">0</span>] || matches-&gt;type[<span class="number">0</span>] || matches-&gt;compatible[<span class="number">0</span>]; matches++) &#123;</span><br><span class="line">        score = __of_device_is_compatible(node, matches-&gt;compatible,</span><br><span class="line">                          matches-&gt;type, matches-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">            best_match = matches;</span><br><span class="line">            best_score = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __of_device_is_compatible(<span class="keyword">const</span> struct device_node *device,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *compat, <span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compatible match has highest priority */</span></span><br><span class="line">    <span class="keyword">if</span> (compat &amp;&amp; compat[<span class="number">0</span>]) &#123;</span><br><span class="line">        prop = __of_find_property(device, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>); <span class="comment">/* 查找 compatible 节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (cp = of_prop_next_string(prop, <span class="literal">NULL</span>); cp;</span><br><span class="line">			<span class="comment">//获取该节点的字符串</span></span><br><span class="line">             cp = of_prop_next_string(prop, cp), index++)  </span><br><span class="line">			&#123;</span><br><span class="line">			<span class="comment">//获得的字符串和compat进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (of_compat_cmp(cp, compat, <span class="built_in">strlen</span>(compat)) == <span class="number">0</span>) &#123;</span><br><span class="line">                score = INT_MAX/<span class="number">2</span> - (index &lt;&lt; <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!score)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Matching type is better than matching name */</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp;&amp; type[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!device-&gt;type || of_node_cmp(type, device-&gt;type))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        score += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Matching name is a bit better than not */</span></span><br><span class="line">    <span class="keyword">if</span> (name &amp;&amp; name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!device-&gt;name || of_node_cmp(name, device-&gt;name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        score++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看 of_device_id 这个结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    type[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    compatible[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们用到的是compatible作为匹配的对象，从结构看最对大支持的长度为128个字节。从上述代码可以看出匹配的过程就是匹配drv.id-&gt;compatible 和 dts中的compatible节点比较，hall的dts的节点如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hall: hall&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,hall-gpio-int&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在驱动中如下配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="comment">//创建一个 of_device_id 数组并初始化内部成员。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">hall_switch_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;mediatek,hall-gpio-int&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个platform_driver结构并对里面的driver结构进行初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">hall_driver</span> =</span> &#123;</span><br><span class="line">    .probe = hall_probe,</span><br><span class="line">    .suspend = hall_suspend,</span><br><span class="line">    .resume  = hall_resume,</span><br><span class="line">    .remove = ln4913_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">           .name = <span class="string">&quot;ln4913_Driver&quot;</span>,</span><br><span class="line">           .of_match_table = hall_switch_of_match,</span><br><span class="line">           &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出匹配其实是会遍历 hall_switch_of_match 数组中的compatible描述，也就是说一个驱动可以尝试匹配多个设备，直到匹配到为止。由前面的分析可知一旦匹配成功，就会调用really_probe函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---&gt; really_probe</span><br><span class="line">     ---&gt; dev-&gt;bus-&gt;probe(dev) <span class="comment">//默认点调用这个，明显platform_bus_type，没有设置prob函数</span></span><br><span class="line">     ---&gt; drv-&gt;probe(dev) <span class="comment">//如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用这函数，platform 驱动在注册的时候呢，将其初始化为platform_drv_probe                                                                                                 </span></span><br></pre></td></tr></table></figure>
<p>来看看platform总线提供的probe函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_drv_probe</span><span class="params">(struct device *_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">drv</span> =</span> to_platform_driver(_dev-&gt;driver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span> =</span> to_platform_device(_dev);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = of_clk_set_defaults(_dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = dev_pm_domain_attach(_dev, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != -EPROBE_DEFER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">            ret = drv-&gt;probe(dev); <span class="comment">//最后调用platform_driver结构中的probe函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                dev_pm_domain_detach(_dev, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* don&#x27;t fail if just dev_pm_domain_attach failed */</span></span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;prevent_deferred_probe &amp;&amp; ret == -EPROBE_DEFER) &#123;</span><br><span class="line">        dev_warn(_dev, <span class="string">&quot;probe deferral not supported\n&quot;</span>);</span><br><span class="line">        ret = -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实最终调用了platform_driver结构中的probe函数。</p>
<p>除此之外匹配id也是常用的方式，匹配代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct platform_device_id *<span class="title">platform_match_id</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct platform_device_id *id,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, id-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">            pdev-&gt;id_entry = id;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、创建自己的platform设备"><a href="#4、创建自己的platform设备" class="headerlink" title="4、创建自己的platform设备"></a>4、创建自己的platform设备</h2><h3 id="1-用名字进行匹配"><a href="#1-用名字进行匹配" class="headerlink" title="1) 用名字进行匹配"></a>1) 用名字进行匹配</h3><p><strong>注册platform_device</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span>  <span class="title">my_platform_dev</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_platform&quot;</span>, <span class="comment">//名字要和驱动的名字一样</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_device_register(&amp;my_platform_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_device_register(&amp;my_platform_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_dev_init);</span><br><span class="line">module_exit(my_platform_dev_exit);</span><br></pre></td></tr></table></figure>
<p><strong>注册platform_driver</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;my_platform&quot;</span>, <span class="comment">//名字要和device一样</span></span><br><span class="line">              &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_drv_init);</span><br><span class="line">module_exit(my_platform_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">tb8768p1_64_bsp:</span>/cache <span class="meta"># insmod my_platform_drive.ko</span></span><br><span class="line"><span class="symbol">tb8768p1_64_bsp:</span>/cache <span class="meta"># insmod my_platform_device.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核打出my_platform_probe说明匹配成功</span></span><br><span class="line">[ <span class="number">2111.422598</span>] <span class="params">&lt;<span class="number">6</span>&gt;</span>.(<span class="number">5</span>)[<span class="number">3265</span>:insmod]my_platform_probe</span><br></pre></td></tr></table></figure>
<h3 id="2-用设备树方式匹配"><a href="#2-用设备树方式匹配" class="headerlink" title="2) 用设备树方式匹配"></a>2) 用设备树方式匹配</h3><p>dts增加配置</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">my_platform_dts:</span> <span class="class">my_platform_dts </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,my_platform&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注册platform_driver</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_platform_match</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;mediatek,my_platform&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;my_platform&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">                .of_match_table = my_platform_match,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">              &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_drv_init);</span><br><span class="line">module_exit(my_platform_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">XF-X2:/cache <span class="comment"># insmod my_platform_drive.ko </span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>加载模块时内核打印出probe</span><br><span class="line">[ <span class="number">1018.455974</span>] &lt;<span class="number">4</span>&gt;.(<span class="number">7</span>)[<span class="number">3165</span>:insmod]my_platform_probe</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong><font color=red>由于作者水平有限，因此不能保证文章内容准确无误。如果你发现了文中的错误(哪怕是错别字也好)，请在评论区指出，任何提高文章质量的建议我都将虚心接纳，thanks</strong></font></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动-基础知识</title>
    <url>/2020/11/23/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp; 用于记录 linux 驱动相关的基础知识，着重与用法于接口，类似于手册，方便快速查阅相关函数。</p>
<a id="more"></a>

<h1 id="一、同步与互斥"><a href="#一、同步与互斥" class="headerlink" title="一、同步与互斥"></a>一、同步与互斥</h1><ul>
<li><p><font color=red>互斥：</font>指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是<strong>无序</strong>的。</p>
</li>
<li><p><font color=red>同步：</font>指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的<strong>有序</strong>访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
</li>
</ul>
<p>参考<a href="https://mp.weixin.qq.com/s?__biz=MzAxNTAyOTczMw==&mid=2649332930&idx=1&sn=cf6b11d2d344e1f192d07d5f5467bccb&chksm=83977848b4e0f15e0650ec8e39593a755d19f4e4f32b8a25e2a2de7ecb0a641bba98019f7e98&scene=126&sessionid=1594705404&key=fa39e04f3e1bcf44088e1716b6d43d3a03b055518147584373ba2c95ca0956ad080126390dacea464cf8ffc82257ffe2d3bf3ebcb9405b6446a978c602cb657a4da2cd6b3cbf401b3a61731f333a9093&ascene=1&uin=NjY2NDMyNjc3&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=Ac2AMR9MZ4QTTczcCBTu2/E=&pass_ticket=zyBtnDr5s7LlelcQOyYHgtbncGCTFppo47/yH8Kh7rf/WiwN/09CMEDyCfHkbEIF">【干货】同步与互斥的失败例子</a></p>
<h2 id="1、原子变量"><a href="#1、原子变量" class="headerlink" title="1、原子变量"></a>1、原子变量</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1) 基本概念"></a>1) 基本概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 原子操作的基本单位，原子操作指的是由多步操作组成的一个操作。如果操作不能原子地执行，则要么执行完所有的步骤，要么一步也不执行，不可能执行所有步骤的一个子集。简单来说<font color=red>原子操作就是不能打断的操作，要么完整执行要么不执行</font>。</p>
<p>内核定义的原子变量结构如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel<span class="number">-4.4</span>/include/linux/types.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-整型原子操作"><a href="#2-整型原子操作" class="headerlink" title="2) 整型原子操作"></a>2) 整型原子操作</h3><h4 id="1-设置原子变量"><a href="#1-设置原子变量" class="headerlink" title="1. 设置原子变量"></a>1. 设置原子变量</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>atomic_t v = ATOMIC_INIT(0)</td>
<td>定义原子变量并初始化v为0</td>
</tr>
<tr>
<td>void atomic_set(atomic_t* v,int i)</td>
<td>设置原子变量的值为i</td>
</tr>
</tbody></table>
<h4 id="2-获取原子变量的值"><a href="#2-获取原子变量的值" class="headerlink" title="2. 获取原子变量的值"></a>2. 获取原子变量的值</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>atomic_read(atomic_t* v)</td>
<td>返回原子变量的值</td>
</tr>
</tbody></table>
<h4 id="3-原子变量加-减"><a href="#3-原子变量加-减" class="headerlink" title="3. 原子变量加/减"></a>3. 原子变量加/减</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void atomic_add(int i, atomic_t* v)</td>
<td>原子变量增加i</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t* v)</td>
<td>原子变量减少i</td>
</tr>
</tbody></table>
<h4 id="4-原子变量自增-自减"><a href="#4-原子变量自增-自减" class="headerlink" title="4. 原子变量自增/自减"></a>4. 原子变量自增/自减</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void atomic_inc(atomic_t* v)</td>
<td>原子变量自增1</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t* v)</td>
<td>源自变量自减1</td>
</tr>
</tbody></table>
<h4 id="5-操作并测试"><a href="#5-操作并测试" class="headerlink" title="5. 操作并测试"></a>5. 操作并测试</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>int atomic_inc_and_test(atomic_t* v)</td>
<td>原子变量自增1，并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t* v)</td>
<td>原子变量自减1，并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t* v)</td>
<td>原子变量减少i， 并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
</tbody></table>
<h4 id="6-操作并返回"><a href="#6-操作并返回" class="headerlink" title="6. 操作并返回"></a>6. 操作并返回</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>int atomic_add_return(int i, atomic_t* v)</td>
<td>原子变量的值增加i，并返回新的值</td>
</tr>
<tr>
<td>int atomic_sub_return(int i, atomic_t* v)</td>
<td>原子变量的值减少i，并返回新的值</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t* v)</td>
<td>原子变量的值自增1，并返回新的值</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t* v)</td>
<td>原子变量的值自减1，并返回新的值</td>
</tr>
</tbody></table>
<h3 id="3-位原子操作"><a href="#3-位原子操作" class="headerlink" title="3) 位原子操作"></a>3) 位原子操作</h3><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(nr,void* addr);</td>
<td>设置addr地址的第nr位，即将nr位置1</td>
</tr>
<tr>
<td>void clear_bit(nr, void* addr);</td>
<td>清除addr地址的nr位，即将nr位清0</td>
</tr>
<tr>
<td>void chang_bit(nr, void* addr);</td>
<td>将addr的nr为反置</td>
</tr>
<tr>
<td>test_bit(nr, void* addr);</td>
<td>返回addr的第nr位</td>
</tr>
<tr>
<td>int test_and_set_bit(nt, void* addr);</td>
<td>测试addr的nr位，再设置为1</td>
</tr>
<tr>
<td>int test_and_clear_bit(nr, void* addr);</td>
<td>测试addr的nr位，再清为0</td>
</tr>
<tr>
<td>int test_and_chang_bit(nr, void* addr);</td>
<td>测试addr的nr位，再反置nr位</td>
</tr>
</tbody></table>
<h2 id="2、信号量"><a href="#2、信号量" class="headerlink" title="2、信号量"></a>2、信号量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一个信号量本质上是一个整数值，它和一对函数联合使用，这对函数通常称为P和V。希望进入临界区的进程将在相关信号量上调用P;如果信号量的值大于0,则该值会减1，而进程可以继续。相反，如果信号量的值为0(或者更小)，进程进入休眠并等待直到其他人释放该信号量。对信号量的解锁通过调用V来完成；该函数增加信号量的值，并在必要时唤醒等待的进程。当我们需要将信号量用于互斥时，只需将信号量的值设为1。这样的信号量在任何给定时刻只能由单个线程拥有。内核定义的信号量如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include/linux/semaphore.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>只有得到信号量的进程才能执行临界区的代码，当得不到信号量时，进程会进入休眠等待状态。并将当前进程放入对应的链表中。当有信号量被释放时遍历这个链表，唤醒被休眠的进程继续执行</li>
</ul>
</blockquote>
<h3 id="1-操作信号量的接口"><a href="#1-操作信号量的接口" class="headerlink" title="1) 操作信号量的接口"></a>1) 操作信号量的接口</h3><h4 id="1-初始化信号量"><a href="#1-初始化信号量" class="headerlink" title="1. 初始化信号量"></a>1. 初始化信号量</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECLARE_MUTEX(name);</td>
<td>将信号量name初始化为1</td>
</tr>
<tr>
<td>DECLARE_MUTEX_LOCKED(name);</td>
<td>将信号量name初始化为0</td>
</tr>
<tr>
<td>void init_MUTEX(struct semaphore *sem)</td>
<td>将信号量sem初始化为1</td>
</tr>
<tr>
<td>void init_NUTEX_LOCKED(struct semaphore *sem);</td>
<td>将信号量sem初始化为0</td>
</tr>
<tr>
<td>void sema_init(struct semaphore* sem, int val);</td>
<td>初始化信号量的值为 val</td>
</tr>
</tbody></table>
<h4 id="2-获取信号量的值"><a href="#2-获取信号量的值" class="headerlink" title="2. 获取信号量的值"></a>2. 获取信号量的值</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void&nbsp;down(struct&nbsp;semaphore&nbsp;*sem);</td>
<td>递减信号量的值，并在必要时一直等待</td>
</tr>
<tr>
<td>int&nbsp;down_interruptible(struct&nbsp;semaphore&nbsp;*sem);</td>
<td>递减信号量的值，并在必要时一直等待，但是操作是可以中断的，它允许一个在等待的信号量的用户空间进程被用户中断。如果在操作中被中断，函数会返回一个非零值，并且调用者不持有信号量，真确的使用它需要一直检查返回值并针对性地响应。</td>
</tr>
<tr>
<td>int&nbsp;down_trylock(struct&nbsp;seamphore*&nbsp;sem);</td>
<td>永远不会休眠，如果信号量在调用时不可获得，它会返回一个非零值</td>
</tr>
</tbody></table>
<ul>
<li>当一个线程成功调用上面的”down”函数之后，该线程就拥有了该信号量。该线程就被赋予了自由访问该信号量保护临界区的权限。当互斥操作完之后必须返回该信号量。</li>
</ul>
<h4 id="3-释放信号量的值"><a href="#3-释放信号量的值" class="headerlink" title="3. 释放信号量的值"></a>3. 释放信号量的值</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void up(struct semaphore *sem);</td>
<td>增加信号量的值并且调用者不在拥有该信号量</td>
</tr>
</tbody></table>
<ul>
<li>任何拿到信号量的线程都必须通过一次对up的调用而释放该信号量。在出现错误的情况下，经常需要特别小心。如果在拥有一个信号量时发生错误，必须将错误状态返回给调用者之前释放该信号量。忘记释放信号量将导致进程在某些无关的位置被意外挂起，很难复现和跟踪</li>
</ul>
<h2 id="3、自旋锁"><a href="#3、自旋锁" class="headerlink" title="3、自旋锁"></a>3、自旋锁</h2><p>自旋锁是一种死等的锁机制，不会进入睡眠，进程会一直等待，直到获到锁为止,内核提供的数据结构如下.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-自旋锁操作接口"><a href="#1-自旋锁操作接口" class="headerlink" title="1) 自旋锁操作接口"></a>1) 自旋锁操作接口</h3><h4 id="1-初始化自旋锁"><a href="#1-初始化自旋锁" class="headerlink" title="1. 初始化自旋锁"></a>1. 初始化自旋锁</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>spin_lock_init(&amp;lock);</td>
<td>初始化自旋锁 lock</td>
</tr>
</tbody></table>
<h4 id="2-获取自旋锁"><a href="#2-获取自旋锁" class="headerlink" title="2. 获取自旋锁"></a>2. 获取自旋锁</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>spin_lock(&amp;lock);</td>
<td>如果能够获得自旋锁则立刻返回，否则将在那里自旋，直到该自旋锁的持有者释放。</td>
</tr>
<tr>
<td>spin_try_lock(&amp;lock);</td>
<td>尝试获得自旋锁，如果能立刻获得锁返回true，否则立刻返回false，实际不再原地打转。</td>
</tr>
</tbody></table>
<h4 id="3-释放自旋锁"><a href="#3-释放自旋锁" class="headerlink" title="3. 释放自旋锁"></a>3. 释放自旋锁</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>spin_unlock(&amp;lock);</td>
<td>释放自旋锁 lock</td>
</tr>
</tbody></table>
<h2 id="4、互斥锁"><a href="#4、互斥锁" class="headerlink" title="4、互斥锁"></a>4、互斥锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;互斥锁主要用于实现内核中的互斥访问功能。的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>       owner;</span><br><span class="line">    <span class="keyword">spinlock_t</span>      wait_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="keyword">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>同一时刻只有一个线程可以持有mutex</li>
<li>只有锁持有者可以解锁。不能再一个进程中持有mutex，在另外一个进程中释放</li>
<li>不允许递归地加锁和解锁</li>
<li>当进程持有mutex时，进程不可以退出</li>
<li>mutex必须使用官方API来初始化</li>
<li>mutex可以睡眠，所以不允许在中断处理程序或者中断下半部中使用，例如tasklet、定时器等</li>
</ul>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/215308082">手把手教Linux驱动7-内核互斥锁</a></p>
<h3 id="1-互斥锁接口"><a href="#1-互斥锁接口" class="headerlink" title="1) 互斥锁接口"></a>1) 互斥锁接口</h3><h4 id="1-初始化互斥锁"><a href="#1-初始化互斥锁" class="headerlink" title="1.初始化互斥锁"></a>1.初始化互斥锁</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name);</td>
<td>静态创建化互斥锁 name</td>
</tr>
<tr>
<td>mutex_init(&amp;mutex);</td>
<td>动态初始化互斥锁 mutex</td>
</tr>
</tbody></table>
<h4 id="2-获取互斥锁"><a href="#2-获取互斥锁" class="headerlink" title="2. 获取互斥锁"></a>2. 获取互斥锁</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>mutex_lock(lock)；</td>
<td>获取互斥锁，获取不到则进入睡眠</td>
</tr>
<tr>
<td>mutex_trylock(lock)；</td>
<td>尝试获取互斥锁，成功返回1，    失败返回0</td>
</tr>
</tbody></table>
<h4 id="3-释放互斥锁"><a href="#3-释放互斥锁" class="headerlink" title="3. 释放互斥锁"></a>3. 释放互斥锁</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>mutex_unlock(lock)；</td>
<td>释放互斥锁</td>
</tr>
</tbody></table>
<h4 id="4-获取锁状态"><a href="#4-获取锁状态" class="headerlink" title="4. 获取锁状态"></a>4. 获取锁状态</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>mutex_is_lock(lock)；</td>
<td>如果锁已被使用返回1，否则返回0</td>
</tr>
</tbody></table>
<h1 id="二、linux-队列"><a href="#二、linux-队列" class="headerlink" title="二、linux 队列"></a>二、linux 队列</h1><h2 id="1、等待队列"><a href="#1、等待队列" class="headerlink" title="1、等待队列"></a>1、等待队列</h2><p>等待队列从功能上可以简单理解为：让进程进入睡眠，在你想让他工作的时候唤醒。它有两部分组成首先是挂接我们等待队列项的等待头，等待队列头的数据结构描述如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock; <span class="comment">// 在对task_list与操作的过程中，使用该锁实现对等待队列的互斥访问。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">task_list</span>;</span> <span class="comment">// 链接等待队列项 wait_queue_t</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>而挂接在其上面的等待队列项的数据局结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">default_wake_function</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* __wait_queue::flags */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE   0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_WOKEN       0x02</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        flags;</span><br><span class="line">    <span class="keyword">void</span>            *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">wait_queue_func_t</span>   func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-等待队列接口"><a href="#1-等待队列接口" class="headerlink" title="1) 等待队列接口"></a>1) 等待队列接口</h3><h4 id="1-创建与初始化"><a href="#1-创建与初始化" class="headerlink" title="1. 创建与初始化"></a>1. 创建与初始化</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECLARE_WAIT_QUEUE_HEAD(name)</td>
<td>声明等待队列头 name</td>
</tr>
<tr>
<td>init_waitqueue_head(name)</td>
<td>初始化等待队列头 name</td>
</tr>
<tr>
<td>DECLARE_WAITQUEUE(name, tsk)</td>
<td>定义等待队列成员 name</td>
</tr>
</tbody></table>
<h4 id="2-添加移除等待队列"><a href="#2-添加移除等待队列" class="headerlink" title="2. 添加移除等待队列"></a>2. 添加移除等待队列</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);</td>
<td>将等待队列成员 wait，添加进入等待队列头 q</td>
</tr>
<tr>
<td>void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);</td>
<td>从等待队列头移除等待队列成员 wait</td>
</tr>
</tbody></table>
<h4 id="3-进程休眠"><a href="#3-进程休眠" class="headerlink" title="3. 进程休眠"></a>3. 进程休眠</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>wait_event(wq,&nbsp;condition)</td>
<td>如果condition为0，则进程休眠，且休眠状态不能被中断打断</td>
</tr>
<tr>
<td>wait_event_timeout(wq,&nbsp;condition,&nbsp;timeout)</td>
<td>如果condition为0，则进入休眠，当 timeout 到了则唤醒进程不管此时condition为真为假都会返回</td>
</tr>
<tr>
<td>wait_event_interruptible(wq,&nbsp;condition)</td>
<td>如果condition为0，则进程休眠，休眠状态可以被中断打断，当休眠被中断打断时返回0，这时驱动应返回 -ERESTARTSYS</td>
</tr>
<tr>
<td>wait_event_interruptible_timeout(wq,&nbsp;condition,&nbsp;timeout)</td>
<td>如果condition为0，则进程休眠，休眠状态可以被中断打断，当休眠被中断打断时返回0，这时驱动应返回 -ERESTARTSY，当 timeout 到了则唤醒进程不管此时condition为真为假都会返回</td>
</tr>
</tbody></table>
<h4 id="4-唤醒进程"><a href="#4-唤醒进程" class="headerlink" title="4. 唤醒进程"></a>4. 唤醒进程</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void&nbsp;wake_up(wait_queue_head_t&nbsp;*q);</td>
<td>唤醒等待队列 q 上的进程，如果 condition 为真则返回</td>
</tr>
<tr>
<td>void&nbsp;wake_up_interruptible(wait_queue_head_t&nbsp;*q);</td>
<td>唤醒等待队列 q 上的进程，如果 condition 为真则返回</td>
</tr>
</tbody></table>
<h2 id="2、工作队列"><a href="#2、工作队列" class="headerlink" title="2、工作队列"></a>2、工作队列</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;工作队列（work queue）是一种将工作推后执行的形式，它和tasklet有所不同。工作队列可以把工作推后，交由一个内核线程去执行，也就是说，这个下半部分可以在进程上下文中执行。这样，通过工作队列执行的代码能占尽进程上下文的所有优势。最重要的就是工作队列允许被重新调度甚至是睡眠。它的数据结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://blog.csdn.net/bullbat/article/details/7410563">Linux内核实践之工作队列</a></p>
<h3 id="3-操作函数"><a href="#3-操作函数" class="headerlink" title="3) 操作函数"></a>3) 操作函数</h3><h4 id="1-初始化工作队列"><a href="#1-初始化工作队列" class="headerlink" title="1. 初始化工作队列"></a>1. 初始化工作队列</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>INIT_WORK(work,func)</td>
<td>初始化工作队列项 work，并设置回调函数func</td>
</tr>
<tr>
<td>DECLARE_WORK(name,func)</td>
<td>声明一个等待队列项 name，并设置回调函数func</td>
</tr>
</tbody></table>
<h4 id="2-调度工作队列"><a href="#2-调度工作队列" class="headerlink" title="2. 调度工作队列"></a>2. 调度工作队列</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>schedule_work(&amp;work)</td>
<td>调度工作队列</td>
</tr>
<tr>
<td>schedule_delayed_work(&amp;work,tick)</td>
<td>延时tick个滴答应答之后调度工作队列</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>pinctrl 子系统</title>
    <url>/2021/04/01/linux%E9%A9%B1%E5%8A%A8pinctrl/</url>
    <content><![CDATA[<p>分析总结pinctrl子系统框架结构，平台 mtk8788 内核版本 kernel-4.4 , 本文所有的分析均基于此版本。</p>
<a id="more"></a>

<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>&nbsp;&nbsp;&nbsp;&nbsp; pinctrl 子系统，我们也可以将其称为引脚控制子系统(pin control subsystem)，和设备模型一样是基本系统之一。 对于一块 soc 的 cpu 上有很多引脚，驱动工程师要做的使其处于我们需要的状态，例如配置某个引脚为 gpio 或者 配置其为 i2c。对于不同的 cpu 其寄存器的地址往往是不一样的，比如 S3C2440 的 gpio 控制器的基地址为 0x53000000，而 mtk 的 gpio 地址为 0x10005000，而且寄存器的地址的位也表示不同的含义，而内核为了兼容不同的芯片于是创建出 pinctrl 子系统，该系统用于<font color=red>将板级信息从内核分离出来</font>，对于真正的寄存器的操作，由 soc 厂家来完成(bsp工程师)，而对于内核来讲将 pin 的功能抽象出来提供统一的接口给驱动工程师使用。</p>
<blockquote>
<p>小贴士：注意区分引脚(pin)和 gpio 的区别，引脚可以复用为gpio，也可以复用为i2c。或者引脚本身就是 gpio , 这由硬件设计决定。</p>
</blockquote>
<h2 id="1、pin"><a href="#1、pin" class="headerlink" title="1、pin"></a>1、pin</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; soc上有大量引脚，每一个引脚使用 pinctrl_pin_desc 来描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核中用其描述 pin 的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> number;  <span class="comment">// pin 引脚号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 此引脚的名称，将用来初始化 pin_desc 的 name，如果为空将使用 PIN + number 例如：PIN0</span></span><br><span class="line">    <span class="keyword">void</span> *drv_data;   <span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例： 当我们的板子上的pin信息如下时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     A   B   C   D   E   F   G   H</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>    o   o   o   o   o   o   o   o</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>    o   o   o   o   o   o   o   o</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>    o   o   o   o   o   o   o   o</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>    o   o   o   o   o   o   o   o</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>    o   o   o   o   o   o   o   o</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>    o   o   o   o   o   o   o   o</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>    o   o   o   o   o   o   o   o</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>    o   o   o   o   o   o   o   o</span><br></pre></td></tr></table></figure>
<p>我们使用下面信息描述这块板子的一组引脚</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">const <span class="keyword">struct</span> pinctrl_pin_desc foo_pins<span class="literal">[]</span> = &#123;</span><br><span class="line">      <span class="constructor">PINCTRL_PIN(0, <span class="string">&quot;A8&quot;</span>)</span>, <span class="comment">//第 0 个引脚</span></span><br><span class="line">      <span class="constructor">PINCTRL_PIN(1, <span class="string">&quot;B8&quot;</span>)</span>,</span><br><span class="line">      <span class="constructor">PINCTRL_PIN(2, <span class="string">&quot;C8&quot;</span>)</span>,</span><br><span class="line">      ...</span><br><span class="line">      <span class="constructor">PINCTRL_PIN(61, <span class="string">&quot;F1&quot;</span>)</span>,</span><br><span class="line">      <span class="constructor">PINCTRL_PIN(62, <span class="string">&quot;G1&quot;</span>)</span>,</span><br><span class="line">      <span class="constructor">PINCTRL_PIN(63, <span class="string">&quot;H1&quot;</span>)</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体怎么描述由具体的bsp工程师来决定</p>
<h2 id="2、pin-group"><a href="#2、pin-group" class="headerlink" title="2、pin group"></a>2、pin group</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于引脚的使用，有时候一次性会使用到多个引脚，I2C接口会同时使用2个引脚，SPI接口会同时使用4个引脚。需要以 group 为单位，访问控制多个 pin，这就是 pin groups，pinctrl 子系统提供了获取 pin group 信息的接口</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pinctrl_ops &#123;</span><br><span class="line">    <span class="comment">// 获取 pin group 的数量</span></span><br><span class="line">    <span class="keyword">int</span> (*get_groups_count) (<span class="keyword">struct</span> pinctrl_dev *pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取使用 selector 作为数组下标指定 group 的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*get_group_name) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 selector 作为数组下标返回指定 group 所用到的 pins 以及 pin 的数量 num_pins</span></span><br><span class="line">    <span class="keyword">int</span> (*get_group_pins) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">const</span> <span class="keyword">unsigned</span> **pins, <span class="keyword">unsigned</span> *num_pins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug相关</span></span><br><span class="line">    <span class="keyword">void</span> (*pin_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="keyword">struct</span> seq_file *s, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于将设备树中的引脚配置转换为对应的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">int</span> (*dt_node_to_map) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="keyword">struct</span> device_node *np_config, <span class="keyword">struct</span> pinctrl_map **map, <span class="keyword">unsigned</span> *num_maps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于释放前面创建的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">void</span> (*dt_free_map) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="keyword">struct</span> pinctrl_map *map, <span class="keyword">unsigned</span> num_maps);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是该接口除了能够获取 pin group 信息之外,还有一个非常重要的回调接口 dt_node_to_map ，用于<font color=red>将设备树中的引脚配置转换为对应的 pinctrl_map</font>。 该接口的实现通常由soc原厂实现。举个栗子，假设我们有一组用于{0，8，16，24}上的SPI接口的引脚，以及一组用于{24，25}上的I2C接口的引脚。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo_group</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *pins;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> num_pins;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> spi0_pins[] = &#123; <span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i2c0_pins[] = &#123; <span class="number">24</span>, <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo_group</span> <span class="title">foo_groups</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;spi0_grp&quot;</span>,</span><br><span class="line">        .pins = spi0_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(spi0_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;i2c0_grp&quot;</span>,</span><br><span class="line">        .pins = i2c0_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(i2c0_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_get_groups_count</span><span class="params">(struct pinctrl_dev *pctldev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ARRAY_SIZE(foo_groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">foo_get_group_name</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> selector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo_groups[selector].name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_get_group_pins</span><span class="params">(struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> **pins,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> *num_pins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *pins = (<span class="keyword">unsigned</span> *) foo_groups[selector].pins;</span><br><span class="line">    *num_pins = foo_groups[selector].num_pins;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> <span class="title">foo_pctrl_ops</span> =</span> &#123;</span><br><span class="line">    .get_groups_count = foo_get_groups_count, <span class="comment">//用于返回 group 的数量</span></span><br><span class="line">    .get_group_name = foo_get_group_name,     <span class="comment">//返回 group 的 name</span></span><br><span class="line">    .get_group_pins = foo_get_group_pins,     <span class="comment">//返回 group 使用到的 pin</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> <span class="title">foo_desc</span> =</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       .pctlops = &amp;foo_pctrl_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3、pinconfig"><a href="#3、pinconfig" class="headerlink" title="3、pinconfig"></a>3、pinconfig</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于每一个引脚都有其特定的电器特性，如上拉、下拉、三态、强推挽输出等用 pinconfig 来描述，pinctrl子系统同样也给出了电器特性的操作函数回调接口。对于电器特性的操作既可以操作一个引脚，也可以操作一组引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">    <span class="keyword">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//获取一个引脚的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_get) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> pin, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个引脚的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_set) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> pin, <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取一个 group 描述的 pin 的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_group_get) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个 group 描述的 pin 的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_group_set) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面这写接口基本用不着，debug相关接口</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_dbg_parse_modify) (struct pinctrl_dev *pctldev, <span class="keyword">const</span> <span class="keyword">char</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_group_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> selector);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_config_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> config);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样的举个栗子</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_pin_config_get</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="built_in">config</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_conftype</span> <span class="title">conf</span>;</span></span><br><span class="line"></span><br><span class="line">    ... Find setting <span class="keyword">for</span> pin @ offset ...</span><br><span class="line"></span><br><span class="line">    *<span class="built_in">config</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) conf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_pin_config_set</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">config</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_conftype</span> *<span class="title">conf</span> =</span> (struct my_conftype *) <span class="built_in">config</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (conf) &#123;</span><br><span class="line">        <span class="keyword">case</span> PLATFORM_X_PULL_UP:</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_pin_config_group_get</span> <span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> selector,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="built_in">config</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_pin_config_group_set</span> <span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> selector,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">config</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> <span class="title">foo_pconf_ops</span> =</span> &#123;</span><br><span class="line">    .pin_config_get = foo_pin_config_get,</span><br><span class="line">    .pin_config_set = foo_pin_config_set,</span><br><span class="line">    .pin_config_group_get = foo_pin_config_group_get,</span><br><span class="line">    .pin_config_group_set = foo_pin_config_group_set,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> <span class="title">foo_desc</span> =</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    .confops = &amp;foo_pconf_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4、引脚复用-pinmux"><a href="#4、引脚复用-pinmux" class="headerlink" title="4、引脚复用(pinmux)"></a>4、引脚复用(pinmux)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;引脚复用这个概念就不做解释了，需要注意的是引脚复用和引脚的电器特性(pinconfig)并不是相同的概念, pinctrl子系统中引脚的复用类型用 <font color=red>func</font> 来描述，例如，某 pin 可以复用为 i2c 也可复用为 spi，那么这个引脚则拥有两个 func。 pinctrl子系统也提供了对应的接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查某个 pin 是否已作它用，用于管脚复用时的互斥（避免多个功能同时使用某个 pin 而不知道，导致奇怪的错误）。</span></span><br><span class="line">    <span class="keyword">int</span> (*request) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 functions 支持的引脚复用的类型的总数，即 func 的数量，例如控制器支持、spi0、i2c0、mmc0 这三种类型则应该返回 3   </span></span><br><span class="line">    <span class="keyword">int</span> (*get_functions_count) (struct pinctrl_dev *pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过数组下标 selector 返回 functions 数组中对应的引脚复用名称，即对应 func 的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*get_function_name) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过数组下标 selector，返回 functions 数组中对应的 func 以及该 func 的长度</span></span><br><span class="line">    <span class="keyword">int</span> (*get_function_groups) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> **groups, <span class="keyword">unsigned</span> *num_groups);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定的  grpoups[group_selector] 设置为指定的 function[func_selector]</span></span><br><span class="line">    <span class="keyword">int</span> (*set_mux) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> func_selector, <span class="keyword">unsigned</span> group_selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是gpio相关</span></span><br><span class="line">    <span class="keyword">int</span> (*gpio_request_enable) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">void</span> (*gpio_disable_free) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*gpio_set_direction) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset, <span class="keyword">bool</span> input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> strict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引脚复用存在一种情况，{ 0, 8, 16, 24 }这组 pin 和 { 38, 46, 54, 62 } 这组 pin 都可以复用为 spi0 接口。 结合上面的内容举个栗子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo_group</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *pins;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> num_pins;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> spi0_0_pins[] = &#123; <span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> spi0_1_pins[] = &#123; <span class="number">38</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">62</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> i2c0_pins[] = &#123; <span class="number">24</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> mmc0_1_pins[] = &#123; <span class="number">56</span>, <span class="number">57</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> mmc0_2_pins[] = &#123; <span class="number">58</span>, <span class="number">59</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> mmc0_3_pins[] = &#123; <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo_group</span> <span class="title">foo_groups</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;spi0_0_grp&quot;</span>,</span><br><span class="line">        .pins = spi0_0_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(spi0_0_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;spi0_1_grp&quot;</span>,</span><br><span class="line">        .pins = spi0_1_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(spi0_1_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;i2c0_grp&quot;</span>,</span><br><span class="line">        .pins = i2c0_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(i2c0_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;mmc0_1_grp&quot;</span>,</span><br><span class="line">        .pins = mmc0_1_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(mmc0_1_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;mmc0_2_grp&quot;</span>,</span><br><span class="line">        .pins = mmc0_2_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(mmc0_2_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;mmc0_3_grp&quot;</span>,</span><br><span class="line">        .pins = mmc0_3_pins,</span><br><span class="line">        .num_pins = ARRAY_SIZE(mmc0_3_pins),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_get_groups_count</span><span class="params">(struct pinctrl_dev *pctldev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ARRAY_SIZE(foo_groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">foo_get_group_name</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> selector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo_groups[selector].name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_get_group_pins</span><span class="params">(struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> ** <span class="keyword">const</span> pins,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> * <span class="keyword">const</span> num_pins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *pins = (<span class="keyword">unsigned</span> *) foo_groups[selector].pins;</span><br><span class="line">    *num_pins = foo_groups[selector].num_pins;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> <span class="title">foo_pctrl_ops</span> =</span> &#123;</span><br><span class="line">    .get_groups_count = foo_get_groups_count,</span><br><span class="line">    .get_group_name = foo_get_group_name,</span><br><span class="line">    .get_group_pins = foo_get_group_pins,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo_pmx_func</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *groups;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> num_groups;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> spi0_groups[] = &#123; <span class="string">&quot;spi0_0_grp&quot;</span>, <span class="string">&quot;spi0_1_grp&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> i2c0_groups[] = &#123; <span class="string">&quot;i2c0_grp&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mmc0_groups[] = &#123; <span class="string">&quot;mmc0_1_grp&quot;</span>, <span class="string">&quot;mmc0_2_grp&quot;</span>, <span class="string">&quot;mmc0_3_grp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo_pmx_func</span> <span class="title">foo_functions</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;spi0&quot;</span>,</span><br><span class="line">        .groups = spi0_groups,</span><br><span class="line">        .num_groups = ARRAY_SIZE(spi0_groups),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;i2c0&quot;</span>,</span><br><span class="line">        .groups = i2c0_groups,</span><br><span class="line">        .num_groups = ARRAY_SIZE(i2c0_groups),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;mmc0&quot;</span>,</span><br><span class="line">        .groups = mmc0_groups,</span><br><span class="line">        .num_groups = ARRAY_SIZE(mmc0_groups),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_get_functions_count</span><span class="params">(struct pinctrl_dev *pctldev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ARRAY_SIZE(foo_functions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">foo_get_fname</span><span class="params">(struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo_functions[selector].name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_get_groups</span><span class="params">(struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> **groups,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">unsigned</span> * <span class="keyword">const</span> num_groups)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *groups = foo_functions[selector].groups;</span><br><span class="line">    *num_groups = foo_functions[selector].num_groups;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_set_mux</span><span class="params">(struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 regbit = (<span class="number">1</span> &lt;&lt; selector + group);</span><br><span class="line"></span><br><span class="line">    writeb((readb(MUX)|regbit), MUX)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> <span class="title">foo_pmxops</span> =</span> &#123;</span><br><span class="line">    .get_functions_count = foo_get_functions_count,</span><br><span class="line">    .get_function_name = foo_get_fname,</span><br><span class="line">    .get_function_groups = foo_get_groups,</span><br><span class="line">    .set_mux = foo_set_mux,</span><br><span class="line">    .strict = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pinmux operations are handled by some pin controller */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> <span class="title">foo_desc</span> =</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    .pctlops = &amp;foo_pctrl_ops,</span><br><span class="line">    .pmxops = &amp;foo_pmxops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5、引脚控制器"><a href="#5、引脚控制器" class="headerlink" title="5、引脚控制器"></a>5、引脚控制器</h2><p>引脚控制器是软件上抽象出来的概念，抽象这个结构是为了方便代码的编写，实际硬件并不存在这样的控制器，它包含了下面内容</p>
<ol>
<li>soc 要处理的所有引脚的软件描述</li>
<li>每个/组引脚的电器特性(pinconfig)操作接口</li>
<li>每组引脚的复用(pinmux)操作接口</li>
<li>支持客制化 pinconfig</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引脚控制器描述符，将其注册到引脚控制子系统</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                    <span class="comment">// 引脚控制器的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span> <span class="comment">// 引脚描述符数组，描述此引脚控制器处理的所有引脚</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> npins;                  <span class="comment">// 数组中描述符的数量，通常只是上面的 pin 字段的 ARRAY_SIZE()</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span>   <span class="comment">// 用于获取pin group 信息以及将设备树中的引脚配置(引脚复用以及pinconfig)转换为对应的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>     <span class="comment">// pin 复用相关操作，以 group 为单位进行操作</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span>   <span class="comment">// 配饰 pin 的 pinconfg(上拉、下拉、输出方式等)，以 pin 或 group 为操作对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                <span class="comment">// 提供引脚控制器的模块，用于重新计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_custom_params;      <span class="comment">// 客制化引脚支持的 pinconfig 的数量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span> <span class="comment">// 客制化引脚支持的 pinconfig</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span>    <span class="comment">// 有关如何在 debugfs 中打印 @params 的信息，必须与 @custom_params 大小相同，即 @num_custom_params</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6、引脚状态-pinctrl-state"><a href="#6、引脚状态-pinctrl-state" class="headerlink" title="6、引脚状态(pinctrl_state)"></a>6、引脚状态(pinctrl_state)</h2><p>顾名思义引脚状态表示引脚所处的状态。包括两个部分的内容引脚复用(pinmux)、和引脚的电器特性(pinconfig)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 挂接到所属的 pinctrl</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;      <span class="comment">// 对应的 pinctrl_map 的 name</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span> <span class="comment">//挂接该 state 下所有的 setting</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于某一个 pin 它的引脚复用只有一种状态，但是电器特性却有可以有多个，如上拉的同时强推挽输出。他们统一由数据结构 pinctrl_setting 表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>       <span class="comment">// 挂接到所属的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span>  <span class="comment">// 该 setting 的 pinctrl_map 的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span> <span class="comment">// 该 pinctrl_map 所属的 pinctrl_dev</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;        <span class="comment">// 被设置为 pinctrl_map-&gt;dev_name</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> <span class="title">mux</span>;</span> <span class="comment">//如果 type 为 PIN_MAP_TYPE_MUX_GROUP 则使用这个结构来保存引脚复用相关参数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> <span class="title">configs</span>;</span> <span class="comment">//如果 type 为 PIN_MAP_TYPE_CONFIGS_PIN 或者  PIN_MAP_TYPE_CONFIGS_GROUP 则使用这个结构来保存引脚电器特性相关参数</span></span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> group; <span class="comment">// 要用到的  pin group 的数组下标</span></span><br><span class="line">    <span class="keyword">unsigned</span> func;  <span class="comment">// 要用到的 func</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> group_or_pin;  <span class="comment">// 要配置的 pin 或者 pin group</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs; <span class="comment">// 对应的 pinconfig</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_configs;   <span class="comment">// config 数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个 setting 只能表示一个引脚复用(pinmux)或者一组电器特性(pinconfig)，怎么进行区分呢？使用 pinctrl_map_type 进行区分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> &#123;</span></span><br><span class="line">    PIN_MAP_TYPE_INVALID,</span><br><span class="line">    PIN_MAP_TYPE_DUMMY_STATE,</span><br><span class="line">    PIN_MAP_TYPE_MUX_GROUP,      <span class="comment">//表示该 setting 或 pinctrl_map 为引脚复用</span></span><br><span class="line">    PIN_MAP_TYPE_CONFIGS_PIN,    <span class="comment">//表示该 setting 或 pinctrl_map 为pinconfig，这个表示一个 pin</span></span><br><span class="line">    PIN_MAP_TYPE_CONFIGS_GROUP,  <span class="comment">//表示该 setting 或 pinctrl_map 为pinconfig，这个表示一组 pin</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此可以知道一个 pinctrl_state 上可以有多个 pinctrl_setting 他们都链接到 pinctrl_state-&gt;settings 链表</p>
<h2 id="7、pinctrl"><a href="#7、pinctrl" class="headerlink" title="7、pinctrl"></a>7、pinctrl</h2><p>pinctrl_state 是对于设备来说的，对于一个设备上的引脚可以有多种 pinctrl_state 供我们选择，而这些 state 由 pinctrl 来进行统一的管理，当前设备下没有pin state，pinctrl也是不会创建的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>        <span class="comment">// 挂接到全局的 pinctrl_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>           <span class="comment">// 表示所属的 dev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span>      <span class="comment">// 挂接该 pinctrl 所有的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span>     <span class="comment">// 用来挂接 pinctrl_dt_map ，该结构管理着 pinctrl 下所有的 pinctrl_map</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="8、pinctrl-dev"><a href="#8、pinctrl-dev" class="headerlink" title="8、pinctrl_dev"></a>8、pinctrl_dev</h2><p>一般一个 soc 有一个 pinctrl_dev</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>                <span class="comment">// 挂接到全局 pinctrldev_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span>            <span class="comment">// 引脚控制器描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span> <span class="comment">// 用于挂接所有的 pin_desc, pinctrl_desc-&gt;pins，将转换为 pin_desc 并用 pinctrl_desc-&gt;number 作为索引将其存入 pin_desc_tree</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span>         <span class="comment">// </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9、pinctrl-maps"><a href="#9、pinctrl-maps" class="headerlink" title="9、pinctrl_maps"></a>9、pinctrl_maps</h2><p>前面我们讲到了 pinctrl_setting 表示引脚复用(pinmux)、和引脚的电器特性(pinconfig)，它是最终的表示形式，在它之前还有个<font color=red>中间结构</font> pinctrl_maps 和它的功能一样，它表示由dts获取的引脚状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span> <span class="comment">//三个 name 都是在 pinctrl_dt_to_map 函数获取，在 dt_remember_or_free_map 函数进行初始化。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;       <span class="comment">// 所属 pinctrl 的 name</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 设备树中的 pinctrl-names 的属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 pinctrl_map 所属的类别，一般用到的有两大类，复用(mux) 和 pinconfig,</span></span><br><span class="line">    <span class="comment">// 当使用 mux 时使用 pinctrl_map_mux，而 pinconfig 则使用 pinctrl_map_configs</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ctrl_dev_name;  <span class="comment">// 所属的 pinctrl_dev 的 name</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span> <span class="comment">// 当 type 为 PIN_MAP_TYPE_MUX_GROUP 则使用这个</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span> <span class="comment">// 当 type为 IN_MAP_TYPE_CONFIGS_PIN、PIN_MAP_TYPE_CONFIGS_GROUP 使用这个</span></span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *group;       <span class="comment">//使用的 group</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *function;    <span class="comment">//要用到的复用函数名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *group_or_pin; <span class="comment">// 该 pin 或者pin group的名字</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs;   <span class="comment">// 要设置的 pinconfig 数组首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_configs;     <span class="comment">// 数组大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="10、pinctrl-dt-map"><a href="#10、pinctrl-dt-map" class="headerlink" title="10、pinctrl_dt_map"></a>10、pinctrl_dt_map</h2><p>用于管理 pinctrl 下的 pinctrl_map ，每一组 pinctrl_map 都会利用这个结构创建一个 dt_map，并将其链接到所属的 pinctrl</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dt_map</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>        <span class="comment">// 挂接到所属的 pinctrl</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span>  <span class="comment">// 指向所属的 pinctrl_dev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span>      <span class="comment">// 指向挂接的 pinctrl_map 数组的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_maps;            <span class="comment">// 上面 map 的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11、pinctrl-maps"><a href="#11、pinctrl-maps" class="headerlink" title="11、pinctrl_maps"></a>11、pinctrl_maps</h2><p>管理所有的 pinctrl_map 数组，每一组 pinctrl_map 都会 struct pinctrl_maps *maps_nod, 初始化后将 map_node 其挂接到全局链表pinctrl_maps上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>          <span class="comment">// 连接到 pinctrl_maps 全局链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> <span class="title">const</span> *<span class="title">maps</span>;</span> <span class="comment">// 指向 pinctrl_map 数组首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_maps;              <span class="comment">// pinctrl_map 的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二、注册-pinctrl-dev"><a href="#二、注册-pinctrl-dev" class="headerlink" title="二、注册 pinctrl_dev"></a>二、注册 pinctrl_dev</h1><p>pinctrl子系统的注册可以分为两个部分，pinctrl_dev 的注册以及 pinctrl 的注册，pinctrl_dev 用来描述 soc 的 pin 控制信息包括，pin 的名字，编号，数量，pin 的复用调函数，电器特性回调函数等，由于它也是一个设备的抽象因此它也有属于自己的 pinctrl，但大部情况都不会用到(一般不在 pinctrl 根节点描述 pin state)。 </p>
<h2 id="pinctrl-register"><a href="#pinctrl-register" class="headerlink" title="pinctrl_register"></a>pinctrl_register</h2><p>pinctrl_register 做的事情其实也挺简单的，对于大部分soc</p>
<ol>
<li>关联pctldesc与pctldev</li>
<li>对 pctldesc-&gt;pins 数组中的每一个 pinctrl_pin_desc ,  创建一个 pin_desc 并将其挂接到 pin_desc_tree</li>
<li>将 pctldev 挂接进入 pinctrldev_list 全局链表</li>
<li>创建 dbugfs 相关目录</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct pinctrl_dev *<span class="title">pinctrl_register</span><span class="params">(struct pinctrl_desc *pctldesc, struct device *dev, <span class="keyword">void</span> *driver_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pctldesc)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    <span class="keyword">if</span> (!pctldesc-&gt;name)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态创建 pinctrl_dev</span></span><br><span class="line">    pctldev = kzalloc(<span class="keyword">sizeof</span>(*pctldev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (pctldev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;failed to alloc struct pinctrl_dev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* Initialize pin control device struct */</span></span><br><span class="line">    pctldev-&gt;owner = pctldesc-&gt;owner;</span><br><span class="line">    pctldev-&gt;desc = pctldesc;</span><br><span class="line">    pctldev-&gt;driver_data = driver_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 pin_desc_tree 用于挂接所有的 gpio_desc</span></span><br><span class="line">    INIT_RADIX_TREE(&amp;pctldev-&gt;pin_desc_tree, GFP_KERNEL);</span><br><span class="line">    INIT_LIST_HEAD(&amp;pctldev-&gt;gpio_ranges);</span><br><span class="line">    pctldev-&gt;dev = dev; <span class="comment">//设置所属的dev</span></span><br><span class="line">    mutex_init(&amp;pctldev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check core ops for sanity */</span></span><br><span class="line">    ret = pinctrl_check_ops(pctldev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;pinctrl ops lacks necessary functions\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re implementing pinmuxing, check the ops for sanity */</span></span><br><span class="line">    <span class="keyword">if</span> (pctldesc-&gt;pmxops) &#123;</span><br><span class="line">        ret = pinmux_check_ops(pctldev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re implementing pinconfig, check the ops for sanity */</span></span><br><span class="line">    <span class="keyword">if</span> (pctldesc-&gt;confops) &#123;</span><br><span class="line">        ret = pinconf_check_ops(pctldev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register all the pins */</span></span><br><span class="line">    dev_dbg(dev, <span class="string">&quot;try to register %d pins ...\n&quot;</span>,  pctldesc-&gt;npins);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 对 pctldesc-&gt;pins 数组中的每一个 pinctrl_pin_desc , </span></span><br><span class="line"><span class="comment">     * 创建一个 pin_desc 并将其挂接到 pin_desc_tree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = pinctrl_register_pins(pctldev, pctldesc-&gt;pins, pctldesc-&gt;npins);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;error during pin registration\n&quot;</span>);</span><br><span class="line">        pinctrl_free_pindescs(pctldev, pctldesc-&gt;pins,</span><br><span class="line">                      pctldesc-&gt;npins);</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrldev_list_mutex);</span><br><span class="line">    list_add_tail(&amp;pctldev-&gt;node, &amp;pinctrldev_list);<span class="comment">//将pctldev 挂接进入 pinctrldev_list 全局链表</span></span><br><span class="line">    mutex_unlock(&amp;pinctrldev_list_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 pinctrl_list 中查找属于本 dev 的 pinctrl,如果没有则判断当前节点是否存在，pinctrl-*,有则创建 pinctrl，</span></span><br><span class="line">    <span class="comment">// 一般情况是不会在创建 pinctrl_dev 的时候创建pinctrl的</span></span><br><span class="line">    pctldev-&gt;p = pinctrl_get(pctldev-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(pctldev-&gt;p)) &#123;</span><br><span class="line">        <span class="comment">//查找出 default 的 state</span></span><br><span class="line">        pctldev-&gt;hog_default =</span><br><span class="line">            pinctrl_lookup_state(pctldev-&gt;p, PINCTRL_STATE_DEFAULT);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(pctldev-&gt;hog_default)) &#123;</span><br><span class="line">            dev_dbg(dev, <span class="string">&quot;failed to lookup the default state\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置pin状态为default状态</span></span><br><span class="line">            <span class="keyword">if</span> (pinctrl_select_state(pctldev-&gt;p,</span><br><span class="line">                        pctldev-&gt;hog_default))</span><br><span class="line">                dev_err(dev,</span><br><span class="line">                    <span class="string">&quot;failed to select default state\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取sleep state</span></span><br><span class="line">        pctldev-&gt;hog_sleep =</span><br><span class="line">            pinctrl_lookup_state(pctldev-&gt;p,</span><br><span class="line">                            PINCTRL_STATE_SLEEP);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(pctldev-&gt;hog_sleep))</span><br><span class="line">            dev_dbg(dev, <span class="string">&quot;failed to lookup the sleep state\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pinctrl_init_device_debugfs(pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pctldev;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">    mutex_destroy(&amp;pctldev-&gt;mutex);</span><br><span class="line">    kfree(pctldev);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pinctrl-register-pins"><a href="#pinctrl-register-pins" class="headerlink" title="pinctrl_register_pins"></a>pinctrl_register_pins</h3><p>对 pctldesc-&gt;pins 数组中的每一个 pinctrl_pin_desc , 使用 pins[i].number 作为索引，创建一个 pin_desc 并将其挂接到 pin_desc_tree</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pinctrl_register_pins</span><span class="params">(struct pinctrl_dev *pctldev, struct pinctrl_pin_desc <span class="keyword">const</span> *pins, <span class="keyword">unsigned</span> num_descs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_descs; i++) &#123;</span><br><span class="line">        ret = pinctrl_register_one_pin(pctldev,</span><br><span class="line">                           pins[i].number, pins[i].name);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pinctrl-register-one-pin"><a href="#pinctrl-register-one-pin" class="headerlink" title="pinctrl_register_one_pin"></a>pinctrl_register_one_pin</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pinctrl_register_one_pin</span><span class="params">(struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> number, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> *<span class="title">pindesc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否已经注册了pin_desc</span></span><br><span class="line"><span class="comment">    static inline struct pin_desc *pin_desc_get(struct  pinctrl_dev *pctldev, unsigned int pin)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return radix_tree_lookup(&amp;pctldev-&gt;pin_desc_tree, pin);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    pindesc = pin_desc_get(pctldev, number);</span><br><span class="line">    <span class="keyword">if</span> (pindesc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;pin %d already registered\n&quot;</span>, number);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态创建一个 pin_desc</span></span><br><span class="line">    pindesc = kzalloc(<span class="keyword">sizeof</span>(*pindesc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (pindesc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;failed to alloc struct pin_desc\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set owner */</span></span><br><span class="line">    pindesc-&gt;pctldev = pctldev; <span class="comment">//设置 pin_desc 所属的 pinctrl_dev</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy basic pin info */</span></span><br><span class="line">    <span class="comment">//初始化 name 为传入的 pinctrl_pin_desc 中的 name，如果传入的 name 为空则使用 PIN + number 作为 name</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">        pindesc-&gt;name = name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pindesc-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;PIN%u&quot;</span>, number);</span><br><span class="line">        <span class="keyword">if</span> (pindesc-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            kfree(pindesc);</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">        pindesc-&gt;dynamic_name = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 number 作为索引将 pindesc 插入到 pctldev-&gt;pin_desc_tree 中</span></span><br><span class="line">    radix_tree_insert(&amp;pctldev-&gt;pin_desc_tree, number, pindesc);</span><br><span class="line">    pr_debug(<span class="string">&quot;registered pin %d (%s) on %s\n&quot;</span>,</span><br><span class="line">         number, pindesc-&gt;name, pctldev-&gt;desc-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三、创建-pinctrl-的时机"><a href="#三、创建-pinctrl-的时机" class="headerlink" title="三、创建 pinctrl 的时机"></a>三、创建 pinctrl 的时机</h1><p>我们知道 pinctrl state 是针对设备而言的，因此创建 pinctrl 的最佳时机就是内核的设备模型，在设备模型的匹配过程中创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    ret = pinctrl_bind_pins(dev);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于设备模型在另一篇文章<a href="https://baron-z.cn/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/#more">linux设备模型</a>有详细的分析, 从注释也可看出在 pinctrl_bind_pins 建立当前设备的 pin state</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">int pinctrl_bind_pins(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">pins</span> = devm_kzalloc(dev, sizeof(*(dev-&gt;</span>pins)), GFP_KERNEL);</span><br><span class="line">    <span class="function"><span class="title">if</span> (!dev-&gt;</span>pins)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p = devm_pinctrl_get(dev); <span class="comment">// 调用 pinctrl_get 扫描当前设备节点下的 pin state 如果有则创建对应的 pinctrl 以及对应的 setting</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (IS_ERR(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p)) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no pinctrl handle\n&quot;</span>);</span><br><span class="line">        <span class="function"><span class="title">ret</span> = PTR_ERR(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p);</span><br><span class="line">        goto cleanup_alloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 default 的 state</span></span><br><span class="line">    <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span><span class="function"><span class="title">default_state</span> = pinctrl_lookup_state(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p,</span><br><span class="line">                    PINCTRL_STATE_DEFAULT);</span><br><span class="line">    <span class="function"><span class="title">if</span> (IS_ERR(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>default_state)) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no default pinctrl state\n&quot;</span>);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        goto cleanup_get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找 init 的 state 如果不存在则设置为 default 否则设置为 init</span></span><br><span class="line">    <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span><span class="function"><span class="title">init_state</span> = pinctrl_lookup_state(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p,</span><br><span class="line">                    PINCTRL_STATE_INIT);</span><br><span class="line">    <span class="function"><span class="title">if</span> (IS_ERR(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>init_state)) &#123;</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no init pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p,</span><br><span class="line">                       <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>default_state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">ret</span> = pinctrl_select_state(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span><span class="function"><span class="title">p</span>, dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>init_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;failed to activate initial pinctrl state\n&quot;</span>);</span><br><span class="line">        goto cleanup_get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If power management is enabled, we also look for the optional</span></span><br><span class="line"><span class="comment">     * sleep and idle pin states, with semantics as defined in</span></span><br><span class="line"><span class="comment">     * &lt;linux/pinctrl/pinctrl-state.h&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">//查找 sleep 的 state</span></span><br><span class="line">    <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span><span class="function"><span class="title">sleep_state</span> = pinctrl_lookup_state(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p,</span><br><span class="line">                    PINCTRL_STATE_SLEEP);</span><br><span class="line">    <span class="function"><span class="title">if</span> (IS_ERR(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>sleep_state))</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no sleep pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span><span class="function"><span class="title">idle_state</span> = pinctrl_lookup_state(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p,</span><br><span class="line">                    PINCTRL_STATE_IDLE);</span><br><span class="line">    <span class="function"><span class="title">if</span> (IS_ERR(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>idle_state))</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no idle pinctrl state\n&quot;</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If no pinctrl handle or default state was found for this device,</span></span><br><span class="line"><span class="comment">     * let&#x27;s explicitly free the pin container in the device, there is</span></span><br><span class="line"><span class="comment">     * no point in keeping it around.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">cleanup_get:</span><br><span class="line">    <span class="function"><span class="title">devm_pinctrl_put</span>(dev-&gt;</span><span class="function"><span class="title">pins</span>-&gt;</span>p);</span><br><span class="line">cleanup_alloc:</span><br><span class="line">    <span class="function"><span class="title">devm_kfree</span>(dev, dev-&gt;</span>pins);</span><br><span class="line">    <span class="function"><span class="title">dev</span>-&gt;</span>pins = NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only return deferrals */</span></span><br><span class="line">    <span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备模型也给我们提供了对应的数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> *<span class="title">pins</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>   <span class="comment">//该设备的 pinctrl</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span> <span class="comment">//默认的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span>    <span class="comment">//如果有则初始化为这个 state 否则初始化为 default</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span>   <span class="comment">//休眠 state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="四、创建-pinctrl"><a href="#四、创建-pinctrl" class="headerlink" title="四、创建 pinctrl"></a>四、创建 pinctrl</h1><p>pinctrl 的创建流程如下</p>
<ol>
<li>根据 dts 中的 pin state 创建出 pinctrl_map</li>
<li>将 pinctrl_map 转换为对应的 pinctrl_setting</li>
</ol>
<h2 id="pinctrl-get"><a href="#pinctrl-get" class="headerlink" title="pinctrl_get"></a>pinctrl_get</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在 pinctrl_list 链表中查找属于本设备的 pinctrl</span></span><br><span class="line"><span class="comment">// 2. 如果不存在则注册一个 pinctrl</span></span><br><span class="line"><span class="function">struct pinctrl *<span class="title">pinctrl_get</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!dev))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * See if somebody else (such as the device core) has already</span></span><br><span class="line"><span class="comment">     * obtained a handle to the pinctrl for this device. In that case,</span></span><br><span class="line"><span class="comment">     * return another pointer to it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">//如果 pinctrl 被注册则直接返回</span></span><br><span class="line">    p = find_pinctrl(dev);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;obtain a copy of previously claimed pinctrl\n&quot;</span>);</span><br><span class="line">        kref_get(&amp;p-&gt;users);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> create_pinctrl(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-pinctrl"><a href="#find-pinctrl" class="headerlink" title="find_pinctrl"></a>find_pinctrl</h3><p>在 pinctrl_list 链表中查找属于本设备的 pinctrl，从这里也可以得出结论，pinctrl 和 pinctrl 的连结是通过两者所属的设备来完成的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="keyword">struct</span> pinctrl *find<span class="constructor">_pinctrl(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> pinctrl *p;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_lock(&amp;<span class="params">pinctrl_list_mutex</span>)</span>;</span><br><span class="line">    <span class="built_in">list</span><span class="constructor">_for_each_entry(<span class="params">p</span>, &amp;<span class="params">pinctrl_list</span>, <span class="params">node</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;dev<span class="operator"> == </span>dev) &#123;</span><br><span class="line">            mutex<span class="constructor">_unlock(&amp;<span class="params">pinctrl_list_mutex</span>)</span>;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_unlock(&amp;<span class="params">pinctrl_list_mutex</span>)</span>;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create-pinctrl"><a href="#create-pinctrl" class="headerlink" title="create_pinctrl"></a>create_pinctrl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pinctrl *<span class="title">create_pinctrl</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span> <span class="comment">//map索引</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> <span class="title">const</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create the state cookie holder struct pinctrl for each</span></span><br><span class="line"><span class="comment">     * mapping, this is what consumers will get when requesting</span></span><br><span class="line"><span class="comment">     * a pin control handle with pinctrl_get()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//创建 pinctrl</span></span><br><span class="line">    p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;failed to alloc struct pinctrl\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;dev = dev; <span class="comment">//初始化所属的dev</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;states); <span class="comment">//初始化 states 链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;dt_maps); <span class="comment">//初始化 dt_maps链表</span></span><br><span class="line"></span><br><span class="line">    ret = pinctrl_dt_to_map(p);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	devname = dev_name(dev);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line">    <span class="comment">/* Iterate over the pin control maps to locate the right ones */</span></span><br><span class="line">    <span class="comment">//对于 maps_node 中的每一组属于该设备的 map 调用 add_setting，将对应的 pinctrl_map 转换为 pinctrl_setting</span></span><br><span class="line">    for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line">        <span class="comment">/* Map must be for this device */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;dev_name, devname))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">        ret = add_setting(p, <span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * At this point the adding of a setting may:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - Defer, if the pinctrl device is not yet available</span></span><br><span class="line"><span class="comment">         * - Fail, if the pinctrl device is not yet available,</span></span><br><span class="line"><span class="comment">         *   AND the setting is a hog. We cannot defer that, since</span></span><br><span class="line"><span class="comment">         *   the hog will kick in immediately after the device</span></span><br><span class="line"><span class="comment">         *   is registered.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If the error returned was not -EPROBE_DEFER then we</span></span><br><span class="line"><span class="comment">         * accumulate the errors to see if we end up with</span></span><br><span class="line"><span class="comment">         * an -EPROBE_DEFER later, as that is the worst case.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">            pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">            mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* If some other error than deferral occured, return here */</span></span><br><span class="line">        pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kref_init(&amp;p-&gt;users);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the pinctrl handle to the global list */</span></span><br><span class="line">    mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">    list_add_tail(&amp;p-&gt;node, &amp;pinctrl_list);</span><br><span class="line">    mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pinctrl-dt-to-map"><a href="#pinctrl-dt-to-map" class="headerlink" title="pinctrl_dt_to_map"></a>pinctrl_dt_to_map</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 从state = 0开始，递增判断 pinctrl 所属的设备的的设备树节点是否存在 pinctrl-state ，不存在则直接返回</span></span><br><span class="line"><span class="comment">// 2. 如果存在则使用 pinctrl- 后面的参数作为索引，例如：pinctrl-0 则使用 0 作为 index 获取 pinctrl-names 属性的值 statename</span></span><br><span class="line"><span class="comment">// 3. 遍历 pinctrl-0 属性的值所表示的节点，在 pinctrldev_list 中查找属于该节点的父节点的 pinctrl_dev, </span></span><br><span class="line"><span class="comment">//    然后调用 pctldev-&gt;desc-&gt;pctlops-&gt;dt_node_to_map(pctldev, np_config, &amp;map, &amp;num_maps); 函数, 创建出需要的  pinctrl_map </span></span><br><span class="line"><span class="comment">// 4. 进一步初始化 pinctrl_map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_dt_to_map</span><span class="params">(struct pinctrl *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> p-&gt;dev-&gt;of_node; <span class="comment">//获取到 pinctrl 所属的设备的设备节点</span></span><br><span class="line">    <span class="keyword">int</span> state, ret;</span><br><span class="line">    <span class="keyword">char</span> *propname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *statename;</span><br><span class="line">    <span class="keyword">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> size, config;</span><br><span class="line">    phandle phandle;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CONFIG_OF enabled, p-&gt;dev not instantiated from DT */</span></span><br><span class="line">    <span class="keyword">if</span> (!np) &#123;</span><br><span class="line">        <span class="keyword">if</span> (of_have_populated_dt())</span><br><span class="line">            dev_dbg(p-&gt;dev,</span><br><span class="line">                <span class="string">&quot;no of_node; not parsing pinctrl DT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We may store pointers to property names within the node */</span></span><br><span class="line">    of_node_get(np); <span class="comment">// 增加节点引用计数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*  //dts 示例</span></span><br><span class="line"><span class="comment">    * &amp;lcm &#123;//                第0个state         第1个state</span></span><br><span class="line"><span class="comment">    *     pinctrl-names = &quot;lcm_1v8_en_low&quot; , &quot;lcm_1v8_en_high&quot;;</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    *     pinctrl-0 = &lt;&amp;gpio_lcm_pwr1v8_low&gt;;  //----这是一个 pinctrl_state</span></span><br><span class="line"><span class="comment">    *     pinctrl-1 = &lt;&amp;gpio_lcm_pwr1v8_high&gt;; //----这是一个 pinctrl_state</span></span><br><span class="line"><span class="comment">    *     status = &quot;okay&quot;;</span></span><br><span class="line"><span class="comment">    * &#125;;</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * &amp;pio &#123; </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    *     gpio_lcm_pwr1v8_low: gpio_lcm_pwr1v8_low &#123; //----这是一组 pinctrl_map </span></span><br><span class="line"><span class="comment">    *         pins_cmd_dat &#123;</span></span><br><span class="line"><span class="comment">    *             pinmux = &lt;PINMUX_GPIO5__FUNC_GPIO5&gt;; //这被解析到一个 pinctrl_map-&gt;data-&gt;mux</span></span><br><span class="line"><span class="comment">    *             slew-rate = &lt;1&gt;;                     //这被解析到一个 pinctrl_map-&gt;data-&gt;configs   </span></span><br><span class="line"><span class="comment">    *             output-low;                          //这被解析到一个 pinctrl_map-&gt;data-&gt;configs</span></span><br><span class="line"><span class="comment">    *         &#125;; //于是这里将创建有3个 pinctrl_map 的数组</span></span><br><span class="line"><span class="comment">    *     &#125;;</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    *     gpio_lcm_pwr1v8_high: gpio_lcm_pwr1v8_high &#123; //----这是一组 pinctrl_map </span></span><br><span class="line"><span class="comment">    *         pins_cmd_dat &#123;</span></span><br><span class="line"><span class="comment">    *             pinmux = &lt;PINMUX_GPIO5__FUNC_GPIO5&gt;; //这被解析到一个 pinctrl_map-&gt;data-&gt;mux</span></span><br><span class="line"><span class="comment">    *             output-high;                         //这被解析到一个 pinctrl_map-&gt;data-&gt;configs</span></span><br><span class="line"><span class="comment">    *         &#125;; /于是这里将创建有2个 pinctrl_map 的数组</span></span><br><span class="line"><span class="comment">    * &#125;;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For each defined state ID */</span></span><br><span class="line">    <span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line">        </span><br><span class="line">        propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 propname 获得对应设备树中的属性，pinctrl-0 属性的值为设备节点的引用，即为 phandle 属性。</span></span><br><span class="line">        prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">        kfree(propname);</span><br><span class="line">        <span class="keyword">if</span> (!prop)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">list</span> = prop-&gt;value;    <span class="comment">// 获取到属性值</span></span><br><span class="line">        size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>); <span class="comment">// 获取属性值的个数，即上面dts中的 &lt;&amp;gpio_lcm_pwr1v8_low&gt; 的个数明显这里只有一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 pinctrl-names, 获取对应的 state 的名字，一般情况下 state = 0 的名字为 default</span></span><br><span class="line">        <span class="comment">// 这里可以看出，pinctrl-names 属性的值，和 pinctrl-* 是一一对应的。</span></span><br><span class="line">        ret = of_property_read_string_index(np, <span class="string">&quot;pinctrl-names&quot;</span>, state, &amp;statename);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If not, statename is just the integer state ID. But rather</span></span><br><span class="line"><span class="comment">         * than dynamically allocate it and have to free it later,</span></span><br><span class="line"><span class="comment">         * just point part way into the property name for the string.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* strlen(&quot;pinctrl-&quot;) == 8 */</span></span><br><span class="line">            statename = prop-&gt;name + <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For every referenced pin configuration node in it */</span></span><br><span class="line">        <span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123; <span class="comment">//</span></span><br><span class="line">           <span class="comment">//将属性值转化为 pandle，只是保证数据的大小端一致性</span></span><br><span class="line">            phandle = be32_to_cpup(<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Look up the pin configuration node */</span></span><br><span class="line">            <span class="comment">//通过 phandle 获取到其所在的设备节点 gpio_lcm_pwr1v8_low</span></span><br><span class="line">            np_config = of_find_node_by_phandle(phandle);</span><br><span class="line">            <span class="keyword">if</span> (!np_config) &#123;</span><br><span class="line">                dev_err(p-&gt;dev,</span><br><span class="line">                    <span class="string">&quot;prop %s index %i invalid phandle\n&quot;</span>,</span><br><span class="line">                    prop-&gt;name, config);</span><br><span class="line">                ret = -EINVAL;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Parse the node */</span></span><br><span class="line">            <span class="comment">// 在 pinctrldev_list 中查找属于 gpio_lcm_pwr1v8_low 所在节点根节点的中的 pinctrl_dev, </span></span><br><span class="line">            <span class="comment">// 然后调用 pctldev-&gt;desc-&gt;pctlops-&gt;dt_node_to_map(pctldev, np_config, &amp;map, &amp;num_maps); 函数, 创建出需要的 pinctrl_map</span></span><br><span class="line">            <span class="comment">// 进一步初始化 pinctrl_map ，创建 pinctrl_dt_map 初始化之后 将，dt_map 挂接到所属的 pinctrl</span></span><br><span class="line">            <span class="comment">// 检查 pinctrl_map 的合法性，动态创建一个 maps_node 初始化之后挂接到全局  pinctrl_maps</span></span><br><span class="line">            ret = dt_to_map_one_config(p, statename, np_config);</span><br><span class="line">            of_node_put(np_config);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    pinctrl_dt_free_maps(p);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dt-to-map-one-config"><a href="#dt-to-map-one-config" class="headerlink" title="dt_to_map_one_config"></a>dt_to_map_one_config</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 pinctrldev_list 中查找属于 gpio_lcm_pwr1v8_low 所在节点根节点的中的 pinctrl_dev, </span></span><br><span class="line"><span class="comment">// 然后调用 pctldev-&gt;desc-&gt;pctlops-&gt;dt_node_to_map(pctldev, np_config, &amp;map, &amp;num_maps); 函数, 创建出需要的 pinctrl_map</span></span><br><span class="line"><span class="comment">// 进一步初始化 pinctrl_map ，创建 pinctrl_dt_map 初始化之后 将，dt_map 挂接到所属的 pinctrl</span></span><br><span class="line"><span class="comment">// 检查 pinctrl_map 的合法性，动态创建一个 maps_node 初始化之后挂接到全局  pinctrl_maps</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dt_to_map_one_config</span><span class="params">(struct pinctrl *p, <span class="keyword">const</span> <span class="keyword">char</span> *statename, struct device_node *np_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_pctldev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_maps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the pin controller containing np_config */</span></span><br><span class="line">    np_pctldev = of_node_get(np_config); <span class="comment">//增加节点引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//获取 np_pctldev 所在的设备节点的父节点，即pinctrl-0 指向的设备节点 gpio_lcm_pwr1v8_low 的父节点，即 pintrl 根节点</span></span><br><span class="line">        np_pctldev = of_get_next_parent(np_pctldev);</span><br><span class="line">        <span class="keyword">if</span> (!np_pctldev || of_node_is_root(np_pctldev)) &#123;</span><br><span class="line">            dev_info(p-&gt;dev, <span class="string">&quot;could not find pctldev for node %s, deferring probe\n&quot;</span>,</span><br><span class="line">                np_config-&gt;full_name);</span><br><span class="line">            of_node_put(np_pctldev);</span><br><span class="line">            <span class="comment">/* OK let&#x27;s just assume this will appear later then */</span></span><br><span class="line">            <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取 pintrl 根节点的 pinctrl_dev</span></span><br><span class="line">        pctldev = get_pinctrl_dev_from_of_node(np_pctldev);</span><br><span class="line">        <span class="keyword">if</span> (pctldev) <span class="comment">//如果存在推出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Do not defer probing of hogs (circular loop) */</span></span><br><span class="line">        <span class="keyword">if</span> (np_pctldev == p-&gt;dev-&gt;of_node) &#123;</span><br><span class="line">            of_node_put(np_pctldev);</span><br><span class="line">            <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    of_node_put(np_pctldev); <span class="comment">//减少节点引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Call pinctrl driver to parse device tree node, and</span></span><br><span class="line"><span class="comment">     * generate mapping table entries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">//获取其 pinctrl_ops </span></span><br><span class="line">    ops = pctldev-&gt;desc-&gt;pctlops;</span><br><span class="line">    <span class="keyword">if</span> (!ops-&gt;dt_node_to_map) &#123;</span><br><span class="line">        dev_err(p-&gt;dev, <span class="string">&quot;pctldev %s doesn&#x27;t support DT\n&quot;</span>,</span><br><span class="line">            dev_name(pctldev-&gt;dev));</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 调用 dt_node_to_map 函数， 对于 gpio_lcm_pwr1v8_low 的所有子节点调用 mtk_pctrl_dt_subnode_to_map</span></span><br><span class="line">    <span class="comment">// 从设备树中获取对应的配置，并创建对应的 pinctrl_map</span></span><br><span class="line">    ret = ops-&gt;dt_node_to_map(pctldev, np_config, &amp;<span class="built_in">map</span>, &amp;num_maps);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stash the mapping table chunk away for later use */</span></span><br><span class="line">	<span class="comment">// 进一步初始化 pinctrl_map ，创建 pinctrl_dt_map 初始化之后 将，dt_map 挂接到所属的 pinctrl</span></span><br><span class="line">    <span class="comment">// 检查 pinctrl_map 的合法性，动态创建一个 maps_node 初始化之后挂接到全局  pinctrl_maps</span></span><br><span class="line">    <span class="keyword">return</span> 	dt_remember_or_free_map(p, statename, pctldev, <span class="built_in">map</span>, num_maps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-pinctrl-dev-from-of-node"><a href="#get-pinctrl-dev-from-of-node" class="headerlink" title="get_pinctrl_dev_from_of_node"></a>get_pinctrl_dev_from_of_node</h3><p>在 pinctrldev_list 中查找属于当前节点的 pinctrl_dev,</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct pinctrl_dev *<span class="title">get_pinctrl_dev_from_of_node</span><span class="params">(struct device_node *np)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrldev_list_mutex);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(pctldev, &amp;pinctrldev_list, node)</span><br><span class="line">        <span class="keyword">if</span> (pctldev-&gt;dev-&gt;of_node == np) &#123;</span><br><span class="line">            mutex_unlock(&amp;pinctrldev_list_mutex);</span><br><span class="line">            <span class="keyword">return</span> pctldev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;pinctrldev_list_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mtk-pctrl-dt-node-to-map"><a href="#mtk-pctrl-dt-node-to-map" class="headerlink" title="mtk_pctrl_dt_node_to_map"></a>mtk_pctrl_dt_node_to_map</h3><p>对于 np_config(就是前面的 gpio_lcm_pwr1v8_low)的所有子节点调用 mtk_pctrl_dt_subnode_to_map, 从设备树中获取对应的配置，并创建对应的 pinctrl_map</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtk_pctrl_dt_node_to_map</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct device_node *np_config,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *num_maps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_maps;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    *<span class="built_in">map</span> = <span class="literal">NULL</span>;</span><br><span class="line">    *num_maps = <span class="number">0</span>; <span class="comment">//表示 pinctrl_map 的数组下标</span></span><br><span class="line">    reserved_maps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 对于 gpio_lcm_pwr1v8_low 的所有子节点调用 mtk_pctrl_dt_subnode_to_map,</span></span><br><span class="line"><span class="comment">    * 从设备树中获取对应的配置，并创建对应的 pinctrl_map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    for_each_child_of_node(np_config, np) &#123;</span><br><span class="line">        ret = mtk_pctrl_dt_subnode_to_map(pctldev, np, <span class="built_in">map</span>,</span><br><span class="line">                &amp;reserved_maps, num_maps);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pinctrl_utils_dt_free_map(pctldev, *<span class="built_in">map</span>, *num_maps);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mtk-pctrl-dt-subnode-to-map"><a href="#mtk-pctrl-dt-subnode-to-map" class="headerlink" title="mtk_pctrl_dt_subnode_to_map"></a>mtk_pctrl_dt_subnode_to_map</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从设备树中获取对应的配置，并创建对应的 pinctrl_map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtk_pctrl_dt_subnode_to_map</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct device_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct pinctrl_map **<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> *reserved_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> *num_maps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">pins</span>;</span></span><br><span class="line">    u32 pinfunc, pin, func;</span><br><span class="line">    <span class="keyword">int</span> num_pins, num_funcs, maps_per_pin;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_configs;</span><br><span class="line">    <span class="keyword">bool</span> has_config = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">unsigned</span> reserve = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl_group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl</span> *<span class="title">pctl</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 pin 的属性，从这里可以知道本平台兼容两种 pin 属性的写法，</span></span><br><span class="line">    <span class="comment">// 一种是 pinmux，一种是 pins</span></span><br><span class="line">    pins = of_find_property(node, <span class="string">&quot;pinmux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pins) &#123;</span><br><span class="line">        pins = of_find_property(node, <span class="string">&quot;pins&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pins) &#123;</span><br><span class="line">        dev_err(pctl-&gt;dev, <span class="string">&quot;missing pins property in node %s .\n&quot;</span>,</span><br><span class="line">                node-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在设备节点查找 dt_params 以及 pctldev-&gt;desc-&gt;custom_params 中的支持的 pinconfig</span></span><br><span class="line">    <span class="comment">// 如果存在则按顺寻将 params 和 custom_params 可配置的 pinconfig 参数 pin_config_param </span></span><br><span class="line">    <span class="comment">// 以及配置的默认状态 default_value 组合后,存入 configs 指向的内存空间, 并返回 configs 的长度</span></span><br><span class="line">    err = pinconf_generic_parse_dt_config(node, pctldev, &amp;configs,</span><br><span class="line">        &amp;num_configs);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_configs)</span><br><span class="line">        has_config = <span class="number">1</span>; <span class="comment">//是否需要配置 configs</span></span><br><span class="line"></span><br><span class="line">    num_pins = pins-&gt;length / <span class="keyword">sizeof</span>(u32); <span class="comment">//获取 dts 配置的 pin 的数量</span></span><br><span class="line">    num_funcs = num_pins; <span class="comment">//计算出 func 的数量</span></span><br><span class="line">    maps_per_pin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_funcs)</span><br><span class="line">        maps_per_pin++; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (has_config &amp;&amp; num_pins &gt;= <span class="number">1</span>) <span class="comment">//如果有配置的 config 以及需要配置的 pin &gt;= 1</span></span><br><span class="line">        maps_per_pin++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!num_pins || !maps_per_pin) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reserve = num_pins * maps_per_pin; <span class="comment">//计算需要的 pinctrl_map 的数量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新申请一片大小为 *num_maps + reserve 的内存空间，并将 map 的值复制过去，</span></span><br><span class="line">    <span class="comment">// reserved_maps 之后的内存空间初始化为 0, 同时更新 pinctrl_map 的数量 reserved_maps</span></span><br><span class="line">    <span class="comment">// num_maps 表示有效的 pinctrl_map 的数量</span></span><br><span class="line">    err = pinctrl_utils_reserve_map(pctldev, <span class="built_in">map</span>,</span><br><span class="line">            reserved_maps, num_maps, reserve);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">        err = of_property_read_u32_index(node, <span class="string">&quot;pinmux&quot;</span>,</span><br><span class="line">                i, &amp;pinfunc);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            err = of_property_read_u32_index(node, <span class="string">&quot;pins&quot;</span>,</span><br><span class="line">                i, &amp;pinfunc);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pin = MTK_GET_PIN_NO(pinfunc); <span class="comment">//获取配置的 pin 脚</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取该引脚对应的复用状态，复用状态在 include/dt-bindings/pinctrl/mt6771-pinfunc.h 文件中配置</span></span><br><span class="line">        func = MTK_GET_PIN_FUNC(pinfunc);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pin &gt;= pctl-&gt;devdata-&gt;npins ||</span><br><span class="line">                func &gt;= ARRAY_SIZE(mtk_gpio_functions)) &#123;</span><br><span class="line">            dev_err(pctl-&gt;dev, <span class="string">&quot;invalid pins value.\n&quot;</span>);</span><br><span class="line">            err = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回该 pin 所对应的 group</span></span><br><span class="line">        grp = mtk_pctrl_find_group_by_pin(pctl, pin);</span><br><span class="line">        <span class="keyword">if</span> (!grp) &#123;</span><br><span class="line">            dev_err(pctl-&gt;dev, <span class="string">&quot;unable to match pin %d to group\n&quot;</span>,</span><br><span class="line">                    pin);</span><br><span class="line">            err = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 pinctrl_map 的 type 为 PIN_MAP_TYPE_MUX_GROUP，</span></span><br><span class="line">        <span class="comment">// 初始化 data.mux.group 为 grp-&gt;name;</span></span><br><span class="line">        <span class="comment">// 初始化 ata.mux.function 为 mtk_gpio_functions[fnum];</span></span><br><span class="line">        err = mtk_pctrl_dt_node_to_map_func(pctl, pin, func, grp, <span class="built_in">map</span>,</span><br><span class="line">                reserved_maps, num_maps);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (has_config) &#123; <span class="comment">//如果有 config 则设置 config 对应的 pinctrl_map</span></span><br><span class="line">            err = pinctrl_utils_add_map_configs(pctldev, <span class="built_in">map</span>,</span><br><span class="line">                    reserved_maps, num_maps, grp-&gt;name,</span><br><span class="line">                    configs, num_configs,</span><br><span class="line">                    PIN_MAP_TYPE_CONFIGS_GROUP);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    kfree(configs);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PIN_NO(x) ((x) &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_GET_PIN_NO(x) ((x) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_GET_PIN_FUNC(x) ((x) &amp; 0xf)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_GPIO0 (MTK_PIN_NO(0) | 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_MRG_SYNC (MTK_PIN_NO(0) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_PCM0_SYNC (MTK_PIN_NO(0) | 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_TP_GPIO0_AO (MTK_PIN_NO(0) | 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_SRCLKENAI0 (MTK_PIN_NO(0) | 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_SCP_SPI2_CS (MTK_PIN_NO(0) | 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_I2S3_MCK (MTK_PIN_NO(0) | 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_SPI2_CSB (MTK_PIN_NO(0) | 7)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="mtk-pctrl-dt-node-to-map-func"><a href="#mtk-pctrl-dt-node-to-map-func" class="headerlink" title="mtk_pctrl_dt_node_to_map_func"></a>mtk_pctrl_dt_node_to_map_func</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 pinctrl_map 的 type 为 PIN_MAP_TYPE_MUX_GROUP，</span></span><br><span class="line"><span class="comment">// 初始化 data.mux.group 为 grp-&gt;name;</span></span><br><span class="line"><span class="comment">// 初始化 ata.mux.function 为 mtk_gpio_functions[fnum];</span></span><br><span class="line"><span class="keyword">static</span> int mtk_pctrl_dt_node_to_map_func(<span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl</span></span> *pctl,</span><br><span class="line">        <span class="built_in">u32</span> pin, <span class="built_in">u32</span> fnum, <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl_group</span></span> *grp,</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span></span> **map, unsigned *reserved_maps,</span><br><span class="line">        unsigned *num_maps)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*num_maps == *reserved_maps)</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">    (*map)[*num_maps].<span class="keyword">type</span> = PIN_MAP_TYPE_MUX_GROUP; <span class="comment">// 初始化 pinctrl_map 的 type</span></span><br><span class="line">    (*map)[*num_maps].data.mux.group = grp-&gt;name; <span class="comment">//初始化 data.mux.group</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//该 pin 的引脚复用 fnum 有效性检查</span></span><br><span class="line">    ret = mtk_pctrl_is_function_valid(pctl, pin, fnum);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        dev_err(pctl-&gt;dev, <span class="string">&quot;invalid function %d on pin %d .\n&quot;</span>,</span><br><span class="line">                fnum, pin);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化对应 pin 脚复用的函数名</span></span><br><span class="line">    (*map)[*num_maps].data.mux.function = mtk_gpio_functions[fnum];</span><br><span class="line">    (*num_maps)++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mtk-pctrl-is-function-valid"><a href="#mtk-pctrl-is-function-valid" class="headerlink" title="mtk_pctrl_is_function_valid"></a>mtk_pctrl_is_function_valid</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该 pin_num 的引脚复用 fnum 有效性检查</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> mtk_pctrl_is_function_valid(<span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl</span></span> *pctl,</span><br><span class="line">        <span class="built_in">u32</span> pin_num, <span class="built_in">u32</span> fnum)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pctl-&gt;devdata-&gt;npins; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_pin</span></span> *pin = pctl-&gt;devdata-&gt;pins + i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pin-&gt;pin.number == pin_num) &#123; 找到该 pin 对应的 mtk_desc_pin</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span></span> *func =</span><br><span class="line">                    pin-&gt;functions; <span class="comment">//获取到对应的 functions</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (func &amp;&amp; func-&gt;name) &#123; <span class="comment">//查找对应的 functions 是否有对应的引脚复用 fnum</span></span><br><span class="line">                <span class="keyword">if</span> (func-&gt;muxval == fnum) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                func++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span> *name;</span><br><span class="line">    unsigned <span class="built_in">char</span> muxval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_pin</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span></span> pin;</span><br><span class="line">#ifdef CONFIG_MTK_EINT_MULTI_TRIGGER_DESIGN</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_eint</span></span> eint;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_eint</span></span> eint;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span></span>  *functions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span> *name;</span><br><span class="line">    unsigned <span class="built_in">char</span> muxval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pinctrl-utils-add-map-configs"><a href="#pinctrl-utils-add-map-configs" class="headerlink" title="pinctrl_utils_add_map_configs"></a>pinctrl_utils_add_map_configs</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_utils_add_map_configs</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *reserved_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> *num_maps, <span class="keyword">const</span> <span class="keyword">char</span> *group,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">enum</span> pinctrl_map_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *dup_configs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(*num_maps == *reserved_maps)) <span class="comment">//防止数组越界</span></span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">    dup_configs = kmemdup(configs, num_configs * <span class="keyword">sizeof</span>(*dup_configs),</span><br><span class="line">                  GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dup_configs) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;kmemdup(configs) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].type = type;</span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.configs.group_or_pin = group;</span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.configs.configs = dup_configs;</span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.configs.num_configs = num_configs;</span><br><span class="line">    (*num_maps)++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pinconf-generic-parse-dt-config"><a href="#pinconf-generic-parse-dt-config" class="headerlink" title="pinconf_generic_parse_dt_config"></a>pinconf_generic_parse_dt_config</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在设备节点 device_node 查找 dt_params 以及 pctldev-&gt;desc-&gt;custom_params 中的支持的引脚状态</span></span><br><span class="line"><span class="comment">// 如果存在则按顺寻将 params 和 custom_params 可配置的引脚状态参数 pin_config_param </span></span><br><span class="line"><span class="comment">// 以及配置的默认状态 default_value 组合后,存入 configs 指向的内存空间, 并返回 configs 的长度nconfigs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinconf_generic_parse_dt_config</span><span class="params">(struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> **configs,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> *nconfigs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *cfg;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_cfg, ncfg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!np)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a temporary array big enough to hold one of each option */</span></span><br><span class="line">    <span class="comment">//获取 dt_params 的中 config 的数量</span></span><br><span class="line">    max_cfg = ARRAY_SIZE(dt_params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pctldev) </span><br><span class="line">        max_cfg += pctldev-&gt;desc-&gt;num_custom_params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个 config 都由 unsigned long 表示，申请 max_cfg 个 unsigned long</span></span><br><span class="line">    cfg = kcalloc(max_cfg, <span class="keyword">sizeof</span>(*cfg), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!cfg)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查询设备节点 np 中存在的  params[] 数组中的属性，</span></span><br><span class="line">   <span class="comment">// 如果存在则按顺寻将该 params 可配置的引脚状态参数 pin_config_param </span></span><br><span class="line">   <span class="comment">// 以及配置的默认状态 default_value 组合后,存入 cfg 指向的内存空间, ncfg 表示 cfg 的长度</span></span><br><span class="line">    parse_dt_cfg(np, dt_params, ARRAY_SIZE(dt_params), cfg, &amp;ncfg);</span><br><span class="line">    <span class="keyword">if</span> (pctldev &amp;&amp; pctldev-&gt;desc-&gt;num_custom_params &amp;&amp; pctldev-&gt;desc-&gt;custom_params)</span><br><span class="line">        <span class="comment">//如果存在 custom_params 则同样查询该节点存在的属性，并返回其值</span></span><br><span class="line">        parse_dt_cfg(np, pctldev-&gt;desc-&gt;custom_params,</span><br><span class="line">                 pctldev-&gt;desc-&gt;num_custom_params, cfg, &amp;ncfg);</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no configs found at all */</span></span><br><span class="line">    <span class="keyword">if</span> (ncfg == <span class="number">0</span>) &#123;</span><br><span class="line">        *configs = <span class="literal">NULL</span>;</span><br><span class="line">        *nconfigs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now limit the number of configs to the real number of</span></span><br><span class="line"><span class="comment">     * found properties.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//为了节省内存空间，这里将值复制到 configs 之后释放掉 cfg 所占的多余的内存空间</span></span><br><span class="line">    *configs = kmemdup(cfg, ncfg * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!*configs) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *nconfigs = ncfg;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(cfg);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> property;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pin_config_param</span> <span class="title">param</span>;</span></span><br><span class="line">    u32 default_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件中定义的全局变量，表示支持的引脚状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> <span class="title">dt_params</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// bias-bus-hold 属性名，在设备树中使用该名字，</span></span><br><span class="line">    <span class="comment">// PIN_CONFIG_BIAS_BUS_HOLD 引脚的状态，</span></span><br><span class="line">    <span class="comment">// 0 引脚状态的值</span></span><br><span class="line">    &#123; <span class="string">&quot;bias-bus-hold&quot;</span>, PIN_CONFIG_BIAS_BUS_HOLD, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-disable&quot;</span>, PIN_CONFIG_BIAS_DISABLE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-high-impedance&quot;</span>, PIN_CONFIG_BIAS_HIGH_IMPEDANCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-pull-up&quot;</span>, PIN_CONFIG_BIAS_PULL_UP, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-pull-pin-default&quot;</span>, PIN_CONFIG_BIAS_PULL_PIN_DEFAULT, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-pull-down&quot;</span>, PIN_CONFIG_BIAS_PULL_DOWN, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-open-drain&quot;</span>, PIN_CONFIG_DRIVE_OPEN_DRAIN, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-open-source&quot;</span>, PIN_CONFIG_DRIVE_OPEN_SOURCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-push-pull&quot;</span>, PIN_CONFIG_DRIVE_PUSH_PULL, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-strength&quot;</span>, PIN_CONFIG_DRIVE_STRENGTH, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-debounce&quot;</span>, PIN_CONFIG_INPUT_DEBOUNCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-disable&quot;</span>, PIN_CONFIG_INPUT_ENABLE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-enable&quot;</span>, PIN_CONFIG_INPUT_ENABLE, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-schmitt&quot;</span>, PIN_CONFIG_INPUT_SCHMITT, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-schmitt-disable&quot;</span>, PIN_CONFIG_INPUT_SCHMITT_ENABLE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-schmitt-enable&quot;</span>, PIN_CONFIG_INPUT_SCHMITT_ENABLE, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;low-power-disable&quot;</span>, PIN_CONFIG_LOW_POWER_MODE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;low-power-enable&quot;</span>, PIN_CONFIG_LOW_POWER_MODE, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;output-high&quot;</span>, PIN_CONFIG_OUTPUT, <span class="number">1</span>, &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;output-low&quot;</span>, PIN_CONFIG_OUTPUT, <span class="number">0</span>, &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;power-source&quot;</span>, PIN_CONFIG_POWER_SOURCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;slew-rate&quot;</span>, PIN_CONFIG_SLEW_RATE, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="parse-dt-cfg"><a href="#parse-dt-cfg" class="headerlink" title="parse_dt_cfg"></a>parse_dt_cfg</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询设备节点np中存在的  params[count] 数组中的属性，</span></span><br><span class="line"><span class="comment">// 如果存在则按顺寻将该 params 可配置的引脚状态参数 pin_config_param </span></span><br><span class="line"><span class="comment">// 以及配置的默认状态 default_value 组合后,存入 cfg 指向的内存空间, 之后 ncfg 等于 cfg 数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse_dt_cfg</span><span class="params">(struct device_node *np, <span class="keyword">const</span> struct pinconf_generic_params *params, <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">unsigned</span> <span class="keyword">long</span> *cfg, <span class="keyword">unsigned</span> <span class="keyword">int</span> *ncfg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        u32 val;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="comment">//获取 params 中的 pinconf_generic_params</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">par</span> =</span> &amp;params[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从np节点中查询是存在该属性</span></span><br><span class="line">        ret = of_property_read_u32(np, par-&gt;property, &amp;val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不存在结束本次循环</span></span><br><span class="line">        <span class="comment">/* property not found */</span></span><br><span class="line">        <span class="keyword">if</span> (ret == -EINVAL)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* use default value, when no value is specified */</span></span><br><span class="line">        <span class="comment">//如果存在这个属性则获取这个default属性的值</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            val = par-&gt;default_value;</span><br><span class="line"></span><br><span class="line">        pr_debug(<span class="string">&quot;found %s with value %u\n&quot;</span>, par-&gt;property, val);</span><br><span class="line">        <span class="comment">//将该params可配置的引脚状态参数 pin_config_param 以及配置的默认状态组合后写入到cfg所在的内存空间。</span></span><br><span class="line">        cfg[*ncfg] = pinconf_to_config_packed(par-&gt;param, val);</span><br><span class="line">        (*ncfg)++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">pinconf_to_config_packed</span><span class="params">(<span class="keyword">enum</span> pin_config_param param,</span></span></span><br><span class="line"><span class="function"><span class="params">                             u16 argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PIN_CONF_PACKED(param, argument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_CONF_PACKED(p, a) ((a &lt;&lt; 16) | ((unsigned long) p &amp; 0xffffUL))</span></span><br></pre></td></tr></table></figure>
<h3 id="pinctrl-utils-reserve-map"><a href="#pinctrl-utils-reserve-map" class="headerlink" title="pinctrl_utils_reserve_map"></a>pinctrl_utils_reserve_map</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新申请一片大小为 *num_maps + reserve 的内存空间，并将 map 的值复制过去，</span></span><br><span class="line"><span class="comment">// reserved_maps 之后的内存空间初始化为 0, 同时更新 pinctrl_map 的数量 reserved_maps</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_utils_reserve_map</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *reserved_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> *num_maps, <span class="keyword">unsigned</span> reserve)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> old_num = *reserved_maps; <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> new_num = *num_maps + reserve; <span class="comment">// </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">new_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_num &gt;= new_num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    new_map = krealloc(*<span class="built_in">map</span>, <span class="keyword">sizeof</span>(*new_map) * new_num, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new_map) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;krealloc(map) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(new_map + old_num, <span class="number">0</span>, (new_num - old_num) * <span class="keyword">sizeof</span>(*new_map));</span><br><span class="line"></span><br><span class="line">    *<span class="built_in">map</span> = new_map;</span><br><span class="line">    *reserved_maps = new_num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="mtk-pctrl-find-group-by-pin"><a href="#mtk-pctrl-find-group-by-pin" class="headerlink" title="mtk_pctrl_find_group_by_pin"></a>mtk_pctrl_find_group_by_pin</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mtk_pinctrl_group * <span class="title">mtk_pctrl_find_group_by_pin</span><span class="params">(struct mtk_pinctrl *pctl, u32 pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pctl-&gt;ngroups; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl_group</span> *<span class="title">grp</span> =</span> pctl-&gt;groups + i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grp-&gt;pin == pin)</span><br><span class="line">            <span class="keyword">return</span> grp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl_group</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   config;</span><br><span class="line">    <span class="keyword">unsigned</span>    pin;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="dt-remember-or-free-map"><a href="#dt-remember-or-free-map" class="headerlink" title="dt_remember_or_free_map"></a>dt_remember_or_free_map</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> int dt_remember_or_free_map(<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span></span> *p, <span class="keyword">const</span> <span class="built_in">char</span> *statename,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span></span> *pctldev,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span></span> *map, unsigned num_maps)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dt_map</span></span> *dt_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize common mapping table entry fields */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line">        map[i].dev_name = dev_name(p-&gt;dev); <span class="comment">//初始化 pinctrl_map 所属的 dev_name</span></span><br><span class="line">        map[i].name = statename; <span class="comment">//初始化 name</span></span><br><span class="line">        <span class="keyword">if</span> (pctldev)</span><br><span class="line">            map[i].ctrl_dev_name = dev_name(pctldev-&gt;dev); <span class="comment">//设置所属的 pinctrl_dev 的 name</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remember the converted mapping table entries */</span></span><br><span class="line">    dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dt_map) &#123;</span><br><span class="line">        dev_err(p-&gt;dev, <span class="string">&quot;failed to alloc struct pinctrl_dt_map\n&quot;</span>);</span><br><span class="line">        dt_free_map(pctldev, map, num_maps);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 pinctrl_dt_map </span></span><br><span class="line">    dt_map-&gt;pctldev = pctldev; </span><br><span class="line">    dt_map-&gt;map = map;</span><br><span class="line">    dt_map-&gt;num_maps = num_maps;</span><br><span class="line">    list_add_tail(&amp;dt_map-&gt;node, &amp;p-&gt;dt_maps); <span class="comment">//将 dt_map 挂接到所属的 pinctrl</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pinctrl_register_map(map, num_maps, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pinctrl-register-map"><a href="#pinctrl-register-map" class="headerlink" title="pinctrl_register_map"></a>pinctrl_register_map</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int pinctrl_register_map(struct pinctrl_map <span class="keyword">const</span> *maps, unsigned num_maps,</span><br><span class="line">             bool dup)</span><br><span class="line">&#123;</span><br><span class="line">    int i, ret;</span><br><span class="line">    struct pinctrl_maps *maps_node;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;add %u pinctrl maps\n&quot;</span>, num_maps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First sanity check the new mapping */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!maps[i].dev_name) &#123; <span class="comment">//每一个 map 都要有所属的设备</span></span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %s (%d): no device given\n&quot;</span>,</span><br><span class="line">                   maps[i].name, i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!maps[i].name) &#123; <span class="comment">//每一个 map 都要有对应的 state</span></span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %d: no map name given\n&quot;</span>,</span><br><span class="line">                   i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当 map 的类型不为 PIN_MAP_TYPE_DUMMY_STAT ，map 必须要有所属的 pinctl_dev</span></span><br><span class="line">        <span class="keyword">if</span> (maps[i].type != PIN_MAP_TYPE_DUMMY_STATE &amp;&amp;</span><br><span class="line">                !maps[i].ctrl_dev_name) &#123; E</span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %s (%d): no pin control device given\n&quot;</span>,</span><br><span class="line">                   maps[i].name, i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (maps[i].type) &#123;</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_DUMMY_STATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">            ret = pinmux_validate_map(&amp;maps[i], i); <span class="comment">//检查 map-&gt;data.mux.function 是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">            ret = pinconf_validate_map(&amp;maps[i], i);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %s (%d): invalid type given\n&quot;</span>,</span><br><span class="line">                   maps[i].name, i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//动态创建一个 maps_node 用于挂接 pinctrl_maps</span></span><br><span class="line">    maps_node = kzalloc(sizeof(*maps_node), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!maps_node) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;failed to alloc struct pinctrl_maps\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maps_node-&gt;num_maps = num_maps; </span><br><span class="line">    <span class="keyword">if</span> (dup) &#123;</span><br><span class="line">        maps_node-&gt;maps = kmemdup(maps, sizeof(*maps) * num_maps,</span><br><span class="line">                      GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!maps_node-&gt;maps) &#123;</span><br><span class="line">            pr_err(<span class="string">&quot;failed to duplicate mapping table\n&quot;</span>);</span><br><span class="line">            kfree(maps_node);</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maps_node-&gt;maps = maps; <span class="comment">//跑这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line">    list_add_tail(&amp;maps_node-&gt;node, &amp;pinctrl_maps); <span class="comment">//将 maps_node 链接到全局 pinctrl_maps</span></span><br><span class="line">    mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add-setting"><a href="#add-setting" class="headerlink" title="add_setting"></a>add_setting</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_setting</span><span class="params">(struct pinctrl *p, struct pinctrl_map <span class="keyword">const</span> *<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> *<span class="title">setting</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取对应的 state</span></span><br><span class="line">    state = find_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="comment">// 如果没有 state 则创建</span></span><br><span class="line">        state = create_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(state))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type == PIN_MAP_TYPE_DUMMY_STATE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 pinctrl_setting</span></span><br><span class="line">    setting = kzalloc(<span class="keyword">sizeof</span>(*setting), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (setting == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(p-&gt;dev,</span><br><span class="line">            <span class="string">&quot;failed to alloc struct pinctrl_setting\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 type</span></span><br><span class="line">    setting-&gt;type = <span class="built_in">map</span>-&gt;type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    setting-&gt;pctldev = get_pinctrl_dev_from_devname(<span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line">    <span class="keyword">if</span> (setting-&gt;pctldev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        kfree(setting);</span><br><span class="line">        <span class="comment">/* Do not defer probing of hogs (circular loop) */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;ctrl_dev_name, <span class="built_in">map</span>-&gt;dev_name))</span><br><span class="line">            <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * OK let us guess that the driver is not there yet, and</span></span><br><span class="line"><span class="comment">         * let&#x27;s defer obtaining this pinctrl handle to later...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dev_info(p-&gt;dev, <span class="string">&quot;unknown pinctrl device %s in map entry, deferring probe&quot;</span>,</span><br><span class="line">            <span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line">        <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setting-&gt;dev_name = <span class="built_in">map</span>-&gt;dev_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">map</span>-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">         <span class="comment">//初始化 setting-&gt;data.mux.func 和 setting-&gt;data.mux.group</span></span><br><span class="line">        ret = pinmux_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ret = pinconf_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(setting);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;setting-&gt;node, &amp;state-&gt;settings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create-state"><a href="#create-state" class="headerlink" title="create_state"></a>create_state</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">static struct pinctrl_state *create_state(struct pinctrl *p,</span><br><span class="line">                      <span class="keyword">const</span> char *name)</span><br><span class="line">&#123;</span><br><span class="line">    struct pinctrl_state *<span class="keyword">state</span>;</span><br><span class="line"></span><br><span class="line">	//创建一个 <span class="keyword">state</span></span><br><span class="line">    <span class="keyword">state</span> = kzalloc(sizeof(*<span class="keyword">state</span>), GFP_KERNEL);</span><br><span class="line">    if (<span class="keyword">state</span> == NULL) &#123;</span><br><span class="line">        dev_err(p-&gt;dev,</span><br><span class="line">            <span class="string">&quot;failed to alloc struct pinctrl_state\n&quot;</span>);</span><br><span class="line">        return ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;name = name; //初始化 name</span><br><span class="line">    INIT_LIST_HEAD(&amp;state-&gt;settings);</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;state-&gt;node, &amp;p-&gt;states); //将其挂接到所属 pinctl 的states</span><br><span class="line"></span><br><span class="line">    return <span class="keyword">state</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pinmux-map-to-setting"><a href="#pinmux-map-to-setting" class="headerlink" title="pinmux_map_to_setting"></a>pinmux_map_to_setting</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">int pinmux_map_to_setting(struct pinctrl_map const *map,</span><br><span class="line">              struct pinctrl_setting *setting)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">struct</span> pinctrl_dev *pctldev = setting-&gt;</span>pctldev;</span><br><span class="line">    <span class="function"><span class="title">const</span> struct pinmux_ops *pmxops = pctldev-&gt;</span><span class="function"><span class="title">desc</span>-&gt;</span>pmxops;</span><br><span class="line">    char const * const *groups;</span><br><span class="line">    unsigned num_groups;</span><br><span class="line">    int ret;</span><br><span class="line">    const char *group;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pmxops) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev, <span class="string">&quot;does not support mux function\n&quot;</span>);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回 function 的数组下标</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = pinmux_func_name_to_selector(pctldev, map-&gt;</span><span class="keyword">data</span>.mux.function);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev, <span class="string">&quot;invalid function %s in map table\n&quot;</span>,</span><br><span class="line">            <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.mux.function);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将其赋值给对应的 setting</span></span><br><span class="line">    <span class="function"><span class="title">setting</span>-&gt;</span><span class="keyword">data</span>.mux.func = ret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ret</span> = pmxops-&gt;</span><span class="function"><span class="title">get_function_groups</span>(pctldev, setting-&gt;</span><span class="keyword">data</span>.mux.func,</span><br><span class="line">                      &amp;groups, &amp;num_groups);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev, <span class="string">&quot;can&#x27;t query groups for function %s\n&quot;</span>,</span><br><span class="line">            <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.mux.function);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!num_groups) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev,</span><br><span class="line">            <span class="string">&quot;function %s can&#x27;t be selected on any group\n&quot;</span>,</span><br><span class="line">            <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.mux.function);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (map-&gt;</span><span class="keyword">data</span>.mux.group) &#123;</span><br><span class="line">        bool found = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="title">group</span> = map-&gt;</span><span class="keyword">data</span>.mux.group;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_groups; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!strcmp(group, groups[i])) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev,</span><br><span class="line">                <span class="string">&quot;invalid group \&quot;</span>%s\<span class="string">&quot; for function \&quot;</span>%s\<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                <span class="function"><span class="title">group</span>, map-&gt;</span><span class="keyword">data</span>.mux.function);</span><br><span class="line">            return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        group = groups[<span class="number">0</span>]; <span class="comment">// 初始化 group </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pinctrl_get_group_selector(pctldev, group);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev, <span class="string">&quot;invalid group %s in map table\n&quot;</span>,</span><br><span class="line">            <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.mux.group);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setting</span>-&gt;</span><span class="keyword">data</span>.mux.group = ret;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pinmux-func-name-to-selector"><a href="#pinmux-func-name-to-selector" class="headerlink" title="pinmux_func_name_to_selector"></a>pinmux_func_name_to_selector</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="function"><span class="keyword">function</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> struct pinmux_ops *ops = pctldev-&gt;desc-&gt;pmxops;</span><br><span class="line">    <span class="keyword">unsigned</span> nfuncs = ops-&gt;get_functions_count(pctldev); <span class="comment">//获取 functions 的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> selector = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if this pctldev has this function */</span></span><br><span class="line">    <span class="keyword">while</span> (selector &lt; nfuncs) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *fname = ops-&gt;get_function_name(pctldev, selector); <span class="comment">//返回 selector 下标中的 func name</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strcmp(<span class="function"><span class="keyword">function</span>, <span class="title">fname</span>))</span></span><br><span class="line"><span class="function">            <span class="title">return</span> <span class="title">selector</span></span>; <span class="comment">//返回数组下标</span></span><br><span class="line"></span><br><span class="line">        selector++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_err(pctldev-&gt;dev, <span class="string">&quot;function &#x27;%s&#x27; not supported\n&quot;</span>, <span class="function"><span class="keyword">function</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pinctrl-get-group-selector"><a href="#pinctrl-get-group-selector" class="headerlink" title="pinctrl_get_group_selector"></a>pinctrl_get_group_selector</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">int pinctrl_get_group_selector(<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span></span> *pctldev,</span><br><span class="line">                   <span class="keyword">const</span> <span class="built_in">char</span> *pin_group)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span></span> *pctlops = pctldev-&gt;desc-&gt;pctlops; </span><br><span class="line">    unsigned ngroups = pctlops-&gt;get_groups_count(pctldev); <span class="comment">//返回 group 的大小</span></span><br><span class="line">    unsigned group_selector = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (group_selector &lt; ngroups) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">char</span> *gname = pctlops-&gt;get_group_name(pctldev,</span><br><span class="line">                                group_selector);</span><br><span class="line">        <span class="keyword">if</span> (!strcmp(gname, pin_group)) &#123;</span><br><span class="line">            dev_dbg(pctldev-&gt;dev,</span><br><span class="line">                <span class="string">&quot;found group selector %u for %s\n&quot;</span>,</span><br><span class="line">                group_selector,</span><br><span class="line">                pin_group);</span><br><span class="line">            <span class="keyword">return</span> group_selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group_selector++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_err(pctldev-&gt;dev, <span class="string">&quot;does not have pin group %s\n&quot;</span>,</span><br><span class="line">        pin_group);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pinconf-map-to-setting"><a href="#pinconf-map-to-setting" class="headerlink" title="pinconf_map_to_setting"></a>pinconf_map_to_setting</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">int pinconf_map_to_setting(struct pinctrl_map const *map,</span><br><span class="line">              struct pinctrl_setting *setting)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">struct</span> pinctrl_dev *pctldev = setting-&gt;</span>pctldev;</span><br><span class="line">    int pin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">switch</span> (setting-&gt;</span>type) &#123;</span><br><span class="line">    case PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">        pin = pin_get_from_name(pctldev,</span><br><span class="line">                    <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.configs.group_or_pin);</span><br><span class="line">        <span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev, <span class="string">&quot;could not map pin config for \&quot;</span>%s\<span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.configs.group_or_pin);</span><br><span class="line">            return pin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">setting</span>-&gt;</span><span class="keyword">data</span>.configs.group_or_pin = pin;</span><br><span class="line">        break;</span><br><span class="line">    case PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">        pin = pinctrl_get_group_selector(pctldev,</span><br><span class="line">                     <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.configs.group_or_pin);</span><br><span class="line">        <span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">dev_err</span>(pctldev-&gt;</span>dev, <span class="string">&quot;could not map group config for \&quot;</span>%s\<span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="function"><span class="title">map</span>-&gt;</span><span class="keyword">data</span>.configs.group_or_pin);</span><br><span class="line">            return pin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">setting</span>-&gt;</span><span class="keyword">data</span>.configs.group_or_pin = pin;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setting</span>-&gt;</span><span class="function"><span class="title">data</span>.configs.num_configs = map-&gt;</span><span class="keyword">data</span>.configs.num_configs;</span><br><span class="line">    <span class="function"><span class="title">setting</span>-&gt;</span><span class="function"><span class="title">data</span>.configs.configs = map-&gt;</span><span class="keyword">data</span>.configs.configs;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pin-get-from-name"><a href="#pin-get-from-name" class="headerlink" title="pin_get_from_name"></a>pin_get_from_name</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pin_get_from_name(struct pinctrl_dev *pctldev, const <span class="type">char</span> *<span class="type">name</span>)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned i, pin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The pin number can be retrived from the pin controller descriptor */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pctldev-&gt;<span class="keyword">desc</span>-&gt;npins; i++) &#123;</span><br><span class="line">        struct pin_desc *<span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">        pin = pctldev-&gt;<span class="keyword">desc</span>-&gt;pins[i].number;</span><br><span class="line">        <span class="keyword">desc</span> = pin_desc_get(pctldev, pin);</span><br><span class="line">        <span class="comment">/* Pin space may be sparse */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">desc</span> &amp;&amp; !strcmp(<span class="type">name</span>, <span class="keyword">desc</span>-&gt;<span class="type">name</span>))</span><br><span class="line">            <span class="keyword">return</span> pin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、使用-pinctrl"><a href="#五、使用-pinctrl" class="headerlink" title="五、使用 pinctrl"></a>五、使用 pinctrl</h1><p>使用就比较简单了接口如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前设备的 pinctrl 句柄</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl *pinctrl<span class="constructor">_get(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取我们需要设置的 state</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl_state *pinctrl<span class="constructor">_lookup_state(<span class="params">struct</span> <span class="params">pinctrl</span> <span class="operator">*</span><span class="params">p</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">name</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置为对应的state</span></span><br><span class="line"><span class="built_in">int</span> pinctrl<span class="constructor">_select_state(<span class="params">struct</span> <span class="params">pinctrl</span> <span class="operator">*</span><span class="params">p</span>, <span class="params">struct</span> <span class="params">pinctrl_state</span> <span class="operator">*</span><span class="params">state</span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>驱动</tag>
        <tag>pinctrl</tag>
      </tags>
  </entry>
</search>
