<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>番外篇-mtk平台logo显示接口</title>
    <url>/2021/07/03/mtk%E5%B9%B3%E5%8F%B0-lcd%E6%98%BE%E7%A4%BA%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>分析 mtk 平台 logo 显示接口, 自己实现一个显示 demo ，并利用 input 子系统在屏上绘图</p>
<a id="more"></a>

<h2 id="1、mtk提供了测试-demo"><a href="#1、mtk提供了测试-demo" class="headerlink" title="1、mtk提供了测试 demo"></a>1、mtk提供了测试 demo</h2><p>/vendor/mediatek/proprietary/external/libshowlogo/libshowlogoTest //路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;charging_animation.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERION_OLD_ANIMATION 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERION_NEW_ANIMATION 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERION_WIRELESS_CHARGING_ANIMATION  2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRAW_ANIM_MODE_FB       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRAW_ANIM_MODE_SURFACE  0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOG_ANIM(x...)     dprintf(0, x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_charging_animation</span><span class="params">(<span class="keyword">int</span> charging_item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(time &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charging_item == <span class="number">2</span>) &#123;</span><br><span class="line">            show_fast_charging(<span class="number">25</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            show_battery_capacity(<span class="number">25</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        time ++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// DRAW_ANIM_MODE_SURFACE 0</span></span><br><span class="line"><span class="comment">// DRAW_ANIM_MODE_FB  1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[logo_test %s %d]libshowlogo Test ...\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***************     libshowlogo Test       ********************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******     Testlibshowlogo  introduce...               *******\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It can test boot logo, kernel logo and charging animation using \n framebuffer or surface flinger with different parameters\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***************************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ---&gt; para 1:boot kernel charging ut\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    boot: boot logo\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    kernel: kernel logo \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    charging: charging animation\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    ut: test all\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ---&gt; para 2: fb sf \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    fb: framebuffer\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    sf: surface flinger\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ---&gt; para 3: new fast wireless \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    new: new version\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    fast: fast Charging\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    wireless: wireless Charging\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n ---&gt; Example (Default):libshowlogoTest boot  sf\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**************************************************************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> draw_mode = DRAW_ANIM_MODE_SURFACE;</span><br><span class="line">    <span class="keyword">int</span> version = VERION_OLD_ANIMATION;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> test_item = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> charging_item = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[logo_test %s %d] argv[1]=%s\n&quot;</span>,__FUNCTION__,__LINE__,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;boot&quot;</span>))&#123;</span><br><span class="line">            test_item = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;kernel&quot;</span>))&#123;</span><br><span class="line">            test_item = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;charging&quot;</span>))&#123;</span><br><span class="line">            test_item = <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;ut&quot;</span>))&#123;</span><br><span class="line">            test_item = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[logo_test %s %d] argv[2]=%s\n&quot;</span>,__FUNCTION__,__LINE__,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;sf&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">       	    draw_mode = DRAW_ANIM_MODE_SURFACE;</span><br><span class="line">       	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;fb&quot;</span>))&#123;</span><br><span class="line">       	    draw_mode = DRAW_ANIM_MODE_FB;</span><br><span class="line">       	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[logo_test %s %d] argv[3]=%s\n&quot;</span>,__FUNCTION__,__LINE__,argv[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">3</span>],<span class="string">&quot;new&quot;</span>))&#123;</span><br><span class="line">            version = VERION_NEW_ANIMATION;</span><br><span class="line">            charging_item = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">3</span>],<span class="string">&quot;fast&quot;</span>))&#123;</span><br><span class="line">            version = VERION_NEW_ANIMATION;</span><br><span class="line">            charging_item = <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">3</span>],<span class="string">&quot;wireless&quot;</span>))&#123;</span><br><span class="line">            version = VERION_WIRELESS_CHARGING_ANIMATION;</span><br><span class="line">            charging_item = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[logo_test %s %d] argc =%d, draw_mode=%d,test_item=%d, version=%d, charging_item=%d\n&quot;</span></span><br><span class="line">        ,__FUNCTION__,__LINE__,argc, draw_mode,test_item,version,charging_item);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// set parameter before init</span></span><br><span class="line">    set_draw_mode(draw_mode);</span><br><span class="line">    set_anim_version(version);</span><br><span class="line">    anim_init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[logo_test %s %d]libshowlogo Test start...\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(test_item)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            show_boot_logo();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            show_kernel_logo();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            test_charging_animation(charging_item);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            show_boot_logo();</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            show_kernel_logo();</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            show_low_battery();</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            show_charger_ov_logo();</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            test_charging_animation(charging_item);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            show_low_battery();</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    anim_deinit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出来代码一共提供了两个接口来显示图片，分别是fb(framebuff)与sf(surface flinger)，此处对于sf不做深究，等以后有时间了在研究。跟踪代码发现，show_boot_logo，show_kernel_logo，test_charging_animation，最终都是调用了函数anim_show_logo于是，简化代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//logo显示初始化</span></span><br><span class="line">    set_draw_mode(DRAW_ANIM_MODE_FB);</span><br><span class="line">    set_anim_version(VERION_NEW_ANIMATION);</span><br><span class="line">    anim_init(); <span class="comment">// 获取 logo 相关地址以及映射 framebuffer 地址等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向 fb 写入对应的图片，同时显示该图片</span></span><br><span class="line">    anim_show_logo(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放init获取的数据结构</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    anim_deinit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码就能显示索引为 index 的图片，图片是怎么索引的呢？后文给出答案</p>
<h2 id="2、选择使用开机-logo"><a href="#2、选择使用开机-logo" class="headerlink" title="2、选择使用开机 logo"></a>2、选择使用开机 logo</h2><p>在路径 /vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo 下有很多logo 文件存放不同分辨率的图片</p>
<p><img width=600 src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mtk-logo/1.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1602580658;2466494258&q-key-time=1602580658;2466494258&q-header-list=&q-url-param-list=&q-signature=6acb057d0dc7600f2930312c87c2d5f34fae06cd
" ></p>
<p>他们之间的区别就是分辨率不同，我们选择使用的文件是和我们lcd屏分辨率相同的，如果logo的分辨率和lcd的分辨率对不上开机就会出现显示不全或者显示位置不对的问题。怎么确定每个文件的分辨率，一般有两个方法，复制其中的文件名直接百度，二就是用画图工具打开，看分辨率如下</p>
<p><img width=700 src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mtk-logo/2.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1602582954;2466496554&q-key-time=1602582954;2466496554&q-header-list=&q-url-param-list=&q-signature=646e9394d9c44ab8fc07436cc47d3278f744087e
" ></p>
<p>图片的下面一行显示了图片的分辨率为1080x1920，这个也是lcd的分辨率，如果已有的分辨率的图片没有和lcd相符合的怎么办呢，方法很简单，就是复制一份现有的，然后用画图工具，修改分辨率为自己需要的的就好了，当然了别忘了重命名。文件名是很重要的，代码就是通过文件名来找到对应的图片文件对其进行编译。<br>怎么使用这里面的文件呢，分别在lk和device配置 BOOT_LOGO 这个宏:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/vendor/mediatek/proprietary/bootable/bootloader/lk/project/tb8768tp1_64_bsp.mk <span class="comment">//路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略部分内容</span></span><br><span class="line">......</span><br><span class="line">BOOT_LOGO := wxga <span class="comment">//配置为要用到的logo文件夹名称</span></span><br><span class="line">DEBUG := <span class="number">2</span></span><br><span class="line">#DEFINES += WITH_DEBUG_DCC=<span class="number">1</span></span><br><span class="line">DEFINES += WITH_DEBUG_UART=<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">配置device</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/device/mediateksample/tb8768p1_64_bsp/ProjectConfig.mk <span class="comment">//路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略部分内容</span></span><br><span class="line">......</span><br><span class="line">BOOT_LOGO = wxga <span class="comment">//配置为要用到的logo文件夹</span></span><br><span class="line">BUILD_AGO_GMS = no</span><br><span class="line">BUILD_KERNEL = yes</span><br><span class="line">BUILD_LK = yes</span><br><span class="line">BUILD_MD32 = no</span><br><span class="line">BUILD_MTK_SDK =</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>device和lk要同时配置成一样的，如果没有配成一样的也没关系，编译器会告诉你，编译会报错。这里的配置决定了使用哪个文件夹的图片，上述配置使用的是 wxga </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make lk -j8 <span class="comment">//安卓9编译方式</span></span><br><span class="line"></span><br><span class="line">make vnd_images <span class="comment">//安卓11编译方式</span></span><br></pre></td></tr></table></figure>
<h2 id="3、新增自己的图片"><a href="#3、新增自己的图片" class="headerlink" title="3、新增自己的图片"></a>3、新增自己的图片</h2><p>如果我想显示一张里面没有的图片怎么新增呢，首先将我们要的图片做好，然后分辨率改成lcd相同的分辨率放入文件中</p>
<img width=700 src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mtk-logo/4.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1602655665;2466569265&q-key-time=1602655665;2466569265&q-header-list=&q-url-param-list=&q-signature=8a681f2ed06b6c9a79b0b698e1dbd2c0c77f2971" >

<p>图中 wxga_updata.bmp 为新增的图片，增加了图片还需要编译到它，在rules.mk 进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/rules.mk</span><br></pre></td></tr></table></figure>
<p>直接附上文件内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOCAL_DIR := $(GET_LOCAL_DIR)</span><br><span class="line">BOOT_LOGO_DIR := $(LOCAL_DIR)</span><br><span class="line"></span><br><span class="line"><span class="meta">#fix no boot_logo config</span></span><br><span class="line">#LOCAL_CFLAGS += -DBOOT_LOGO=wvga</span><br><span class="line"></span><br><span class="line">ifeq ($(strip $(BOOT_LOGO)),)</span><br><span class="line">  BOOT_LOGO = fwvga</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(strip $(MTK_LK_CAMERA_SUPPORT)), yes)</span><br><span class="line">  BOOT_LOGO = fhd</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(info BOOT_LOGO = $(BOOT_LOGO))</span><br><span class="line">$(info lk/logo/dir=$(LOCAL_DIR),builddir=$(BUILDDIR))</span><br><span class="line"></span><br><span class="line">ifeq ($(HOST_OS),darwin)</span><br><span class="line">BMP_TO_RAW := $(BOOT_LOGO_DIR)/tool/bmp_to_raw.darwin</span><br><span class="line">ZPIPE := $(BOOT_LOGO_DIR)/tool/zpipe.darwin</span><br><span class="line">MKIMG := $(LOCAL_DIR)/../../scripts/mkimage.darwin</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">BMP_TO_RAW := $(BOOT_LOGO_DIR)/tool/bmp_to_raw</span><br><span class="line">ZPIPE := $(BOOT_LOGO_DIR)/tool/zpipe</span><br><span class="line">MKIMG := $(LOCAL_DIR)/../../scripts/mkimage</span><br><span class="line">endif</span><br><span class="line">IMG_HDR_CFG := $(LOCAL_DIR)/img_hdr_logo.cfg</span><br><span class="line"></span><br><span class="line">EMPTY :=</span><br><span class="line">UNDER_LINE := _</span><br><span class="line">TEMP := $(strip $(subst $(UNDER_LINE), $(EMPTY), $(BOOT_LOGO)))</span><br><span class="line">COUNT := $(words $(TEMP))</span><br><span class="line">BASE_LOGO := $(word $(COUNT),$(TEMP))</span><br><span class="line">EXIST := $(shell <span class="keyword">if</span> [ -e $(BOOT_LOGO_DIR)/$(BASE_LOGO) ]; then echo <span class="string">&quot;exist&quot;</span>; <span class="keyword">else</span> echo <span class="string">&quot;noexist&quot;</span>; fi;)</span><br><span class="line">ifeq ($(EXIST), <span class="string">&quot;noexist&quot;</span>)</span><br><span class="line">  BASE_LOGO := $(BOOT_LOGO)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">SUPPORT_PUMP_EXPRESS = no</span><br><span class="line">ifeq ($(strip $(MTK_PUMP_EXPRESS_SUPPORT)), yes)</span><br><span class="line">  SUPPORT_PUMP_EXPRESS = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ifeq ($(strip $(MTK_PUMP_EXPRESS_PLUS_SUPPORT)), yes)</span><br><span class="line">    SUPPORT_PUMP_EXPRESS = yes</span><br><span class="line">  endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">BOOT_LOGO_RESOURCE := $(BUILDDIR)/$(BOOT_LOGO_DIR)/$(BOOT_LOGO).raw</span><br><span class="line">LOGO_IMAGE := $(BUILDDIR)/logo.bin</span><br><span class="line"></span><br><span class="line">SUPPORT_PROTOCOL1_RAT_CONFIG = no</span><br><span class="line">SUPPORT_CARRIEREXPRESS_PACK = no</span><br><span class="line">ifdef MTK_CARRIEREXPRESS_PACK</span><br><span class="line">ifneq ($(strip $(MTK_CARRIEREXPRESS_PACK)), no)</span><br><span class="line">	SUPPORT_CARRIEREXPRESS_PACK = yes</span><br><span class="line">	RAT_CONFIG = $(strip $(MTK_PROTOCOL1_RAT_CONFIG))</span><br><span class="line">	ifneq (,$(RAT_CONFIG))</span><br><span class="line">		ifneq (,$(findstring L,$(RAT_CONFIG)))</span><br><span class="line">			SUPPORT_PROTOCOL1_RAT_CONFIG = yes</span><br><span class="line">		endif</span><br><span class="line">	endif</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(strip $(SUPPORT_CARRIEREXPRESS_PACK)),yes) </span><br><span class="line">RESOLUTION := $(word $(COUNT),$(TEMP))</span><br><span class="line">RESOURCE_OBJ_LIST :=   \</span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_uboot.raw <span class="comment">//第1张图片</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">RESOURCE_OBJ_LIST :=   \</span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_uboot.raw <span class="comment">//第1张图片</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifneq ($(strip $(MACH_TYPE)), <span class="number">2701</span>)</span><br><span class="line">ifneq ($(strip $(MTK_ALPS_BOX_SUPPORT)), yes)</span><br><span class="line">RESOURCE_OBJ_LIST +=   \</span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_battery.raw \			<span class="comment">// 第2张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_low_battery.raw \		<span class="comment">// 第3张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_charger_ov.raw \			<span class="comment">// 第4张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_0.raw \				<span class="comment">// 第5张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_1.raw \				<span class="comment">// 第6张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_2.raw \				<span class="comment">// 第7张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_3.raw \				<span class="comment">// 第8张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_4.raw \				<span class="comment">// 第9张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_5.raw \				<span class="comment">// 第10张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_6.raw \				<span class="comment">// 第11张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_7.raw \				<span class="comment">// 第12张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_8.raw \				<span class="comment">// 第13张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_9.raw \				<span class="comment">// 第14张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_num_percent.raw \		<span class="comment">// 第15张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_01.raw \	<span class="comment">// 第16张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_02.raw \	<span class="comment">// 第17张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_03.raw \	<span class="comment">// 第18张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_04.raw \	<span class="comment">// 第19张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_05.raw \	<span class="comment">// 第20张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_06.raw \	<span class="comment">// 第21张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_07.raw \	<span class="comment">// 第22张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_08.raw \	<span class="comment">// 第23张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_09.raw \	<span class="comment">// 第24张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_animation_10.raw \	<span class="comment">// 第25张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_01.raw \			<span class="comment">// 第26张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_02.raw \			<span class="comment">// 第27张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_03.raw \			<span class="comment">// 第28张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_04.raw \			<span class="comment">// 第29张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_05.raw \			<span class="comment">// 第30张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_06.raw \			<span class="comment">// 第31张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_07.raw \			<span class="comment">// 第32张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_08.raw \			<span class="comment">// 第33张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_09.raw \			<span class="comment">// 第34张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_10_10.raw \			<span class="comment">// 第35张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_bg.raw \				<span class="comment">// 第36张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_img.raw \			<span class="comment">// 第37张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_bat_100.raw				<span class="comment">// 第39张</span></span><br><span class="line">ifeq ($(strip $(SUPPORT_CARRIEREXPRESS_PACK)),yes)</span><br><span class="line">RESOURCE_OBJ_LIST +=   \</span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_kernel.raw				<span class="comment">//第39张</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">RESOURCE_OBJ_LIST +=   \</span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_kernel.raw				<span class="comment">//第39张</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">RESOURCE_OBJ_LIST +=   \</span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_low_battery01.raw \		<span class="comment">//第40张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_low_battery02.raw \		<span class="comment">//第41张</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_low_battery_remind.raw	<span class="comment">//第42张</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">RESOURCE_OBJ_LIST +=   \</span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_updata.raw	\			<span class="comment">//第43张，后面省略</span></span><br><span class="line">            $(BOOT_LOGO_DIR)/$(BASE_LOGO)/$(BASE_LOGO)_power_off.raw</span><br><span class="line">endif</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>上面有两个第1张和39张，这两个是二选一，最终只会编译一个，可以看见我将新增的图片放在第43张，图片的顺序就是参数index的值，因此index就为42(index是从0开始的因此第一张图片是index 0)。为什么把图片放在这个位置，因为后面的图片，我这个项目用不着，不会影响前面图片的显示。自己添加的图片尽量加在最后面，这样不会影响前面的图片显示。显示新增的图片代码应该如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//logo显示初始化</span></span><br><span class="line">    set_draw_mode(DRAW_ANIM_MODE_FB);</span><br><span class="line">    set_anim_version(VERION_NEW_ANIMATION);</span><br><span class="line">    anim_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示索引index的图片</span></span><br><span class="line">    anim_show_logo(<span class="number">42</span>); <span class="comment">//这里的42就是我们新增的图片了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放init获取的数据结构</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    anim_deinit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：我们如果要替换里面的图片，一定要删除 out 目录下已经生成的图片bin文件，可能不会生效，重新编译才会生效！！！。</strong></p>
</blockquote>
<h2 id="4、调用简单分析"><a href="#4、调用简单分析" class="headerlink" title="4、调用简单分析"></a>4、调用简单分析</h2><p>对于这个anim_show_logo函数最终是怎么显示图片的呢，我们知道想让lcd显示图片只需将图片写入framebuff，soc的lcd控制器就会帮我们将图片显示出来，对于 anim_show_logo fb调用链如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">anim_show_logo-&gt;</span><br><span class="line">    fill_animation_logo-&gt;</span><br><span class="line">        这里省略中间调用最后会调用内核的</span><br><span class="line">            mtkfb_pan_display_proxy-&gt;</span><br><span class="line">                mtkfb_pan_display_impl-&gt;</span><br><span class="line">                    primary_display_trigger-&gt;</span><br><span class="line">                        primary_display_trigger_nolock <span class="comment">//这个函数 </span></span><br></pre></td></tr></table></figure>
<p>对于sf的调用链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">anim_show_logo-&gt;</span><br><span class="line">        这里省略中间调用最后会调用内核的</span><br><span class="line">            primary_display_frame_cfg-&gt;</span><br><span class="line">            primary_display_trigger_nolock <span class="comment">//这个函数 </span></span><br></pre></td></tr></table></figure>
<p>中间省略是因为水平有限，懒得跟代码，我们发现无论是fb 还是 sf显示最终都调用了primary_display_trigger_nolock 这个函数，这个函数的路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/kernel<span class="number">-4.9</span>/drivers/misc/mediatek/video/mt6765/videox/primary_display.c</span><br></pre></td></tr></table></figure>
<p>关于充电动画的文件路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/vendor/mediatek/proprietary/external/libshowlogo/show_animation_common.c</span><br></pre></td></tr></table></figure>
<h2 id="5、源码阅读"><a href="#5、源码阅读" class="headerlink" title="5、源码阅读"></a>5、源码阅读</h2><p>源码阅读不排版当手册用</p>
<h3 id="1-LCM-SCREEN-T"><a href="#1-LCM-SCREEN-T" class="headerlink" title="1) LCM_SCREEN_T"></a>1) LCM_SCREEN_T</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dedfine the LCM SCREEM parameters</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="keyword">int</span>         width;</span><br><span class="line">     <span class="keyword">int</span>         height;</span><br><span class="line">     <span class="keyword">int</span>         bits_per_pixel;  <span class="comment">// 每个像素多少 bpp ，单位 bit</span></span><br><span class="line">     <span class="keyword">int</span>         rotation;                  <span class="comment">// phical screen rotation:0 , 90, 180, 270</span></span><br><span class="line">     <span class="keyword">int</span>         needAllign;                <span class="comment">// if need adjust the width or height with 32: no need  (0), need (1)</span></span><br><span class="line">     <span class="keyword">int</span>         allignWidth;</span><br><span class="line">     <span class="keyword">int</span>         need180Adjust;             <span class="comment">// if need adjust the drawing logo for 180 roration: no need  (0), need (1)</span></span><br><span class="line">     <span class="keyword">int</span>         fb_size;</span><br><span class="line">     <span class="keyword">int</span>         fill_dst_bits;</span><br><span class="line">     <span class="keyword">int</span>         red_offset;                <span class="comment">// if red_offset is 0: logo use format BGR565 or ABGR8888,  red_offset is 11/16: RGB565, ARGB8888</span></span><br><span class="line">     <span class="keyword">int</span>         blue_offset;               <span class="comment">// if blue_offset is 11/16: logo use format BGR565 or ABGR8888,  blue_offset is 0: RGB565, ARGB8888</span></span><br><span class="line">&#125; LCM_SCREEN_T;</span><br></pre></td></tr></table></figure>
<h3 id="2-anim-logo-init"><a href="#2-anim-logo-init" class="headerlink" title="2) anim_logo_init"></a>2) anim_logo_init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anim_logo_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read and de-compress logo data here</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Fstab fstab;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadDefaultFstab(&amp;fstab)) &#123; </span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;failed to open fstab\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        error_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rec = GetEntryForMountPoint(&amp;fstab, LOGO_MNT_POINT);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;failed to get entry for %s\n&quot;</span>, LOGO_MNT_POINT);</span><br><span class="line">        &#125;</span><br><span class="line">        error_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;rec-&gt;blk_device&quot; is the path</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rec-&gt;blk_device: %s\n&quot;</span>,rec-&gt;blk_device.c_str()); <span class="comment">// 获取 logo 的设备路径</span></span><br><span class="line">    fd = open(rec-&gt;blk_device.c_str(), O_RDONLY);  <span class="comment">// 打开 logo 文件是一个块设备</span></span><br><span class="line">    <span class="comment">// get logo patition from fstab end</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;[libshowlogo: %s %d]open logo partition device file fail, errno = %d \n&quot;</span>,__FUNCTION__,__LINE__ , errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请 logo 需要的内存空间</span></span><br><span class="line">    logo_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="built_in">malloc</span>(LOGO_BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(logo_addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;[libshowlogo: %s %d]allocate logo buffer fail, size=0x%08x \n&quot;</span>,__FUNCTION__,__LINE__ , LOGO_BUFFER_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) skip the image header 读取头部信息</span></span><br><span class="line">    len = read(fd, logo_addr, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;[libshowlogo: %s %d]read from logo addr for 512B is failed! \n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get the image //获取照片</span></span><br><span class="line">    len = read(fd, logo_addr, LOGO_BUFFER_SIZE - <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;[libshowlogo: %s %d]read from logo addr for buffer is failed! \n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (show_animationm_ver &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> *pinfo = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)logo_addr;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGD(<span class="string">&quot;[libshowlogo: %s %d]pinfo[0]=%d, pinfo[1]=%d\n&quot;</span>, __FUNCTION__,__LINE__, pinfo[<span class="number">0</span>], pinfo[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((show_animationm_ver == VERION_WIRELESS_CHARGING_ANIMATION) &amp;&amp; (pinfo[<span class="number">0</span>] &lt; ANIM_V2_LOGO_NUM))</span><br><span class="line">        &#123;</span><br><span class="line">            set_anim_version(VERION_NEW_ANIMATION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pinfo[<span class="number">0</span>] &lt; ANIM_V1_LOGO_NUM)</span><br><span class="line">        &#123;</span><br><span class="line">            kernel_logo_position = ANIM_V0_LOGO_NUM - <span class="number">1</span>;</span><br><span class="line">            set_anim_version(VERION_OLD_ANIMATION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]show_animationm_ver =  :%d&quot;</span>,__FUNCTION__,__LINE__ ,show_animationm_ver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    free_fstab();</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    error_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d] error return !!!\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// to prevent interlace operation with MD reset</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-anim-fb-init"><a href="#3-anim-fb-init" class="headerlink" title="3) anim_fb_init"></a>3) anim_fb_init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anim_fb_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fb_fd = open(FB_NODE_PATH, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fb_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;[libshowlogo: %s %d]open dev file fail, errno = %d \n&quot;</span>,__FUNCTION__,__LINE__ , errno);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fb_fd);</span><br><span class="line">        error_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 lcd 可变信息</span></span><br><span class="line">    ioctl(fb_fd, FBIOGET_VSCREENINFO, &amp;vinfo);</span><br><span class="line">    <span class="comment">// 返回 lcd 固定信息</span></span><br><span class="line">    ioctl(fb_fd, FBIOGET_FSCREENINFO, &amp;finfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算fb 的大小</span></span><br><span class="line">    fb_size  = finfo.line_length * vinfo.yres;</span><br><span class="line">    <span class="comment">//分配内存空间</span></span><br><span class="line">    dec_logo_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*) <span class="built_in">malloc</span>(fb_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将屏幕缓冲区映射到用户空间</span></span><br><span class="line">    lk_fb_addr =(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)mmap(<span class="number">0</span>, fb_size*<span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一帧地址用于显示 charging</span></span><br><span class="line">    charging_fb_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)lk_fb_addr + fb_size);</span><br><span class="line">    <span class="comment">// 第二帧地址用于显示 kernel_fb_addr</span></span><br><span class="line">    kernel_fb_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)charging_fb_addr + fb_size);</span><br><span class="line">    fb_addr = lk_fb_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123; <span class="comment">// debug</span></span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]vinfo:xres  = %d, yres = %d, xres_virtual =%d, bits_per_pixel = %d,red.offset = %d,blue.offset = %d\n&quot;</span></span><br><span class="line">                ,__FUNCTION__, __LINE__, vinfo.xres,vinfo.yres, vinfo.xres_virtual, vinfo.bits_per_pixel,vinfo.red.offset,vinfo.blue.offset);</span><br><span class="line"></span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]fb_size =%d, fb_addr = %d,charging_fb_addr=%d\n&quot;</span></span><br><span class="line">                ,__FUNCTION__, __LINE__, fb_size,( <span class="keyword">int</span>)fb_addr, (<span class="keyword">int</span>)charging_fb_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fb_addr == <span class="literal">NULL</span> || charging_fb_addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;ChargingAnimation mmap fail\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap(lk_fb_addr, fb_size*<span class="number">2</span>);</span><br><span class="line">        close(fb_fd);</span><br><span class="line">        error_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对应的 lcm 参数</span></span><br><span class="line">    phical_screen.bits_per_pixel = vinfo.bits_per_pixel; <span class="comment">// 每个像素多少 bpp ，单位 bit </span></span><br><span class="line">    phical_screen.fill_dst_bits = vinfo.bits_per_pixel;  <span class="comment">// 每个像素多少 bpp ，单位 bit</span></span><br><span class="line">    phical_screen.red_offset = vinfo.red.offset;    <span class="comment">// 红色像素偏移位置</span></span><br><span class="line">    phical_screen.blue_offset = vinfo.blue.offset;  <span class="comment">// 蓝色像素偏移位置</span></span><br><span class="line"></span><br><span class="line">    phical_screen.width = vinfo.xres;  <span class="comment">// 屏幕一行有多少个像素点</span></span><br><span class="line">    phical_screen.height = vinfo.yres; <span class="comment">// 屏幕一列有多少个像素点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一行的像素个数</span></span><br><span class="line">    phical_screen.allignWidth = finfo.line_length/(vinfo.bits_per_pixel/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    phical_screen.needAllign = <span class="number">1</span>;</span><br><span class="line">    phical_screen.need180Adjust = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//一帧图片的大小</span></span><br><span class="line">    phical_screen.fb_size = fb_size;</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]MTK_LCM_PHYSICAL_ROTATION = %s\n&quot;</span>,__FUNCTION__,__LINE__, MTK_LCM_PHYSICAL_ROTATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rotation = getRotation(); <span class="comment">//获取屏幕旋转多少度</span></span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]rotation = %d\n&quot;</span>,__FUNCTION__,__LINE__, rotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ORIENTATION_270 == rotation)&#123;<span class="comment">//270</span></span><br><span class="line">        phical_screen.rotation = <span class="number">270</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ORIENTATION_90 == rotation)&#123;<span class="comment">//90</span></span><br><span class="line">        phical_screen.rotation = <span class="number">90</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((ORIENTATION_180 == rotation) &amp;&amp; (phical_screen.need180Adjust == <span class="number">1</span>))&#123;<span class="comment">//180</span></span><br><span class="line">        phical_screen.rotation = <span class="number">180</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        phical_screen.rotation = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo]phical_screen: width= %d,height= %d,bits_per_pixel =%d,needAllign = %d,allignWidth=%d rotation =%d ,need180Adjust = %d\n&quot;</span>,</span><br><span class="line">                phical_screen.width, phical_screen.height,</span><br><span class="line">                phical_screen.bits_per_pixel, phical_screen.needAllign,</span><br><span class="line">                phical_screen.allignWidth, phical_screen.rotation, phical_screen.need180Adjust);</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]show old animtion= 1, running show_animationm_ver %d\n&quot;</span>,__FUNCTION__,__LINE__, show_animationm_ver);</span><br><span class="line">        SLOGD(<span class="string">&quot;[libshowlogo: %s %d]draw_anim_mode = 1, running mode %d\n&quot;</span>,__FUNCTION__,__LINE__, draw_anim_mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-anim-set-buffer-address"><a href="#4-anim-set-buffer-address" class="headerlink" title="4) anim_set_buffer_address"></a>4) anim_set_buffer_address</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anim_set_buffer_address</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == BOOT_LOGO_INDEX) &#123;</span><br><span class="line">        fb_addr = lk_fb_addr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == kernel_logo_position) &#123;</span><br><span class="line">        fb_addr = kernel_fb_addr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        anim_fb_addr_switch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-anim-show-logo"><a href="#5-anim-show-logo" class="headerlink" title="5) anim_show_logo"></a>5) anim_show_logo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anim_show_logo</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">         SLOGD(<span class="string">&quot;[libshowlogo: %s %d]draw_anim_mode=%d, show  index =  %d\n&quot;</span>,__FUNCTION__,__LINE__,draw_anim_mode,index);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (draw_anim_mode == (DRAW_ANIM_MODE_FB)) &#123;</span><br><span class="line">        anim_set_buffer_address(index); <span class="comment">// 获取显存地址</span></span><br><span class="line">        fill_animation_logo(index, fb_addr, dec_logo_addr, logo_addr,phical_screen);</span><br><span class="line">        anim_fb_disp_update();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ARect tmpRect;</span><br><span class="line">        tmpRect.left = <span class="number">0</span>;</span><br><span class="line">        tmpRect.top = <span class="number">0</span>;</span><br><span class="line">        tmpRect.right = phical_screen.width;</span><br><span class="line">        tmpRect.bottom = phical_screen.height;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span>  lockResult = surface-&gt;lock(&amp;outBuffer, &amp;tmpRect);</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGD(<span class="string">&quot;[libshowlogo: %s %d]outBuffer.bits = %d\n&quot;</span>,__FUNCTION__,__LINE__, (<span class="keyword">int</span>)outBuffer.bits);</span><br><span class="line">            SLOGD(<span class="string">&quot;[libshowlogo: %s %d]surface-&gt;lock return =  0x%08x,  %d\n&quot;</span>,__FUNCTION__,__LINE__,lockResult,lockResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == lockResult)</span><br><span class="line">        &#123;</span><br><span class="line">            fill_animation_logo(index, (<span class="keyword">void</span> *)outBuffer.bits, dec_logo_addr, logo_addr,phical_screen);</span><br><span class="line">            surface-&gt;unlockAndPost();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-fill-animation-logo"><a href="#6-fill-animation-logo" class="headerlink" title="6) fill_animation_logo"></a>6) fill_animation_logo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index 图片索引</span></span><br><span class="line"><span class="comment">// fill_addr 显存地址</span></span><br><span class="line"><span class="comment">// dec_logo_addr </span></span><br><span class="line"><span class="comment">// logo_addr logo.bin 的数据首地址</span></span><br><span class="line"><span class="comment">// phical_screen 内核 获取的 lcd 的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_animation_logo</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">void</span> *fill_addr, <span class="keyword">void</span> * dec_logo_addr, <span class="keyword">void</span> * logo_addr, LCM_SCREEN_T phical_screen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOGO_PARA_T logo_info;</span><br><span class="line">    <span class="keyword">int</span> logo_width;</span><br><span class="line">    <span class="keyword">int</span> logo_height;</span><br><span class="line">    <span class="keyword">int</span> raw_data_size;</span><br><span class="line">    <span class="keyword">int</span> logo_index = index;</span><br><span class="line">    <span class="keyword">int</span> logo_offset = <span class="number">-1</span>;</span><br><span class="line">    g_dec_logo_addr = dec_logo_addr;</span><br><span class="line"></span><br><span class="line">    logo_offset = calculate_logo_offset(index, dec_logo_addr, logo_addr, phical_screen);</span><br><span class="line">    <span class="keyword">if</span>(logo_offset == <span class="number">-1</span>)&#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d]Resolution not supported\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算要显示的图片索引</span></span><br><span class="line">    logo_index = logo_index + logo_offset;</span><br><span class="line">    <span class="keyword">if</span>(check_logo_index_valid(logo_index, logo_addr, &amp;logo_info) != CHECK_LOGO_BIN_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将图片解压缩</span></span><br><span class="line">    <span class="comment">// logo_info.inaddr         解压缩前图片地址</span></span><br><span class="line">    <span class="comment">// dec_logo_addr            解压缩后图片地址</span></span><br><span class="line">    <span class="comment">// logo_info.logolen        解压缩前图片长度</span></span><br><span class="line">    <span class="comment">// phical_screen.fb_size    解压缩后图片长度</span></span><br><span class="line">    raw_data_size = decompress_logo((<span class="keyword">void</span>*)logo_info.inaddr, dec_logo_addr, logo_info.logolen, phical_screen.fb_size);</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[show_animation_common: %s %d]raw_data_size = %d\n&quot;</span>,__FUNCTION__,__LINE__, raw_data_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//RECT_REGION_T rect = &#123;0, 0, phical_screen.width, phical_screen.height&#125;;</span></span><br><span class="line">    logo_width =phical_screen.width;</span><br><span class="line">    logo_height = phical_screen.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果旋转图片则交换长宽位置</span></span><br><span class="line">    <span class="keyword">if</span> (phical_screen.rotation == <span class="number">270</span> || phical_screen.rotation == <span class="number">90</span>) &#123;</span><br><span class="line">        logo_width = phical_screen.height;</span><br><span class="line">        logo_height = phical_screen.width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每一个像素需要的 bit</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == bits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (raw_data_size == logo_width*logo_height*<span class="number">4</span>) &#123;</span><br><span class="line">            bits = <span class="number">32</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (raw_data_size == logo_width*logo_height*<span class="number">2</span>) &#123;</span><br><span class="line">            bits = <span class="number">16</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">                SLOGE(<span class="string">&quot;[show_animation_common: %s %d]Logo data error\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGD(<span class="string">&quot;[show_animation_common: %s %d]bits = %d\n&quot;</span>,__FUNCTION__,__LINE__, bits);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置显示区域大小</span></span><br><span class="line">    RECT_REGION_T rect = &#123;<span class="number">0</span>, <span class="number">0</span>, logo_width, logo_height&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据填充到 fb 显示图片</span></span><br><span class="line">    fill_rect_with_content(fill_addr, rect, dec_logo_addr, phical_screen, bits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-fill-rect-with-content"><a href="#7-fill-rect-with-content" class="headerlink" title="7) fill_rect_with_content"></a>7) fill_rect_with_content</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_rect_with_content</span><span class="params">(<span class="keyword">void</span> *fill_addr, RECT_REGION_T rect, <span class="keyword">void</span> *src_addr, LCM_SCREEN_T phical_screen, <span class="keyword">unsigned</span> <span class="keyword">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[show_logo_common: %s %d]\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check_rect_valid(rect) != CHECK_RECT_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (bits == <span class="number">32</span>) &#123; <span class="comment">//32 位</span></span><br><span class="line">        <span class="keyword">if</span> (phical_screen.fill_dst_bits == <span class="number">16</span>) &#123; <span class="comment">// fb 每个像素需要16bit</span></span><br><span class="line">            fill_rect_with_content_by_16bit_argb8888((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)fill_addr, rect, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)src_addr, phical_screen);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phical_screen.fill_dst_bits == <span class="number">32</span>)&#123; <span class="comment">//// fb 每个像素需要16bit</span></span><br><span class="line">            fill_rect_with_content_by_32bit_argb8888((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)fill_addr, rect, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)src_addr, phical_screen, bits);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">                SLOGD(<span class="string">&quot;[show_logo_common %s %d]unsupported phical_screen.fill_dst_bits =%d\n&quot;</span>,__FUNCTION__,__LINE__, phical_screen.fill_dst_bits );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (phical_screen.fill_dst_bits == <span class="number">16</span>) &#123;</span><br><span class="line">            fill_rect_with_content_by_16bit_rgb565((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)fill_addr, rect, (<span class="keyword">unsigned</span> <span class="keyword">short</span> *)src_addr, phical_screen);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phical_screen.fill_dst_bits == <span class="number">32</span>)&#123;</span><br><span class="line">            fill_rect_with_content_by_32bit_rgb565((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)fill_addr, rect, (<span class="keyword">unsigned</span> <span class="keyword">short</span> *)src_addr, phical_screen, bits);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">                SLOGD(<span class="string">&quot;[show_logo_common %s %d]unsupported phical_screen.fill_dst_bits =%d\n&quot;</span>,__FUNCTION__,__LINE__, phical_screen.fill_dst_bits );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-fill-rect-with-content-by-32bit-argb8888"><a href="#8-fill-rect-with-content-by-32bit-argb8888" class="headerlink" title="8) fill_rect_with_content_by_32bit_argb8888"></a>8) fill_rect_with_content_by_32bit_argb8888</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_rect_with_content_by_32bit_argb8888</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *fill_addr, RECT_REGION_T rect, <span class="keyword">unsigned</span> <span class="keyword">int</span> *src_addr, LCM_SCREEN_T phical_screen, <span class="keyword">unsigned</span> <span class="keyword">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[show_logo_common: %s %d]\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> virtual_width = phical_screen.needAllign == <span class="number">0</span>? phical_screen.width:phical_screen.allignWidth;</span><br><span class="line">    <span class="keyword">int</span> virtual_height = phical_screen.height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> * dst_addr = fill_addr;  <span class="comment">// 要填充的显存地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> * color_addr = src_addr; <span class="comment">// 要显示的图片地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// left, top, right, bottom</span></span><br><span class="line">    <span class="comment">// RECT_REGION_T rect = &#123;0, 0, logo_width, logo_height&#125;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0 - logo_height</span></span><br><span class="line">    <span class="keyword">for</span>(i = rect.top; i &lt; rect.bottom; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 0 - logo_width</span></span><br><span class="line">        <span class="keyword">for</span>(j = rect.left; j &lt; rect.right; j++) <span class="comment">// 逐行显示</span></span><br><span class="line">        &#123;</span><br><span class="line">            color_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)src_addr; <span class="comment">// 获取要显示的地址</span></span><br><span class="line">            src_addr++;</span><br><span class="line">            <span class="keyword">switch</span> (phical_screen.rotation)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">90</span>:</span><br><span class="line">                    dst_addr = fill_addr + (virtual_width * j  + phical_screen.width - i - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">270</span>:</span><br><span class="line">                    dst_addr = fill_addr + ((virtual_width * (virtual_height - j - <span class="number">1</span>)+ i));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">180</span>:</span><br><span class="line">                    <span class="comment">// adjust fill in address</span></span><br><span class="line">                    dst_addr = fill_addr + virtual_width * (virtual_height - i)- j<span class="number">-1</span>-(virtual_width-phical_screen.width);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    dst_addr = fill_addr + virtual_width * i + j;</span><br><span class="line">            &#125;</span><br><span class="line">            fill_point_buffer(dst_addr, *color_addr, phical_screen, bits);</span><br><span class="line">            <span class="keyword">if</span>((i == rect.top &amp;&amp; j == rect.left) || (i == rect.bottom - <span class="number">1</span> &amp;&amp; j == rect.left) ||</span><br><span class="line">               (i == rect.top &amp;&amp; j == rect.right - <span class="number">1</span>) || (i == rect.bottom - <span class="number">1</span> &amp;&amp; j == rect.right - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">                    SLOGD(<span class="string">&quot;[show_logo_common]dst_addr= 0x%08x, color_addr= 0x%08x, i= %d, j=%d\n&quot;</span>, *dst_addr, *color_addr, i , j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-fill-point-buffer"><a href="#9-fill-point-buffer" class="headerlink" title="9) fill_point_buffer"></a>9) fill_point_buffer</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_point_buffer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *fill_addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> src_color, LCM_SCREEN_T phical_screen, <span class="keyword">unsigned</span> <span class="keyword">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">32</span> == phical_screen.bits_per_pixel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">32</span> == bits) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">16</span> == phical_screen.blue_offset) &#123;</span><br><span class="line">                *fill_addr = ARGB8888_TO_ABGR8888(src_color);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *fill_addr = src_color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">16</span> == phical_screen.blue_offset) &#123;</span><br><span class="line">                *fill_addr = RGB565_TO_ARGB8888(src_color);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *fill_addr = RGB565_TO_ABGR8888(src_color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGD(<span class="string">&quot;[show_logo_common %s %d]not support bits_per_pixel = %d \n&quot;</span>,__FUNCTION__,__LINE__,(<span class="keyword">int</span>)phical_screen.bits_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-calculate-logo-offset"><a href="#10-calculate-logo-offset" class="headerlink" title="10) calculate_logo_offset"></a>10) calculate_logo_offset</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index 图片索引</span></span><br><span class="line"><span class="comment">// dec_logo_addr 图片解压缩后的图片地址</span></span><br><span class="line"><span class="comment">// logo_addr logo.bin 的数据首地址</span></span><br><span class="line"><span class="comment">// phical_screen 内核获取的屏参数</span></span><br><span class="line"><span class="comment">// 返货图片索引的偏移位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate_logo_offset</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">void</span> * dec_logo_addr, <span class="keyword">void</span> * logo_addr, LCM_SCREEN_T phical_screen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOGO_PARA_T logo_info;</span><br><span class="line">    <span class="keyword">int</span> logo_width = phical_screen.width;</span><br><span class="line">    <span class="keyword">int</span> logo_height = phical_screen.height;</span><br><span class="line">    <span class="keyword">int</span> raw_data_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *pinfo;</span><br><span class="line">    <span class="keyword">int</span> logo_index = index;</span><br><span class="line">    <span class="keyword">int</span> total_logo_entries = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(logo_offset != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> logo_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 logo.bin 的数据首地址</span></span><br><span class="line">    pinfo = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)logo_addr;</span><br><span class="line">    logo_offset = <span class="number">0</span>;</span><br><span class="line">    total_logo_entries = get_total_logo_images_entries(); <span class="comment">// 获取 logo 的长度</span></span><br><span class="line">    SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d]pinfo[0] = %d\n&quot;</span>,__FUNCTION__,__LINE__, pinfo[<span class="number">0</span>]); <span class="comment">// 打印所有的图片有多少张</span></span><br><span class="line"></span><br><span class="line">    SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d]TOTAL_LOG0_COUNT = %d , initial index = %d\n&quot;</span>,__FUNCTION__,__LINE__, total_logo_entries, logo_index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(logo_index &lt;  pinfo[<span class="number">0</span>])&#123; <span class="comment">//如果显示的索引是否小于图片数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// logo_info-&gt;logonum   获取图片数量</span></span><br><span class="line">        <span class="comment">// logo_info-&gt;logolen   获取要显示的图片长度</span></span><br><span class="line">        <span class="comment">// logo_info-&gt;inaddr    获取要显示的图片的地址</span></span><br><span class="line">        <span class="keyword">if</span>(check_logo_index_valid(logo_index, logo_addr, &amp;logo_info) != CHECK_LOGO_BIN_OK)&#123;</span><br><span class="line">            SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d][Error]Resolution not supported&quot;</span>,</span><br><span class="line">                  __FUNCTION__,__LINE__);</span><br><span class="line">            logo_offset = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将图片解压缩</span></span><br><span class="line">        <span class="comment">// logo_info.inaddr         解压缩前图片地址</span></span><br><span class="line">        <span class="comment">// dec_logo_addr            解压缩后图片地址</span></span><br><span class="line">        <span class="comment">// logo_info.logolen        解压缩前图片长度</span></span><br><span class="line">        <span class="comment">// phical_screen.fb_size    解压缩后图片长度</span></span><br><span class="line">        raw_data_size = decompress_logo((<span class="keyword">void</span>*)logo_info.inaddr, dec_logo_addr, logo_info.logolen，phical_screen.fb_size);</span><br><span class="line"></span><br><span class="line">        SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d]Width = %d\n  Height = %d\n  raw_data_size = %d\n  logo_index = %d\n&quot;</span>,</span><br><span class="line">              __FUNCTION__,__LINE__, logo_width, logo_height, raw_data_size, logo_index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取每个像素的像素点</span></span><br><span class="line">        <span class="keyword">if</span> (raw_data_size == logo_width*logo_height*<span class="number">4</span>) &#123;</span><br><span class="line">            bits = <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (raw_data_size == logo_width*logo_height*<span class="number">2</span>) &#123;</span><br><span class="line">            bits = <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logo_offset += total_logo_entries;<span class="comment">// Add number of logos entries</span></span><br><span class="line">            logo_index += total_logo_entries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d]bits = %d\n&quot;</span>,__FUNCTION__,__LINE__, bits);</span><br><span class="line">        SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d]logo_offset = %d  logo_index = %d\n&quot;</span>,__FUNCTION__,__LINE__, logo_offset,logo_index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SLOGD(<span class="string">&quot;[calculate_logo_offset: %s %d] final logo_offset = %d logo_index = %d\n&quot;</span>,__FUNCTION__,__LINE__, logo_offset,logo_index);</span><br><span class="line">    <span class="keyword">return</span> logo_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-check-logo-index-valid"><a href="#11-check-logo-index-valid" class="headerlink" title="11) check_logo_index_valid"></a>11) check_logo_index_valid</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check logo.bin address if valid, and get logo related info</span></span><br><span class="line"><span class="comment"> * pinfo[0] : the number of all pictures in logo.bin</span></span><br><span class="line"><span class="comment"> * pinf0[1] : the whole length of logo.bin</span></span><br><span class="line"><span class="comment"> * pinf0[2] : the index = 0 picture&#x27;s length</span></span><br><span class="line"><span class="comment"> * pinfo[3+index] - pinfo[2+index] : means index length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_logo_index_valid</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">void</span> * logo_addr, LOGO_PARA_T *logo_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *pinfo = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)logo_addr;</span><br><span class="line">    logo_info-&gt;logonum = pinfo[<span class="number">0</span>]; <span class="comment">// 获取图片数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;[show_animation_common: %s %d]logonum =%d, index =%d\n&quot;</span>, __FUNCTION__,__LINE__,logo_info-&gt;logonum, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= logo_info-&gt;logonum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;[show_animation_common: %s %d]unsupported logo, index =%d\n&quot;</span>, __FUNCTION__,__LINE__, index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CHECK_LOGO_BIN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; logo_info-&gt;logonum - <span class="number">1</span>) &#123;</span><br><span class="line">        logo_info-&gt;logolen = pinfo[<span class="number">3</span>+index] - pinfo[<span class="number">2</span>+index]; <span class="comment">// 获取要显示的图片长度</span></span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGD(<span class="string">&quot;show_animation_common, pinfo[1]=%d, pinfo[3+index] - pinfo[2+index]= %d\n&quot;</span>,</span><br><span class="line">                   pinfo[<span class="number">1</span>], pinfo[<span class="number">3</span>+index] - pinfo[<span class="number">2</span>+index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logo_info-&gt;logolen = pinfo[<span class="number">1</span>] - pinfo[<span class="number">2</span>+index]; <span class="comment">// 获取要显示的图片长度</span></span><br><span class="line">        <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">            SLOGD(<span class="string">&quot;show_animation_common, pinfo[1]=%d, pinfo[1] - pinfo[2+index] =%d \n&quot;</span>,</span><br><span class="line">                   pinfo[<span class="number">1</span>], pinfo[<span class="number">1</span>] - pinfo[<span class="number">2</span>+index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要显示的图片的地址</span></span><br><span class="line">    logo_info-&gt;inaddr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)logo_addr + pinfo[<span class="number">2</span>+index];</span><br><span class="line">    <span class="keyword">if</span> (MTK_LOG_ENABLE == <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGD(<span class="string">&quot;show_animation_common, logo_addr=0x%08x , in_addr=0x%08x,  logolen=%d\n&quot;</span>,</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">int</span>)logo_addr, logo_info-&gt;inaddr,  logo_info-&gt;logolen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CHECK_LOGO_BIN_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-get-total-logo-images-entries"><a href="#13-get-total-logo-images-entries" class="headerlink" title="13) get_total_logo_images_entries"></a>13) get_total_logo_images_entries</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_total_logo_images_entries</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total_logo_entries = <span class="number">0</span>;</span><br><span class="line">    total_logo_entries = LOGOS_COUNT_NORMAL;</span><br><span class="line">    <span class="keyword">int</span> to_include_fast_charging = getValue(<span class="string">&quot;ro.vendor.mtk_pump_express_plus_support&quot;</span> , <span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #if defined(MTK_PUMP_EXPRESS_SUPPORT) || defined(MTK_PUMP_EXPRESS_PLUS_SUPPORT) || defined(MTK_PUMP_EXPRESS_PLUS_20_SUPPORT)</span></span><br><span class="line"><span class="comment">        total_logo_entries += LOGOS_COUNT_FAST_CHARGING;</span></span><br><span class="line"><span class="comment">    #endif</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(to_include_fast_charging == <span class="number">1</span>)</span><br><span class="line">    total_logo_entries += LOGOS_COUNT_FAST_CHARGING;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(MTK_WIRELESS_CHARGER_SUPPORT)</span></span><br><span class="line">        total_logo_entries += LOGOS_COUNT_WIRELESS;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   SLOGD(<span class="string">&quot;[get_total_logo_images_entries: %s %d] total_logo_entries = %d to_include_fast_charging = %d\n&quot;</span>,__FUNCTION__,__LINE__, total_logo_entries , to_include_fast_charging);</span><br><span class="line">    <span class="keyword">return</span> total_logo_entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、在屏上显示任意绘制点"><a href="#6、在屏上显示任意绘制点" class="headerlink" title="6、在屏上显示任意绘制点"></a>6、在屏上显示任意绘制点</h2><p>看了这个源码我就想我能不能自己在屏上画出点，于是捯饬了一下，整理得到下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// use for nmap framebuffer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *lk_fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *charging_fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *kernel_fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> v_width = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fb_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fb_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清屏函数，将屏幕颜色设置为 color</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearScreen</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *pfb, <span class="keyword">unsigned</span> <span class="keyword">int</span> width, <span class="keyword">unsigned</span> <span class="keyword">int</span> height, <span class="keyword">unsigned</span> <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;draw_back, %p , %d, %d\n&quot;</span>,pfb , width, height);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(pfb + y * width + x) = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制对应的点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_point</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y, <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x: %d y: %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2400</span>) <span class="comment">// 防止越界</span></span><br><span class="line">        y = <span class="number">2400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1080</span>) <span class="comment">// 防止越界</span></span><br><span class="line">        x = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line">    *(fb_addr + y * v_width + x) = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 x , y 为中心绘制10x10的小方块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawCube</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xmin = x<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">int</span> xmax = x+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> ymin = y<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">int</span> ymax = y+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xmin &lt; <span class="number">0</span>)</span><br><span class="line">        xmin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ymin &lt; <span class="number">0</span>)</span><br><span class="line">        ymin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = ymin; i&lt; ymax; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(j = xmin; j &lt; xmax; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           draw_point(j,i,<span class="number">0xFF</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 fb 相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFbInit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//unsigned int color = 0;</span></span><br><span class="line">    fb_fd = open(<span class="string">&quot;/dev/graphics/fb0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fb_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fb open err\n&quot;</span>);</span><br><span class="line">        close(fb_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fb_fd, FBIOGET_VSCREENINFO, &amp;vinfo);</span><br><span class="line">    ioctl(fb_fd, FBIOGET_FSCREENINFO, &amp;finfo);</span><br><span class="line"></span><br><span class="line">    fb_size  = finfo.line_length * vinfo.yres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射对应的显存到用户空间</span></span><br><span class="line">    lk_fb_addr =(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)mmap(<span class="number">0</span>, fb_size*<span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    charging_fb_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)lk_fb_addr + fb_size);</span><br><span class="line"></span><br><span class="line">    kernel_fb_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)charging_fb_addr + fb_size);</span><br><span class="line"></span><br><span class="line">    fb_addr = charging_fb_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出显示区域的宽度</span></span><br><span class="line">    v_width = finfo.line_length/(vinfo.bits_per_pixel/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉内核刷新 fb</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fbShow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fb_addr == charging_fb_addr) &#123;</span><br><span class="line">        vinfo.yoffset = vinfo.yres;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fb_addr == kernel_fb_addr) &#123;</span><br><span class="line">        vinfo.yoffset = vinfo.yres * <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vinfo.yoffset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vinfo.activate |= (FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fb_fd, FBIOPUT_VSCREENINFO, &amp;vinfo) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ioctl FBIOPUT_VSCREENINFO flip failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    myFbInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清屏</span></span><br><span class="line">    clearScreen(fb_addr, vinfo.xres, vinfo.yres, <span class="number">0xFF0000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 300,300 处画个 10x10 小方块</span></span><br><span class="line">    drawCube(<span class="number">300</span>,<span class="number">300</span>,<span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//刷新 fb 显示</span></span><br><span class="line">    fbShow();</span><br><span class="line"></span><br><span class="line">    munmap(lk_fb_addr, fb_size*<span class="number">2</span>); <span class="comment">// 释放映射的内存空间</span></span><br><span class="line">    close(fb_db);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码验证有问题，原因就是安卓也在刷图会将我的图刷掉，于是为了简单直接如下操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">primary_display_frame_cfg</span><span class="params">(struct <span class="keyword">disp_frame_cfg_t</span> *cfg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 啥也不干直接返回</span></span><br><span class="line"></span><br><span class="line">    s_info = disp_get_session_sync_info_for_debug(cfg-&gt;session_id);</span><br><span class="line">    <span class="keyword">if</span> (s_info) &#123;</span><br><span class="line">        input_event = &amp;s_info-&gt;event_setinput;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是再次验证就可以了。</p>
<h2 id="7、在屏幕上面绘制"><a href="#7、在屏幕上面绘制" class="headerlink" title="7、在屏幕上面绘制"></a>7、在屏幕上面绘制</h2><p>利用 input 子系统就可以在屏幕上面进行绘制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// use for nmap framebuffer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *lk_fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *charging_fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *kernel_fb_addr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> v_width = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fb_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fb_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清屏函数，将屏幕颜色设置为 color</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearScreen</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *pfb, <span class="keyword">unsigned</span> <span class="keyword">int</span> width, <span class="keyword">unsigned</span> <span class="keyword">int</span> height, <span class="keyword">unsigned</span> <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;draw_back, %p , %d, %d\n&quot;</span>,pfb , width, height);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(pfb + y * width + x) = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制对应的点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_point</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y, <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x: %d y: %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2400</span>) <span class="comment">// 防止越界</span></span><br><span class="line">        y = <span class="number">2400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1080</span>) <span class="comment">// 防止越界</span></span><br><span class="line">        x = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line">    *(fb_addr + y * v_width + x) = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 x , y 为中心绘制10x10的小方块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawCube</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xmin = x<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">int</span> xmax = x+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> ymin = y<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">int</span> ymax = y+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xmin &lt; <span class="number">0</span>)</span><br><span class="line">        xmin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ymin &lt; <span class="number">0</span>)</span><br><span class="line">        ymin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = ymin; i&lt; ymax; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(j = xmin; j &lt; xmax; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           draw_point(j,i,<span class="number">0xFF</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 fb 相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFbInit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//unsigned int color = 0;</span></span><br><span class="line">    fb_fd = open(<span class="string">&quot;/dev/graphics/fb0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fb_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fb open err\n&quot;</span>);</span><br><span class="line">        close(fb_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fb_fd, FBIOGET_VSCREENINFO, &amp;vinfo);</span><br><span class="line">    ioctl(fb_fd, FBIOGET_FSCREENINFO, &amp;finfo);</span><br><span class="line"></span><br><span class="line">    fb_size  = finfo.line_length * vinfo.yres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射对应的显存到用户空间</span></span><br><span class="line">    lk_fb_addr =(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)mmap(<span class="number">0</span>, fb_size*<span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    charging_fb_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)lk_fb_addr + fb_size);</span><br><span class="line"></span><br><span class="line">    kernel_fb_addr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)charging_fb_addr + fb_size);</span><br><span class="line"></span><br><span class="line">    fb_addr = charging_fb_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出显示区域的宽度</span></span><br><span class="line">    v_width = finfo.line_length/(vinfo.bits_per_pixel/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉内核刷新 fb</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fbShow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fb_addr == charging_fb_addr) &#123;</span><br><span class="line">        vinfo.yoffset = vinfo.yres;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fb_addr == kernel_fb_addr) &#123;</span><br><span class="line">        vinfo.yoffset = vinfo.yres * <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vinfo.yoffset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vinfo.activate |= (FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fb_fd, FBIOPUT_VSCREENINFO, &amp;vinfo) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ioctl FBIOPUT_VSCREENINFO flip failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    myFbInit();</span><br><span class="line">    clearScreen(fb_addr, vinfo.xres, vinfo.yres, <span class="number">0xFF0000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开设备</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/input/event5&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, EVIOCGNAME(<span class="keyword">sizeof</span>(name) - <span class="number">1</span>), name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;find device name = %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        read(fd, &amp;ev, <span class="keyword">sizeof</span>(struct input_event));</span><br><span class="line">        <span class="comment">// 打印当前触发类型</span></span><br><span class="line">       <span class="comment">// printf(&quot;ev ==  %x \n&quot;,ev.type );</span></span><br><span class="line">        <span class="keyword">switch</span>(ev.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EV_SYN:</span><br><span class="line">         <span class="comment">//   printf(&quot;-------------------------\n&quot;);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;do x: %d, y: %d\n&quot;</span>,x,y);</span><br><span class="line">            drawCube(x,y);</span><br><span class="line">            fbShow();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按键</span></span><br><span class="line">        <span class="keyword">case</span> EV_KEY:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;key down / up: %d \n&quot;</span>,ev.code );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标</span></span><br><span class="line">        <span class="keyword">case</span> EV_REL:</span><br><span class="line">          <span class="comment">//  printf(&quot;mouse: &quot;);</span></span><br><span class="line">            <span class="keyword">if</span> (ev.code == REL_X) &#123;</span><br><span class="line">              <span class="comment">// printf(&quot; x -- %d\n&quot;, ev.value);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.code == REL_Y) &#123;</span><br><span class="line">              <span class="comment">// printf(&quot; y -- %d\n&quot;, ev.value);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触摸屏</span></span><br><span class="line">        <span class="keyword">case</span> EV_ABS:</span><br><span class="line">            <span class="comment">//printf(&quot;ts: &quot;);</span></span><br><span class="line">            <span class="keyword">if</span>(ev.code == ABS_MT_POSITION_X) &#123;</span><br><span class="line">                <span class="comment">//printf(&quot; x -- %d\n&quot;, ev.value);</span></span><br><span class="line">                x = ev.value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.code == ABS_MT_POSITION_Y) &#123;</span><br><span class="line">                <span class="comment">// printf(&quot; y -- %d\n&quot;, ev.value);</span></span><br><span class="line">                y = ev.value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.code == ABS_PRESSURE) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; pressure: %d\n&quot;</span>, ev.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(lk_fb_addr, fb_size*<span class="number">2</span>); <span class="comment">// 释放映射的内存空间</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fb_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是就可以在屏上画图了</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mtk-logo/%E7%94%BB%E5%9B%BE.jpg?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1626260415;10266174015&q-key-time=1626260415;10266174015&q-header-list=&q-url-param-list=&q-signature=6a279df81113702caddbff933964042f587ac202" >
]]></content>
      <tags>
        <tag>mtk</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动-项目杂记</title>
    <url>/2021/06/16/%E9%A1%B9%E7%9B%AE%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>用于记录项目中乱七八糟的东西，不定期更新，没有排版。</p>
<a id="more"></a>

<h2 id="一、G90-mt67850-SIM卡功能"><a href="#一、G90-mt67850-SIM卡功能" class="headerlink" title="一、G90(mt67850)-SIM卡功能"></a>一、G90(mt67850)-SIM卡功能</h2><h3 id="1、支持双卡，配置config文件"><a href="#1、支持双卡，配置config文件" class="headerlink" title="1、支持双卡，配置config文件"></a>1、支持双卡，配置config文件</h3><p>路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/device/mediateksample/k85v1_64/ProjectConfig.mk</span><br></pre></td></tr></table></figure>
<p>修改参数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MTK_SIM1_SOCKET_TYPE = <span class="number">1</span></span><br><span class="line">MTK_SIM2_SOCKET_TYPE = <span class="number">1</span></span><br><span class="line">MTK_SIM_CARD_ONOFF = <span class="number">2</span></span><br><span class="line">MTK_SIM_HOT_SWAP = yes</span><br><span class="line">MTK_SIM_HOT_SWAP_COMMON_SLOT = no</span><br><span class="line">MTK_SIM_LOCK_POWER_ON_WRITE_PROTECT = no</span><br><span class="line">MTK_SIM_RECOVERY = yes</span><br><span class="line"></span><br><span class="line">MTK_MULTI_SIM_SUPPORT = dsds <span class="comment">//一般只需修改这个就好了，其他都是默认配好的，单卡配置成ss</span></span><br><span class="line"></span><br><span class="line">SIM_ME_LOCK_MODE = <span class="number">3</span></span><br><span class="line">SIM_REFRESH_RESET_BY_MODEM = yes</span><br><span class="line">MTK_EAP_SIM_AKA = yes</span><br><span class="line">MTK_EXTERNAL_SIM_ONLY_SLOTS = <span class="number">0</span></span><br><span class="line">MTK_EXTERNAL_SIM_SUPPORT = no</span><br></pre></td></tr></table></figure>
<h3 id="2、配置dct文件"><a href="#2、配置dct文件" class="headerlink" title="2、配置dct文件"></a>2、配置dct文件</h3><p>路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\vendor\mediatek\proprietary\scripts\dct\DrvGen.exe <span class="comment">//dct配置工具</span></span><br><span class="line">\vendor\mediatek\proprietary\bootable\bootloader\lk\target\k85v1_64\dct\dct\codegen.dws <span class="comment">//lk下dct路径</span></span><br><span class="line">\vendor\mediatek\proprietary\bootable\bootloader\preloader\custom\k85v1_64\dct\dct\codegen.dws <span class="comment">//pl下dct路径</span></span><br><span class="line">\kernel<span class="number">-4.14</span>\drivers\misc\mediatek\dws\mt6785\codegen.dws  <span class="comment">//kernel下dct路径</span></span><br></pre></td></tr></table></figure>
<p>配置根据中断检测脚状态来配置</p>
<blockquote>
<p>如果插入sim卡为高电平拔出时为低电平则配置 PlugOutPolarity 为低电平<br>如果插入sim卡为低电平拔出时为高电平则配置 PlugOutPolarity 为高电平</p>
</blockquote>
<p>我的为第一种情况因此如下配置：<br><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/G90%E9%A1%B9%E7%9B%AE/sim.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1610763714;88010677314&q-key-time=1610763714;88010677314&q-header-list=&q-url-param-list=&q-signature=1da371ae29efdf84b431edf5f87f58b688f98308"></p>
<h2 id="二、tf卡配置"><a href="#二、tf卡配置" class="headerlink" title="二、tf卡配置"></a>二、tf卡配置</h2><h3 id="1、配置中断引脚"><a href="#1、配置中断引脚" class="headerlink" title="1、配置中断引脚"></a>1、配置中断引脚</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">路径： /arch/arm64/boot/dts/mediatek/cust_mt6785_msdc.dtsi</span><br><span class="line"></span><br><span class="line">具体修改： 原理图使用的 msdc1</span><br><span class="line"></span><br><span class="line">        host_function = /bits/ <span class="number">8</span> &lt;MSDC_SD&gt;;</span><br><span class="line"></span><br><span class="line">-       cd_level = /bits/ <span class="number">8</span> &lt;MSDC_CD_LOW&gt;;</span><br><span class="line">+       cd_level = /bits/ <span class="number">8</span> &lt;MSDC_CD_HIGH&gt;; <span class="comment">//由于插入tf卡中断检测脚为高这里修改为高电平触发</span></span><br><span class="line">        cd-gpios = &lt;&amp;pio <span class="number">8</span> <span class="number">0</span>&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="2、配置下电方式"><a href="#2、配置下电方式" class="headerlink" title="2、配置下电方式"></a>2、配置下电方式</h3><p>mt6360 的 sdcard 的下电方式可以配置选择</p>
<p><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/G90%E9%A1%B9%E7%9B%AE/pmic_sdcard_det_n.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1610765551;88010679151&q-key-time=1610765551;88010679151&q-header-list=&q-url-param-list=&q-signature=111ac4de6885b0162b548936698497afe9a03fa8"></p>
<p>我的原理图长这样</p>
<p><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/G90%E9%A1%B9%E7%9B%AE/tfcard.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1610765022;88010678622&q-key-time=1610765022;88010678622&q-header-list=&q-url-param-list=&q-signature=d9ed65e258e6dbbbcad0bf533de040fbb6809cbd"></p>
<p>=-= 我的原理图插入 sd 卡之后，EINT_SD 会被拉高，由于它和 SD_CARD_DET_N_PMU 短接在一起的，因此 SD_CARD_DET_N_PMU 跟着被拉高了，于是满图上图第一种情况 active high，LD05 被拉低。。。。。，sd卡的供电就被拉低了，现象就是插上tf卡供电就掉下来 =w= 导致tf卡没功能。这种情况需要配置为上图的第二种状态 active low，配置如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">路径： drivers/misc/mediatek/pmic/mt6360/ldo/mt6360_ldo_i2c.c</span><br><span class="line">具体修改：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mt6360_ldo_platform_data</span> <span class="title">def_platform_data</span> =</span> &#123;</span><br><span class="line">-       .sdcard_det_en = <span class="literal">true</span>,</span><br><span class="line">+       .sdcard_det_en = <span class="literal">false</span>,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外记得检测卡托，卡托和卡座一定要匹配，不匹配的卡托可能会在插入的过程中短路，导致 pmic 因为自身的保护机制直接关掉对应的 ldo5 引脚供电，这种情况和上面出现的现象是一样的。</p>
<h2 id="三、G90-mt6785-快充配置"><a href="#三、G90-mt6785-快充配置" class="headerlink" title="三、G90(mt6785)-快充配置"></a>三、G90(mt6785)-快充配置</h2><p>这款芯片是支持快充的，默认没有打开需要手动配置一下</p>
<h3 id="1、快充说明"><a href="#1、快充说明" class="headerlink" title="1、快充说明"></a>1、快充说明</h3><h4 id="1-充电策略"><a href="#1-充电策略" class="headerlink" title="1) 充电策略"></a>1) 充电策略</h4><blockquote>
<p>VAT在比较小的时候，转换效率很低：假设VBAT=3.4V,IBAT=3A,当VBUS=7.5V的时候，转换效率为82.7%，当VBUS=12V的时候，转换效率为80.51%，差了接近%2；而当VBAT比较高的时候，转换效率对电压就不会很敏感，在VBAT=4V的情况下，最低一档的转换效率都有86.94%，所以mtk的充电策略：在保证充电功率的情况下，转换效率尽可能的高</p>
</blockquote>
<h4 id="2-温度控制充电"><a href="#2-温度控制充电" class="headerlink" title="2) 温度控制充电"></a>2) 温度控制充电</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max_charge_temp = &lt;<span class="number">50</span>&gt;; <span class="comment">//大于50°停止充电</span></span><br><span class="line">max_charge_temp_minux_x_degree = &lt;<span class="number">47</span>&gt;; <span class="comment">//从50°降低到47°之后，允许充电</span></span><br></pre></td></tr></table></figure>
<h4 id="3-充电检测"><a href="#3-充电检测" class="headerlink" title="3) 充电检测"></a>3) 充电检测</h4><p>手机插入充电线之后，会走一个充电器类型检测，这个检测流程软硬件都有参与，要满足最基本的 BC1.2 协议才会充电，协议规定几种接口，DCP,SDP,CDP都是5v，mtk 有类似的机制在 dual charger 进入 PE40 的时候，会判断当前点量来决定跑不跑 dual charger 快充，涉及 dts 里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pe40_stop_battery_soc,pd_stop_battery_sooc</span><br></pre></td></tr></table></figure>
<h4 id="4-充电挡位支持"><a href="#4-充电挡位支持" class="headerlink" title="4) 充电挡位支持"></a>4) 充电挡位支持</h4><p>PE快充可以支持三档7v、9v、12v，三选一，</p>
<p>当使用 switch_charger 时没有这种机制，在 85% 电量的时候插入充电器，它一样是跑 switch_charger, 和手机插着充电器从 0% 开始一直充电没有差别</p>
<h4 id="5）-mtk-电量计算法"><a href="#5）-mtk-电量计算法" class="headerlink" title="5） mtk 电量计算法"></a>5） mtk 电量计算法</h4><p>MTK的电量算法是由 driver 和上层的 daemon组成的，<br>电量变化时 Gauge 的硬件产生中断来通知 driver，<br>然后由 driver 将电量计算要用的值传到上层 daemon，<br>上层计算出的 SOC 会用您问题中的 CMD FG_DAEMON_CMD_SET_KERNEL_UISOC 再写到 kernel。</p>
<h4 id="6-相关参数含义"><a href="#6-相关参数含义" class="headerlink" title="6) 相关参数含义"></a>6) 相关参数含义</h4><p>ICHG = “設定的充電電流”,<br>AICR = “AICR 保護下允許的最高抽電流”<br>MIVR = “設定的允許的充電器最低電壓”<br>IEOC = “設定的截止充電電流”<br>CV = “設定的Constant Voltage 值”<br>VSYS = “量測到的 VSYS 值”<br>VBAT = “测量到的电池电压”<br>IBAT = “测量到的充电电流”<br>IBUS = “测量到充电器的电流”<br>VBUS = “测量到充电器的电压”<br>soc  = 底层电量百分比<br>uiso = 上层显示电量百分比<br>CT = 充电器类型</p>
<h3 id="2、打开dts中的相关配置"><a href="#2、打开dts中的相关配置" class="headerlink" title="2、打开dts中的相关配置"></a>2、打开dts中的相关配置</h3><p>具体修改：<br>/kernel-4.14/arch/arm64/boot/dts/mediatek/mt6785.dts b/arch/arm64/boot/dts/mediatek/mt6785.dts</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        charger: charger &#123;</span><br><span class="line">                compatible = <span class="string">&quot;mediatek,charger&quot;</span>;</span><br><span class="line">                algorithm_name = <span class="string">&quot;SwitchCharging&quot;</span>;</span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-               <span class="comment">/* enable_sw_jeita; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_plus; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_2; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_3; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_4; */</span></span><br><span class="line"><span class="comment">//修改后               </span></span><br><span class="line">+               enable_sw_jeita;</span><br><span class="line">+               enable_pe_plus;</span><br><span class="line">+               enable_pe_2;</span><br><span class="line">+               enable_pe_3;</span><br><span class="line">+               enable_pe_4;</span><br><span class="line">               </span><br><span class="line">                enable_type_c;</span><br><span class="line">                power_path_support;</span><br><span class="line">                enable_dynamic_mivr;</span><br><span class="line">                <span class="comment">/* common */</span></span><br><span class="line">                battery_cv = &lt;<span class="number">4350000</span>&gt;; <span class="comment">//cv 电压，如果想提高快充时间可以适当调高，不过要考虑到电池耐压。</span></span><br><span class="line">                max_charger_voltage = &lt;<span class="number">6500000</span>&gt;;</span><br><span class="line">                min_charger_voltage = &lt;<span class="number">4600000</span>&gt;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* dynamic mivr */</span></span><br><span class="line">                min_charger_voltage_1 = &lt;<span class="number">4400000</span>&gt;;</span><br><span class="line">                min_charger_voltage_2 = &lt;<span class="number">4200000</span>&gt;;</span><br><span class="line">                max_dmivr_charger_current = &lt;<span class="number">1400000</span>&gt;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* charging current */</span></span><br><span class="line">                usb_charger_current_suspend = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">                usb_charger_current_unconfigured = &lt;<span class="number">70000</span>&gt;;</span><br><span class="line">                usb_charger_current_configured = &lt;<span class="number">500000</span>&gt;;</span><br><span class="line">                usb_charger_current = &lt;<span class="number">500000</span>&gt;;</span><br><span class="line">                ac_charger_current = &lt;<span class="number">2050000</span>&gt;; <span class="comment">// 普通充电的 ichg </span></span><br><span class="line">                ac_charger_input_current = &lt;<span class="number">2050000</span>&gt;; <span class="comment">// ibus</span></span><br><span class="line">                non_std_ac_charger_current = &lt;<span class="number">500000</span>&gt;;</span><br><span class="line">                charging_host_charger_current = &lt;<span class="number">1500000</span>&gt;;</span><br><span class="line">                apple_1_0a_charger_current = &lt;<span class="number">650000</span>&gt;;</span><br><span class="line">                apple_2_1a_charger_current = &lt;<span class="number">800000</span>&gt;;</span><br><span class="line">                ta_ac_charger_current = &lt;<span class="number">3000000</span>&gt;; <span class="comment">//快充的 ichg</span></span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* PD */</span></span><br><span class="line">                pd_vbus_low_bound = &lt;<span class="number">5000000</span>&gt;; <span class="comment">//支持的充电最低电压，pd-&gt;vbus_l</span></span><br><span class="line">                pd_vbus_upper_bound = &lt;<span class="number">9000000</span>&gt;; <span class="comment">//支持的充电最高电压,pd-&gt;vbus_h</span></span><br><span class="line">                pd_ichg_level_threshold = &lt;<span class="number">1000000</span>&gt;; <span class="comment">/* uA */</span></span><br><span class="line">                pd_stop_battery_soc = &lt;<span class="number">90</span>&gt;; <span class="comment">//停止快充电量，gm3 已经舍弃</span></span><br><span class="line"></span><br><span class="line">                ibus_err = &lt;<span class="number">14</span>&gt;;</span><br><span class="line">                vsys_watt = &lt;<span class="number">5000000</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>kernel-4.14/arch/arm64/boot/dts/mediatek/bat_setting/mt6765_battery_prop.dtsi</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bat_gm30: battery&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,bat_gm30&quot;</span>;</span><br><span class="line">     ......</span><br><span class="line"><span class="comment">/*  The ui_soc will keep 100% until SOC drop X percents after unplugged*/</span></span><br><span class="line">    R_FG_VALUE = &lt;(<span class="number">10</span>)&gt;; <span class="comment">//rf 电阻用于测量充电流，需要校准</span></span><br><span class="line">    ......</span><br><span class="line">    ACTIVE_TABLE = &lt;(<span class="number">4</span>)&gt;; <span class="comment">//这里要注意一下，我们用到的电池参数table一般为四个</span></span><br><span class="line"><span class="comment">/* Table numbers per battery*/</span></span><br><span class="line">    MULTI_TEMP_GAUGE0 = &lt;(<span class="number">1</span>)&gt;;</span><br><span class="line"><span class="comment">/* Multi gauge0 enable*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mt6785_battery_table.dtsi&quot;</span> <span class="comment">// ACTIVE_TABLE 的值就是里面的参数的数组数量。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mt6785_battery_prop_dim2_ext.dtsi&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、修改-kernel-下的-config-文件"><a href="#3、修改-kernel-下的-config-文件" class="headerlink" title="3、修改 kernel 下的 config 文件"></a>3、修改 kernel 下的 config 文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/kernel<span class="number">-4.14</span>/arch/arm64/configs/k85v1_64_defconfig b/arch/arm64/configs/k85v1_64_defconfig</span><br><span class="line"></span><br><span class="line"> CONFIG_ACCDET_EINT_IRQ=y</span><br><span class="line"> CONFIG_ACCDET_SUPPORT_EINT0=y</span><br><span class="line"> CONFIG_MTK_LENS=y</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加相关配置</span></span><br><span class="line">+CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT=y</span><br><span class="line">+CONFIG_MTK_PUMP_EXPRESS_PLUS_20_SUPPORT=y</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/device/mediateksample/k85v1_64/ProjectConfig.mk b/mediateksample/k85v1_64/ProjectConfig.mk</span><br><span class="line"></span><br><span class="line"> MTK_PROTOCOL2_RAT_CONFIG = L/W/G</span><br><span class="line"> MTK_PROTOCOL3_RAT_CONFIG = G</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-MTK_PUMP_EXPRESS_PLUS_SUPPORT = no</span><br><span class="line">-MTK_PUMP_EXPRESS_PLUS_20_SUPPORT = no</span><br><span class="line"></span><br><span class="line"> MTK_PUMP_EXPRESS_PLUS_30_SUPPORT = no</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">+MTK_PUMP_EXPRESS_PLUS_20_SUPPORT = yes</span><br><span class="line">+MTK_PUMP_EXPRESS_PLUS_SUPPORT = yes</span><br><span class="line"></span><br><span class="line"> MTK_PUMP_EXPRESS_SUPPORT = no</span><br><span class="line"> MTK_RADIOOFF_POWER_OFF_MD = no</span><br><span class="line"> MTK_RAT_WCDMA_PREFERRED = no</span><br></pre></td></tr></table></figure>
<h3 id="4、vendor-目录下修改lk配置文件"><a href="#4、vendor-目录下修改lk配置文件" class="headerlink" title="4、vendor 目录下修改lk配置文件"></a>4、vendor 目录下修改lk配置文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/vendor/mediatek/proprietary/bootable/bootloader/lk/project/k85v1_64.mk b/mediatek/proprietary/bootable/bootloader/lk/project/k85v1_64.mk</span><br><span class="line"></span><br><span class="line"> DEFINES += MTK_NEW_COMBO_EMMC_SUPPORT</span><br><span class="line"> DEFINES += MTK_GPT_SCHEME_SUPPORT</span><br><span class="line"> MTK_CHARGER_NEW_ARCH := yes</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-MTK_PUMP_EXPRESS_PLUS_SUPPORT := no</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">+MTK_PUMP_EXPRESS_PLUS_SUPPORT := yes</span><br><span class="line"></span><br><span class="line"> MTK_CHARGER_INTERFACE := yes</span><br><span class="line"> MTK_MT6360_PMU_CHARGER_SUPPORT := yes</span><br><span class="line"> MTK_LCM_PHYSICAL_ROTATION = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="5、mt6360-pd-快充升压逻辑gm3-0"><a href="#5、mt6360-pd-快充升压逻辑gm3-0" class="headerlink" title="5、mt6360 pd 快充升压逻辑gm3.0"></a>5、mt6360 pd 快充升压逻辑gm3.0</h3><p>代码调用流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swchg_select_charging_current_limit</span><br><span class="line">    --&gt; mtk_pdc_get_setting <span class="comment">//这里判断是否要升压，并获取要设置的电压</span></span><br><span class="line">    --&gt; mtk_pdc_setup   <span class="comment">//设置当前应当使用的电压</span></span><br><span class="line">        --&gt; adapter_dev_set_cap(info-&gt;pd_adapter, MTK_PD,pd-&gt;cap.max_mv[idx], pd-&gt;cap.ma[idx]); <span class="comment">// 设置电压</span></span><br><span class="line">        --&gt; mtk_pdc_get_idx(info, idx, &amp;pd-&gt;pd_boost_idx, &amp;pd-&gt;pd_buck_idx); <span class="comment">// 基于当前设置的电压，更新升压，降压选项</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-升压算法"><a href="#1-升压算法" class="headerlink" title="1) 升压算法"></a>1) 升压算法</h4><p>pd 的升压逻辑很简单，就是检测当前需要的功耗是否达到了需要升压的高阈值。如果是则升压，如果低于低阈值则降压，否则使用当前电压。</p>
<p>pd_max_watt =  12400000 //升压功耗的高阈值<br>pd_min_watt =  7900000  // 升压的功耗低阈值<br>now_max_watt = cap-&gt;max_mv[idx] * ibus + chg2_watt; //当前经过计算需要的功耗</p>
<p>升压举例说明：</p>
<p>当前的 idx = 0 使用 5v 充电各个参数如下</p>
<p>idx = selected_idx = 0 //选择 5000<br>boost_idx = 1 // 选择 9000 ，当前挡位电压下的升压电压<br>buck_idx = 0  // 选择 5000 ，当前挡位下的降压电压</p>
<p>总结： 当 now_max_watt &gt; pd_max_watt 则选择升压到当前电压的高一级电压，当 now_max_watt &lt; pd_min_watt 则降低一级电压，在中间则保持不变。需要注意的是 chg1_mivr 和 chg2_mivr 也会决定了是否升压，至于这两个的判定条件是啥我也没研究清除，有大佬研究的可以告知一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtk_pdc_get_setting</span><span class="params">(struct charger_manager *info, <span class="keyword">int</span> *newvbus, <span class="keyword">int</span> *newcur,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> *newidx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx, selected_idx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pd_max_watt, pd_min_watt, now_max_watt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pdc</span> *<span class="title">pd</span> =</span> &amp;info-&gt;pdc;</span><br><span class="line">    <span class="keyword">int</span> ibus = <span class="number">0</span>, vbus;</span><br><span class="line">    <span class="keyword">int</span> ibat = <span class="number">0</span>, chg1_ibat = <span class="number">0</span>, chg2_ibat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> chg2_watt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> boost = <span class="literal">false</span>, buck = <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adapter_power_cap</span> *<span class="title">cap</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mivr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mivr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> chg1_mivr = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> chg2_mivr = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> chg2_enable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    mtk_pdc_init_table(info); <span class="comment">//获取 cap-&gt;selected_cap_idx</span></span><br><span class="line">    mtk_pdc_get_reset_idx(info);</span><br><span class="line">    mtk_pdc_get_cap_max_watt(info); <span class="comment">//当前支持的获取最大的 watt </span></span><br><span class="line"></span><br><span class="line">    cap = &amp;pd-&gt;cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cap-&gt;nr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;enable_hv_charging == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">goto</span> reset;</span><br><span class="line"></span><br><span class="line">    ret = charger_dev_get_ibus(info-&gt;chg1_dev, &amp;ibus);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        chr_err(<span class="string">&quot;[%s] get ibus fail, keep default voltage\n&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;data.parallel_vbus) &#123; <span class="comment">//计算出 chg2_watt 一般情况为0</span></span><br><span class="line">        ret = charger_dev_get_ibat(info-&gt;chg1_dev, &amp;chg1_ibat);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            chr_err(<span class="string">&quot;[%s] get ibat fail\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">        ret = charger_dev_get_ibat(info-&gt;chg2_dev, &amp;chg2_ibat);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ibat = battery_get_bat_current();</span><br><span class="line">            chg2_ibat = ibat * <span class="number">100</span> - chg1_ibat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ibat &lt; <span class="number">0</span> || chg2_ibat &lt; <span class="number">0</span>)</span><br><span class="line">            chg2_watt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            chg2_watt = chg2_ibat / <span class="number">1000</span> * battery_get_bat_voltage()</span><br><span class="line">                    / info-&gt;data.chg2_eff * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        chr_err(<span class="string">&quot;[%s] chg2_watt:%d ibat2:%d ibat1:%d ibat:%d\n&quot;</span>,</span><br><span class="line">            __func__, chg2_watt, chg2_ibat, chg1_ibat, ibat * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    charger_dev_get_mivr_state(info-&gt;chg1_dev, &amp;chg1_mivr);</span><br><span class="line">    charger_dev_get_mivr(info-&gt;chg1_dev, &amp;mivr1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_dual_charger_supported(info)) &#123;</span><br><span class="line">        charger_dev_is_enabled(info-&gt;chg2_dev, &amp;chg2_enable);</span><br><span class="line">        <span class="keyword">if</span> (chg2_enable) &#123;</span><br><span class="line">            charger_dev_get_mivr_state(info-&gt;chg2_dev, &amp;chg2_mivr);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vbus = battery_get_vbus();</span><br><span class="line">    ibus = ibus / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((chg1_mivr &amp;&amp; (vbus &lt; mivr1 / <span class="number">1000</span> - <span class="number">500</span>)) ||</span><br><span class="line">        (chg2_mivr &amp;&amp; (vbus &lt; mivr2 / <span class="number">1000</span> - <span class="number">500</span>)))</span><br><span class="line">        <span class="keyword">goto</span> reset;</span><br><span class="line"></span><br><span class="line">    selected_idx = cap-&gt;selected_cap_idx; <span class="comment">//获取当前的 idx</span></span><br><span class="line">    idx = selected_idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= ADAPTER_CAP_MAX_NR)</span><br><span class="line">        idx = selected_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pd_max_watt = cap-&gt;max_mv[idx] * (cap-&gt;ma[idx]</span><br><span class="line">            / <span class="number">100</span> * (<span class="number">100</span> - info-&gt;data.ibus_err) - <span class="number">100</span>); <span class="comment">// 高级功耗，一般为固定值从 log 读出为 12400000</span></span><br><span class="line"></span><br><span class="line">    now_max_watt = cap-&gt;max_mv[idx] * ibus + chg2_watt; <span class="comment">//当前经过计算需要的功耗</span></span><br><span class="line"></span><br><span class="line">    pd_min_watt = cap-&gt;max_mv[pd-&gt;pd_buck_idx] * cap-&gt;ma[pd-&gt;pd_buck_idx] <span class="comment">//低级功耗 7900000</span></span><br><span class="line">            / <span class="number">100</span> * (<span class="number">100</span> - info-&gt;data.ibus_err)</span><br><span class="line">            - info-&gt;data.vsys_watt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pd_min_watt &lt;= <span class="number">5000000</span>) <span class="comment">//pd 快充的最小功耗 5000000</span></span><br><span class="line">        pd_min_watt = <span class="number">5000000</span>;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;pd-&gt;pd_boost_idx: %d, pd-&gt;pd_buck_idx: %d, selected_idx: %d\n&quot;</span>,</span><br><span class="line">            pd-&gt;pd_boost_idx, pd-&gt;pd_buck_idx, selected_idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((now_max_watt &gt;= pd_max_watt) || chg1_mivr || chg2_mivr) &#123; </span><br><span class="line">        printk(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        *newidx = pd-&gt;pd_boost_idx; <span class="comment">// 选择 pd_boost_idx 也就是升压</span></span><br><span class="line">        boost = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now_max_watt &lt;= pd_min_watt) &#123;</span><br><span class="line">        printk(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">        *newidx = pd-&gt;pd_buck_idx;  <span class="comment">// 选择 pd_buck_idx 也就是降压</span></span><br><span class="line">        buck = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printk(<span class="string">&quot;333\n&quot;</span>);</span><br><span class="line">        *newidx = selected_idx;      <span class="comment">// 不变继续当前挡位充电</span></span><br><span class="line">        boost = <span class="literal">false</span>;</span><br><span class="line">        buck = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *newvbus = cap-&gt;max_mv[*newidx]; <span class="comment">//获取对应的电压</span></span><br><span class="line">    *newcur = cap-&gt;ma[*newidx];      <span class="comment">//获取对应的电流</span></span><br><span class="line"></span><br><span class="line">    chr_err(<span class="string">&quot;[%s]watt:%d,%d,%d up:%d,%d vbus:%d ibus:%d, mivr:%d,%d\n&quot;</span>,</span><br><span class="line">        __func__,</span><br><span class="line">        pd_max_watt, now_max_watt, pd_min_watt,</span><br><span class="line">       boost, buck,</span><br><span class="line">        vbus, ibus, chg1_mivr, chg2_mivr);</span><br><span class="line"></span><br><span class="line">    chr_err(<span class="string">&quot;[%s]vbus:%d:%d:%d current:%d idx:%d default_idx:%d\n&quot;</span>,</span><br><span class="line">        __func__, pd-&gt;vbus_h, pd-&gt;vbus_l, *newvbus,</span><br><span class="line">        *newcur, *newidx, selected_idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">    mtk_pdc_reset(info);</span><br><span class="line">    *newidx = pd-&gt;pd_reset_idx;</span><br><span class="line">    *newvbus = cap-&gt;max_mv[*newidx];</span><br><span class="line">    *newcur = cap-&gt;ma[*newidx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）更新当前挡位下的升压、降压-idx"><a href="#2）更新当前挡位下的升压、降压-idx" class="headerlink" title="2）更新当前挡位下的升压、降压 idx"></a>2）更新当前挡位下的升压、降压 idx</h4><p>该函数基于当前的 selected_idx 来更新升压，降压 idx，举例说明：<br>6360 当前可以供选择的电压挡位如下</p>
<p>max_mv[0] = 5000 ，ma[0] = 3000  //数组下标就是 idx<br>max_mv[1] = 9000 ，ma[1] = 2660<br>max_mv[2] = 12000, ma[2] = 2000</p>
<p>maxwatt[i] = max_mv[i] * ma[i]; // 表示功率</p>
<p>maxwatt[0] = 15000000<br>maxwatt[1] = 23940000<br>maxwatt[2] = 24000000</p>
<p>pd 支持的范围为 5000 - 9000<br>第一次插上充电器，默认使用当前挡位为最低档 0 档即设置 5000 mv 充电，同时下面参数也是默认状态 0</p>
<p>idx = selected_idx = 0 //选择 5000<br>boost_idx = 0 // 选择 5000<br>buck_idx = 0  // 选择 5000</p>
<p>调用 mtk_pdc_get_idx 更新当前状态更新完状态后如下</p>
<p>idx = selected_idx = 0 //选择 5000<br>boost_idx = 1 // 选择 9000 ，当前挡位电压下的升压电压<br>buck_idx = 0  // 选择 5000 ，当前挡位下的降压电压</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    更新升压下标 boost_idx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. 判断 max_mv[0] = 5000 是否在 5000 - 9000 范围内，明显是在的</span></span><br><span class="line"><span class="comment">    2. 判断 idx = 0 表示的功耗 maxwatt[idx] 是否小于 maxwatt[0] 明显是相等的</span></span><br><span class="line"><span class="comment">    3. 判断 max_mv[1] = 9000 是否在 5000 - 9000 范围内，明显是在的</span></span><br><span class="line"><span class="comment">    4. 判断 idx = 0 表示的功耗 maxwatt[idx] 是否小于 maxwatt[1] 明显后者更大，于是更新 idx = 1</span></span><br><span class="line"><span class="comment">    5. 判断 max_mv[2] = 12000 是否在 5000 - 9000 范围内，明显不在于是结束</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    更新 boost_idx 使用当前挡 idx 位下的更高电压即 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    接下来更新降压下标 buck_idx 更新前重新初始化当前下标 idx = selected_idx = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. 判断 max_mv[0] = 5000 是否在 5000 - 9000 范围内，明显是在的</span></span><br><span class="line"><span class="comment">    2. 判断 idx = 0 表示的功耗 maxwatt[idx] 是否大于 maxwatt[0] 明显是相等的</span></span><br><span class="line"><span class="comment">    3. 判断 max_mv[1] = 9000 是否在 5000 - 9000 范围内，明显是在的</span></span><br><span class="line"><span class="comment">    4. 判断 idx = 0 表示的功耗 maxwatt[idx] 是否大于 maxwatt[1] 明显后者更大</span></span><br><span class="line"><span class="comment">    5. 判断 max_mv[2] = 12000 是否在 5000 - 9000 范围内，明显不在于是结束</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    更新 buck_idx 使用当前挡 idx 位下的更低电压即 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtk_pdc_get_idx</span><span class="params">(struct charger_manager *info, <span class="keyword">int</span> selected_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *boost_idx, <span class="keyword">int</span> *buck_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pdc</span> *<span class="title">pd</span> =</span> &amp;info-&gt;pdc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adapter_power_cap</span> *<span class="title">cap</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cap = &amp;pd-&gt;cap;</span><br><span class="line">    idx = selected_idx;  <span class="comment">//当前设置的电压</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        chr_err(<span class="string">&quot;[%s] invalid idx:%d\n&quot;</span>, __func__, idx);</span><br><span class="line">        *boost_idx = <span class="number">0</span>;</span><br><span class="line">        *buck_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get boost_idx */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cap-&gt;nr; i++) &#123;</span><br><span class="line"></span><br><span class="line">           chr_err(<span class="string">&quot;min_mv:%d %d %d %d\n&quot;</span>,</span><br><span class="line">                    cap-&gt;min_mv[i],</span><br><span class="line">                    cap-&gt;max_mv[i],</span><br><span class="line">                    pd-&gt;vbus_l,</span><br><span class="line">                    pd-&gt;vbus_h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断 cap-&gt;mv 支付在 pd 快充支持的电压范围 </span></span><br><span class="line">        <span class="keyword">if</span> (cap-&gt;min_mv[i] &lt; pd-&gt;vbus_l ||</span><br><span class="line">            cap-&gt;max_mv[i] &lt; pd-&gt;vbus_l) &#123;</span><br><span class="line">            chr_err(<span class="string">&quot;min_mv error:%d %d %d\n&quot;</span>,</span><br><span class="line">                    cap-&gt;min_mv[i],</span><br><span class="line">                    cap-&gt;max_mv[i],</span><br><span class="line">                    pd-&gt;vbus_l);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cap-&gt;min_mv[i] &gt; pd-&gt;vbus_h ||</span><br><span class="line">            cap-&gt;max_mv[i] &gt; pd-&gt;vbus_h) &#123;</span><br><span class="line">            chr_err(<span class="string">&quot;max_mv error:%d %d %d\n&quot;</span>,</span><br><span class="line">                    cap-&gt;min_mv[i],</span><br><span class="line">                    cap-&gt;max_mv[i],</span><br><span class="line">                    pd-&gt;vbus_h);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == selected_idx) &#123;  <span class="comment">//如果当前i下标对应的功率更大，则使用更新 idx 使用更大功率表示的下标</span></span><br><span class="line">            <span class="keyword">if</span> (cap-&gt;maxwatt[i] &gt; cap-&gt;maxwatt[idx])</span><br><span class="line">                idx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap-&gt;maxwatt[i] &lt; cap-&gt;maxwatt[idx] &amp;&amp;</span><br><span class="line">                cap-&gt;maxwatt[i] &gt; cap-&gt;maxwatt[selected_idx])</span><br><span class="line">                idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *boost_idx = idx;</span><br><span class="line">    idx = selected_idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get buck_idx */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cap-&gt;nr; i++) &#123;</span><br><span class="line"></span><br><span class="line">            chr_err(<span class="string">&quot;min_mv error:%d %d %d %d\n&quot;</span>,</span><br><span class="line">                    cap-&gt;min_mv[i],</span><br><span class="line">                    cap-&gt;max_mv[i],</span><br><span class="line">                    pd-&gt;vbus_l,</span><br><span class="line">                    pd-&gt;vbus_h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cap-&gt;min_mv[i] &lt; pd-&gt;vbus_l ||</span><br><span class="line">            cap-&gt;max_mv[i] &lt; pd-&gt;vbus_l) &#123;</span><br><span class="line">            chr_err(<span class="string">&quot;min_mv error:%d %d %d\n&quot;</span>,</span><br><span class="line">                    cap-&gt;min_mv[i],</span><br><span class="line">                    cap-&gt;max_mv[i],</span><br><span class="line">                    pd-&gt;vbus_l);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cap-&gt;min_mv[i] &gt; pd-&gt;vbus_h ||</span><br><span class="line">            cap-&gt;max_mv[i] &gt; pd-&gt;vbus_h) &#123;</span><br><span class="line">            chr_err(<span class="string">&quot;max_mv error:%d %d %d\n&quot;</span>,</span><br><span class="line">                    cap-&gt;min_mv[i],</span><br><span class="line">                    cap-&gt;max_mv[i],</span><br><span class="line">                    pd-&gt;vbus_h);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == selected_idx) &#123;  <span class="comment">//如果当前i下标对应的功率更小，则使用 i 更新 idx 使用更小功率表示的下标</span></span><br><span class="line">            <span class="keyword">if</span> (cap-&gt;maxwatt[i] &lt; cap-&gt;maxwatt[idx])</span><br><span class="line">                idx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap-&gt;maxwatt[i] &gt; cap-&gt;maxwatt[idx] &amp;&amp;</span><br><span class="line">                cap-&gt;maxwatt[i] &lt; cap-&gt;maxwatt[selected_idx])</span><br><span class="line">                idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *buck_idx = idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、G90-mt6785-功放调试之控制"><a href="#四、G90-mt6785-功放调试之控制" class="headerlink" title="四、G90(mt6785)-功放调试之控制"></a>四、G90(mt6785)-功放调试之控制</h2><h3 id="1、耳机检测代码"><a href="#1、耳机检测代码" class="headerlink" title="1、耳机检测代码"></a>1、耳机检测代码</h3><p>G90 的功放和 8788 平台的有点不一样，在插上耳机的时候功放不会自动停止播放，因此在耳机检测的时候手动添加开关功放的使能引脚的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/drivers/misc/mediatek/accdet/mt6359/accdet.c</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> PMIC_ACCDET_KERNEL</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eint_work_callback</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"> <span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eint_work_callback</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> <span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     pr_info(<span class="string">&quot;accdet %s(),DCC EINT func\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cur_eint_state == EINT_PIN_PLUG_IN) &#123; <span class="comment">//检测到耳机插入跑这里</span></span><br><span class="line">         <span class="comment">/* wk, disable vusb LP */</span></span><br><span class="line">         pmic_write(PMIC_RG_LDO_VUSB_HW0_OP_EN_ADDR, <span class="number">0x8000</span>);</span><br><span class="line">         pr_info(<span class="string">&quot;%s VUSB LP dis\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">         pr_info(<span class="string">&quot;accdet cur: plug-in, cur_eint_state = %d\n&quot;</span>,</span><br><span class="line">             cur_eint_state);</span><br><span class="line"></span><br><span class="line">         amplifier_control_off();<span class="comment">/* 关闭功放， 这个函数是自己添加的 */</span></span><br><span class="line"></span><br><span class="line">         mutex_lock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         eint_accdet_sync_flag = <span class="literal">true</span>;</span><br><span class="line">         mutex_unlock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         __pm_wakeup_event(accdet_timer_lock,</span><br><span class="line">             jiffies_to_msecs(<span class="number">7</span> * HZ));</span><br><span class="line"></span><br><span class="line">         accdet_init();</span><br><span class="line"></span><br><span class="line">         pr_info(<span class="string">&quot;%s VUSB LP dis done\n&quot;</span>, __func__);</span><br><span class="line">         enable_accdet(<span class="number">0</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  <span class="comment">//检测到耳机拔出跑这里</span></span><br><span class="line">         pr_info(<span class="string">&quot;accdet cur:plug-out, cur_eint_state = %d\n&quot;</span>,</span><br><span class="line">             cur_eint_state);</span><br><span class="line"></span><br><span class="line">         amplifier_control_on();<span class="comment">/* 打开功放，这个函数是自己添加的 */</span></span><br><span class="line"></span><br><span class="line">         mutex_lock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         eint_accdet_sync_flag = <span class="literal">false</span>;</span><br><span class="line">         accdet_thing_in_flag = <span class="literal">false</span>;</span><br><span class="line">         mutex_unlock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         <span class="keyword">if</span> (accdet_dts.moisture_detect_mode != <span class="number">0x5</span>)</span><br><span class="line">             del_timer_sync(&amp;micbias_timer);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* disable accdet_sw_en=0</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         pmic_write_clr(PMIC_ACCDET_SW_EN_ADDR,</span><br><span class="line">             PMIC_ACCDET_SW_EN_SHIFT);</span><br><span class="line">         disable_accdet();</span><br><span class="line">         headset_plug_out();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ACCDET_EINT_IRQ</span></span><br><span class="line"> <span class="keyword">if</span> (get_moisture_det_en() == <span class="number">0x1</span>)</span><br><span class="line">     recover_moisture_setting(gmoistureID);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     recover_eint_setting(gmoistureID);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ACCDET_EINT</span></span><br><span class="line"> enable_irq(accdet_irq);</span><br><span class="line"> pr_info(<span class="string">&quot;accdet %s enable_irq !!\n&quot;</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、耳机有声音功放没声音"><a href="#2、耳机有声音功放没声音" class="headerlink" title="2、耳机有声音功放没声音"></a>2、耳机有声音功放没声音</h3><p>插上耳机 pmu 才有功放信号输出，拔出耳机就没有信号输出，这里的信号指 pmu 端的信号，其实就是外置功放修改，修改如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/device/mediateksample/k85v1_64/ProjectConfig.mk b/mediateksample/k85v1_64/ProjectConfig.mk</span><br><span class="line"></span><br><span class="line"> MTK_AUDIO_MIC_INVERSE = no</span><br><span class="line"> MTK_AUDIO_NUMBER_OF_MIC = <span class="number">2</span></span><br><span class="line"> MTK_AUDIO_NUMBER_OF_SPEAKER = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-MTK_AUDIO_SPEAKER_PATH = smartpa_mtk_mt6660</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">+MTK_AUDIO_SPEAKER_PATH = int_hp_buf</span><br><span class="line"> MTK_AUDIO_TUNING_TOOL_VERSION = V2<span class="number">.2</span></span><br><span class="line"> MTK_AUDIO_TUNNELING_SUPPORT = no</span><br><span class="line"> MTK_AUIDO_MIC_INVERSE = no</span><br></pre></td></tr></table></figure>
<h3 id="3、喇叭尾音"><a href="#3、喇叭尾音" class="headerlink" title="3、喇叭尾音"></a>3、喇叭尾音</h3><p>Android系统默认播放停止后3秒会进入Standby模式以节省电源.standby里面有pcm_close接口，会关闭speaker的输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/av/services/audioflinger/AudioFlinger.h b/av/services/audioflinger/AudioFlinger.h</span><br><span class="line">old mode <span class="number">100644</span></span><br><span class="line"><span class="keyword">new</span> mode <span class="number">100755</span></span><br><span class="line">index <span class="number">978</span>d39132.<span class="number">.73</span>db1b203</span><br><span class="line">--- a/av/services/audioflinger/AudioFlinger.h</span><br><span class="line">+++ b/av/services/audioflinger/AudioFlinger.h</span><br><span class="line">@@ <span class="number">-97</span>,<span class="number">7</span> +<span class="number">97</span>,<span class="number">7</span> @@ class ServerProxy;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">-<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">nsecs_t</span> kDefaultStandbyTimeInNsecs = seconds(<span class="number">3</span>);</span><br><span class="line">+<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">nsecs_t</span> kDefaultStandbyTimeInNsecs = milliseconds(<span class="number">200</span>);</span><br><span class="line"> <span class="comment">//MTK_AUDIO_FIX_DEFAULT_DEFECT</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">nsecs_t</span> kDefaultA2dpStandbyTimeInNsecs = milliseconds(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<h3 id="四、耳机立体声修改"><a href="#四、耳机立体声修改" class="headerlink" title="四、耳机立体声修改"></a>四、耳机立体声修改</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vendor/mediatek/proprietary/custom/tb8788p1_64_bsp/hal/audioflinger/audio/audio_custom_exp.h</span><br><span class="line"><span class="comment">//在这个文件中增加宏 #define ENABLE_STEREO_SPEAKER</span></span><br></pre></td></tr></table></figure>
<h3 id="4、-打开-ATCI"><a href="#4、-打开-ATCI" class="headerlink" title="4、 打开 ATCI"></a>4、 打开 ATCI</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*#*#<span class="number">3646633</span>#*#*</span><br></pre></td></tr></table></figure>
<p>Log and Debugging -&gt; ATCI -&gt; ALWAYS ENABLE ATCI</p>
<p><strong>喇叭文件频响曲线存放目录</strong><br>device/mediatek/common/audio_param</p>
<h2 id="三、G90-mt6785-sensorhub"><a href="#三、G90-mt6785-sensorhub" class="headerlink" title="三、G90(mt6785)-sensorhub"></a>三、G90(mt6785)-sensorhub</h2><h2 id="四、背光能调到黑屏"><a href="#四、背光能调到黑屏" class="headerlink" title="四、背光能调到黑屏"></a>四、背光能调到黑屏</h2><p>当打开自动调节背光功能的时候，手动调节设置中背光滚动条将背光设置到最小，屏幕会完全变黑，这种现象可能与lcm的最小亮度有关，可以采用如下方式解决：</p>
<p>1、adb comand设置背光，确定可以使lcm点亮的最小背光值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adb shell echo xx &gt;/sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">lcd</span>-<span class="title">backlight</span>/<span class="title">brightness</span>    <span class="title">xx</span>为<span class="title">backlight</span> <span class="title">level</span></span></span><br></pre></td></tr></table></figure>
<p>2、修改alps/frameworks/base/core/res/res/values/config.xml中如下参数的值为步骤1中所获取的最小背光值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;!-- Minimum allowable screen brightness to use in a very dark room.</span><br><span class="line">This value sets the <span class="built_in">floor</span> <span class="keyword">for</span> the darkest possible <span class="keyword">auto</span>-brightness</span><br><span class="line">adjustment. It is expected to be somewhat less than the first entry in</span><br><span class="line">config_autoBrightnessLcdBacklightValues so as to allow the user to have</span><br><span class="line">some range of adjustment to dim the screen further than usual in very</span><br><span class="line">dark rooms. The contents of the screen must still be clearly visible</span><br><span class="line">in darkness (although they may not be visible in a bright room). --&gt;</span><br><span class="line">&lt;integer name=<span class="string">&quot;config_screenBrightnessDark&quot;</span>&gt;<span class="number">1</span>&lt;/integer&gt;</span><br></pre></td></tr></table></figure>
<h2 id="五、摄像头"><a href="#五、摄像头" class="headerlink" title="五、摄像头"></a>五、摄像头</h2><h3 id="1、摄像头引脚"><a href="#1、摄像头引脚" class="headerlink" title="1、摄像头引脚"></a>1、摄像头引脚</h3><p>IOVDD(input output vdd): 负责i2c电压，没有这路电无法读到id，电压一般为 1.8, 少数为2.8内部转化为1.8</p>
<p>DVDD(digital vdd): 用于给数字信号供电，1.2v</p>
<p>AVDD( VDD)：用于给 cmos 供电，放大模拟信号，2.8v</p>
<p>PWDN(power wdn): 给摄像头芯片供电，1.8</p>
<p>RESET: 芯片复位信号</p>
<p>MCLK:一般为 24/26MHZ</p>
<h3 id="2、摄像头去掉af"><a href="#2、摄像头去掉af" class="headerlink" title="2、摄像头去掉af"></a>2、摄像头去掉af</h3><p>vendor/mediatek/proprietary/custom/mt6785/hal/imgsensor_metadata/gc5035_mipi_raw/config_static_metadata.module.gc5035mipiraw.h</p>
<p>将 MTK_CONTROL_AF_MODE_CONTINUOUS_PICTRUE 改为 MTK_CONTROL_AF_MODE_OFF</p>
<p>同时修改<br>vendor/mediatek/proprietary/custom/mt6785/hal/lens/src/lenslist.cpp<br>将对应的配置改为 “Dummy” 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;S5K3M3_SENSOR_ID, DUMMY_MODULE_ID, AK7371AF_LENS_ID, <span class="string">&quot;Dummy&quot;</span>, pAK7371AF_MAIN2_getDefaultData&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="3、修改摄像头方向以及mipi通道"><a href="#3、修改摄像头方向以及mipi通道" class="headerlink" title="3、修改摄像头方向以及mipi通道"></a>3、修改摄像头方向以及mipi通道</h3><p>vendor\mediatek\proprietary\custom\mt8168\hal\imgsensor_src\cfg_setting_imgsensor.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> CUSTOM_CFG gCustomCfg[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .sensorIdx     = IMGSENSOR_SENSOR_IDX_MAIN,</span><br><span class="line"><span class="comment">//        .mclk          = CUSTOM_CFG_MCLK_1,</span></span><br><span class="line"><span class="comment">//        .port          = CUSTOM_CFG_CSI_PORT_0,</span></span><br><span class="line">        .mclk          = CUSTOM_CFG_MCLK_3, <span class="comment">//修改mipi通道为 3</span></span><br><span class="line">        .port          = CUSTOM_CFG_CSI_PORT_2,</span><br><span class="line">        .dir           = CUSTOM_CFG_DIR_REAR,</span><br><span class="line">        .bitOrder      = CUSTOM_CFG_BITORDER_9_2,</span><br><span class="line">        .orientation   = <span class="number">90</span>, <span class="comment">//设置方向</span></span><br><span class="line">        .horizontalFov = <span class="number">67</span>,</span><br><span class="line">        .verticalFov   = <span class="number">49</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .sensorIdx     = IMGSENSOR_SENSOR_IDX_SUB,</span><br><span class="line"> <span class="comment">//       .mclk          = CUSTOM_CFG_MCLK_3,</span></span><br><span class="line"> <span class="comment">//       .port          = CUSTOM_CFG_CSI_PORT_2,</span></span><br><span class="line">        .mclk          = CUSTOM_CFG_MCLK_1,</span><br><span class="line">        .port          = CUSTOM_CFG_CSI_PORT_0,</span><br><span class="line">        .dir           = CUSTOM_CFG_DIR_FRONT,</span><br><span class="line">        .bitOrder      = CUSTOM_CFG_BITORDER_9_2,</span><br><span class="line">        .orientation   = <span class="number">270</span>,</span><br><span class="line">        .horizontalFov = <span class="number">63</span>,</span><br><span class="line">        .verticalFov   = <span class="number">40</span>,</span><br><span class="line">        .secure        = CUSTOM_CFG_SECURE_M0</span><br><span class="line">    &#125;,</span><br><span class="line">.......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、摄像头连不上cct"><a href="#4、摄像头连不上cct" class="headerlink" title="4、摄像头连不上cct"></a>4、摄像头连不上cct</h3><p>请检查是否设置了 SENSOR_OUTPUT_FORMAT_RAW_Gb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+++ b/drivers/misc/mediatek/imgsensor/src/common/v1_1/s5k5e9_mipi_raw/s5k5e9mipiraw_Sensor.c</span><br><span class="line">@@ <span class="number">-156</span>,<span class="number">7</span> +<span class="number">156</span>,<span class="number">7</span> @@ <span class="keyword">static</span> imgsensor_info_struct imgsensor_info = &#123;</span><br><span class="line">        .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,</span><br><span class="line">        .mipi_sensor_type = MIPI_OPHY_NCSI2, <span class="comment">//0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2</span></span><br><span class="line">        .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,<span class="comment">//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL</span></span><br><span class="line">-       .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,</span><br><span class="line">+       .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gr,</span><br><span class="line">        .mclk = <span class="number">24</span>,</span><br><span class="line">        .mipi_lane_num = SENSOR_MIPI_2_LANE,</span><br><span class="line">        .i2c_addr_table = &#123;<span class="number">0x5a</span>,<span class="number">0x20</span>,<span class="number">0xff</span>&#125;,</span><br><span class="line">@@ <span class="number">-165</span>,<span class="number">7</span> +<span class="number">165</span>,<span class="number">7</span> @@ <span class="keyword">static</span> imgsensor_info_struct imgsensor_info = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> imgsensor_struct imgsensor = &#123;</span><br><span class="line">-       .mirror = IMAGE_HV_MIRROR,                              <span class="comment">//mirrorflip information</span></span><br><span class="line">+       .mirror = IMAGE_NORMAL,                         <span class="comment">//mirrorflip information</span></span><br><span class="line">        .sensor_mode = IMGSENSOR_MODE_INIT, <span class="comment">//IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Ca       pture, Video,High Speed Video, Slim Video</span></span><br><span class="line">        .shutter = <span class="number">0x3D0</span>,                                       <span class="comment">//current shutter</span></span><br><span class="line">        .gain = <span class="number">0x100</span>,                                          <span class="comment">//current gain</span></span><br></pre></td></tr></table></figure>
<h2 id="六、adb-remount"><a href="#六、adb-remount" class="headerlink" title="六、adb remount"></a>六、adb remount</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader </span><br><span class="line">echo 等待进入bootloader</span><br><span class="line">pause</span><br><span class="line">fastboot flashing unlock</span><br><span class="line">echo 按照界面提示按小机音量+按键</span><br><span class="line">pause</span><br><span class="line">fastboot reboot</span><br><span class="line">echo 等待开机完成</span><br><span class="line">pause</span><br><span class="line">adb root</span><br><span class="line">pause</span><br><span class="line">adb disable-verity </span><br><span class="line">adb reboot</span><br><span class="line">pause</span><br><span class="line">adb root </span><br><span class="line">adb remount</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<h2 id="七、安卓11打开串口log"><a href="#七、安卓11打开串口log" class="headerlink" title="七、安卓11打开串口log"></a>七、安卓11打开串口log</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/drivers/misc/mediatek/mtprintk/mtk_printk_ctrl.c</span><br><span class="line">+++ b/drivers/misc/mediatek/mtprintk/mtk_printk_ctrl.c</span><br><span class="line">@@ <span class="number">-34</span>,<span class="number">7</span> +<span class="number">34</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTK_ENG_BUILD</span></span><br><span class="line"> <span class="keyword">int</span> printk_ctrl;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">-<span class="keyword">int</span> printk_ctrl = <span class="number">1</span>;</span><br><span class="line">+<span class="keyword">int</span> printk_ctrl = <span class="number">0</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> module_param_named(disable_uart, printk_ctrl, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">@@ <span class="number">-51</span>,<span class="number">7</span> +<span class="number">51</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">bool</span> <span class="title">mt_get_uartlog_status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">mt_disable_uart</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="comment">/* uart print not always enable */</span></span><br><span class="line">-       <span class="keyword">if</span> (printk_ctrl != <span class="number">2</span>)</span><br><span class="line">+       <span class="keyword">if</span> (printk_ctrl != <span class="number">0</span>)</span><br><span class="line">                printk_ctrl = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="八、安卓按键映射"><a href="#八、安卓按键映射" class="headerlink" title="八、安卓按键映射"></a>八、安卓按键映射</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\out\target\product\tb8168p1_64_bsp\system\usr\keylayout\Generic.kl</span><br></pre></td></tr></table></figure>
<h2 id="九、mtk-平台反汇编-dts"><a href="#九、mtk-平台反汇编-dts" class="headerlink" title="九、mtk 平台反汇编 dts"></a>九、mtk 平台反汇编 dts</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out/target/product/tb8788p1_64_bsp/obj/KERNEL_OBJ/scripts/dtc/dtc -I dtb -O dts -o out/target/product/tb8788p1_64_bsp/obj/KERNEL_OBJ/arch/arm64/boot/dts/mediatek/mt6771.dtb</span><br></pre></td></tr></table></figure>
<p>1、dtbo img -&gt; dtb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./out/host/linux-x86/bin/mkdtimg dump out/target/product/tb8788p1_64_bsp/dtbo-verified.img -b a<span class="number">.0</span></span><br><span class="line">执行后生成a<span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>2、dtb-&gt;dts</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./out/target/product/tb8788p1_64_bsp/obj/KERNEL_OBJ/scripts/dtc/dtc -I dtb -O dts -o x100.dts a<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">执行后生成x100.dts</span><br></pre></td></tr></table></figure>
<h2 id="十、快速打包patch"><a href="#十、快速打包patch" class="headerlink" title="十、快速打包patch"></a>十、快速打包patch</h2><ol>
<li>将脚本 outdiff 拷贝进需要打包的目录</li>
<li>运行 git status &gt; a.txt 创建 a.txt 文件</li>
<li>运行脚本 ./outdiff 创建出 patch 目录 out_diff 该目录有 modified 文件</li>
<li>对比 a.txt 将新曾文件拷贝进对应目录</li>
</ol>
<h2 id="十一、打开mtklog"><a href="#十一、打开mtklog" class="headerlink" title="十一、打开mtklog"></a>十一、打开mtklog</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adb shell am start -n com.mediatek.mtklogger/com.mediatek.mtklogger.MainActivity</span><br></pre></td></tr></table></figure>
<h2 id="十二、给sys节点权限"><a href="#十二、给sys节点权限" class="headerlink" title="十二、给sys节点权限"></a>十二、给sys节点权限</h2><p>1.并非所有的 Linux distributions 都支持 SELinux<br> 目前 SELinux 支持三种模式，分别如下：<br>enforcing ： 强制模式，代表 SELInux 运作中，且已经 正确的开始限制domain/type<br>permisssive:宽容模式，代表 SELinux 运座钟，不过仅会有警告讯息并不会限制<br>domain/type的存取。这个模式可以用来运作为 SELinux 的 debug 之用。<br>disabled： 关闭， SELinux 并没有实际运作</p>
<p>2.查看 SELinux 的模式<br> get enforcing =》enforcing<br>在 MTK 的平台下查看 SELinux 的方法是使用 getenforce<br>如果显示是 enforcing 就说明 SELinux 是打开的<br>如果显示是 disabled 就说明 SELinux 是关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第一处修改</span><br><span class="line">system/core/init/selinux.cpp</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">IsEnforcing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+       <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//这里返回false</span></span><br><span class="line">     <span class="keyword">if</span> (ALLOW_PERMISSIVE_SELINUX) &#123;</span><br><span class="line">         <span class="keyword">return</span> StatusFromCmdline() == SELINUX_ENFORCING;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二处修改</span><br><span class="line">diff --git a/mediateksample/k71v1_64_bsp/init.project.rc b/mediateksample/k71v1_64_bsp/init.project.rc</span><br><span class="line">index <span class="number">8722</span>a5a5..c87338c3 <span class="number">100755</span></span><br><span class="line">--- a/mediateksample/k71v1_64_bsp/init.project.rc</span><br><span class="line">+++ b/mediateksample/k71v1_64_bsp/init.project.rc</span><br><span class="line">@@ <span class="number">-35</span>,<span class="number">6</span> +<span class="number">35</span>,<span class="number">11</span> @@ on post-fs-data</span><br><span class="line">     chmod <span class="number">0660</span> /dev/spm</span><br><span class="line">     chown system system /dev/spm</span><br><span class="line"></span><br><span class="line">+#ADDNODE</span><br><span class="line">+       chmod <span class="number">0666</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">led_ctrl</span>/<span class="title">led_ctrl</span></span></span><br><span class="line"><span class="class">+       <span class="title">chmod</span> 0666 /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">hall</span>/<span class="title">hall_1</span></span></span><br><span class="line"><span class="class">+       <span class="title">chmod</span> 0666 /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">hall</span>/<span class="title">hall_2</span></span></span><br></pre></td></tr></table></figure>
<h2 id="十三、安卓11编译相关"><a href="#十三、安卓11编译相关" class="headerlink" title="十三、安卓11编译相关"></a>十三、安卓11编译相关</h2><h3 id="1、-Split-command-build-for-system-product"><a href="#1、-Split-command-build-for-system-product" class="headerlink" title="1、 Split command build for system product"></a>1、 Split command build for system product</h3><h4 id="1）Build-system-project"><a href="#1）Build-system-project" class="headerlink" title="1）Build system project"></a>1）Build system project</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out_sys</span><br><span class="line">lunch sys_mssi_64_ww-eng</span><br><span class="line">make sys_images</span><br></pre></td></tr></table></figure>
<h4 id="2）Partial-build"><a href="#2）Partial-build" class="headerlink" title="2）Partial build"></a>2）Partial build</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out_sys</span><br><span class="line">lunch sys_mssi_64_ww-eng</span><br><span class="line">mmma system/related/paths</span><br><span class="line">(<span class="keyword">or</span> make system_module_name, <span class="keyword">or</span> mm, mmm google <span class="keyword">default</span> command.)</span><br></pre></td></tr></table></figure>
<h3 id="2、Split-command-build-for-vendor-product"><a href="#2、Split-command-build-for-vendor-product" class="headerlink" title="2、Split command build for vendor product"></a>2、Split command build for vendor product</h3><h4 id="1）Build-vendor-project"><a href="#1）Build-vendor-project" class="headerlink" title="1）Build vendor project"></a>1）Build vendor project</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out</span><br><span class="line">lunch vnd_k71v1_64_bsp-eng</span><br><span class="line">make vnd_images krn_images</span><br></pre></td></tr></table></figure>
<h4 id="2-Partial-build"><a href="#2-Partial-build" class="headerlink" title="2) Partial build"></a>2) Partial build</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out</span><br><span class="line">lunch vnd_k71v1_64_bsp-eng</span><br><span class="line">mmma vendor/related/paths</span><br></pre></td></tr></table></figure>
<h3 id="3、Image-post-process"><a href="#3、Image-post-process" class="headerlink" title="3、Image post process"></a>3、Image post process</h3><h4 id="1-Normal-load"><a href="#1-Normal-load" class="headerlink" title="1) Normal load"></a>1) Normal load</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out/target/product/mssi_t_64_cn/images/split_build.py --system-dir out/target/product/mssi_t_64_cn/images --vendor-dir out/target/product/tb8789p2_64/images --kernel-dir out/target/product/tb8789p2_64/images --output-dir out/target/product/tb8789p2_64/merged</span><br></pre></td></tr></table></figure>
<h4 id="2-Normal-OTA"><a href="#2-Normal-OTA" class="headerlink" title="2) Normal + OTA"></a>2) Normal + OTA</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out_sys/target/product/mssi_64_ww/images/split_build.py --system-dir out_sys/target/product/mssi</span><br><span class="line">_64_ww/images --vendor-dir out/target/product/k71v1_64_bsp/images --kernel-dir out/target/product/k71v1</span><br><span class="line">_64_bsp/images --output-dir output_load --otapackage</span><br></pre></td></tr></table></figure>
<h4 id="3-Normal-CTS"><a href="#3-Normal-CTS" class="headerlink" title="3) Normal + CTS"></a>3) Normal + CTS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out_sys/target/product/mssi_64_ww/images/split_build.py --system-dir out_sys/target/product/mssi</span><br><span class="line">_64_ww/images --vendor-dir out/target/product/k71v1_64_bsp/images --kernel-dir out/target/product/k71v1</span><br><span class="line">_64_bsp/images --output-dir output_load --certs-dir $CTS_SECURITY_KEY</span><br></pre></td></tr></table></figure>
<h4 id="4-Normal-OTA-CTS"><a href="#4-Normal-OTA-CTS" class="headerlink" title="4) Normal + OTA + CTS"></a>4) Normal + OTA + CTS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out_sys/target/product/mssi_64_ww/images/split_build.py --system-dir out_sys/target/product/mssi</span><br><span class="line">_64_ww/images --vendor-dir out/target/product/k71v1_64_bsp/images --kernel-dir out/target/product/k71v1</span><br><span class="line">_64_bsp/images --output-dir output_load --otapackage --certs-dir $CTS_SECURITY_KEY</span><br></pre></td></tr></table></figure>
<h4 id="5）编译命令"><a href="#5）编译命令" class="headerlink" title="5）编译命令"></a>5）编译命令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh &amp;&amp; lunch sys_mssi_t_64_cn-userdebug &amp;&amp; make sys_images &amp;&amp; lunch vnd_tb8789p2_64-userdebug &amp;&amp; make -j24 vnd_images krn_images</span><br></pre></td></tr></table></figure>
<h2 id="十四、linux-查看内存空间"><a href="#十四、linux-查看内存空间" class="headerlink" title="十四、linux 查看内存空间"></a>十四、linux 查看内存空间</h2><p>df -h</p>
<h2 id="十五、设置蓝牙开机默认状态"><a href="#十五、设置蓝牙开机默认状态" class="headerlink" title="十五、设置蓝牙开机默认状态"></a>十五、设置蓝牙开机默认状态</h2><p>开机设置系统将 wifi 蓝牙 gsensor 默认打开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vendor/mediatek/proprietary/packages/apps/SettingsProvider/ res/values/defaults.xml</span><br><span class="line">&lt;<span class="keyword">bool</span> name=<span class="string">&quot;def_accelerometer_rotation&quot;</span>&gt;<span class="literal">true</span>&lt;/<span class="keyword">bool</span>&gt;</span><br><span class="line">&lt;integer name=<span class="string">&quot;def_user_rotation&quot;</span>&gt;<span class="number">1</span>&lt;/integer&gt;</span><br><span class="line">&lt;<span class="keyword">bool</span> name=<span class="string">&quot;def_bluetooth_on&quot;</span>&gt;<span class="literal">true</span>&lt;/<span class="keyword">bool</span>&gt;</span><br><span class="line">&lt;<span class="keyword">bool</span> name=<span class="string">&quot;def_wifi_on&quot;</span>&gt;<span class="literal">true</span>&lt;/<span class="keyword">bool</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="十六、快速获取设备路径"><a href="#十六、快速获取设备路径" class="headerlink" title="十六、快速获取设备路径"></a>十六、快速获取设备路径</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">    dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">    path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="十七、lk-阶段到-kernel-阶段屏幕会闪一下"><a href="#十七、lk-阶段到-kernel-阶段屏幕会闪一下" class="headerlink" title="十七、lk 阶段到 kernel 阶段屏幕会闪一下"></a>十七、lk 阶段到 kernel 阶段屏幕会闪一下</h2><p>抓取 mipi 波形发现，mipi 波形从 lk 到 kernel 阶段时波形被拉宽了<br>最终发现原因如下 lk 阶段直接使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码路径</span></span><br><span class="line">mediatek/proprietary/bootable/bootloader/lk/platform/mt6785/ddp_dsi.c </span><br><span class="line"></span><br><span class="line">    horizontal_backporch_byte =</span><br><span class="line">          ((dsi_params-&gt;horizontal_backporch +</span><br><span class="line">            dsi_params-&gt;horizontal_sync_active) * dsiTmpBufBpp - <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>这个公式计算这里的 horizontal_sync_active = 16 计算出来得到 188<br>但是 kernel 阶段对 t_hsa 多做了一个处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码路径</span></span><br><span class="line">drivers/misc/mediatek/video/mt6785/dispsys/ddp_dsi.c </span><br><span class="line"></span><br><span class="line">t_hsa = ALIGN_TO(t_hsa * dsiTmpBufBpp - <span class="number">4</span>, <span class="number">4</span>); <span class="comment">// kernel多了这个计算</span></span><br><span class="line"></span><br><span class="line"> ASSERT((t_hbp + t_hsa) * dsiTmpBufBpp &gt; <span class="number">9</span>);</span><br><span class="line">t_hbp = ALIGN_TO((t_hbp + t_hsa) * dsiTmpBufBpp - <span class="number">10</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>在kernel 多了这个算法使得 t_hsa  从 16 变成了 44， 最终导致 计算结果变成了 272 ，mtk 给的解决方案如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前面的第三行代码为如下</span></span><br><span class="line">t_hbp = ALIGN_TO((t_hbp + dsi_params-&gt;horizontal_sync_active) * dsiTmpBufBpp - <span class="number">10</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>同时对于<strong>行同步型号</strong> hsa，hbp 等都会调用 ALIGN_TO 函数对 4 做取整的操作(mtk 说是和内部设计相关)。因此我们填写参数可以直接将行同步信号填为 4 的整数倍</p>
<h2 id="十八、安卓-11-关闭-lib-库校验"><a href="#十八、安卓-11-关闭-lib-库校验" class="headerlink" title="十八、安卓 11 关闭 lib 库校验"></a>十八、安卓 11 关闭 lib 库校验</h2><p>安卓 9 是默认关闭的，在 Android.mk 中增加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOCAL_CHECK_ELF_FILES := <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="十九、安卓-9-编译打包-dtbo"><a href="#十九、安卓-9-编译打包-dtbo" class="headerlink" title="十九、安卓 9 编译打包 dtbo"></a>十九、安卓 9 编译打包 dtbo</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make dtboimage -j8 <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee build.<span class="built_in">log</span></span><br><span class="line">./vendor/mediatek/proprietary/scripts/sign-image/sign_image.sh</span><br></pre></td></tr></table></figure>
<h2 id="二十、mkt-pclk计算"><a href="#二十、mkt-pclk计算" class="headerlink" title="二十、mkt pclk计算"></a>二十、mkt pclk计算</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">params-&gt;dsi.PLL_CLOCK  = (vertical_sync_active + vertical_backporch + vertical_frontporch + FRAME_HEIGHT) * (horizontal_sync_active + horizontal_backporch + horizontal_frontporch + FRAME_WIDTH) * fps * <span class="number">24</span> / (<span class="number">4</span> * <span class="number">2</span>)；</span><br></pre></td></tr></table></figure>
<h2 id="二十一、闪屏debug"><a href="#二十一、闪屏debug" class="headerlink" title="二十一、闪屏debug"></a>二十一、闪屏debug</h2><ol>
<li>排除背光。<br> a、  把背光接固定背光，如果仍然闪屏，说明不是背光的问题；<br>如果屏不闪，说明是背光问题。<br> b、 如果是背光问题，继续分析是否有开AAL功能，如果有开<br>AAL功能，请将AAL功能关闭。如果关闭AAL功能后，屏不闪，说明是<br>AAL导致的屏闪，请提issue给MTK。如果关闭AAL功能后，屏仍然闪，<br>请内部确认贵司是否有在framework层做改动，很多情况是由于改动<br>Framework，绕过LightService直接控制背光结点导致的问题。<br> c、 其实当定位到是背光的问题了，这个时候就可以提问题给<br>MTK了，抓取Mobile log给MTK。</li>
<li>排除ESD。<br> a、如果通过第一步（a）排除说不是背光闪,第二步可以检查是否由于ESD check<br>导致的闪屏。可以先关闭ESD功能，看显示是否仍然会闪。如果关闭ESD功能后，lcm不<br>再闪动，说明是ESD check导致的闪屏。这个时候就可以提把Mobile log抓过来给MTK看了。<br>如果关闭ESD功能后，lcm仍然闪动，说明和ESD check无关。</li>
<li>其他情况。<br>  a、如果背光和ESD都给排除了，这个时候是bug的概率比较大。（常见的情况是待机<br>的时候不定时的闪屏），抓取Mobilelog过来给MTK check。</li>
</ol>
<h2 id="二十二、g-sensor-系统不转"><a href="#二十二、g-sensor-系统不转" class="headerlink" title="二十二、g-sensor 系统不转"></a>二十二、g-sensor 系统不转</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">frameworks/base/core/res/res/values/config.xml</span><br><span class="line">&lt;<span class="keyword">bool</span> name=<span class="string">&quot;config_allowAllRotations&quot;</span>&gt;<span class="literal">true</span>&lt;/<span class="keyword">bool</span>&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>pinctrl 子系统</title>
    <url>/2021/06/11/linux%E9%A9%B1%E5%8A%A8-pinctrl/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;分析总结 pinctrl 子系统框架结构，平台 mtk6771 内核版本 kernel-4.4 , 本文所有的分析均基于此版本。</p>
<a id="more"></a>

<h2 id="一、pinctrl-子系统基本概念"><a href="#一、pinctrl-子系统基本概念" class="headerlink" title="一、pinctrl 子系统基本概念"></a>一、pinctrl 子系统基本概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; 引脚控制子系统(pin control subsystem)，和设备模型一样是linux驱动最基础的系统之一。 对于一块 soc 的 cpu 上有很多引脚，驱动工程师需要根据其应用场景使其处于我们需要的状态，例如配置某个引脚为 gpio 或者 配置其为 i2c。对于不同的 cpu 其寄存器的地址往往是不一样的，比如 S3C2440 的 gpio 控制器的基地址为 0x53000000，而 mtk 的 gpio 地址为 0x10005000，而且寄存器的地址的位也表示不同的含义，而内核为了兼容不同的芯片于是创建出 pinctrl 子系统，该系统用于<font color=red>将板级信息从内核分离出来</font>，对于真正的寄存器的操作，由 soc 厂家来完成(bsp工程师)，而对于普通的驱动工程师来讲，我们调用内核给出的统一接口来设置对应的pin脚就行了。</p>
<h3 id="1、pinctrl-dev"><a href="#1、pinctrl-dev" class="headerlink" title="1、pinctrl_dev"></a>1、pinctrl_dev</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;该结构是 pinctrl 子系统的核心结构，每一个 soc 都需要向内核注册一个 pinctrl_dev 来描述该 pinctl 子系统，它包含下面几部分内容。</p>
<ol>
<li>注册到该子系统的 soc 的引脚控制器 pinctrl_desc</li>
<li>注册到该子系统的 pin 脚 pin_desc_tree</li>
<li>注册到该子系统的 pin 脚对应的 gpio_rang</li>
<li>注册到该子系统的 私有数据</li>
<li>soc 的 pin 脚的默认状态以及，板子休眠时 pin 脚的状态，我看了一下 mtk 平台好像并没有用到这部分功能，不知道其他平台有没有用到这个功能。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>                <span class="comment">// 挂接到全局 pinctrldev_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span>            <span class="comment">// 引脚控制器描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span> <span class="comment">// 用于挂接所有注册到该设备的 pin 脚，注册的 pin 脚由</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span>         <span class="comment">// 用于挂接 gpio_range</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                   <span class="comment">// 设备模型中的设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *driver_data;                    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>                    <span class="comment">// 当前设备的 pinctrl ，用于管理整个 soc 板子的 pin 脚状态。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span>    <span class="comment">// 板子默认的 pin 脚状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span>      <span class="comment">// 板子休眠时的 pin 脚状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、pinctrl-desc"><a href="#2、pinctrl-desc" class="headerlink" title="2、pinctrl_desc"></a>2、pinctrl_desc</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;pinctrl_desc 表示引脚控制器，它是软件上抽象出来的概念，抽象这个结构是为了方便代码的编写，实际硬件并不存在这样的控制器，该结构描述对 pin 脚寄存器真正的操作接口，该接口通常由 soc 厂完成，一般情况一个 soc 只有一个 pinctrl_desc 结构，它包含了下面内容。</p>
<ol>
<li>soc 要处理的<font color=red>所有引脚</font>的软件描述</li>
<li>获取每个(组)引脚的 pin 脚信息的操作接口 pctlops</li>
<li>每个(组)引脚的复用(pinmux)操作接口 pmxops</li>
<li>每个(组)引脚的电器特性(pinconfig)操作接口 confops</li>
<li>支持客制化的 pinconfig</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引脚控制器描述符，将其注册到引脚控制子系统</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                    <span class="comment">// 引脚控制器的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span> <span class="comment">// 引脚描述符数组，描述此引脚控制器处理的所有引脚</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> npins;                  <span class="comment">// 数组中描述符的数量，通常只是上面的 pin 字段的 ARRAY_SIZE()</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span>   <span class="comment">// 用于获取pin group 信息以及将设备树中的引脚配置(引脚复用以及pinconfig)转换为对应的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>     <span class="comment">// pin 复用相关操作，以 group 为单位进行操作</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span>   <span class="comment">// 配饰 pin 的 pinconfg(上拉、下拉、输出方式等)，以 pin 或 group 为操作对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                <span class="comment">// 提供引脚控制器的模块，用于重新计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_custom_params;      <span class="comment">// 客制化引脚支持的 pinconfig 的数量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span> <span class="comment">// 客制化引脚支持的 pinconfig</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span>    <span class="comment">// 有关如何在 debugfs 中打印 @params 的信息，必须与 @custom_params 大小相同，即 @num_custom_params</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-pinctrl-pin-desc"><a href="#1-pinctrl-pin-desc" class="headerlink" title="1) pinctrl_pin_desc"></a>1) pinctrl_pin_desc</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; soc上有大量引脚，每一个引脚使用 pinctrl_pin_desc 来描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核中用其描述 pin 的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> number;  <span class="comment">// pin 引脚号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 此引脚的名称，将用来初始化 pin_desc 的 name，如果为空将使用 PIN + number 例如：PIN0</span></span><br><span class="line">    <span class="keyword">void</span> *drv_data;   <span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-pinctrl-ops"><a href="#2-pinctrl-ops" class="headerlink" title="2) pinctrl_ops"></a>2) pinctrl_ops</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于引脚的使用，有时候一次性会使用到多个引脚，I2C接口会同时使用 2 个引脚，SPI 接口会同时使用 4 个引脚。需要以 group 为单位，访问控制多个 pin，这就是 <strong>pin groups</strong>。但是 <font color=red>mtk 平台采取的策略则是每一个 pin 就是一个 group。</font>，而 pinctrl_ops 则用于获取对应 group 的 pin 脚信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 获取 pin group 的数量，对于mtk平台这里就是 pin 脚的数量</span></span><br><span class="line">    <span class="keyword">int</span> (*get_groups_count) (struct pinctrl_dev *pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取使用 selector 作为数组下标指定 group 的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*get_group_name) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 selector 作为数组下标返回指定 group 所用到的 pins 以及 pin 的数量 num_pins，由于mtk 平台采一个 pin 就是一个 group，因此这里固定返回 1.</span></span><br><span class="line">    <span class="keyword">int</span> (*get_group_pins) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">const</span> <span class="keyword">unsigned</span> **pins, <span class="keyword">unsigned</span> *num_pins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug 相关</span></span><br><span class="line">    <span class="keyword">void</span> (*pin_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于将设备树中的引脚配置转换为对应的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">int</span> (*dt_node_to_map) (struct pinctrl_dev *pctldev, struct device_node *np_config, struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *num_maps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于释放前面创建的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">void</span> (*dt_free_map) (struct pinctrl_dev *pctldev, struct pinctrl_map *<span class="built_in">map</span>, <span class="keyword">unsigned</span> num_maps);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是该接口除了能够获取 pin group 信息之外,还有一个非常重要的回调接口 dt_node_to_map ，用于<font color=red>将设备树中的引脚配置转换为对应的 pinctrl_map</font>。 该接口的实现通常由soc原厂实现。</p>
<h4 id="3-pinmux"><a href="#3-pinmux" class="headerlink" title="3) pinmux"></a>3) pinmux</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;pinmux 表示引脚复，用这个概念就不做解释了。需要注意的是引脚复用和引脚的电器特性(pinconfig)并不是相同的概念, pinctrl子系统中引脚的复用类型用 <font color=red>func</font> 来描述，例如，某 pin 可以复用为 i2c 也可复用为 spi，那么这个引脚则拥有两个 func。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查某个 pin 是否已作它用，用于管脚复用时的互斥（避免多个功能同时使用某个 pin 而不知道，导致奇怪的错误）。</span></span><br><span class="line">    <span class="keyword">int</span> (*request) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回板子 functions 支持的引脚复用的类型的总数，spi0、i2c0、mmc0 这三种类型则应该返回 3   </span></span><br><span class="line">    <span class="keyword">int</span> (*get_functions_count) (struct pinctrl_dev *pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过数组下标 selector 返回 functions 数组中对应的引脚复用为什么功能</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*get_function_name) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 selector 表示的复用功能有哪些 group, 例如：当 selector 表示的复用功能为 i2c 的数组下标时，可能返回 &quot;i2c-0&quot;，&quot;i2c-1&quot;,num_groups = 2.</span></span><br><span class="line">    <span class="keyword">int</span> (*get_function_groups) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> **groups, <span class="keyword">unsigned</span> *num_groups);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 group 为 func_selector 表示的复用功能</span></span><br><span class="line">    <span class="keyword">int</span> (*set_mux) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> func_selector, <span class="keyword">unsigned</span> group_selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是gpio相关</span></span><br><span class="line">    <span class="keyword">int</span> (*gpio_request_enable) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">void</span> (*gpio_disable_free) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*gpio_set_direction) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset, <span class="keyword">bool</span> input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> strict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-pinconf-ops"><a href="#4-pinconf-ops" class="headerlink" title="4) pinconf_ops"></a>4) pinconf_ops</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于每一个引脚都有其特定的电器特性，如上拉、下拉、三态、强推挽输出等用 pinconfig 来描述，pinctrl子系统同样也给出了电器特性的操作函数回调接口。对于电器特性的操作既可以操作一个引脚，也可以操作一组引脚。<font color = red>对于 mtk 平台每个 pin 都是一个 group，因此只用到了 pin_config_group_get 和 pin_config_group_set 接口</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">    <span class="keyword">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//获取一个引脚的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_get) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> pin, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个引脚的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_set) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> pin, <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取一个 group 描述的 pin 的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_group_get) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个 group 描述的 pin 的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_group_set) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面这写接口基本用不着，debug相关接口</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_dbg_parse_modify) (struct pinctrl_dev *pctldev, <span class="keyword">const</span> <span class="keyword">char</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_group_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> selector);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_config_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> config);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、pinctrl"><a href="#3、pinctrl" class="headerlink" title="3、pinctrl"></a>3、pinctrl</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于不同的设备的引脚状态统一由属于该设备的 pinctrl 统一管理。也就是说每一个设备都有一个属于自己的 pinctrl ,该 pinctrl 管理着该设备的 pinctrl_state。相关结构如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>        <span class="comment">// 挂接到全局的 pinctrl_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>           <span class="comment">// 表示所属的 dev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span>      <span class="comment">// 挂接该 pinctrl 所有的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span>     <span class="comment">// 用来挂接 pinctrl_dt_map ，该结构管理着 pinctrl 下所有的 pinctrl_map</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个设备中都有自己的 pin_info</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> *<span class="title">pins</span>;</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>  <span class="comment">//每个创建的设备中的 pinctrl</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-pinctrl-state"><a href="#1-pinctrl-state" class="headerlink" title="1) pinctrl_state"></a>1) pinctrl_state</h4><p>用于描述设备上的 pin 脚所处的状态，一个设备上的 pin 脚可以有多种状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 挂接到所属的 pinctrl</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;      <span class="comment">// 对应的 pinctrl_map 的 name</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span> <span class="comment">// 挂接该 state 下所有的 setting</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个 pin 脚有两个状态, 引脚复用(pinmux)，和引脚状态(pinconfig)，这两种状态由 pinctrl_setting 来描述。</p>
<h4 id="2-pinctrl-setting"><a href="#2-pinctrl-setting" class="headerlink" title="2) pinctrl_setting"></a>2) pinctrl_setting</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一个 pinctrl_setting 只能表示一个引脚复用(pinmux)或者一组电器特性(pinconfig)，通过 pinctrl_map_type 来区分当前的 pinctrl_setting 是描述 pinmux 还是描述 pinconfig，如果 pinctrl_map_type 为 PIN_MAP_TYPE_MUX_GROUP 表示该 setting 或 pinctrl_map 为引脚复用，如果为 PIN_MAP_TYPE_CONFIGS_GROUP 则表示 setting 或 pinctrl_map 为 pinconfig。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>       <span class="comment">// 挂接到所属的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span>  <span class="comment">// 该 setting 的 pinctrl_map 的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span> <span class="comment">// 该 pinctrl_map 所属的 pinctrl_dev</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;        <span class="comment">// 被设置为 pinctrl_map-&gt;dev_name</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> <span class="title">mux</span>;</span> <span class="comment">//如果 type 为 PIN_MAP_TYPE_MUX_GROUP 则使用这个结构来保存引脚复用相关参数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> <span class="title">configs</span>;</span> <span class="comment">//如果 type 为 PIN_MAP_TYPE_CONFIGS_PIN 或者  PIN_MAP_TYPE_CONFIGS_GROUP 则使用这个结构来保存引脚电器特性相关参数</span></span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> group; <span class="comment">// 要用到的  pin group 的数组下标</span></span><br><span class="line">    <span class="keyword">unsigned</span> func;  <span class="comment">// 要用到的 func 的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> group_or_pin;  <span class="comment">// 要配置的 pin 或者 pin group 的数组下标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs; <span class="comment">// 对应的 pinconfig，具体的含义由 soc 原厂定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_configs;   <span class="comment">// config 数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过这个结构需要通过中间结构 pinctrl_map 转化而来，这个结构又通过 dts 配置的引脚参数创建而来。</p>
<h4 id="3-pinctrl-map"><a href="#3-pinctrl-map" class="headerlink" title="3) pinctrl_map"></a>3) pinctrl_map</h4><p>该结构也是提供对应的索引，不过它提供的索引是以字符串的形式提供的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span> <span class="comment">//三个 name 都是在 pinctrl_dt_to_map 函数获取，在 dt_remember_or_free_map 函数进行初始化。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;       <span class="comment">// 所属 pinctrl 的 name</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 设备树中的 pinctrl-names 的属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 pinctrl_map 所属的类别，一般用到的有两大类，复用(mux) 和 pinconfig,</span></span><br><span class="line">    <span class="comment">// 当使用 mux 时使用 pinctrl_map_mux，而 pinconfig 则使用 pinctrl_map_configs</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ctrl_dev_name;  <span class="comment">// 所属的 pinctrl_dev 的 name</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span> <span class="comment">// 当 type 为 PIN_MAP_TYPE_MUX_GROUP 则使用这个</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span> <span class="comment">// 当 type为 IN_MAP_TYPE_CONFIGS_PIN、PIN_MAP_TYPE_CONFIGS_GROUP 使用这个</span></span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *group;       <span class="comment">//具体用到的group，例如：i2c0 有 &quot;i2c0_grp1&quot;、&quot;i2c0_grp1&quot;,如果使用 &quot;i2c0_grp1&quot; 这组，则 group = &quot;i2c0_grp1&quot;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *function;    <span class="comment">//要用到的复用功能，例如: i2c0、i2c1、spi1 等</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *group_or_pin; <span class="comment">// 该 pin 或者pin group的名字</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs;   <span class="comment">// 要设置的 pinconfig 数组首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_configs;     <span class="comment">// 数组大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、mtk-平台寄存器的表示方式"><a href="#二、mtk-平台寄存器的表示方式" class="headerlink" title="二、mtk 平台寄存器的表示方式"></a>二、mtk 平台寄存器的表示方式</h2><p>如下图所示，mtk 平台的寄存器在内核中的数据组织方式如下所示：</p>
<p><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/mtk%E5%B9%B3%E5%8F%B0pin%E8%84%9A%E5%AF%84%E5%AD%98%E5%99%A8%E8%A1%A8%E7%A4%BA.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1622682822;86400000001622600000&q-key-time=1622682822;86400000001622600000&q-header-list=&q-url-param-list=&q-signature=8050114349f3348de91b2edb09e72d1d84cfbb58" alt="mtk 平台寄存器的表示方式"></p>
<h2 id="三、pinctrl-子系统的系统框架"><a href="#三、pinctrl-子系统的系统框架" class="headerlink" title="三、pinctrl 子系统的系统框架"></a>三、pinctrl 子系统的系统框架</h2><h3 id="1、框架接口"><a href="#1、框架接口" class="headerlink" title="1、框架接口"></a>1、框架接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;pinctrl 子系统提供的服务并不复杂，主要提供了以下两个服务，向驱动工程师提供操作 pin 的接口也就是具体的设备要使用的接口，向 bsp 工程师提供对应的寄存器操作的接口。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1622712744;86400000001622640000&q-key-time=1622712744;86400000001622640000&q-header-list=&q-url-param-list=&q-signature=4c7485bd86a798d58e70091a2a2453f819fffda1" width="75%" height="75%" alt="pinctrl 子系统的系统框架">

<h3 id="2、内部实现"><a href="#2、内部实现" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;pinctrl 子系统提供的服务接口很简单，但它的内部实现还是有点复杂的。内核驱动都是基于设备模型来开发的，因此对引脚的操作都是基于设备来讲的。对于一个设备首先要做的就是配置其需要使用到的软硬件资源，当然其中就包括 pin 脚资源。而 pinctrl 子系统则需要解析处理我们配置的 pin 脚资源。当我们配置设备的引脚资源后 pinctrl 会在合适的时机来解析我们配置的引脚资源，什么时机是最合适的呢，显而易见设备和驱动匹配的时候。因为设备资源最终的使用者是驱动，当驱动匹配到设备的时候也就是要使用该资源的时候。当完成对资源的解析，我们只需要调用简单的接口就能使我们的设备上的 pin 脚处于我们需要的状态。</p>
<h4 id="1-配置设备的引脚资源"><a href="#1-配置设备的引脚资源" class="headerlink" title="1) 配置设备的引脚资源"></a>1) 配置设备的引脚资源</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; 配置引脚资源有两种方式首先是使用设备树，这也是目前主流的方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lcm_dev: lcm &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;lcm_1v8_en_low&quot;</span> , <span class="string">&quot;lcm_1v8_en_high&quot;</span>; <span class="comment">//对应的 pinctrl_state 的 name</span></span><br><span class="line"></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gpio_lcm_pwr1v8_low&gt;;  <span class="comment">//----这是一个 pinctrl_state</span></span><br><span class="line">    pinctrl<span class="number">-1</span> = &lt;&amp;gpio_lcm_pwr1v8_high&gt;; <span class="comment">//----这是一个 pinctrl_state</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;pio &#123; </span><br><span class="line"></span><br><span class="line">    gpio_lcm_pwr1v8_low: gpio_lcm_pwr1v8_low &#123; <span class="comment">//----这是一组 pinctrl_map </span></span><br><span class="line">        pins_cmd_dat &#123;</span><br><span class="line">            pinmux = &lt;PINMUX_GPIO5__FUNC_GPIO5&gt;; <span class="comment">//这被解析 pinctrl_map-&gt;data-&gt;mux</span></span><br><span class="line">            slew-rate = &lt;<span class="number">1</span>&gt;;           <span class="comment">//这两个被解析到pinctrl_map-&gt;data-&gt;configs   </span></span><br><span class="line">            output-low;                          </span><br><span class="line">        &#125;;  <span class="comment">//于是这里将创建有 2 个 pinctrl_map 的数组</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio_lcm_pwr1v8_high: gpio_lcm_pwr1v8_high &#123; <span class="comment">//----这是一组 pinctrl_map </span></span><br><span class="line">        pins_cmd_dat &#123;</span><br><span class="line">            pinmux = &lt;PINMUX_GPIO5__FUNC_GPIO5&gt;; <span class="comment">//这被解析到 pinctrl_map-&gt;data-&gt;mux</span></span><br><span class="line">            output-high;                         <span class="comment">//这被解析到 pinctrl_map-&gt;data-&gt;configs</span></span><br><span class="line">        &#125;; <span class="comment">// 于是这里将创建有 2 个 pinctrl_map 的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 lcm 配置了两个 state ，他们分别是”lcm_1v8_en_low” 和 “lcm_1v8_en_high”.</p>
<h4 id="2-解析设备引脚资源的时机"><a href="#2-解析设备引脚资源的时机" class="headerlink" title="2) 解析设备引脚资源的时机"></a>2) 解析设备引脚资源的时机</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当设备和驱动匹配的时候在 really_probe 函数中会调用 pinctrl_bind_pins 来解析并创建属于该设备的 pinctrl，匹配流程可以参考<a href="https://baron-z.cn/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/#more">linux设备模型</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    ret = pinctrl_bind_pins(dev);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看这个函数做了什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_bind_pins</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    dev-&gt;pins = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;pins)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析 pin 脚信息并返回 pinctrl</span></span><br><span class="line">    dev-&gt;pins-&gt;p = devm_pinctrl_get(dev);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;p)) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no pinctrl handle\n&quot;</span>);</span><br><span class="line">        ret = PTR_ERR(dev-&gt;pins-&gt;p);</span><br><span class="line">        <span class="keyword">goto</span> cleanup_alloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 default 的 sate</span></span><br><span class="line">    dev-&gt;pins-&gt;default_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;default_state)) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no default pinctrl state\n&quot;</span>);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> cleanup_get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 init 的 state 如果不存在则设置为 default 否则设置为 init</span></span><br><span class="line">    dev-&gt;pins-&gt;init_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_INIT);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;init_state)) &#123;</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no init pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ret = pinctrl_select_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                       dev-&gt;pins-&gt;default_state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = pinctrl_select_state(dev-&gt;pins-&gt;p, dev-&gt;pins-&gt;init_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;failed to activate initial pinctrl state\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> cleanup_get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">    <span class="comment">//查找 sleep 的 state</span></span><br><span class="line">    dev-&gt;pins-&gt;sleep_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_SLEEP);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;sleep_state))</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no sleep pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找 sleep 的 state</span></span><br><span class="line">    dev-&gt;pins-&gt;idle_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_IDLE);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;idle_state))</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no idle pinctrl state\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cleanup_get:</span><br><span class="line">    devm_pinctrl_put(dev-&gt;pins-&gt;p);</span><br><span class="line">cleanup_alloc:</span><br><span class="line">    devm_kfree(dev, dev-&gt;pins);</span><br><span class="line">    dev-&gt;pins = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only return deferrals */</span></span><br><span class="line">    <span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数解析 pin 脚信息并返回 pinctrl ，获取 default 以及其他默认state，这些state 在 include/linux/pinctrl/pinctrl-state.h 中提供</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_DEFAULT <span class="meta-string">&quot;default&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_INIT <span class="meta-string">&quot;init&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_IDLE <span class="meta-string">&quot;idle&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_SLEEP <span class="meta-string">&quot;sleep&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>在 default 之后查找 init 的 state 如果不存在则设置为 default ，从代码也可以看出如果没有 default 也不会去获取后面的 state ，因此<font color=red>如果需要使用到 init、idle、sleep 这三个 state 必须配置 default state</font>。由于解析过程涉及的函数比较多因此先给出内部数据结构的组织结构方便理解。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%20pinctr%20%E7%9A%84%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1622778256;86400000001622700000&q-key-time=1622778256;86400000001622700000&q-header-list=&q-url-param-list=&q-signature=da4eb2c74bc03c747b997c052e507548c1aada8e" width="100%" height="100%" alt="设备 pinctr 的内部数据组织结构">

<p>可以从数据结构中看出涉及到两个关键的数据 pinctrl_map 和 pinctrl_setting， 这两个数据结构是直接连接到外部的 pinmux 信息和 pinconfig 信息。</p>
<h4 id="3-pinctrl-解析设备引脚资源"><a href="#3-pinctrl-解析设备引脚资源" class="headerlink" title="3) pinctrl 解析设备引脚资源"></a>3) pinctrl 解析设备引脚资源</h4><p>解析过程如下图所示</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/pin_state%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1623235951;86400000001623150000&q-key-time=1623235951;86400000001623150000&q-header-list=&q-url-param-list=&q-signature=bf31a7976aeadcc08a17b2740d6c73d5da2b9331" width="100%" height="100%" alt="设备树 pin_state 解析流程">

<h4 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4) 源码分析"></a>4) 源码分析</h4><p>涉及到的代码相对比较多就不去排版了，每个函数都有注释可以作为一个手册阅读。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在 pinctrl_list 链表中查找属于本设备的 pinctrl</span></span><br><span class="line"><span class="comment">// 2. 如果不存在则注册一个 pinctrl</span></span><br><span class="line"><span class="function">struct pinctrl *<span class="title">pinctrl_get</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!dev))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 pinctrl 被注册则,直接返回该 pinctrl</span></span><br><span class="line">    p = find_pinctrl(dev);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;obtain a copy of previously claimed pinctrl\n&quot;</span>);</span><br><span class="line">        kref_get(&amp;p-&gt;users);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 pinctrl</span></span><br><span class="line">    <span class="keyword">return</span> create_pinctrl(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 pinctrl_list 链表中查找属于本设备的 pinctrl</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct pinctrl *<span class="title">find_pinctrl</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">    list_for_each_entry(p, &amp;pinctrl_list, node)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;dev == dev) &#123;</span><br><span class="line">            mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pinctrl *<span class="title">create_pinctrl</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span> <span class="comment">//map索引</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> <span class="title">const</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化 pinctrl -------------------------- part 1</span></span><br><span class="line">    p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;failed to alloc struct pinctrl\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;dev = dev; <span class="comment">//初始化所属的dev</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;states); <span class="comment">//初始化 states 链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;dt_maps); <span class="comment">//初始化 dt_maps链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该设备 dts 中的 pin state 转化为 pinctrl_map ------------------- part 2</span></span><br><span class="line">    ret = pinctrl_dt_to_map(p);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    devname = dev_name(dev);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于 maps_node 中的每一组属于该设备的 map 调用 add_setting，将对应的 pinctrl_map 转换为 pinctrl_setting ------ patr 3</span></span><br><span class="line">    for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line">        <span class="comment">/* Map must be for this device */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;dev_name, devname))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">        ret = add_setting(p, <span class="built_in">map</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">            pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">            mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* If some other error than deferral occured, return here */</span></span><br><span class="line">        pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kref_init(&amp;p-&gt;users);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">    <span class="comment">//将 pinctrl 加入到全局链表 pinctrl_list</span></span><br><span class="line">    list_add_tail(&amp;p-&gt;node, &amp;pinctrl_list);</span><br><span class="line">    mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实整个解析过程也是分为三步、<strong>part1</strong>-创建本设备的 pinctrl、<strong>part2</strong>-将 dts 转化为对应的 pinctrl_map、<strong>part3</strong>-最后是将 pinctrl_map 转换为pinctrl_setting</p>
</blockquote>
<h5 id="a-创建-pinctrl-map"><a href="#a-创建-pinctrl-map" class="headerlink" title="a. 创建 pinctrl_map"></a>a. 创建 pinctrl_map</h5><h6 id="pinctrl-dt-to-map"><a href="#pinctrl-dt-to-map" class="headerlink" title="pinctrl_dt_to_map"></a>pinctrl_dt_to_map</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 从state = 0 开始，递增判断 pinctrl 所属的设备的的设备树节点是否存在 pinctrl-state ，不存在则直接返回</span></span><br><span class="line"><span class="comment">// 2. 如果存在则 state 作为 index 获取 pinctrl-names 属性的值 statename</span></span><br><span class="line"><span class="comment">// 3. 遍历 pinctrl-0 属性的值所表示的节点，在 pinctrldev_list 中查找属于该节点的父节点的 pinctrl_dev</span></span><br><span class="line"><span class="comment">//    然后调用 pctldev-&gt;desc-&gt;pctlops-&gt;dt_node_to_map(pctldev, np_config, &amp;map, &amp;num_maps); 函数, 创建出需要的  pinctrl_map </span></span><br><span class="line"><span class="comment">// 4. 进一步初始化 pinctrl_map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_dt_to_map</span><span class="params">(struct pinctrl *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> p-&gt;dev-&gt;of_node; <span class="comment">//获取到 pinctrl 所属的设备的设备节点</span></span><br><span class="line">    <span class="keyword">int</span> state, ret;</span><br><span class="line">    <span class="keyword">char</span> *propname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *statename;</span><br><span class="line">    <span class="keyword">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> size, config;</span><br><span class="line">    phandle phandle;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CONFIG_OF enabled, p-&gt;dev not instantiated from DT */</span></span><br><span class="line">    <span class="keyword">if</span> (!np) &#123;</span><br><span class="line">        <span class="keyword">if</span> (of_have_populated_dt())</span><br><span class="line">            dev_dbg(p-&gt;dev,</span><br><span class="line">                <span class="string">&quot;no of_node; not parsing pinctrl DT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    of_node_get(np); <span class="comment">// 增加节点引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line">        </span><br><span class="line">        propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 propname 获得对应设备树中的属性，pinctrl-0 属性的值为设备节点的引用，即为 phandle 属性。</span></span><br><span class="line">        prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">        kfree(propname);</span><br><span class="line">        <span class="keyword">if</span> (!prop)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">list</span> = prop-&gt;value;    <span class="comment">// 获取到属性值</span></span><br><span class="line">        size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>); <span class="comment">// 获取属性值的个数，即上面dts中的 &lt;&amp;gpio_lcm_pwr1v8_low&gt; 的个数明显这里只有一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 pinctrl-names, 获取对应的 state 的名字，一般情况下 state = 0 的名字为 default</span></span><br><span class="line">        <span class="comment">// 这里可以看出，pinctrl-names 属性的值，和 pinctrl-* 是一一对应的。</span></span><br><span class="line">        ret = of_property_read_string_index(np, <span class="string">&quot;pinctrl-names&quot;</span>, state, &amp;statename);</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* strlen(&quot;pinctrl-&quot;) == 8 */</span></span><br><span class="line">            statename = prop-&gt;name + <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123; <span class="comment">//</span></span><br><span class="line">           <span class="comment">//将属性值转化为 pandle，只是保证数据的大小端一致性</span></span><br><span class="line">            phandle = be32_to_cpup(<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过 phandle 获取到其所在的设备节点 gpio_lcm_pwr1v8_low</span></span><br><span class="line">            np_config = of_find_node_by_phandle(phandle);</span><br><span class="line">            <span class="keyword">if</span> (!np_config) &#123;</span><br><span class="line">                dev_err(p-&gt;dev,</span><br><span class="line">                    <span class="string">&quot;prop %s index %i invalid phandle\n&quot;</span>,</span><br><span class="line">                    prop-&gt;name, config);</span><br><span class="line">                ret = -EINVAL;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在 pinctrldev_list 中查找属于 gpio_lcm_pwr1v8_low 所在节点根节点的中的 pinctrl_dev, </span></span><br><span class="line">            <span class="comment">// 然后调用 pctldev-&gt;desc-&gt;pctlops-&gt;dt_node_to_map(pctldev, np_config, &amp;map, &amp;num_maps); 函数, 创建出需要的 pinctrl_map</span></span><br><span class="line">            <span class="comment">// 进一步初始化 pinctrl_map ，创建 pinctrl_dt_map 初始化之后 将，dt_map 挂接到所属的 pinctrl</span></span><br><span class="line">            <span class="comment">// 检查 pinctrl_map 的合法性，动态创建一个 maps_node 初始化之后挂接到全局  pinctrl_maps</span></span><br><span class="line">            ret = dt_to_map_one_config(p, statename, np_config);</span><br><span class="line">            of_node_put(np_config);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    pinctrl_dt_free_maps(p);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="dt-to-map-one-config"><a href="#dt-to-map-one-config" class="headerlink" title="dt_to_map_one_config"></a>dt_to_map_one_config</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 pinctrldev_list 中查找属于 gpio_lcm_pwr1v8_low 所在节点根节点的中的 pinctrl_dev, </span></span><br><span class="line"><span class="comment">// 然后调用 pctldev-&gt;desc-&gt;pctlops-&gt;dt_node_to_map(pctldev, np_config, &amp;map, &amp;num_maps); 函数, 创建出需要的 pinctrl_map</span></span><br><span class="line"><span class="comment">// 进一步初始化 pinctrl_map ，创建 pinctrl_dt_map 初始化之后 将，dt_map 挂接到所属的 pinctrl</span></span><br><span class="line"><span class="comment">// 检查 pinctrl_map 的合法性，动态创建一个 maps_node 初始化之后挂接到全局  pinctrl_maps</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dt_to_map_one_config</span><span class="params">(struct pinctrl *p, <span class="keyword">const</span> <span class="keyword">char</span> *statename, struct device_node *np_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_pctldev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_maps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  查找 pinctrl 的根节点 */</span></span><br><span class="line">    np_pctldev = of_node_get(np_config); <span class="comment">//增加节点引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取 np_pctldev 所在的设备节点的父节点，即pinctrl-0 指向的设备节点 gpio_lcm_pwr1v8_low 的父节点，即 pintrl 根节点</span></span><br><span class="line">        np_pctldev = of_get_next_parent(np_pctldev);</span><br><span class="line">        <span class="keyword">if</span> (!np_pctldev || of_node_is_root(np_pctldev)) &#123;</span><br><span class="line">            dev_info(p-&gt;dev, <span class="string">&quot;could not find pctldev for node %s, deferring probe\n&quot;</span>,</span><br><span class="line">                np_config-&gt;full_name);</span><br><span class="line">            of_node_put(np_pctldev);</span><br><span class="line">            <span class="comment">/* OK let&#x27;s just assume this will appear later then */</span></span><br><span class="line">            <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 pintrl 根节点的 pinctrl_dev</span></span><br><span class="line">        pctldev = get_pinctrl_dev_from_of_node(np_pctldev);</span><br><span class="line">        <span class="keyword">if</span> (pctldev) <span class="comment">//如果存在推出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 如果 pinctrl 所在的节点和 dts 中的 pinctrl 根节点相同则 error */</span></span><br><span class="line">        <span class="keyword">if</span> (np_pctldev == p-&gt;dev-&gt;of_node) &#123;</span><br><span class="line">            of_node_put(np_pctldev);</span><br><span class="line">            <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    of_node_put(np_pctldev); <span class="comment">//减少节点引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其 pinctrl_ops </span></span><br><span class="line">    ops = pctldev-&gt;desc-&gt;pctlops;</span><br><span class="line">    <span class="keyword">if</span> (!ops-&gt;dt_node_to_map) &#123;</span><br><span class="line">        dev_err(p-&gt;dev, <span class="string">&quot;pctldev %s doesn&#x27;t support DT\n&quot;</span>,</span><br><span class="line">            dev_name(pctldev-&gt;dev));</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 dt_node_to_map 函数， 对于 gpio_lcm_pwr1v8_low 的所有子节点调用 mtk_pctrl_dt_subnode_to_map</span></span><br><span class="line">    <span class="comment">// 从设备树中获取对应的配置，并创建对应的 pinctrl_map</span></span><br><span class="line">    ret = ops-&gt;dt_node_to_map(pctldev, np_config, &amp;<span class="built_in">map</span>, &amp;num_maps);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进一步初始化 pinctrl_map ，创建 pinctrl_dt_map 初始化之后 将，dt_map 挂接到所属的 pinctrl</span></span><br><span class="line">    <span class="comment">// 检查 pinctrl_map 的合法性，动态创建一个 maps_node 初始化之后挂接到全局  pinctrl_maps</span></span><br><span class="line">    <span class="keyword">return</span> dt_remember_or_free_map(p, statename, pctldev, <span class="built_in">map</span>, num_maps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是 mtk 平台的处理过程</p>
<h6 id="mtk-pctrl-dt-node-to-map"><a href="#mtk-pctrl-dt-node-to-map" class="headerlink" title="mtk_pctrl_dt_node_to_map"></a>mtk_pctrl_dt_node_to_map</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于 np_config(就是前面的 gpio_lcm_pwr1v8_low)的所有子节点调用 mtk_pctrl_dt_subnode_to_map, 从设备树中获取对应的配置，并创建对应的 pinctrl_map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtk_pctrl_dt_node_to_map</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct device_node *np_config,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *num_maps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_maps;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    *<span class="built_in">map</span> = <span class="literal">NULL</span>;</span><br><span class="line">    *num_maps = <span class="number">0</span>; <span class="comment">//表示 pinctrl_map 的数组下标</span></span><br><span class="line">    reserved_maps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 对于 gpio_lcm_pwr1v8_low 的所有子节点调用 mtk_pctrl_dt_subnode_to_map,</span></span><br><span class="line"><span class="comment">    * 从设备树中获取对应的配置，并创建对应的 pinctrl_map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    for_each_child_of_node(np_config, np) &#123;</span><br><span class="line">        ret = mtk_pctrl_dt_subnode_to_map(pctldev, np, <span class="built_in">map</span>,</span><br><span class="line">                &amp;reserved_maps, num_maps);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pinctrl_utils_dt_free_map(pctldev, *<span class="built_in">map</span>, *num_maps);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="mtk-pctrl-dt-subnode-to-map"><a href="#mtk-pctrl-dt-subnode-to-map" class="headerlink" title="mtk_pctrl_dt_subnode_to_map"></a>mtk_pctrl_dt_subnode_to_map</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从设备树中获取对应的配置，并创建对应的 pinctrl_map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtk_pctrl_dt_subnode_to_map</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct device_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct pinctrl_map **<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> *reserved_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> *num_maps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">pins</span>;</span></span><br><span class="line">    u32 pinfunc, pin, func;</span><br><span class="line">    <span class="keyword">int</span> num_pins, num_funcs, maps_per_pin;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_configs;</span><br><span class="line">    <span class="keyword">bool</span> has_config = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">unsigned</span> reserve = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl_group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl</span> *<span class="title">pctl</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 pin 的属性，从这里可以知道 mtk 平台兼容两种 pin 属性的写法，</span></span><br><span class="line">    <span class="comment">// 一种是 pinmux，一种是 pins</span></span><br><span class="line">    pins = of_find_property(node, <span class="string">&quot;pinmux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pins) &#123;</span><br><span class="line">        pins = of_find_property(node, <span class="string">&quot;pins&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pins) &#123;</span><br><span class="line">        dev_err(pctl-&gt;dev, <span class="string">&quot;missing pins property in node %s .\n&quot;</span>,</span><br><span class="line">                node-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在设备节点查找 dt_params 以及 pctldev-&gt;desc-&gt;custom_params 中的支持的 pinconfig</span></span><br><span class="line">    <span class="comment">// 如果存在则按顺寻将 params 和 custom_params 可配置的 pinconfig 参数 pin_config_param </span></span><br><span class="line">    <span class="comment">// 以及配置的默认状态 default_value 组合后,存入 configs 指向的内存空间, 并返回 configs 的长度</span></span><br><span class="line">    err = pinconf_generic_parse_dt_config(node, pctldev, &amp;configs,</span><br><span class="line">        &amp;num_configs);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_configs)</span><br><span class="line">        has_config = <span class="number">1</span>; <span class="comment">//是否需要配置 configs</span></span><br><span class="line"></span><br><span class="line">    num_pins = pins-&gt;length / <span class="keyword">sizeof</span>(u32); <span class="comment">//获取 dts 配置的 pin 的数量</span></span><br><span class="line">    num_funcs = num_pins; <span class="comment">//计算出 func 的数量</span></span><br><span class="line">    maps_per_pin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_funcs)</span><br><span class="line">        maps_per_pin++; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (has_config &amp;&amp; num_pins &gt;= <span class="number">1</span>) <span class="comment">//如果有配置的 config 以及需要配置的 pin &gt;= 1</span></span><br><span class="line">        maps_per_pin++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!num_pins || !maps_per_pin) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reserve = num_pins * maps_per_pin; <span class="comment">//计算需要的 pinctrl_map 的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新申请一片大小为 *num_maps + reserve 的内存空间，并将 map 的值复制过去，</span></span><br><span class="line">    <span class="comment">// reserved_maps 之后的内存空间初始化为 0, 同时更新 pinctrl_map 的数量 reserved_maps</span></span><br><span class="line">    <span class="comment">// num_maps 表示有效的 pinctrl_map 的数量</span></span><br><span class="line">    err = pinctrl_utils_reserve_map(pctldev, <span class="built_in">map</span>,</span><br><span class="line">            reserved_maps, num_maps, reserve);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">        err = of_property_read_u32_index(node, <span class="string">&quot;pinmux&quot;</span>,</span><br><span class="line">                i, &amp;pinfunc);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            err = of_property_read_u32_index(node, <span class="string">&quot;pins&quot;</span>,</span><br><span class="line">                i, &amp;pinfunc);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pin = MTK_GET_PIN_NO(pinfunc); <span class="comment">//获取配置的 pin 脚</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取该引脚对应的复用状态，复用状态在 include/dt-bindings/pinctrl/mt6771-pinfunc.h 文件中配置</span></span><br><span class="line">        func = MTK_GET_PIN_FUNC(pinfunc);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pin &gt;= pctl-&gt;devdata-&gt;npins ||</span><br><span class="line">                func &gt;= ARRAY_SIZE(mtk_gpio_functions)) &#123;</span><br><span class="line">            dev_err(pctl-&gt;dev, <span class="string">&quot;invalid pins value.\n&quot;</span>);</span><br><span class="line">            err = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回该 pin 所对应的 group</span></span><br><span class="line">        grp = mtk_pctrl_find_group_by_pin(pctl, pin);</span><br><span class="line">        <span class="keyword">if</span> (!grp) &#123;</span><br><span class="line">            dev_err(pctl-&gt;dev, <span class="string">&quot;unable to match pin %d to group\n&quot;</span>,</span><br><span class="line">                    pin);</span><br><span class="line">            err = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 pinctrl_map 的 type 为 PIN_MAP_TYPE_MUX_GROUP，</span></span><br><span class="line">        <span class="comment">// 初始化 data.mux.group 为 grp-&gt;name;</span></span><br><span class="line">        <span class="comment">// 初始化 ata.mux.function 为 mtk_gpio_functions[fnum];</span></span><br><span class="line">        err = mtk_pctrl_dt_node_to_map_func(pctl, pin, func, grp, <span class="built_in">map</span>,</span><br><span class="line">                reserved_maps, num_maps);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有 config 则设置 config 对应的 pinctrl_map，</span></span><br><span class="line">        <span class="comment">//因此 poinconfig 是对该节点的所有 pin 生效</span></span><br><span class="line">        <span class="keyword">if</span> (has_config) &#123; </span><br><span class="line">            err = pinctrl_utils_add_map_configs(pctldev, <span class="built_in">map</span>,</span><br><span class="line">                    reserved_maps, num_maps, grp-&gt;name,</span><br><span class="line">                    configs, num_configs,</span><br><span class="line">                    PIN_MAP_TYPE_CONFIGS_GROUP);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    kfree(configs);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PIN_NO(x) ((x) &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_GET_PIN_NO(x) ((x) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_GET_PIN_FUNC(x) ((x) &amp; 0xf)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_GPIO0 (MTK_PIN_NO(0) | 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_MRG_SYNC (MTK_PIN_NO(0) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_PCM0_SYNC (MTK_PIN_NO(0) | 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_TP_GPIO0_AO (MTK_PIN_NO(0) | 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_SRCLKENAI0 (MTK_PIN_NO(0) | 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_SCP_SPI2_CS (MTK_PIN_NO(0) | 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_I2S3_MCK (MTK_PIN_NO(0) | 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINMUX_GPIO0__FUNC_SPI2_CSB (MTK_PIN_NO(0) | 7)</span></span><br></pre></td></tr></table></figure>
<h6 id="mtk-pctrl-dt-node-to-map-func"><a href="#mtk-pctrl-dt-node-to-map-func" class="headerlink" title="mtk_pctrl_dt_node_to_map_func"></a>mtk_pctrl_dt_node_to_map_func</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 pinctrl_map 的 type 为 PIN_MAP_TYPE_MUX_GROUP，</span></span><br><span class="line"><span class="comment">// 初始化 data.mux.group 为 grp-&gt;name;</span></span><br><span class="line"><span class="comment">// 初始化 ata.mux.function 为 mtk_gpio_functions[fnum];</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtk_pctrl_dt_node_to_map_func</span><span class="params">(struct mtk_pinctrl *pctl,</span></span></span><br><span class="line"><span class="function"><span class="params">        u32 pin, u32 fnum, struct mtk_pinctrl_group *grp,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *reserved_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> *num_maps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*num_maps == *reserved_maps)</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP; <span class="comment">// 初始化 pinctrl_map 的 type</span></span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.mux.group = grp-&gt;name; <span class="comment">//初始化 data.mux.group</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//该 pin 的引脚复用 fnum 有效性检查</span></span><br><span class="line">    ret = mtk_pctrl_is_function_valid(pctl, pin, fnum);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        dev_err(pctl-&gt;dev, <span class="string">&quot;invalid function %d on pin %d .\n&quot;</span>,</span><br><span class="line">                fnum, pin);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化对应 pin 脚复用的函数名</span></span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.mux.function = mtk_gpio_functions[fnum];</span><br><span class="line">    (*num_maps)++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="mtk-pctrl-is-function-valid"><a href="#mtk-pctrl-is-function-valid" class="headerlink" title="mtk_pctrl_is_function_valid"></a>mtk_pctrl_is_function_valid</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该 pin_num 的引脚复用 fnum 有效性检查</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">mtk_pctrl_is_function_valid</span><span class="params">(struct mtk_pinctrl *pctl,</span></span></span><br><span class="line"><span class="function"><span class="params">        u32 pin_num, u32 fnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pctl-&gt;devdata-&gt;npins; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_pin</span> *<span class="title">pin</span> =</span> pctl-&gt;devdata-&gt;pins + i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pin-&gt;pin.number == pin_num) &#123; 找到该 pin 对应的 mtk_desc_pin</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span> *<span class="title">func</span> =</span></span><br><span class="line">                    pin-&gt;functions; <span class="comment">//获取到对应的 functions</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (func &amp;&amp; func-&gt;name) &#123; <span class="comment">//查找对应的 functions 是否有对应的引脚复用 fnum</span></span><br><span class="line">                <span class="keyword">if</span> (func-&gt;muxval == fnum) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                func++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> muxval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_pin</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> <span class="title">pin</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTK_EINT_MULTI_TRIGGER_DESIGN</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_eint</span> <span class="title">eint</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_eint</span> <span class="title">eint</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span>  *<span class="title">functions</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_desc_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> muxval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="pinctrl-utils-add-map-configs"><a href="#pinctrl-utils-add-map-configs" class="headerlink" title="pinctrl_utils_add_map_configs"></a>pinctrl_utils_add_map_configs</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除多余内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_utils_add_map_configs</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *reserved_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> *num_maps, <span class="keyword">const</span> <span class="keyword">char</span> *group,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">enum</span> pinctrl_map_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *dup_configs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(*num_maps == *reserved_maps)) <span class="comment">//防止数组越界</span></span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">    dup_configs = kmemdup(configs, num_configs * <span class="keyword">sizeof</span>(*dup_configs),</span><br><span class="line">                  GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dup_configs) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;kmemdup(configs) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].type = type;</span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.configs.group_or_pin = group;</span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.configs.configs = dup_configs;</span><br><span class="line">    (*<span class="built_in">map</span>)[*num_maps].data.configs.num_configs = num_configs;</span><br><span class="line">    (*num_maps)++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pinconf-generic-parse-dt-config"><a href="#pinconf-generic-parse-dt-config" class="headerlink" title="pinconf_generic_parse_dt_config"></a>pinconf_generic_parse_dt_config</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在设备节点 device_node 查找 dt_params 以及 pctldev-&gt;desc-&gt;custom_params 中的支持的引脚状态</span></span><br><span class="line"><span class="comment">// 如果存在则按顺寻将 params 和 custom_params 可配置的引脚状态参数 pin_config_param </span></span><br><span class="line"><span class="comment">// 以及配置的默认状态 default_value 组合后,存入 configs 指向的内存空间, 并返回 configs 的长度nconfigs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinconf_generic_parse_dt_config</span><span class="params">(struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> **configs,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> *nconfigs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *cfg;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_cfg, ncfg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!np)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a temporary array big enough to hold one of each option */</span></span><br><span class="line">    <span class="comment">//获取 dt_params 的中 config 的数量</span></span><br><span class="line">    max_cfg = ARRAY_SIZE(dt_params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pctldev) </span><br><span class="line">        max_cfg += pctldev-&gt;desc-&gt;num_custom_params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个 config 都由 unsigned long 表示，申请 max_cfg 个 unsigned long</span></span><br><span class="line">    cfg = kcalloc(max_cfg, <span class="keyword">sizeof</span>(*cfg), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!cfg)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查询设备节点 np 中存在的  params[] 数组中的属性，</span></span><br><span class="line">   <span class="comment">// 如果存在则按顺寻将该 params 可配置的引脚状态参数 pin_config_param </span></span><br><span class="line">   <span class="comment">// 以及配置的默认状态 default_value 组合后,存入 cfg 指向的内存空间, ncfg 表示 cfg 的长度</span></span><br><span class="line">    parse_dt_cfg(np, dt_params, ARRAY_SIZE(dt_params), cfg, &amp;ncfg);</span><br><span class="line">    <span class="keyword">if</span> (pctldev &amp;&amp; pctldev-&gt;desc-&gt;num_custom_params &amp;&amp; pctldev-&gt;desc-&gt;custom_params)</span><br><span class="line">        <span class="comment">//如果存在 custom_params 则同样查询该节点存在的属性，并返回其值</span></span><br><span class="line">        parse_dt_cfg(np, pctldev-&gt;desc-&gt;custom_params,</span><br><span class="line">                 pctldev-&gt;desc-&gt;num_custom_params, cfg, &amp;ncfg);</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有 configs 则推出</span></span><br><span class="line">    <span class="keyword">if</span> (ncfg == <span class="number">0</span>) &#123;</span><br><span class="line">        *configs = <span class="literal">NULL</span>;</span><br><span class="line">        *nconfigs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了节省内存空间，这里将值复制到 configs 之后释放掉 cfg 所占的多余的内存空间</span></span><br><span class="line">    *configs = kmemdup(cfg, ncfg * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!*configs) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *nconfigs = ncfg;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(cfg);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> property;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pin_config_param</span> <span class="title">param</span>;</span></span><br><span class="line">    u32 default_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件中定义的全局变量，表示支持的引脚状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> <span class="title">dt_params</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// bias-bus-hold 属性名，在设备树中使用该名字，</span></span><br><span class="line">    <span class="comment">// PIN_CONFIG_BIAS_BUS_HOLD 引脚的状态，</span></span><br><span class="line">    <span class="comment">// 0 引脚状态的值</span></span><br><span class="line">    &#123; <span class="string">&quot;bias-bus-hold&quot;</span>, PIN_CONFIG_BIAS_BUS_HOLD, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-disable&quot;</span>, PIN_CONFIG_BIAS_DISABLE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-high-impedance&quot;</span>, PIN_CONFIG_BIAS_HIGH_IMPEDANCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-pull-up&quot;</span>, PIN_CONFIG_BIAS_PULL_UP, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-pull-pin-default&quot;</span>, PIN_CONFIG_BIAS_PULL_PIN_DEFAULT, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;bias-pull-down&quot;</span>, PIN_CONFIG_BIAS_PULL_DOWN, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-open-drain&quot;</span>, PIN_CONFIG_DRIVE_OPEN_DRAIN, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-open-source&quot;</span>, PIN_CONFIG_DRIVE_OPEN_SOURCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-push-pull&quot;</span>, PIN_CONFIG_DRIVE_PUSH_PULL, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;drive-strength&quot;</span>, PIN_CONFIG_DRIVE_STRENGTH, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-debounce&quot;</span>, PIN_CONFIG_INPUT_DEBOUNCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-disable&quot;</span>, PIN_CONFIG_INPUT_ENABLE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-enable&quot;</span>, PIN_CONFIG_INPUT_ENABLE, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-schmitt&quot;</span>, PIN_CONFIG_INPUT_SCHMITT, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-schmitt-disable&quot;</span>, PIN_CONFIG_INPUT_SCHMITT_ENABLE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;input-schmitt-enable&quot;</span>, PIN_CONFIG_INPUT_SCHMITT_ENABLE, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;low-power-disable&quot;</span>, PIN_CONFIG_LOW_POWER_MODE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;low-power-enable&quot;</span>, PIN_CONFIG_LOW_POWER_MODE, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;output-high&quot;</span>, PIN_CONFIG_OUTPUT, <span class="number">1</span>, &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;output-low&quot;</span>, PIN_CONFIG_OUTPUT, <span class="number">0</span>, &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;power-source&quot;</span>, PIN_CONFIG_POWER_SOURCE, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;slew-rate&quot;</span>, PIN_CONFIG_SLEW_RATE, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="parse-dt-cfg"><a href="#parse-dt-cfg" class="headerlink" title="parse_dt_cfg"></a>parse_dt_cfg</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询设备节点np中存在的  params[count] 数组中的属性，</span></span><br><span class="line"><span class="comment">// 如果存在则按顺寻将该 params 可配置的引脚状态参数 pin_config_param </span></span><br><span class="line"><span class="comment">// 以及配置的默认状态 default_value 组合后,存入 cfg 指向的内存空间, 之后 ncfg 等于 cfg 数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse_dt_cfg</span><span class="params">(struct device_node *np, <span class="keyword">const</span> struct pinconf_generic_params *params, <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">unsigned</span> <span class="keyword">long</span> *cfg, <span class="keyword">unsigned</span> <span class="keyword">int</span> *ncfg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        u32 val;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="comment">//获取 params 中的 pinconf_generic_params</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">par</span> =</span> &amp;params[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从np节点中查询是存在该属性</span></span><br><span class="line">        ret = of_property_read_u32(np, par-&gt;property, &amp;val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不存在结束本次循环</span></span><br><span class="line">        <span class="comment">/* property not found */</span></span><br><span class="line">        <span class="keyword">if</span> (ret == -EINVAL)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* use default value, when no value is specified */</span></span><br><span class="line">        <span class="comment">//如果存在这个属性则获取这个default属性的值</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            val = par-&gt;default_value;</span><br><span class="line"></span><br><span class="line">        pr_debug(<span class="string">&quot;found %s with value %u\n&quot;</span>, par-&gt;property, val);</span><br><span class="line">        <span class="comment">//将该params可配置的引脚状态参数 pin_config_param 以及配置的默认状态组合后写入到cfg所在的内存空间。</span></span><br><span class="line">        cfg[*ncfg] = pinconf_to_config_packed(par-&gt;param, val);</span><br><span class="line">        (*ncfg)++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">pinconf_to_config_packed</span><span class="params">(<span class="keyword">enum</span> pin_config_param param,</span></span></span><br><span class="line"><span class="function"><span class="params">                             u16 argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PIN_CONF_PACKED(param, argument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_CONF_PACKED(p, a) ((a &lt;&lt; 16) | ((unsigned long) p &amp; 0xffffUL))</span></span><br></pre></td></tr></table></figure>
<h6 id="pinctrl-utils-reserve-map"><a href="#pinctrl-utils-reserve-map" class="headerlink" title="pinctrl_utils_reserve_map"></a>pinctrl_utils_reserve_map</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新申请一片大小为 *num_maps + reserve 的内存空间，并将 map 的值复制过去，</span></span><br><span class="line"><span class="comment">// reserved_maps 之后的内存空间初始化为 0, 同时更新 pinctrl_map 的数量 reserved_maps</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_utils_reserve_map</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *reserved_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> *num_maps, <span class="keyword">unsigned</span> reserve)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> old_num = *reserved_maps; <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> new_num = *num_maps + reserve; <span class="comment">// </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">new_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_num &gt;= new_num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    new_map = krealloc(*<span class="built_in">map</span>, <span class="keyword">sizeof</span>(*new_map) * new_num, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new_map) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;krealloc(map) failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(new_map + old_num, <span class="number">0</span>, (new_num - old_num) * <span class="keyword">sizeof</span>(*new_map));</span><br><span class="line"></span><br><span class="line">    *<span class="built_in">map</span> = new_map;</span><br><span class="line">    *reserved_maps = new_num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="mtk-pctrl-find-group-by-pin"><a href="#mtk-pctrl-find-group-by-pin" class="headerlink" title="mtk_pctrl_find_group_by_pin"></a>mtk_pctrl_find_group_by_pin</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回该 pin 脚所在的 group，mtk平台每一个 pin 就是一个 group</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct mtk_pinctrl_group * <span class="title">mtk_pctrl_find_group_by_pin</span><span class="params">(struct mtk_pinctrl *pctl, u32 pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pctl-&gt;ngroups; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl_group</span> *<span class="title">grp</span> =</span> pctl-&gt;groups + i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grp-&gt;pin == pin)</span><br><span class="line">            <span class="keyword">return</span> grp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtk_pinctrl_group</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   config;</span><br><span class="line">    <span class="keyword">unsigned</span>    pin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="dt-remember-or-free-map"><a href="#dt-remember-or-free-map" class="headerlink" title="dt_remember_or_free_map"></a>dt_remember_or_free_map</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进一步初始化 pinctrl_map, 并创建对应的 pinctrl_dt_map 映射</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dt_remember_or_free_map</span><span class="params">(struct pinctrl *p, <span class="keyword">const</span> <span class="keyword">char</span> *statename,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct pinctrl_map *<span class="built_in">map</span>, <span class="keyword">unsigned</span> num_maps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dt_map</span> *<span class="title">dt_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 dev_name 这个很重要，转化为 pinctrl_settings 时这个作为判断条件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line">        <span class="built_in">map</span>[i].dev_name = dev_name(p-&gt;dev); <span class="comment">//初始化 pinctrl_map 所属的 pinctrl 的 dev_name</span></span><br><span class="line">        <span class="built_in">map</span>[i].name = statename; <span class="comment">//初始化 name</span></span><br><span class="line">        <span class="keyword">if</span> (pctldev)</span><br><span class="line">            <span class="built_in">map</span>[i].ctrl_dev_name = dev_name(pctldev-&gt;dev); <span class="comment">//设置所属的 pinctrl_dev 的 name</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 pinctrl_dt_map</span></span><br><span class="line">    dt_map = kzalloc(<span class="keyword">sizeof</span>(*dt_map), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dt_map) &#123;</span><br><span class="line">        dev_err(p-&gt;dev, <span class="string">&quot;failed to alloc struct pinctrl_dt_map\n&quot;</span>);</span><br><span class="line">        dt_free_map(pctldev, <span class="built_in">map</span>, num_maps);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 pinctrl_dt_map </span></span><br><span class="line">    dt_map-&gt;pctldev = pctldev; </span><br><span class="line">    dt_map-&gt;<span class="built_in">map</span> = <span class="built_in">map</span>;</span><br><span class="line">    dt_map-&gt;num_maps = num_maps;</span><br><span class="line">    list_add_tail(&amp;dt_map-&gt;node, &amp;p-&gt;dt_maps); <span class="comment">//将 dt_map 挂接到所属的 pinctrl</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pinctrl_register_map(<span class="built_in">map</span>, num_maps, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pinctrl-register-map"><a href="#pinctrl-register-map" class="headerlink" title="pinctrl_register_map"></a>pinctrl_register_map</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_register_map</span><span class="params">(struct pinctrl_map <span class="keyword">const</span> *maps, <span class="keyword">unsigned</span> num_maps,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">bool</span> dup)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span></span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;add %u pinctrl maps\n&quot;</span>, num_maps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先检测 map 的合法性</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!maps[i].dev_name) &#123; <span class="comment">//每一个 map 都要有所属的设备</span></span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %s (%d): no device given\n&quot;</span>,</span><br><span class="line">                   maps[i].name, i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!maps[i].name) &#123; <span class="comment">//每一个 map 都要有对应的 state</span></span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %d: no map name given\n&quot;</span>,</span><br><span class="line">                   i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当 map 的类型不为 PIN_MAP_TYPE_DUMMY_STAT ，map 必须要有所属的 pinctl_dev</span></span><br><span class="line">        <span class="keyword">if</span> (maps[i].type != PIN_MAP_TYPE_DUMMY_STATE &amp;&amp;</span><br><span class="line">                !maps[i].ctrl_dev_name) &#123; E</span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %s (%d): no pin control device given\n&quot;</span>,</span><br><span class="line">                   maps[i].name, i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (maps[i].type) &#123;</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_DUMMY_STATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">            ret = pinmux_validate_map(&amp;maps[i], i); <span class="comment">//检查 map-&gt;data.mux.function 是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">        <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">            ret = pinconf_validate_map(&amp;maps[i], i);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pr_err(<span class="string">&quot;failed to register map %s (%d): invalid type given\n&quot;</span>,</span><br><span class="line">                   maps[i].name, i);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态创建一个 maps_node 用于挂接 pinctrl_maps</span></span><br><span class="line">    maps_node = kzalloc(<span class="keyword">sizeof</span>(*maps_node), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!maps_node) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;failed to alloc struct pinctrl_maps\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maps_node-&gt;num_maps = num_maps; </span><br><span class="line">    <span class="keyword">if</span> (dup) &#123;</span><br><span class="line">        maps_node-&gt;maps = kmemdup(maps, <span class="keyword">sizeof</span>(*maps) * num_maps,</span><br><span class="line">                      GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!maps_node-&gt;maps) &#123;</span><br><span class="line">            pr_err(<span class="string">&quot;failed to duplicate mapping table\n&quot;</span>);</span><br><span class="line">            kfree(maps_node);</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maps_node-&gt;maps = maps; <span class="comment">//跑这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line">    list_add_tail(&amp;maps_node-&gt;node, &amp;pinctrl_maps); <span class="comment">//将 maps_node 链接到全局 pinctrl_maps</span></span><br><span class="line">    mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="b-将pinctrl-map转化为pinctrl-setting"><a href="#b-将pinctrl-map转化为pinctrl-setting" class="headerlink" title="b. 将pinctrl_map转化为pinctrl_setting"></a>b. 将pinctrl_map转化为pinctrl_setting</h5><h6 id="add-setting"><a href="#add-setting" class="headerlink" title="add_setting"></a>add_setting</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_setting</span><span class="params">(struct pinctrl *p, struct pinctrl_map <span class="keyword">const</span> *<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> *<span class="title">setting</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对应的 state</span></span><br><span class="line">    state = find_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="comment">// 如果没有 state 则创建</span></span><br><span class="line">        state = create_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(state))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type == PIN_MAP_TYPE_DUMMY_STATE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 pinctrl_setting</span></span><br><span class="line">    setting = kzalloc(<span class="keyword">sizeof</span>(*setting), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (setting == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(p-&gt;dev,</span><br><span class="line">            <span class="string">&quot;failed to alloc struct pinctrl_setting\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 type</span></span><br><span class="line">    setting-&gt;type = <span class="built_in">map</span>-&gt;type;</span><br><span class="line"></span><br><span class="line">    setting-&gt;pctldev = get_pinctrl_dev_from_devname(<span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line">    <span class="keyword">if</span> (setting-&gt;pctldev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        kfree(setting);</span><br><span class="line">        <span class="comment">/* Do not defer probing of hogs (circular loop) */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;ctrl_dev_name, <span class="built_in">map</span>-&gt;dev_name))</span><br><span class="line">            <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * OK let us guess that the driver is not there yet, and</span></span><br><span class="line"><span class="comment">         * let&#x27;s defer obtaining this pinctrl handle to later...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dev_info(p-&gt;dev, <span class="string">&quot;unknown pinctrl device %s in map entry, deferring probe&quot;</span>,</span><br><span class="line">            <span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line">        <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setting-&gt;dev_name = <span class="built_in">map</span>-&gt;dev_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">map</span>-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">        <span class="comment">//转化引脚复用</span></span><br><span class="line">        ret = pinmux_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">        <span class="comment">//转化pinconfig</span></span><br><span class="line">        ret = pinconf_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(setting);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;setting-&gt;node, &amp;state-&gt;settings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="create-state"><a href="#create-state" class="headerlink" title="create_state"></a>create_state</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pinctrl_state *<span class="title">create_state</span><span class="params">(struct pinctrl *p,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个 state</span></span><br><span class="line">    state = kzalloc(<span class="keyword">sizeof</span>(*state), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(p-&gt;dev,</span><br><span class="line">            <span class="string">&quot;failed to alloc struct pinctrl_state\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;name = name; <span class="comment">//初始化 name</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;state-&gt;settings);</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;state-&gt;node, &amp;p-&gt;states); <span class="comment">//将其挂接到所属 pinctl 的states</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pinmux-map-to-setting"><a href="#pinmux-map-to-setting" class="headerlink" title="pinmux_map_to_setting"></a>pinmux_map_to_setting</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinmux_map_to_setting</span><span class="params">(struct pinctrl_map <span class="keyword">const</span> *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct pinctrl_setting *setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span> =</span> pctldev-&gt;desc-&gt;pmxops;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> *groups;</span><br><span class="line">    <span class="keyword">unsigned</span> num_groups;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *group;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pmxops) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;does not support mux function\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 function所在数据结构的数组下标</span></span><br><span class="line">    ret = pinmux_func_name_to_selector(pctldev, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;invalid function %s in map table\n&quot;</span>,</span><br><span class="line">            <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将其赋值给对应的 setting</span></span><br><span class="line">    setting-&gt;data.mux.func = ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前  function 结构中支持的 groups</span></span><br><span class="line">    ret = pmxops-&gt;get_function_groups(pctldev, setting-&gt;data.mux.func, &amp;groups, &amp;num_groups);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;can&#x27;t query groups for function %s\n&quot;</span>,</span><br><span class="line">            <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!num_groups) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev,</span><br><span class="line">            <span class="string">&quot;function %s can&#x27;t be selected on any group\n&quot;</span>,</span><br><span class="line">            <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data.mux.group) &#123;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        group = <span class="built_in">map</span>-&gt;data.mux.group;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_groups; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(group, groups[i])) &#123; <span class="comment">//查看是否支持 data.mux.group</span></span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            dev_err(pctldev-&gt;dev,</span><br><span class="line">                <span class="string">&quot;invalid group \&quot;%s\&quot; for function \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">                group, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        group = groups[<span class="number">0</span>]; <span class="comment">//如果没有  map-&gt;data.mux.group 则使用 groups[0] 作为默认状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在所有的 group 中查找该 group 的下标，并用来初始化 map-&gt;data.mux.group</span></span><br><span class="line">    ret = pinctrl_get_group_selector(pctldev, group);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(pctldev-&gt;dev, <span class="string">&quot;invalid group %s in map table\n&quot;</span>,</span><br><span class="line">            <span class="built_in">map</span>-&gt;data.mux.group);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    setting-&gt;data.mux.group = ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pinmux-func-name-to-selector"><a href="#pinmux-func-name-to-selector" class="headerlink" title="pinmux_func_name_to_selector"></a>pinmux_func_name_to_selector</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pinmux_func_name_to_selector</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *function)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">ops</span> =</span> pctldev-&gt;desc-&gt;pmxops;</span><br><span class="line">    <span class="keyword">unsigned</span> nfuncs = ops-&gt;get_functions_count(pctldev); <span class="comment">//获取 functions 的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> selector = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 function 所在数据结构的数组下标</span></span><br><span class="line">    <span class="keyword">while</span> (selector &lt; nfuncs) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *fname = ops-&gt;get_function_name(pctldev, selector); <span class="comment">//返回 selector 下标中的 func name</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(function, fname))</span><br><span class="line">            <span class="keyword">return</span> selector; <span class="comment">//返回数组下标</span></span><br><span class="line"></span><br><span class="line">        selector++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_err(pctldev-&gt;dev, <span class="string">&quot;function &#x27;%s&#x27; not supported\n&quot;</span>, function);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pinctrl-get-group-selector"><a href="#pinctrl-get-group-selector" class="headerlink" title="pinctrl_get_group_selector"></a>pinctrl_get_group_selector</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在所有的 group 中查找该 group 的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_get_group_selector</span><span class="params">(struct pinctrl_dev *pctldev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *pin_group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span> =</span> pctldev-&gt;desc-&gt;pctlops; </span><br><span class="line">    <span class="keyword">unsigned</span> ngroups = pctlops-&gt;get_groups_count(pctldev); <span class="comment">//返回 group 的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> group_selector = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (group_selector &lt; ngroups) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *gname = pctlops-&gt;get_group_name(pctldev,</span><br><span class="line">                                group_selector);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(gname, pin_group)) &#123; </span><br><span class="line">            dev_dbg(pctldev-&gt;dev,</span><br><span class="line">                <span class="string">&quot;found group selector %u for %s\n&quot;</span>,</span><br><span class="line">                group_selector,</span><br><span class="line">                pin_group);</span><br><span class="line">            <span class="keyword">return</span> group_selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group_selector++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_err(pctldev-&gt;dev, <span class="string">&quot;does not have pin group %s\n&quot;</span>,</span><br><span class="line">        pin_group);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pinconf-map-to-setting"><a href="#pinconf-map-to-setting" class="headerlink" title="pinconf_map_to_setting"></a>pinconf_map_to_setting</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pinconf_map_to_setting 将 conifg 对应的 map 转化为setting</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinconf_map_to_setting</span><span class="params">(struct pinctrl_map <span class="keyword">const</span> *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct pinctrl_setting *setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;</span><br><span class="line">    <span class="keyword">int</span> pin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">        <span class="comment">// 对应的 pin 脚</span></span><br><span class="line">        pin = pin_get_from_name(pctldev,</span><br><span class="line">                    <span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line">        <span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dev_err(pctldev-&gt;dev, <span class="string">&quot;could not map pin config for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">                <span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line">            <span class="keyword">return</span> pin;</span><br><span class="line">        &#125;</span><br><span class="line">        setting-&gt;data.configs.group_or_pin = pin;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">        <span class="comment">//返回对应的 group 的下标</span></span><br><span class="line">        pin = pinctrl_get_group_selector(pctldev,</span><br><span class="line">                     <span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line">        <span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dev_err(pctldev-&gt;dev, <span class="string">&quot;could not map group config for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">                <span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line">            <span class="keyword">return</span> pin;</span><br><span class="line">        &#125;</span><br><span class="line">        setting-&gt;data.configs.group_or_pin = pin;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//config 的数量</span></span><br><span class="line">    setting-&gt;data.configs.num_configs = <span class="built_in">map</span>-&gt;data.configs.num_configs;</span><br><span class="line">    <span class="comment">//config </span></span><br><span class="line">    setting-&gt;data.configs.configs = <span class="built_in">map</span>-&gt;data.configs.configs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pin-get-from-name"><a href="#pin-get-from-name" class="headerlink" title="pin_get_from_name"></a>pin_get_from_name</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过 name 返回对应的 pin 脚</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pin_get_from_name</span><span class="params">(struct pinctrl_dev *pctldev, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> i, pin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The pin number can be retrived from the pin controller descriptor */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pctldev-&gt;desc-&gt;npins; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">        pin = pctldev-&gt;desc-&gt;pins[i].number;</span><br><span class="line">        desc = pin_desc_get(pctldev, pin);</span><br><span class="line">        <span class="comment">/* Pin space may be sparse */</span></span><br><span class="line">        <span class="keyword">if</span> (desc &amp;&amp; !<span class="built_in">strcmp</span>(name, desc-&gt;name))</span><br><span class="line">            <span class="keyword">return</span> pin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、pinctrl-子系统的使用"><a href="#四、pinctrl-子系统的使用" class="headerlink" title="四、pinctrl 子系统的使用"></a>四、pinctrl 子系统的使用</h2><p>使用就比较简单了接口如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前设备的 pinctrl 句柄</span></span><br><span class="line"><span class="function">struct pinctrl *<span class="title">pinctrl_get</span><span class="params">(struct device *dev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取我们需要设置的 state</span></span><br><span class="line"><span class="function">struct pinctrl_state *<span class="title">pinctrl_lookup_state</span><span class="params">(struct pinctrl *p, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置为对应的state</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_select_state</span><span class="params">(struct pinctrl *p, struct pinctrl_state *state)</span></span>;</span><br></pre></td></tr></table></figure>
<p>mtk 平台可以参考这篇文章 <a href="https://my.oschina.net/u/4323904/blog/3937409">mtk-GPIO设置与应用</a></p>
]]></content>
      <tags>
        <tag>驱动</tag>
        <tag>pinctrl</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动-input子系统</title>
    <url>/2021/05/06/linux%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<p>input系统，内核里面比较简单的子系统，也比较常用，</p>
<a id="more"></a>

<h2 id="一、框架"><a href="#一、框架" class="headerlink" title="一、框架"></a>一、框架</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;input 子系统 linux 为输入设备（键盘，鼠标，触摸屏等）提供了统一的接口。它的框架有三层组成，设备驱动层(drivers)，核心层，事件处理层，如下图所示。其实看了源码就会发现，所谓的 input 子系统本质也就是字符设备而已，不过内核将常用的设备接口封装在里面了，直接使用就行了。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/input/input%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1624851767;1984848167&q-key-time=1624851767;1984848167&q-header-list=&q-url-param-list=&q-signature=9594514eb336a368f374eeb33de380fce0ff3589" width="100%" height="100%" alt="input 子系统的系统框架">

<h2 id="二、输入核心层"><a href="#二、输入核心层" class="headerlink" title="二、输入核心层"></a>二、输入核心层</h2><p>输入核心层在整个框架中处于承上启下的作用，它提供的功能</p>
<ol>
<li>在/sys/class/ 下创建一个类 名字叫做 input，在/proc下面建立相关的文件，注册一个字符设备 input</li>
<li>向设备驱动层提供注册函数 input_register_device</li>
<li>向事件处理层提供注册函数 input_register_handler</li>
<li>提供匹配函数 input_attach_handler 用于建立 input_dev 和 input_handler 之间的连接，并对其进行管理。</li>
<li>提供上报中转接口 input_event</li>
</ol>
<h3 id="1、相关数据结构"><a href="#1、相关数据结构" class="headerlink" title="1、相关数据结构"></a>1、相关数据结构</h3><h4 id="1-input-handler"><a href="#1-input-handler" class="headerlink" title="1) input_handler"></a>1) input_handler</h4><p>每一个 input_handler 结构都是一类事件处理接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*event)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*events)(struct input_handle *handle, <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">bool</span> (*filter)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配时调用这个函数，如果返回 0 则匹配失败</span></span><br><span class="line">    <span class="keyword">bool</span> (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配成功调用这个函数建立连接</span></span><br><span class="line">    <span class="keyword">int</span> (*connect)(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id);</span><br><span class="line">    <span class="keyword">void</span> (*disconnect)(struct input_handle *handle);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> legacy_minors;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//handler 的名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 能够支持哪一些输入设备 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span> <span class="comment">//用来存放input_handle-&gt;h_node</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span>   <span class="comment">//链接进入 input_handler_list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在老式的 2.6 内核， input_handler 在内核中由 input_table 管理，它是在 input.c 中的全局数组，表示支持的输入设备类型最多有8类，其中包含 mousedev，joydev，evdev 等。 input 子系统的主设备号固定为 INPUT_MAJOR 这个宏被初始化为 13 ,次设备号为 0~255，input_table 数组有8个 input_handler,这 8 个input_handler 将 256 个设备号划分为8份，即每一个 input_handler 最多支持 32个字符设备节点。evdev 的次设备号起始为 EVDEV_MINOR_BASE ，这个宏被初始化为 64，因此 evdev 对应的 table 数组项为 input_table[2]。<br>&nbsp;&nbsp;&nbsp;&nbsp;而新的内核则使用了更加方便的方式，直接将 input_handler 的管理由核心层移交给事件处理层来管理，使用 input_handle 来动态管理。每个连接成功的 input_handler 和 input_dev 都会动态创建一个 input_handle 来管理，当卸载时释放掉这个结构就可以了。</p>
<h4 id="2-input-device-id"><a href="#2-input-device-id" class="headerlink" title="2) input_device_id"></a>2) input_device_id</h4><p>能够支持哪一些输入设备，用于匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> INPUT_DEVICE_ID_MATCH_BUS       1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> INPUT_DEVICE_ID_MATCH_VENDOR    2</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> INPUT_DEVICE_ID_MATCH_PRODUCT   4</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> INPUT_DEVICE_ID_MATCH_VERSION   8</span></span><br><span class="line">    <span class="comment">// 用于设置需要匹配的内容，虽然内核提供了许多选择</span></span><br><span class="line">    <span class="comment">// 但是 input_match_device_id 函数也就用到了上面四个而已，</span></span><br><span class="line">    <span class="comment">// 其他的匹配项目或许是用于客制化吧。</span></span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> flags; </span><br><span class="line"></span><br><span class="line">    __u16 bustype;</span><br><span class="line">    __u16 vendor;</span><br><span class="line">    __u16 product;</span><br><span class="line">    __u16 version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> evbit[INPUT_DEVICE_ID_EV_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> keybit[INPUT_DEVICE_ID_KEY_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> relbit[INPUT_DEVICE_ID_REL_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> absbit[INPUT_DEVICE_ID_ABS_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> mscbit[INPUT_DEVICE_ID_MSC_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> ledbit[INPUT_DEVICE_ID_LED_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> sndbit[INPUT_DEVICE_ID_SND_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> ffbit[INPUT_DEVICE_ID_FF_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> swbit[INPUT_DEVICE_ID_SW_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> propbit[INPUT_DEVICE_ID_PROP_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">kernel_ulong_t</span> driver_info; <span class="comment">//设置为 1 则表示默认进行匹配。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-input-dev"><a href="#3-input-dev" class="headerlink" title="3) input_dev"></a>3) input_dev</h4><p>每一个 input_dev 都是一个具体的硬件设备，里面包含该硬件设备的信息和处理函数，该结构也是驱动要处理的结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 设备名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *phys; <span class="comment">// 设备节点名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *uniq; <span class="comment">// 唯一的ID号，</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span> <span class="comment">// 输入设备ID，用于 handler 匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> evbit[BITS_TO_LONGS(EV_CNT)];  <span class="comment">//设备支持的事件类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">//按键 ex：上下左右 home</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">//相对坐标 ex 鼠标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">//绝对坐标 ex 触摸屏</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">//其他功能</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">//指示灯</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sndbit[BITS_TO_LONGS(SND_CNT)]; <span class="comment">//声音或警报</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">//作用力</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">//开关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodemax; <span class="comment">//设备支持最大按键值个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodesize; <span class="comment">//每个按键字节大小</span></span><br><span class="line">    <span class="keyword">void</span> *keycode; <span class="comment">//按键池，指向按键值数组首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*setkeycode)(struct input_dev *dev,</span><br><span class="line">              <span class="keyword">const</span> struct input_keymap_entry *ke,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> *old_keycode); <span class="comment">// 修改按键值</span></span><br><span class="line">    <span class="keyword">int</span> (*getkeycode)(struct input_dev *dev,</span><br><span class="line">              struct input_keymap_entry *ke); <span class="comment">// 获取按键值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span> <span class="comment">//强制更新输入设备的部分内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat_key; <span class="comment">//重复按键的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span> <span class="comment">//连击时定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rep[REP_CNT]; <span class="comment">//按键重复</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct input_dev *dev); <span class="comment">//open 回调接口</span></span><br><span class="line">    <span class="keyword">void</span> (*close)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">int</span> (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">    <span class="keyword">int</span> (*event)(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> event_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> users; <span class="comment">//设备使用计数</span></span><br><span class="line">    <span class="keyword">bool</span> going_away;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">//设备结构</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span> <span class="comment">// handle list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span>   <span class="comment">// input dev list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_vals;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_vals;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">vals</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-input-handle"><a href="#4-input-handle" class="headerlink" title="4) input_handle"></a>4) input_handle</h4><p>用于连接上面的 input_dev 和 input_handler</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> open;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">d_node</span>;</span> <span class="comment">// 链接到 handle-&gt;dev-&gt;h_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_node</span>;</span> <span class="comment">// 链接到 handler-&gt;h_list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-input-event"><a href="#5-input-event" class="headerlink" title="5) input_event"></a>5) input_event</h4><p>上报的事件由 input_event 描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">    __u16 type;    <span class="comment">//事件类型</span></span><br><span class="line">    __u16 code;    <span class="comment">//事件</span></span><br><span class="line">    __s32 value;   <span class="comment">//事件值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、三角关系"><a href="#2、三角关系" class="headerlink" title="2、三角关系"></a>2、三角关系</h3><p>对于每一个和 input_handler 匹配成功的 input_dev 内核都会在connect函数中创建一个 input_handle 结构，用于建立以及维护input_handler和input_dev之间的联系。input_handle作为 input_dev 和 input_handler 沟通的桥梁。建立联系的过程如下：</p>
<ol>
<li>调用 input_register_handler 注册 input_dev 结构</li>
<li>在 input_register_handler 中遍历 input_handler_list 中所有的 input_handler,对每一个 input_hander 调用 input_attach_handler 进行匹配 (提示:这说明input_dev可以和多个input_hander 匹配成功)</li>
<li>匹配成功则调用 input_handler.connect函数</li>
<li>connect 函数中将 input_dev 和 input_handler 赋值给 input_handle.dev 和 input_handle.handler</li>
<li>调用 input_register_handle 将 handle-&gt;d_node 链入 handle-&gt;dev-&gt;h_list 同时将 handle-&gt;h_node 链入 handler-&gt;h_list</li>
</ol>
<div align=left> <img width=800 src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/input/1.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1602247945;2379847945&q-key-time=1602247945;2379847945&q-header-list=&q-url-param-list=&q-signature=bd099cbf269f41ddf63c19417c91ec61d8248006" > </div>

<p>于是 input_dev 可以利用 input_dev.h_list 中保存的d_node 找到 input_handle 结构从而找到对应的 input_handle.handler 中保存的 input_handler 结构,同理 input_hander 也可以借助 input_handle 找到对应 的input_dev。上述只是简单的描述了三者的关系，而input_dev和input_handler，并不是<font color=red><strong>简单的一对一的关系，而是多对多的关系。</strong></font>。</p>
<h3 id="3、核心层相关接口"><a href="#3、核心层相关接口" class="headerlink" title="3、核心层相关接口"></a>3、核心层相关接口</h3><h4 id="1-input-register-handler"><a href="#1-input-register-handler" class="headerlink" title="1) input_register_handler"></a>1) input_register_handler</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将 handler 链接到 input_handler_list</span></span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对遍历 input_dev_list 上的所有 dev 对每一个 dev 都调用 input_attach_handler 函数</span></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handler);</span><br></pre></td></tr></table></figure>
<h4 id="2-input-attach-handler"><a href="#2-input-attach-handler" class="headerlink" title="2) input_attach_handler"></a>2) input_attach_handler</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">// 调用匹配接口</span></span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    <span class="keyword">if</span> (!id)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配成功则调用 handler-&gt;connect 函数建立连接</span></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">        pr_err(<span class="string">&quot;failed to attach handler %s to device %s, error: %d\n&quot;</span>,</span><br><span class="line">               handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-input-match-device"><a href="#3-input-match-device" class="headerlink" title="3) input_match_device"></a>3) input_match_device</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct input_device_id *<span class="title">input_match_device</span><span class="params">(struct input_handler *handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否有 flag 或者 driver_info, 如果有设置则进行匹配</span></span><br><span class="line">    <span class="comment">// 匹配成功如果有 handler-&gt;match 函数时，只有该函数返回为真时表示匹配成功</span></span><br><span class="line">    <span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input_match_device_id(dev, id) &amp;&amp;</span><br><span class="line">            (!handler-&gt;match || handler-&gt;match(handler, dev))) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-input-match-device-id"><a href="#4-input-match-device-id" class="headerlink" title="4) input_match_device_id"></a>4) input_match_device_id</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">input_match_device_id</span><span class="params">(<span class="keyword">const</span> struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS) <span class="comment">// 匹配总线</span></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">        <span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor) <span class="comment">// 匹配供应商</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">        <span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product) <span class="comment">// 匹配产品</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">        <span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version) <span class="comment">// 匹配版本</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bitmap_subset 这个函数的算法也是挺有意思的，感兴趣可以看看源码，下面直接给出结论</span></span><br><span class="line">    <span class="comment">// static inline int bitmap_subset(const unsigned long *src1, const unsigned long *src2, unsigned int nbits)</span></span><br><span class="line">    <span class="comment">// 当 src1 的第 n 位 (n &lt; nbits) 为 0 时，src2 的第 n 位为任何数结果为真</span></span><br><span class="line">    <span class="comment">// 当 src1 的第 n 位 (n &lt; nbits) 为 1 时，src2 的第 n 位为 1 是结果为真，否则结果为假</span></span><br><span class="line">    <span class="comment">// 只有当两者的 nbits 描述的位都位真时返回真</span></span><br><span class="line">    <span class="comment">// 举例说明1： bitmap_subset(5,3,3);</span></span><br><span class="line">    <span class="comment">// 5 二进制表示:    1     0     1</span></span><br><span class="line">    <span class="comment">// 3 二进制表示：   0     1     1</span></span><br><span class="line">    <span class="comment">// 计算结果         0  &amp;  1  &amp;  1  ==&gt; 0</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 举例说明2： bitmap_subset(5,7,2); //只计算两位忽略最高位</span></span><br><span class="line">    <span class="comment">// 5 二进制表示:    1     0     1</span></span><br><span class="line">    <span class="comment">// 3 二进制表示：   0     1     1</span></span><br><span class="line">    <span class="comment">// 计算结果               1  &amp;  1  ==&gt; 1        </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 引申到这个函数的功能就是，当 input_handler 的事件类型某一位设置位 0 则表示兼容。</span></span><br><span class="line">    <span class="comment">// 如果设置位 1 则表示，当设备不支持时则无法匹配成功。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||     <span class="comment">// 匹配支持的事件类型</span></span><br><span class="line">        !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||  <span class="comment">// 匹配支持的按键事件</span></span><br><span class="line">        !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||  <span class="comment">// 匹配支持的相对坐标事件</span></span><br><span class="line">        !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||  <span class="comment">// 匹配支持的绝对坐标事件</span></span><br><span class="line">        !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||  <span class="comment">// 匹配支持的其他功能</span></span><br><span class="line">        !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||  <span class="comment">// 匹配支持的指示灯</span></span><br><span class="line">        !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||  </span><br><span class="line">        !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">        !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">        !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_match_device_id);</span><br></pre></td></tr></table></figure>
<h4 id="4-input-register-device"><a href="#4-input-register-device" class="headerlink" title="4) input_register_device"></a>4) input_register_device</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试是否设置了 EV_ABS ，如果设置的同时  dev-&gt;absinfo 为空则返回</span></span><br><span class="line">    <span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit) &amp;&amp; !dev-&gt;absinfo) &#123;</span><br><span class="line">        dev_err(&amp;dev-&gt;dev,</span><br><span class="line">            <span class="string">&quot;Absolute device without dev-&gt;absinfo, refusing to register\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否使用设备资源管理，</span></span><br><span class="line">    <span class="comment">// 驱动注册失败时自动调用 devm_input_device_unregister 函数释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123; </span><br><span class="line">        devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">                      <span class="keyword">sizeof</span>(*devres), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!devres)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        devres-&gt;input = dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个设备都支持 EV_SYN/SYN_REPORT 事件</span></span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY_RESERVED 事件不应该被传输到应用空间</span></span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空其他事件，也就是说在 input_dev 注册前设置的其他事件是没有意义的会被清空</span></span><br><span class="line">    input_cleanse_bitmasks(dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取每个包多少个事件</span></span><br><span class="line">    packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">        dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出每个包最大的事件数</span></span><br><span class="line">    dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 动态分出需要的内存空间</span></span><br><span class="line">    dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;vals) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err_devres_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复按键相关</span></span><br><span class="line">    <span class="comment">// REP_PERIOD 秒之后每个 REP_DELAY 秒检测一次按键是否被按下。</span></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span><br><span class="line">        input_enable_softrepeat(dev, <span class="number">250</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">        dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">        dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册设备创建出设备节点 /sys/devices/xxx</span></span><br><span class="line">    error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> err_free_vals;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//打印设备所在路径</span></span><br><span class="line">    path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">    pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">        dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">        path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">    kfree(path);</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> err_device_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 input_dev 链接到 input_dev_list</span></span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于 input_handler_list 上的每一个 handler 调用 input_attach_handler 进行匹配</span></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler); </span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123; <span class="comment">// 如果设置了设备资源管理则注册对应</span></span><br><span class="line">        dev_dbg(dev-&gt;dev.parent, <span class="string">&quot;%s: registering %s with devres.\n&quot;</span>,</span><br><span class="line">            __func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">        devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_del:</span><br><span class="line">    device_del(&amp;dev-&gt;dev);</span><br><span class="line">err_free_vals:</span><br><span class="line">    kfree(dev-&gt;vals);</span><br><span class="line">    dev-&gt;vals = <span class="literal">NULL</span>;</span><br><span class="line">err_devres_free:</span><br><span class="line">    devres_free(devres);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_device);</span><br></pre></td></tr></table></figure>
<h4 id="5-input-register-handle"><a href="#5-input-register-handle" class="headerlink" title="5) input_register_handle"></a>5) input_register_handle</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handle</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> =</span> handle-&gt;handler;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> handle-&gt;dev;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;filter) <span class="comment">//将 d_node 节点连接到 dev-&gt;h_list</span></span><br><span class="line">        list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 handle-&gt;h_node 链接到 handler-&gt;h_list</span></span><br><span class="line">    list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">        handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handle);</span><br></pre></td></tr></table></figure>
<h2 id="三、evdev-分析"><a href="#三、evdev-分析" class="headerlink" title="三、evdev 分析"></a>三、evdev 分析</h2><p>常用的 input_handler 内核都已经为我们做好了，这里来分析最最常用的 evdev。</p>
<h3 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h3><h4 id="1-evdev"><a href="#1-evdev" class="headerlink" title="1) evdev"></a>1) evdev</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> open; / 对被打开的设备进行计数</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span>  <span class="comment">// handle 被嵌入到 evdev，用于建立 input_dev 和 input_handler 之间的链接</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait; <span class="comment">//等待队列头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span> <span class="comment">//连接 client</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> client_lock; <span class="comment">/* protects client_list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">// 设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>  <span class="comment">// 字符设备结构</span></span><br><span class="line">    <span class="keyword">bool</span> exist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2）evdev-client"><a href="#2）evdev-client" class="headerlink" title="2）evdev_client"></a>2）evdev_client</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span> <span class="comment">// 指向所属的 evdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> clk_type;</span><br><span class="line">    <span class="keyword">bool</span> revoked;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *evmasks[EV_CNT];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize; <span class="comment">// 数据大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span> <span class="comment">// 需要上报的数据存储在这里，这是一个环形数组缓存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、evdev-的注册"><a href="#2、evdev-的注册" class="headerlink" title="2、evdev 的注册"></a>2、evdev 的注册</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] =</span> &#123;</span><br><span class="line">    &#123; .driver_info = <span class="number">1</span> &#125;,   <span class="comment">/* 对所有的设备进行匹配 */</span></span><br><span class="line">    &#123; &#125;,                    <span class="comment">/* 其他项为 0 则支持所有的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(input, evdev_ids);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">    .event      = evdev_event,       <span class="comment">// 事件处理回调接口</span></span><br><span class="line">    .events     = evdev_events,      </span><br><span class="line">    .connect    = evdev_connect,     <span class="comment">// 当有 input_dev 匹配成功时调用，建立连接</span></span><br><span class="line">    .disconnect = evdev_disconnect,  <span class="comment">// 断开连接</span></span><br><span class="line">    .legacy_minors  = <span class="literal">true</span>,           </span><br><span class="line">    .minor      = EVDEV_MINOR_BASE,  <span class="comment">// 次设备号的基地址 64</span></span><br><span class="line">    .name       = <span class="string">&quot;evdev&quot;</span>,           <span class="comment">// handler 名字</span></span><br><span class="line">    .id_table   = evdev_ids,         <span class="comment">// id_table 用于 input_dev 的匹配</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">evdev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、与设备建立连接"><a href="#3、与设备建立连接" class="headerlink" title="3、与设备建立连接"></a>3、与设备建立连接</h3><p>当有设备匹配成功时,直接调用 evdev_connect 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_connect</span><span class="params">(struct input_handler *handler, struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">int</span> dev_no;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取次设备号</span></span><br><span class="line">    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (minor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error = minor;</span><br><span class="line">        pr_err(<span class="string">&quot;failed to reserve new minor: %d\n&quot;</span>, error);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 evdev</span></span><br><span class="line">    evdev = kzalloc(<span class="keyword">sizeof</span>(struct evdev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!evdev) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err_free_minor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">    spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">    mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化等待队列头</span></span><br><span class="line">    init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line">    evdev-&gt;exist = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    dev_no = minor;</span><br><span class="line">    <span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line">    <span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)</span><br><span class="line">        dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置设备名字为 event + 次设备号</span></span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, <span class="string">&quot;event%d&quot;</span>, dev_no);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 handle 结构的 dev 为传入的 input_dev, 同时增加相关设备的引用计数</span></span><br><span class="line">    evdev-&gt;handle.dev = input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);  <span class="comment">// 设置 name 为 evdev</span></span><br><span class="line">    evdev-&gt;handle.handler = handler;             <span class="comment">// 设置 handler</span></span><br><span class="line">    evdev-&gt;handle.<span class="keyword">private</span> = evdev;               <span class="comment">// 设置私有数据</span></span><br><span class="line"></span><br><span class="line">    evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor); <span class="comment">// 设置设备号</span></span><br><span class="line">    evdev-&gt;dev.class = &amp;input_class; <span class="comment">// 设置所属类 /sys/class/input</span></span><br><span class="line">    evdev-&gt;dev.parent = &amp;dev-&gt;dev;   <span class="comment">// 设置父节点为 input_dev-&gt;dev</span></span><br><span class="line">    evdev-&gt;dev.release = evdev_free; <span class="comment">// 设置 release 回调函数</span></span><br><span class="line">    device_initialize(&amp;evdev-&gt;dev);  <span class="comment">// 初始化设备结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 handle 结构，就是将对应节点链接到对应的 input_dev 和 input_handler</span></span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> err_free_evdev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化字符设备，evdev 的本质就是字符设备</span></span><br><span class="line">    cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册字符设备，同时也会在 /dev 下创建出对应的设备 dev/intput0</span></span><br><span class="line">    <span class="comment">// 创建 /sys/class/input/input0</span></span><br><span class="line">    <span class="comment">// 创建 /sys/devices/注册的设备名/input0</span></span><br><span class="line">    error = cdev_device_add(&amp;evdev-&gt;cdev, &amp;evdev-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">    evdev_cleanup(evdev);</span><br><span class="line">    input_unregister_handle(&amp;evdev-&gt;handle);</span><br><span class="line"> err_free_evdev:</span><br><span class="line">    put_device(&amp;evdev-&gt;dev);</span><br><span class="line"> err_free_minor:</span><br><span class="line">    input_free_minor(minor);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在建立连接时将创建字符设备，提供的接口如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> =</span> &#123;</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">    .read       = evdev_read,</span><br><span class="line">    .write      = evdev_write,</span><br><span class="line">    .poll       = evdev_poll,</span><br><span class="line">    .open       = evdev_open,</span><br><span class="line">    .release    = evdev_release,</span><br><span class="line">    .unlocked_ioctl = evdev_ioctl,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">    .compat_ioctl   = evdev_ioctl_compat,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    .fasync     = evdev_fasync,</span><br><span class="line">    .llseek     = no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、打开设备"><a href="#4、打开设备" class="headerlink" title="4、打开设备"></a>4、打开设备</h3><p>当上层打开对应的字符设备接口时回调流程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> evdev_open</span><br><span class="line">    --&gt; <span class="keyword">static</span> <span class="keyword">int</span> evdev_open_device</span><br><span class="line">        --&gt; <span class="keyword">int</span> input_open_device</span><br><span class="line">            --&gt; dev-&gt;open(dev); <span class="comment">//如果存在则调用，不存在直接返回</span></span><br></pre></td></tr></table></figure>
<p>当我们打开一个 evdev 节点的时候最终会调用对应的设备的 open 回调函数</p>
<h3 id="5、读取数据"><a href="#5、读取数据" class="headerlink" title="5、读取数据"></a>5、读取数据</h3><p>当 以 O_NONBLOCK 读取数据时，读取不到数据进入休眠。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">evdev_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判读读取的数据是否过长</span></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; count &lt; input_event_size())</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!evdev-&gt;exist || client-&gt;revoked)</span><br><span class="line">            <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client-&gt;packet_head == client-&gt;tail &amp;&amp;</span><br><span class="line">            (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取的长度为 0 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (read + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">               evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (input_event_to_user(buffer + read, &amp;event))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            read += input_event_size();</span><br><span class="line">        &#125; <span class="comment">// 循环读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read) <span class="comment">// 读取到则返回</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未读取到数据同时状态是 O_NONBLOCK 则进入休眠。</span></span><br><span class="line">        <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123; </span><br><span class="line">            error = wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">                    client-&gt;packet_head != client-&gt;tail ||</span><br><span class="line">                    !evdev-&gt;exist || client-&gt;revoked);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、事件上报"><a href="#四、事件上报" class="headerlink" title="四、事件上报"></a>四、事件上报</h2><p>所谓事件上报，不过是将要上报的事件准备好，然后唤醒前面 evdev_read 休眠的进程，将数据返回给用户空间。调用流程如下感兴趣可以跟一下源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> input_event</span><br><span class="line">    --&gt; <span class="keyword">static</span> <span class="keyword">void</span> input_handle_event</span><br><span class="line">        --&gt; <span class="keyword">static</span> <span class="keyword">void</span> input_pass_values</span><br><span class="line">            --&gt; <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> input_to_handler</span><br><span class="line">                 --&gt; handler-&gt;event</span><br><span class="line">                     --&gt; <span class="keyword">static</span> <span class="keyword">void</span> evdev_event</span><br><span class="line">                             --&gt; <span class="keyword">static</span> <span class="keyword">void</span> evdev_events</span><br><span class="line">                                 --&gt; <span class="keyword">static</span> <span class="keyword">void</span> evdev_pass_values</span><br><span class="line">                                     --&gt; wake_up_interruptible(&amp;evdev-&gt;wait);</span><br></pre></td></tr></table></figure>
<p>内核已经将上报的接口封装好了，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向输入子系统报告产生的按键事件类型的事件code，以及事件的值value</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_key</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向输入子系统报告相对坐标事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_rel</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_REL, code, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向输入子系统报告绝对坐标事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_abs</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_ABS, code, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耳机插拔等事件上报</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_switch</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_SW, code, !!value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知子系统处理上报的事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多点触摸事件 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_mt_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_SYN, SYN_MT_REPORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 type 事件的事件值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_set_capability</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="五、应用程序处理-input-事件"><a href="#五、应用程序处理-input-事件" class="headerlink" title="五、应用程序处理 input 事件"></a>五、应用程序处理 input 事件</h2><p>参考问章 <a href="https://www.136.la/tech/show-60258.html">https://www.136.la/tech/show-60258.html</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开设备</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/input/event5&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, EVIOCGNAME(<span class="keyword">sizeof</span>(name) - <span class="number">1</span>), name); <span class="comment">//获取设备名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;find device name = %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        read(fd, &amp;ev, <span class="keyword">sizeof</span>(struct input_event));</span><br><span class="line">        <span class="comment">// 打印当前触发类型</span></span><br><span class="line">        <span class="comment">// printf(&quot;ev ==  %x \n&quot;,ev.type );</span></span><br><span class="line">        <span class="keyword">switch</span>(ev.type) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> EV_SYN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按键</span></span><br><span class="line">            <span class="keyword">case</span> EV_KEY:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;key down / up: %d \n&quot;</span>,ev.code );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 鼠标</span></span><br><span class="line">            <span class="keyword">case</span> EV_REL:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;mouse: &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ev.code == REL_X) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; x -- %d\n&quot;</span>, ev.value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.code == REL_Y) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; y -- %d\n&quot;</span>, ev.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 触摸屏</span></span><br><span class="line">            <span class="keyword">case</span> EV_ABS:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ts: &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(ev.code == ABS_MT_POSITION_X) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; x -- %d\n&quot;</span>, ev.value);</span><br><span class="line">                    x = ev.value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.code == ABS_MT_POSITION_Y) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; y -- %d\n&quot;</span>, ev.value);</span><br><span class="line">                    y = ev.value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.code == ABS_PRESSURE) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; pressure: %d\n&quot;</span>, ev.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>驱动</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动-电源管理</title>
    <url>/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;Linux 电源管理也由设备模型的一部分，但设备模型的篇幅已经够长了，而他本身内容也比较多，因此将其独立出来。学习平台 mt8789 内核版本 kernel-4.14</p>
<a id="more"></a>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*prepare)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*complete)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*freeze)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*thaw)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*poweroff)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*restore)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend_late)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*resume_early)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*freeze_late)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*thaw_early)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*poweroff_late)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*restore_early)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend_noirq)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*resume_noirq)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*freeze_noirq)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*thaw_noirq)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*poweroff_noirq)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*restore_noirq)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*runtime_suspend)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*runtime_resume)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*runtime_idle)(struct device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1、休眠"><a href="#1、休眠" class="headerlink" title="1、休眠"></a>1、休眠</h2><h2 id="2、唤醒"><a href="#2、唤醒" class="headerlink" title="2、唤醒"></a>2、唤醒</h2><h2 id="3、PM-notifier"><a href="#3、PM-notifier" class="headerlink" title="3、PM notifier"></a>3、PM notifier</h2><h2 id="4、wakeup-events"><a href="#4、wakeup-events" class="headerlink" title="4、wakeup events"></a>4、wakeup events</h2><h2 id="5、-wakelocks"><a href="#5、-wakelocks" class="headerlink" title="5、_wakelocks"></a>5、_wakelocks</h2><h2 id="6、-autosleep"><a href="#6、-autosleep" class="headerlink" title="6、_autosleep"></a>6、_autosleep</h2><h2 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h2>]]></content>
      <tags>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>linux设备模型</title>
    <url>/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;Linux设备模型的核心是使用<font color=red>Bus、Class、Device、Driver</font>四个核心数据结构，将大量的、不同功能的硬件设备（以及驱动该硬件设备的方法），以树状结构的形式，进行归纳、抽象，从而方便Kernel的统一管理。<font color = red><strong>学习平台mt8768，内核版本kernel-4.9</strong> </font></p>
<a id="more"></a>

<h1 id="一、kobject"><a href="#一、kobject" class="headerlink" title="一、kobject"></a>一、kobject</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 它是构建设备模型的根基，它使设备模型下能在 /sys/ 下以目录层次的形式呈现、 动态管理着所属对象的生命周期，以及提供了与用户空间进行信息交互的属性文件(attribute).</p>
<blockquote>
<p><strong>温馨提示</strong>目录文件是两个不同的概念，别搞混了。</p>
</blockquote>
<h2 id="1、相关数据结构"><a href="#1、相关数据结构" class="headerlink" title="1、相关数据结构"></a>1、相关数据结构</h2><h3 id="1-kobject"><a href="#1-kobject" class="headerlink" title="1) kobject"></a>1) kobject</h3><p>核心结构kobject，牢牢记住每一个注册到内核的kobject就是一个目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Kobject: include/linux/kobject.h line 60 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                  <span class="comment">//该Kobject的名称，同时也是sys/中的目录名称。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>         <span class="comment">//用于将该Kobject加入到Kset中的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span>       <span class="comment">//kobject以此形成层次目录结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>         *<span class="title">kset</span>;</span>         <span class="comment">//该kobject所属的Kset，可以为NULL，如果存在且没有指定parent，则会把Kset.kobj做为parent。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>        <span class="comment">//该Kobject属于的kobj_type，只有拥有ktye的kobj才能创建属性文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span> *<span class="title">sd</span>;</span>           <span class="comment">//该Kobject在sysfs中的表示</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>          <span class="title">kref</span>;</span>         <span class="comment">//用于原子操作的引用计数（在include/linux/kref.h中定义）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;  <span class="comment">//指示该Kobject是否已经初始化，在Kobject的Init，Put，Add等操作时进行异常校验。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;     <span class="comment">//指示该Kobject是否已经在sysfs中呈现，以便在自动注销时在从sysfs中移除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 记录是否已经向用户空间发送add uevent，如果有，且没有发送remove uevent，</span></span><br><span class="line"><span class="comment">     * 则在自动注销时，补发remove uevent，以便让用户空间正确处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>; <span class="comment">//如果该字段为1，则表示忽略所有上报的uevent事件。</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobj-type"><a href="#2-kobj-type" class="headerlink" title="2) kobj_type"></a>2) kobj_type</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用户空间怎么和内核进行交互，就是通过这个结构中包含的属性链表，指向的属性文件和属性操作函数进行交互。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/kobject.h, line 108 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">release</span>)(struct kobject *kobj);    <span class="comment">//当引用计数为0时自动调用，将包含该种类型kobject的数据结构的内存空间释放掉</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span>        <span class="comment">//kobject属性操作函数指针，上层在open属性文件时获取这个指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>         <span class="comment">//属性链表指针，指向attribute *数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-attribute"><a href="#3-attribute" class="headerlink" title="3) attribute"></a>3) attribute</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;牢牢记住，每一个注册到内核的 attribute 都是它所属的 kobj 目录下的一个属性文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">--include/linux/sysfs.h</span><br><span class="line"><span class="comment">/* FIXME</span></span><br><span class="line"><span class="comment"> * The *owner field is no longer used.</span></span><br><span class="line"><span class="comment"> * x86 tree has been cleaned up. The owner</span></span><br><span class="line"><span class="comment"> * attribute is still left for other arches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>    *name;        <span class="comment">/* 属性的名字,即sys目录中的属性文件名称 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>       <span class="comment">/* 属性的拥有者，已不再使用 */</span></span><br><span class="line">        <span class="keyword">mode_t</span> mode;                <span class="comment">/* 属性的读写权限，定义在include/linux/stat.h*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>读写权限</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/stat.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &quot;0&quot; 表示没有权限</span></span><br><span class="line"><span class="comment"> * &quot;1&quot; 表示可执行权限</span></span><br><span class="line"><span class="comment"> * &quot;2&quot; 表示可写权限</span></span><br><span class="line"><span class="comment"> * &quot;4&quot; 表示可读权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXU 00700 <span class="comment">//用户所有者拥有执行、写、读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUSR 00400 <span class="comment">//用户所有者拥有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUSR 00200 <span class="comment">//用户所有者拥有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUSR 00100 <span class="comment">//用户所有者拥有执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXG 00070 <span class="comment">//用户组拥有xxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRGRP 00040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWGRP 00020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXGRP 00010</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXO 00007 <span class="comment">//其他人拥有xxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IROTH 00004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWOTH 00002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXOTH 00001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/stat.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXUGO   (S_IRWXU|S_IRWXG|S_IRWXO) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IALLUGO   (S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUGO     (S_IRUSR|S_IRGRP|S_IROTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUGO     (S_IWUSR|S_IWGRP|S_IWOTH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUGO     (S_IXUSR|S_IXGRP|S_IXOTH)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：kobject是目录，attribute是文件。</strong></p>
</blockquote>
<h3 id="4-sysfs-ops"><a href="#4-sysfs-ops" class="headerlink" title="4) sysfs_ops"></a>4) sysfs_ops</h3><p>属性文件操作函数，当 cat 属性文件时，会调用 kobj-&gt;ktype-&gt;sysfs_ops-&gt;show，当 echo 属性文件时调用 kobj-&gt;ktype-&gt;sysfs_ops-&gt;store 函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">--include/linux/sysfs.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span></span> &#123;                                                                     <span class="comment">/* 对属性的操作函数 */</span></span><br><span class="line">        ssize_t (*show)(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *,<span class="built_in">char</span> *);                  <span class="comment">/* 读属性操作函数 */</span></span><br><span class="line">        ssize_t (*store)(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *,<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *,<span class="keyword">const</span> <span class="built_in">char</span> *, size_t);    <span class="comment">/* 写属性操作函数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、kobject-的创建与初始化"><a href="#2、kobject-的创建与初始化" class="headerlink" title="2、kobject 的创建与初始化"></a>2、kobject 的创建与初始化</h2><h3 id="1-kobject-create"><a href="#1-kobject-create" class="headerlink" title="1) kobject_create"></a>1) kobject_create</h3><p>该函数动态申请一个kobject结构，然后调用kobject_init对内部成员进行初始化,并且使用 dynamic_kobj_ktype 作为默认的 ktype</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">kernel<span class="number">-4.9</span>/lib/kobject.c</span><br><span class="line"></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line"></span><br><span class="line">    kobj = kzalloc(<span class="keyword">sizeof</span>(*kobj), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kobject_init(kobj, &amp;dynamic_kobj_ktype);</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-init"><a href="#2-kobject-init" class="headerlink" title="2) kobject_init"></a>2) kobject_init</h3><p>该函数初始化kobj的ktype以及内部成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_init</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *err_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj) &#123;   <span class="comment">/* 检测kobj是否为NULL */</span></span><br><span class="line">        err_str = <span class="string">&quot;invalid kobject pointer!&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ktype) &#123;  <span class="comment">/* 检测ktype是否为NULL */</span></span><br><span class="line">        err_str = <span class="string">&quot;must have a ktype to be initialized properly!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_initialized) &#123; <span class="comment">/* 判断kobject是否已经被初始化过，如果初始化过给出警告 */</span></span><br><span class="line">        <span class="comment">/* do not error out as sometimes we can recover */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;kobject (%p): tried to init an initialized &quot;</span></span><br><span class="line">               <span class="string">&quot;object, something is seriously wrong.\n&quot;</span>, kobj);</span><br><span class="line">        dump_stack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kobject_init_internal(kobj);   <span class="comment">/* 初始化kobject内部成员 */</span></span><br><span class="line">    kobj-&gt;ktype = ktype;           <span class="comment">/* 设置ktype */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">error:</span><br><span class="line"></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;kobject (%p): %s\n&quot;</span>, kobj, err_str);</span><br><span class="line">    dump_stack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kobject-init-internal"><a href="#3-kobject-init-internal" class="headerlink" title="3) kobject_init_internal"></a>3) kobject_init_internal</h3><p>该函数初始化引用计数，entry链表以及状态位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_init_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj)	                         <span class="comment">/* 参数检测,确保kobj不为空 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    kref_init(&amp;kobj-&gt;kref);              <span class="comment">/* 引用计数初始化，初始化为1 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;kobj-&gt;entry);        <span class="comment">/* 初始化kobject链表 */</span></span><br><span class="line">    kobj-&gt;state_in_sysfs = <span class="number">0</span>;            <span class="comment">/* 状态位设置:未导出到sys中 */</span></span><br><span class="line">    kobj-&gt;state_add_uevent_sent = <span class="number">0</span>;     <span class="comment">/* 状态位设置:未添加uevent */</span> </span><br><span class="line">    kobj-&gt;state_remove_uevent_sent = <span class="number">0</span>;  <span class="comment">/* 状态位设置:未移除uevent */</span></span><br><span class="line">    kobj-&gt;state_initialized = <span class="number">1</span>;         <span class="comment">/* 状态位设置:已完成初始化 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kobject的创建与初始化基本也就反复用这三个接口了。</p>
</blockquote>
<h2 id="3、kobject-的注册"><a href="#3、kobject-的注册" class="headerlink" title="3、kobject 的注册"></a>3、kobject 的注册</h2><h3 id="1-kobject-add"><a href="#1-kobject-add" class="headerlink" title="1) kobject_add"></a>1) kobject_add</h3><p>设置 kobj 的 name 以及 parent 并将 kobject 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_add</span><span class="params">(struct kobject *kobj, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list vargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name_vargs(kobj, fmt, vargs); <span class="comment">//设置kobject的name</span></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;kobject: can not set name properly!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    kobj-&gt;parent = parent;			<span class="comment">//设置kobject的parent</span></span><br><span class="line">    <span class="keyword">return</span> kobject_add_internal(kobj);		<span class="comment">//在sys/中添加kobject的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-add-internal"><a href="#2-kobject-add-internal" class="headerlink" title="2) kobject_add_internal"></a>2) kobject_add_internal</h3><p>将 kobject 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_add_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj-&gt;name || !kobj-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        WARN(<span class="number">1</span>, <span class="string">&quot;kobject: (%p): attempted to be registered with empty &quot;</span></span><br><span class="line">             <span class="string">&quot;name!\n&quot;</span>, kobj);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent = kobject_get(kobj-&gt;parent); <span class="comment">//如果父节点存在，则增加父节点引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* join kset if set, use it as parent if we do not already have one */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;kset) &#123; <span class="comment">//判断是否存在 kset</span></span><br><span class="line">        <span class="keyword">if</span> (!parent)</span><br><span class="line">            parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj); <span class="comment">//如果父节点不存在则使用Kset-&gt;kobj作为父节点，并增加引用计数</span></span><br><span class="line">        kobj_kset_kobj_kset_leavejoin(kobj);  <span class="comment">//将kobject中的entry链接进入kset中的list链表。</span></span><br><span class="line">        kobj-&gt;parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: parent: &#x27;%s&#x27;, set: &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">         kobject_name(kobj), kobj, __func__,</span><br><span class="line">         parent ? kobject_name(parent) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>,</span><br><span class="line">         kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : <span class="string">&quot;&lt;NULL&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    error = create_dir(kobj); <span class="comment">//使用kobj创建目录和属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123; <span class="comment">//如果创建失败减少引用计数</span></span><br><span class="line">        kobj_kset_leave(kobj);</span><br><span class="line">        kobject_put(parent);</span><br><span class="line">        kobj-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* be noisy on error issues */</span></span><br><span class="line">        <span class="keyword">if</span> (error == -EEXIST)</span><br><span class="line">            pr_err(<span class="string">&quot;%s failed for %s with -EEXIST, don&#x27;t try to register things with the same name in the same directory.\n&quot;</span>,</span><br><span class="line">                   __func__, kobject_name(kobj));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pr_err(<span class="string">&quot;%s failed for %s (error: %d parent: %s)\n&quot;</span>,</span><br><span class="line">                   __func__, kobject_name(kobj), error,</span><br><span class="line">                   parent ? kobject_name(parent) : <span class="string">&quot;&#x27;none&#x27;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        kobj-&gt;state_in_sysfs = <span class="number">1</span>; <span class="comment">//如果创建成功。将state_in_sysfs建为1。表示该object已经在sysfs中了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便理解我在这里附上 create_dir 、 sysfs_create_dir_ns 以及 populate_dir 的源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_dir</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); <span class="comment">//创建kobj目录</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    error = populate_dir(kobj); <span class="comment">//创建kobj默认属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        sysfs_remove_dir(kobj);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分代码***/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_dir_ns</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> <span class="keyword">void</span> *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">parent</span>, *<span class="title">kn</span>;</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(!kobj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;parent) <span class="comment">//判断parent是否存在，如果不存在则在sys/下创建目录</span></span><br><span class="line">        parent = kobj-&gt;parent-&gt;sd; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent = sysfs_root_kn; <span class="comment">// sys/ 所在目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!parent)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    kn = kernfs_create_dir_ns(parent, kobject_name(kobj),</span><br><span class="line">                  S_IRWXU | S_IRUGO | S_IXUGO, kobj, ns); <span class="comment">//创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kn)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(kn) == -EEXIST)</span><br><span class="line">            sysfs_warn_dup(parent, kobject_name(kobj));</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(kn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kobj-&gt;sd = kn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">populate_dir</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> =</span> get_ktype(kobj);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; t-&gt;default_attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; (attr = t-&gt;default_attrs[i]) != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">            error = sysfs_create_file(kobj, attr); <span class="comment">//遍历default_attrs，创建存在的属性文件</span></span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kobjcet的注册主要完成了下面三件事情</p>
<ol>
<li>判断父节点是否存在，如果存在增加父节点引用计数，判断是否存在 kset 如果存在则链接进 kset ，如果 kset 存在且父节点不存在则使用 Kset-&gt;kobj 作为父节点，增加 kset 点引用计数</li>
<li>调用 create_dir 为kobj创建目录和属性文件，在 create_dir 中调用 sysfs_create_dir_ns 为 kobject 创建目录，创建时会判断如果父节点为NULL则使用 sysfs_root_kn 作为父节点，即直接在 sys/ 目录下创建当前目录，在 create_dir 中调用 populate_dir 遍历属性文件链表创建默认属性文件</li>
<li>创建成功则设置 state_in_sysfs 为 1</li>
</ol>
</blockquote>
<p>内核也提供了一些组合API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就是将kobject_creat 函数和 kobject_add 函数组合在一起的函数，创建并注册一个 kobject 到内核。</span></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, struct kobject *parent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//就是将 kobject_init 函数和 kobject_add 函数组合在一起的函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_init_and_add</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype, struct kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>》上面的api这么多，可以根据需要灵活选择来创建并注册kobj，我也总结了一条很简单的原则：</p>
<blockquote>
<ul>
<li><font color=red><strong>如果你的 kobject 不需要嵌入到更大的数据结构则使用 kobject_create_and_add</strong></font></li>
<li><font color=red><strong>反之如果你的 kobject 需要嵌入到更大的数据结构则使用 kobject_init_and_add</strong></font></li>
</ul>
</blockquote>
<p>为什么这么选择呢这涉及到后文提到的对对象生命周期管理的内容，这里只需记住这两条规则就行了。</p>
<h3 id="3-编程实验-1"><a href="#3-编程实验-1" class="headerlink" title="3) 编程实验 1"></a>3) 编程实验 1</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;光说不练假把式，这个实验很简单，我们只需要再内核中创建一个名为 my_kobject 的目录，并不需要将 kobject 嵌入到其他数据结构因此选择使用 kobject_create_and_add</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>)<span class="comment">;</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct kobject *my_kobj<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> my_kobject_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    my_kobj = kobject_create_and_add(<span class="string">&quot;my_kobject&quot;</span>, <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void my_kobject_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    kobject_del(my_kobj)<span class="comment">;</span></span><br><span class="line">    kfree(my_kobj)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_kobject_init)<span class="comment">;</span></span><br><span class="line">module_exit(my_kobject_exit)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_kobject</span> <span class="title">power</span> //加载后生成 <span class="title">my_kobject</span> 目录</span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># rmmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span> //卸载后移除 <span class="title">my_kobject</span> 目录</span></span><br></pre></td></tr></table></figure>
<p>上面这种方式内核也用的挺多的，例如我们熟悉的 /sys/dev 、/sys/dev/char 、/sys/dev/block 等都是用这个方式创建的。</p>
<h3 id="4-编程实验-2"><a href="#4-编程实验-2" class="headerlink" title="4) 编程实验 2"></a>4) 编程实验 2</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在sys/下创建一个叫做 my_dir 的目录，这里我们将 kobject 嵌入到我们自己创建的结构中，于是选择 kobject_init_and_add 来创建目录。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_del(&amp;my_dirp-&gt;kobj);</span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">k85v1_64:<span class="regexp">/ # ls sys/</span></span><br><span class="line">block<span class="regexp">/     bus/</span>       dev<span class="regexp">/       firmware/</span>  kernel<span class="regexp">/    mtk_rgu/</span></span><br><span class="line">bootinfo<span class="regexp">/  class/</span>     devices<span class="regexp">/   fs/</span>        module<span class="regexp">/    power/</span></span><br><span class="line">k85v1_64:<span class="regexp">/ # ls sys/</span></span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu power</span><br><span class="line">k85v1_64:/ <span class="comment">#</span></span><br><span class="line">k85v1_64:<span class="regexp">/ # cd cache/</span></span><br><span class="line">k85v1_64:/cache <span class="comment"># insmod my_kobject.ko </span></span><br><span class="line">k85v1_64:<span class="regexp">/cache # ls /</span>sys/</span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu my_dir power <span class="regexp">//</span>加载后生成 my_dir 目录</span><br><span class="line">k85v1_64:/cache <span class="comment"># </span></span><br><span class="line"><span class="number">2</span>|k85v1_64:<span class="regexp">/cache # cd /</span>sys<span class="regexp">/my_dir/</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment"># ls</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment">#</span></span><br><span class="line">k85v1_64:<span class="regexp">/sys/my</span>_dir <span class="comment"># cd ..</span></span><br><span class="line">k85v1_64:/sys <span class="comment"># rmmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/sys <span class="comment"># ls</span></span><br><span class="line">block bootinfo bus class dev devices firmware fs kernel module mtk_rgu power <span class="regexp">//</span>卸载后移除 my_dir 目录</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;看起来这种方式更加复杂，但实际上我们的 bus、 device、 device_driver 等都是使用这个方式，使用这个方式的优点见后文 “对象生命周期管理”以及”用户空间与内核信息交互”。</p>
<h2 id="4、在-sys-下组织出目录层次"><a href="#4、在-sys-下组织出目录层次" class="headerlink" title="4、在 sys/ 下组织出目录层次"></a>4、在 sys/ 下组织出目录层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;object的核心功能之一，利用 kobject.parent 组织出文件的目录层次，前面 kobject 的注册已经分析的很清楚了这里就不再赘述了，内核还提供了链接文件的创建接口。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在kobj目录下创建指向target目录的软链接，name 为软链接文件名称</span></span><br><span class="line"><span class="built_in">int</span> __must_check sysfs<span class="constructor">_create_link(<span class="params">struct</span> <span class="params">kobject</span> <span class="operator">*</span><span class="params">kobj</span>, <span class="params">struct</span> <span class="params">kobject</span> <span class="operator">*</span><span class="params">target</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">name</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>编程实验</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个实验很简单，在/sys/目录下创建一个目录 father 然后在这个目录下创建两个子文件 son1 和 son2，再在 son1 下创建一个链接到 son2 的链接文件 link_to_son2。 只是单纯的展示层次目录关系，因此无需将kobject嵌入到更大的数据结构，采用 kobject_create_and_add 来注册</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">father</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">son1</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>* <span class="title">son2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_kobject_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在 /sys/ 目录下创建一个目录 father</span></span><br><span class="line">    father = kobject_create_and_add(<span class="string">&quot;father&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 father 目录下创建两个子文件 son1 和 son2</span></span><br><span class="line">    son1 = kobject_create_and_add(<span class="string">&quot;son1&quot;</span>, father);</span><br><span class="line">    son2 = kobject_create_and_add(<span class="string">&quot;son2&quot;</span>, father);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 son1 下创建一个链接到son2的链接文件 link_to_son2</span></span><br><span class="line">    sysfs_create_link(son1, son2, <span class="string">&quot;link_to_son2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_kobject_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_del(father);</span><br><span class="line">    kfree(father);</span><br><span class="line"></span><br><span class="line">    kobject_del(son1);</span><br><span class="line">    kfree(son1);</span><br><span class="line"></span><br><span class="line">    kobject_del(son2);</span><br><span class="line">    kfree(son2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_kobject_init);</span><br><span class="line">module_exit(my_kobject_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">k85v1_64</span>:/cache # insmod my_kobject.ko</span><br><span class="line"><span class="attribute">k85v1_64</span>:/cache #</span><br><span class="line"><span class="attribute">k85v1_64</span>:/cache # cd /sys/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys # ls</span><br><span class="line"><span class="attribute">block</span> bootinfo bus class dev devices father firmware fs kernel module mtk_rgu power  //创建出的 father</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys # cd father/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father # ls</span><br><span class="line"><span class="attribute">son1</span> son<span class="number">2</span> //创建出的 son<span class="number">1</span> son<span class="number">2</span></span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father # cd son<span class="number">1</span>/</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> # ls</span><br><span class="line"><span class="attribute">link_to_son2</span></span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> # ls -la</span><br><span class="line"><span class="attribute">total</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">drwxr</span>-xr-x <span class="number">2</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">40</span> .</span><br><span class="line"><span class="attribute">drwxr</span>-xr-x <span class="number">4</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">40</span> ..</span><br><span class="line"><span class="attribute">lrwxrwxrwx</span> <span class="number">1</span> root root <span class="number">0</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">11</span> <span class="number">06</span>:<span class="number">41</span> link_to_son<span class="number">2</span> -&gt; ../son<span class="number">2</span> //创建出的链接文件</span><br><span class="line"><span class="attribute">k85v1_64</span>:/sys/father/son<span class="number">1</span> #</span><br></pre></td></tr></table></figure>
<h2 id="5、kobj-对象生命周期管理"><a href="#5、kobj-对象生命周期管理" class="headerlink" title="5、kobj 对象生命周期管理"></a>5、kobj 对象生命周期管理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 还有一个非常强大的功能就是管理所嵌入的对象的生命周期，而引用计数 kref 则是它管理所嵌入对象生命周期的核心。对于kerf内核提供了两个下面函数来进行操作。</p>
<h3 id="1-kobject-get"><a href="#1-kobject-get" class="headerlink" title="1) kobject_get"></a>1) kobject_get</h3><p>增加kobj引用计数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_get - increment refcount for object.</span></span><br><span class="line"><span class="comment"> * @kobj: object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kobject *<span class="title">kobject_get</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">                   <span class="string">&quot;initialized, yet kobject_get() is being &quot;</span></span><br><span class="line">                   <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">        kref_get(&amp;kobj-&gt;kref); <span class="comment">//增加引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kobject-put"><a href="#2-kobject-put" class="headerlink" title="2) kobject_put"></a>2) kobject_put</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_put</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;kobject: &#x27;%s&#x27; (%p): is not &quot;</span></span><br><span class="line">                   <span class="string">&quot;initialized, yet kobject_put() is being &quot;</span></span><br><span class="line">                   <span class="string">&quot;called.\n&quot;</span>, kobject_name(kobj), kobj);</span><br><span class="line">        kref_put(&amp;kobj-&gt;kref, kobject_release); <span class="comment">//调用kref_put减少引用计数，同时传入回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 kref_put 减少引用计数，同时传入回调函数 kobject_release，该回调函数在引用计数为0时调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kref_put</span><span class="params">(struct kref *kref, <span class="keyword">void</span> (*release)(struct kref *kref))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        WARN_ON(release == <span class="literal">NULL</span>);</span><br><span class="line">        WARN_ON(release == (<span class="keyword">void</span> (*)(struct kref *))kfree);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (atomic_dec_and_test(&amp;kref-&gt;refcount)) &#123;   <span class="comment">/* 当引用计数为0时，调用 release 函数进行资源的释放  */</span></span><br><span class="line">                release(kref);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少引用计数，当 kref 为 0 时调用传入的 release 回调函数，即前面的 kobject_release 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_release</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        kobject_cleanup(container_of(kref, struct kobject, kref)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kobject_put 传入的回调函数，使用 container_of 函数获取到包含 kref 的 kobjec 结构地址，并传入 kobject_cleanup</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kobject_cleanup - free kobject resources.</span></span><br><span class="line"><span class="comment"> * @kobj: object to cleanup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_cleanup</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> =</span> get_ktype(kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = kobj-&gt;name;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s, parent %p\n&quot;</span>,</span><br><span class="line">         kobject_name(kobj), kobj, __func__, kobj-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; !t-&gt;release) <span class="comment">// 判断 release 函数是否存在</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): does not have a release() &quot;</span></span><br><span class="line">             <span class="string">&quot;function, it is broken and must be fixed.\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send &quot;remove&quot; if the caller did not do it but sent &quot;add&quot; */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_add_uevent_sent &amp;&amp; !kobj-&gt;state_remove_uevent_sent) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): auto cleanup &#x27;remove&#x27; event\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        kobject_uevent(kobj, KOBJ_REMOVE); <span class="comment">//发送 uevent 事件 KOBJ_REMOVE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove from sysfs if the caller did not do it */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;state_in_sysfs) &#123; <span class="comment">// 如果在sys中存在kobj则调用kobject_del删除kobj</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): auto cleanup kobject_del\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        kobject_del(kobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &amp;&amp; t-&gt;release) &#123; <span class="comment">//如果release存在则调用release函数</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): calling ktype release\n&quot;</span>,</span><br><span class="line">             kobject_name(kobj), kobj);</span><br><span class="line">        t-&gt;release(kobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free name if we allocated it */</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123; <span class="comment">// 释放name空间</span></span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27;: free name\n&quot;</span>, name);</span><br><span class="line">        kfree_const(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;判断 kobj 的 release 函数是否存在，如果在 sys 中存在 kobj 则调用 kobject_del 删除 kobj, 如果 release 存在则调用 release 函数，该函数需要自己实现，如果是用  kobject_create 创建的 kobj，则会使用默认 dynamic_kobj_ktype 中的 release。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_del - unlink kobject from hierarchy.</span></span><br><span class="line"><span class="comment"> * @kobj: object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_del</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    sd = kobj-&gt;sd;</span><br><span class="line">    sysfs_remove_dir(kobj); <span class="comment">//删除sys目录相关文件</span></span><br><span class="line">    sysfs_put(sd);</span><br><span class="line"></span><br><span class="line">    kobj-&gt;state_in_sysfs = <span class="number">0</span>;</span><br><span class="line">    kobj_kset_leave(kobj);  	<span class="comment">//删除所属的kset链表中的kobj成员，减少该kset引用计数 </span></span><br><span class="line">    kobject_put(kobj-&gt;parent);  <span class="comment">//减少parent计数</span></span><br><span class="line">    kobj-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除sys目录相关文件，减少parent引用计数，并调用 kobj_kset_leave函数从 kset list 中移除这个kobject</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove the kobject from its kset&#x27;s list */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobj_kset_leave</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj-&gt;kset)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">    list_del_init(&amp;kobj-&gt;entry);</span><br><span class="line">    spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">    kset_put(kobj-&gt;kset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到 kobject_put 的实现比较复杂，但总的来说它也就完成了下面几件事情</p>
<ol>
<li>减少 kobject 引用计数，当 kobject 引用计数为 0 时调用 kobject-&gt;ktype-&gt;release 函数。</li>
<li>向用户空间发送 uevent 事件 KOBJ_REMOVE</li>
<li>调用 kobject_del 删除 sys 目录相关文件，从属于的kset链表中删除该 kobj 成员，减少 kset 引用计数，减少 parent 的引用计数(这里分别减少了parent的和所属的kset的引用计数) </li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中我们需要实现的也就是这个回调函数 kobject-&gt;ktype-&gt;release ，但实际上内核提供的设备模型已经都实现好了，例如 bus 总线</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bus_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span> =</span> to_subsys_private(kobj);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> priv-&gt;bus;</span><br><span class="line"></span><br><span class="line">    kfree(priv);</span><br><span class="line">    bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">bus_ktype</span> =</span> &#123;</span><br><span class="line">    .sysfs_ops  = &amp;bus_sysfs_ops,</span><br><span class="line">    .release    = bus_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其他的device，device_driver，等凡是内核提供的结构基本内核都帮我们设计好了它的relase函数</p>
<h3 id="3-优化-my-dir"><a href="#3-优化-my-dir" class="headerlink" title="3) 优化 my_dir"></a>3) 优化 my_dir</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;有了上面知识了之后我们也可以用其来优化我们前面创建的 my_dir, 给我们的 my_dir 增加自动释放自身数据结构的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit); </span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_dir</span> <span class="title">power</span> //这里创建出 <span class="title">my_dir</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache <span class="meta"># rmmod my_kobject.ko</span></span><br><span class="line">于此同时内核打印出下面<span class="built_in">log</span></span><br><span class="line">[   <span class="number">52.897412</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">2526</span>:rmmod] my dir release</span><br><span class="line"></span><br><span class="line">k85v1_64:/cache <span class="meta"># ls /sys/</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">power</span> //<span class="title">mydir</span> 被移除</span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/cache # </span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里用了一个非常巧妙的方式实现了，利用 kobject 释放其所嵌入的更大的数据结构的功能，从而实现对 my_dir 生命周期的管理，于是可以得到下面这个结论： <strong><font color = red>凡是需要做对象生命周期管理的对象，都可以通过内嵌kobject来实现需求</font></strong> </p>
<p>该结论来自窝窝科技的文章 <a href="http://www.wowotech.net/device_model/421.html">http://www.wowotech.net/device_model/421.html</a></p>
<h2 id="6、用户空间与内核信息交互"><a href="#6、用户空间与内核信息交互" class="headerlink" title="6、用户空间与内核信息交互"></a>6、用户空间与内核信息交互</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;kobject 的另一个核心功能就是能实现用户空间与内核空间的信息交互，我们知道每一个注册的 kobject 都会在 /sys 中以目录的形式呈现，也就是 bus 等数据结构可以利用嵌入 kobject 可以使它显示在 /sys 中。内核为我们提供了快速修改获取内核中 bus 相关的信息(这些信息可以是变量，字符串等)的方法”属性文件(attribute)”。属性文件就是内核空间和用户空间交互信息的一种方法。在Linux内核中，attribute分为普通的attribute和二进制attribute，这里只记录普通的，二进制的没研究，后面有机会研究了再补充(希望渺茫)</p>
<h3 id="1-属性文件调用逻辑"><a href="#1-属性文件调用逻辑" class="headerlink" title="1) 属性文件调用逻辑"></a>1) 属性文件调用逻辑</h3><p>在 fs/sysfs/file.c 文件下查看相关的逻辑代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct sysfs_ops *<span class="title">sysfs_file_ops</span><span class="params">(struct kernfs_node *kn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> kn-&gt;parent-&gt;priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kn-&gt;flags &amp; KERNFS_LOCKDEP)</span><br><span class="line">        lockdep_assert_held(kn);</span><br><span class="line">    <span class="keyword">return</span> kobj-&gt;ktype ? kobj-&gt;ktype-&gt;sysfs_ops : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kernfs read callback for regular sysfs files with pre-alloc */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">sysfs_kf_read</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">	...</span><br><span class="line">    len = ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">min_t</span>(<span class="keyword">ssize_t</span>, count, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">sysfs_kf_write</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!count)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ops-&gt;store(kobj, of-&gt;kn-&gt;priv, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;代码很简单就不注释了，看起来处理过程很简单在 cat/echo 属性文件时(读/写属性文件写数据时)，先调用 sysfs_file_ops 获取到 kobj-&gt;ktype-&gt;sysfs_ops 指针，在调用对应内核的 show/store 函数。从这里可以看出对于用户空间来讲，只负责把数据丢给内核的store以及从内核的show获取数据，至于store的数据用来做什么和show获取到什么数据则由内核决定。这里还可以得出结论：<font color=red>如果从属的 kobject（就是 attribute 文件所在的目录）没有 ktype，或者没有 ktype-&gt;sysfs_ops 指针，是不允许它注册任何 attribute 的</font></p>
<h3 id="2-属性文件的创建以及删除"><a href="#2-属性文件的创建以及删除" class="headerlink" title="2) 属性文件的创建以及删除"></a>2) 属性文件的创建以及删除</h3><p>内核也提供了创建属性文件的api</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include/linux/sysfs.h</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_file</span><span class="params">(struct kobject *kobj, struct attribute *attr)</span></span>; <span class="comment">//在传入的kobj下创建attr属性文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sysfs_remove_file</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute *attr)</span> <span class="comment">//在传入的kobj下移除attr属性文件</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_files</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute **ptr)</span> <span class="comment">//在kobj下创建传入的prt指向的一组属性文件</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sysfs_remove_files</span><span class="params">(struct kobject *kobj, <span class="keyword">const</span> struct attribute **attr)</span></span>;<span class="comment">//在kobj下移除传入的prt指向的一组属性文件</span></span><br></pre></td></tr></table></figure>
<h3 id="3-在-my-dir-下创建属性文件"><a href="#3-在-my-dir-下创建属性文件" class="headerlink" title="3) 在 my_dir 下创建属性文件"></a>3) 在 my_dir 下创建属性文件</h3><p>动手实践一下，在 my_dir 下创建两个属性文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建一个 struct my_dir, 并初始化 name 后返回该指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_create</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读属性操作函数, cat 属性文件时调用这个函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_show</span><span class="params">(struct kobject *kobj, struct attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir show  attr-&gt;name : %s\n&quot;</span>, attr-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s\n&quot;</span>, attr-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>((<span class="keyword">char</span>*)attr-&gt;name) +<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写属性操作文件, echo 属性文件时调用这个函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_store</span><span class="params">(struct kobject *kobj,struct attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my dir store : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有 kobj_type 同时还要存在 my_sysfs_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">my_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show  = my_dir_show,</span><br><span class="line">    .store = my_dir_store,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要创建属性文件首先要有 kobj_type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">    .sysfs_ops = &amp;my_sysfs_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个注册的 attribute 结构都是一个属性文件，这里创建两个属性文件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">my_dir_attr1</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_dir_attr1&quot;</span>,</span><br><span class="line">    .mode = S_IRWXUGO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">my_dir_attr2</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_dir_attr2&quot;</span>,</span><br><span class="line">    .mode = S_IRWXUGO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    my_dirp = my_dir_create(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr1 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr2 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br></pre></td></tr></table></figure>
<p>验证结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k85v1_64:/cache <span class="meta"># insmod my_kobject.ko <span class="comment">//加载模块</span></span></span><br><span class="line">k85v1_64:/cache #</span><br><span class="line">k85v1_64:/cache <span class="meta"># cd /sys/</span></span><br><span class="line">k85v1_64:/sys <span class="meta"># ls</span></span><br><span class="line">block bootinfo bus <span class="class"><span class="keyword">class</span> <span class="title">dev</span> <span class="title">devices</span> <span class="title">firmware</span> <span class="title">fs</span> <span class="title">kernel</span> <span class="title">module</span> <span class="title">mtk_rgu</span> <span class="title">my_dir</span> <span class="title">power</span> //查看生成了 <span class="title">my_dir</span></span></span><br><span class="line"><span class="class"><span class="title">k85v1_64</span>:</span>/sys <span class="meta"># cd my_dir/  <span class="comment">//进入 my_dir</span></span></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># ls</span></span><br><span class="line">my_dir_attr1 my_dir_attr2   <span class="comment">//查看生成了  my_dir_attr1 my_dir_attr2</span></span><br><span class="line">k85v1_64:/sys/my_dir #</span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># echo 123 &gt; my_dir_attr1 <span class="comment">//写入123</span></span></span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[  <span class="number">848.043148</span>] &lt;<span class="number">0</span>&gt;.(<span class="number">0</span>)[<span class="number">5617</span>:sh]my dir store : <span class="number">123</span></span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># cat my_dir_attr1  <span class="comment">//读取数据</span></span></span><br><span class="line">my_dir_attr1</span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1002.452204</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">8065</span>:cat]my dir show  attr-&gt;name : my_dir_attr1</span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir #</span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># echo 222 &gt; my_dir_attr2</span></span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1028.696923</span>] &lt;<span class="number">1</span>&gt;.(<span class="number">1</span>)[<span class="number">5617</span>:sh]my dir store : <span class="number">222</span></span><br><span class="line"></span><br><span class="line">k85v1_64:/sys/my_dir <span class="meta"># cat my_dir_attr2</span></span><br><span class="line">my_dir_attr2</span><br><span class="line"><span class="comment">//于此同时内核打印下面信息</span></span><br><span class="line">[ <span class="number">1033.116307</span>] &lt;<span class="number">7</span>&gt;.(<span class="number">7</span>)[<span class="number">8397</span>:cat]my dir show  attr-&gt;name : my_dir_attr2</span><br></pre></td></tr></table></figure>
<h3 id="4-优化属性文件操作"><a href="#4-优化属性文件操作" class="headerlink" title="4) 优化属性文件操作"></a>4) 优化属性文件操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子我们虽然创建了属性文件，也能操作属性文件，但是两个属性文件最终都是调用的同一个 show/store 函数，即这种方式的属性文件拥有共用的属性操作函数。而这样明显属性文件就失去了它的独立性。 </p>
<blockquote>
<p>怎么实现属性文件自己的 show/store ？<br>我们可以将 attribute 嵌入到更大的数据结构中，该数据结构包含真正的 show/store 函数然后使用 my_dir_type 中的 show/store 函数作为中转函数，利用 container_of 调用属性文件真正的 show/store 函数</p>
</blockquote>
<p>于是我们调整代码架构将通用的部分提取出来作为 my_kobject_core.c 这部分代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_kobject_core.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当引用计数为 0 时会自动调用这个函数来释放包含 kobject 的更大的数据结构 struct my_dir</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;my dir release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读属性文件操作函数中间层 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_show</span><span class="params">(struct kobject *kobj, struct attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> *<span class="title">my_attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">    my_attr = container_of(attr, struct my_attribute, attr);</span><br><span class="line">    <span class="keyword">if</span> (my_attr-&gt;show)</span><br><span class="line">        ret = my_attr-&gt;show(kobj, my_attr, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写属性文件操作函数中间层 */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_store</span><span class="params">(struct kobject *kobj,struct attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> *<span class="title">my_attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">    my_attr = container_of(attr, struct my_attribute, attr);</span><br><span class="line">    <span class="keyword">if</span> (my_attr-&gt;store)</span><br><span class="line">        ret = my_attr-&gt;store(kobj, my_attr, buf, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有 kobj_type 同时还要存在 my_sysfs_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">my_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show  = my_dir_show,</span><br><span class="line">    .store = my_dir_store,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要创建属性文件首先要有 kobj_type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">my_dir_type</span> =</span> &#123;</span><br><span class="line">    .release = my_dir_release,</span><br><span class="line">    .sysfs_ops = &amp;my_sysfs_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 /sys/ 下创建一个名为 name dir */</span></span><br><span class="line"><span class="function">struct my_dir* <span class="title">my_dir_regiseter</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    my_dirp = kzalloc(<span class="keyword">sizeof</span>(*my_dirp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!my_dirp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;name = name;</span><br><span class="line"></span><br><span class="line">    kobject_init_and_add(&amp;my_dirp-&gt;kobj, &amp;my_dir_type, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, my_dirp-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_dirp;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(my_dir_regiseter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 移除注册的 my_dir */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_dir_unregiseter</span><span class="params">(struct my_dir* my_dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(my_dirp)</span><br><span class="line">        kobject_put(&amp;my_dirp-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(my_dir_unregiseter);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们将公共的部分放在头文件my_kobject_core.h中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _KOBJECT_CORE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _KOBJECT_CORE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span>  date;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span> <span class="comment">//将 attribute 嵌入到更大的数据结构中</span></span><br><span class="line">    <span class="comment">//真正的 show/store函数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> struct my_dir* <span class="title">my_dir_regiseter</span><span class="params">(<span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">my_dir_unregiseter</span><span class="params">(struct my_dir* my_dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在我们想要创建目录的时候就调用 my_dir_regiseter 来创建 my_dir，想要创建属性文件的时候调用 sysfs_create_file 来创建。 于是在我们真正在 my_kobject.c 中创建 my_dir 以及其属性文件如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_kobject_core.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr1 自己的 show 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_attr1_show</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s : %d\n&quot;</span>, attr-&gt;attr.name, my_dirp-&gt;date);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr1 自己的 store 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span>  <span class="title">my_dir_attr1_store</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于输入的是字符串这里做一个简单的转换，并不严谨仅用于展示功能</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; buf[i] &lt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            tmp = <span class="number">10</span> *tmp + (buf[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;date = tmp;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s store :  my_dirp-&gt;date = %d, buf = %s\n&quot;</span>,attr-&gt;attr.name, my_dirp-&gt;date, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr2 自己的 show 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">my_dir_attr2_show</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s : %d\n&quot;</span>, attr-&gt;attr.name, my_dirp-&gt;date);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于 my_dir_attr2 自己的 store 函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span>  <span class="title">my_dir_attr2_store</span><span class="params">(struct kobject *kobj, struct my_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_dir</span>* <span class="title">my_dirp</span> =</span> container_of(kobj, struct my_dir, kobj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于输入的是字符串这里做一个简单的转换，并不严谨仅用于展示功能</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; buf[i] &lt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            tmp = <span class="number">10</span> *tmp + (buf[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_dirp-&gt;date = tmp;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s store :  my_dirp-&gt;date = %d, buf = %s\n&quot;</span>,attr-&gt;attr.name, my_dirp-&gt;date, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里创建两个属性文件 my_dir_attr1、my_dir_attr2 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> <span class="title">my_dir_attr1</span> =</span> &#123;</span><br><span class="line">    .attr =&#123;</span><br><span class="line">        .name = <span class="string">&quot;my_dir_attr1&quot;</span>,</span><br><span class="line">        .mode = S_IRWXUGO,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    .show  = my_dir_attr1_show,</span><br><span class="line">    .store = my_dir_attr1_store,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_attribute</span> <span class="title">my_dir_attr2</span> =</span> &#123;</span><br><span class="line">    .attr =&#123;</span><br><span class="line">        .name = <span class="string">&quot;my_dir_attr2&quot;</span>,</span><br><span class="line">        .mode = S_IRWXUGO,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    .show  = my_dir_attr2_show,</span><br><span class="line">    .store = my_dir_attr2_store,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_dir_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_dirp = my_dir_regiseter(<span class="string">&quot;my_dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr1 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr1.attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 my_dir_attr2 属性文件</span></span><br><span class="line">    sysfs_create_file(&amp;my_dirp-&gt;kobj, &amp;my_dir_attr2.attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_dir_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_dir_unregiseter(my_dirp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_dir_init);</span><br><span class="line">module_exit(my_dir_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>验证结果：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># insmod my_kobject_core.ko</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># insmod my_kobject.ko</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span>/cache <span class="meta"># cd /sys/my_dir/</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># ls</span></span><br><span class="line">my_dir_attr1 my_dir_attr2</span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># echo 11 &gt; my_dir_attr1</span></span><br><span class="line"><span class="comment">//同时内核打印出</span></span><br><span class="line">[ <span class="number">5223.566440</span>] <span class="params">&lt;<span class="number">2</span>&gt;</span>.(<span class="number">2</span>)[<span class="number">23263</span>:sh]my_dir_attr1 store :  my_dirp-&gt;date = <span class="number">11</span>, buf = <span class="number">11</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># cat my_dir_attr1</span></span><br><span class="line">my_dir_attr1 : <span class="number">11</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># echo 22 &gt; my_dir_attr2</span></span><br><span class="line"><span class="comment">//同时内核打印出</span></span><br><span class="line">[ <span class="number">5248.493173</span>] <span class="params">&lt;<span class="number">3</span>&gt;</span>.(<span class="number">3</span>)[<span class="number">23263</span>:sh]my_dir_attr2 store :  my_dirp-&gt;date = <span class="number">22</span>, buf = <span class="number">22</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta"># cat my_dir_attr2</span></span><br><span class="line">my_dir_attr2 : <span class="number">22</span></span><br><span class="line"><span class="symbol">k85v1_64:</span><span class="meta-keyword">/sys/</span>my_dir <span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面的逻辑实现比前面的代码要复杂一点点，可以花点时间看一下，这个方式的牛逼之处在于通过 kobject 我们将我们自己创建的数据结构 struct my_dir 开放到用户空间，以目录的形式呈现出来，同时通过属性文件用户空间能够获取和修改 my_dir.date 这个属于my_dir的成员变量。内核的bus、device、device_driver 等设备模型不过是在这个基础之上增加了一些其他功能，如设备和驱动的匹配等。</p>
<blockquote>
<p><strong><font color=red>错误纠正</font></strong><br><strong><font color=red>前面的代码里面有一处错误，MODULE_AUTHOR(“baron”); MODULE_LICENSE(“GPL”); 这两句代码一定要放在代码最后！！！ ，因为前面没有用 EXPORT_SYMBOL_GPL 模块导出符所以不会有什么影响。</font></strong></p>
</blockquote>
<h1 id="二、kset"><a href="#二、kset" class="headerlink" title="二、kset"></a>二、kset</h1><p>kset的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/kobject.h, line 159 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 该Kset下所有的Kobject都被链接进入该节点               </span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>  <span class="comment">// kset也是kobj的一种，因为c语言无法向面向对象一样继承，因此只能使用这种方式。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 该kset的uevent操作函数集。</span></span><br><span class="line"><span class="comment">    * 当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，</span></span><br><span class="line"><span class="comment">    * 添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。</span></span><br><span class="line"><span class="comment">    * 因此，如果一个kobject不属于任何kset时，是不允许发送uevent的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;因为 kset 本身包含 kobject 结构，因此拥有上述 kobject 的所有特性，而 kset 除了上述的 kobject 的所有功能之外，同时也和它有所区别。要想知道区别是什么就得知道，它多出来的数据结构是干啥的。可以看出主要多出了两个数据结构 list 和 kset_uevent_ops，在前面的 kobject_add 分析中可以知道,只要是 kobject 属于某个 kset 那么都会被链接到所属的 kset 中的 list 链表。 <strong>也就是 kset 具有管理 kobject 的功能</strong>，举个栗子，例如： 当 kernel 关机时， 会在 device_shutdown  中利用 devices_kset-&gt;list 找到该链表上的所有设备，并做相应的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_shutdown</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>, *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过 kset-&gt;list 链表找到链表上的所有设备</span></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;devices_kset-&gt;<span class="built_in">list</span>)) &#123;</span><br><span class="line">        dev = list_entry(devices_kset-&gt;<span class="built_in">list</span>.prev, struct device,  kobj.entry);</span><br><span class="line">	</span><br><span class="line">		...... <span class="comment">//对所有的设备做相关操作</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;devices_kset-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;除此之外，我们所熟知的热插拔机制的功能也是由 kset 提供的，热插拔指的是当一个设备加入系统，内核如何通知用户空间。感兴趣可以看看这篇文章：<a href="http://bbs.chinaunix.net/thread-3678367-1-1.html">http://bbs.chinaunix.net/thread-3678367-1-1.html</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;热插拔大致的可以分为两个部分组成，内核部分和用户空间部分，而 kset则负责将事件发送到用户空间，而发送的方式则是 uevent。 大致的流程如下</p>
<blockquote>
<p>外设接入设备，设备产生中断<br>内核响应中断，调用 device_add 添加新设备<br>在device_add中会调用 kobject_uevent 将事件通知给用户空间</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于热插拔的内容相对复杂可以单独成文，而且也不影响对设备模型的理解，因此这里只提一下它的功能，关于热插拔更加详细的内容后面认真学习之后再整理出一篇文章。</p>
<h2 id="1、-kset的创建与注册"><a href="#1、-kset的创建与注册" class="headerlink" title="1、 kset的创建与注册"></a>1、 kset的创建与注册</h2><h3 id="1-kset-create"><a href="#1-kset-create" class="headerlink" title="1) kset_create"></a>1) kset_create</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;动态获取一个 kset 内存空间,初始化 uevent_ops ,初始化 parent_kobj ,<strong>初始化一个内核默认的 kset_ktype</strong> ,初始化 kset 中的 kset 为NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kset *<span class="title">kset_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct kset_uevent_ops *uevent_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    kset = kzalloc(<span class="keyword">sizeof</span>(*kset), GFP_KERNEL); <span class="comment">//动态获得一个 kset 内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (!kset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name(&amp;kset-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name); <span class="comment">//初始化 name</span></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        kfree(kset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kset-&gt;uevent_ops = uevent_ops; 	<span class="comment">//初始化 uenent_ops</span></span><br><span class="line">    kset-&gt;kobj.parent = parent_kobj;    <span class="comment">//初始化 parent_kobj</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The kobject of this kset will have a type of kset_ktype and belong to</span></span><br><span class="line"><span class="comment">     * no kset itself.  That way we can properly free it when it is</span></span><br><span class="line"><span class="comment">     * finished being used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    kset-&gt;kobj.ktype = &amp;kset_ktype;  <span class="comment">//初始化该 kset 的 ktype</span></span><br><span class="line">    kset-&gt;kobj.kset = <span class="literal">NULL</span>;	     <span class="comment">//kset 的 kset 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kset-init"><a href="#2-kset-init" class="headerlink" title="2) kset_init"></a>2) kset_init</h3><p>初始化kset的kobj成员，初始化list链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_init - initialize a kset for use</span></span><br><span class="line"><span class="comment"> * @k: kset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_init</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_init_internal(&amp;k-&gt;kobj); <span class="comment">//初始化kobj成员</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;k-&gt;<span class="built_in">list</span>); <span class="comment">//初始化list链表</span></span><br><span class="line">    spin_lock_init(&amp;k-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kset-register"><a href="#3-kset-register" class="headerlink" title="3) kset_register"></a>3) kset_register</h3><p>将 kset 注册进入内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_register - initialize and add a kset.</span></span><br><span class="line"><span class="comment"> * @k: kset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_register</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    kset_init(k); <span class="comment">//调用kset_init初始化kobj成员，初始化list链表</span></span><br><span class="line">    err = kobject_add_internal(&amp;k-&gt;kobj); <span class="comment">//注册kobj即生成kset对应的目录</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD); <span class="comment">//发送uevent事件，KOBJ_ADD</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-kset-create-and-add"><a href="#3-kset-create-and-add" class="headerlink" title="3) kset_create_and_add"></a>3) kset_create_and_add</h3><p>动态创建一个kset结构，并将其注册,其实就是 kset_create 和 kset_register 的组合</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct kset *<span class="title">kset_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> struct kset_uevent_ops *uevent_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    kset = kset_create(name, uevent_ops, parent_kobj); <span class="comment">//动态创建 kset</span></span><br><span class="line">    <span class="keyword">if</span> (!kset)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    error = kset_register(kset); <span class="comment">//注册kset</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(kset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kset 的创建与注册的函数的选择和前面的kobject一样:</p>
<blockquote>
<p><font color=red>当 kset 需要嵌入到更大的数据结构时使用 kset_register</font><br><font color=red>当 kset 不需嵌入到更大的数据结构时使用 kset_create_and_add</font></p>
</blockquote>
<h2 id="2、卸载kset"><a href="#2、卸载kset" class="headerlink" title="2、卸载kset"></a>2、卸载kset</h2><h3 id="1-kset-unregister"><a href="#1-kset-unregister" class="headerlink" title="1) kset_unregister"></a>1) kset_unregister</h3><p>从卸载一个keset</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kset_unregister - remove a kset.</span></span><br><span class="line"><span class="comment"> * @k: kset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    kobject_del(&amp;k-&gt;kobj);</span><br><span class="line">    kobject_put(&amp;k-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-kset-put"><a href="#2-kset-put" class="headerlink" title="2) kset_put"></a>2) kset_put</h3><p>减少kset的kobj成员引用计数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kset_put</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_put(&amp;k-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、bus总线"><a href="#三、bus总线" class="headerlink" title="三、bus总线"></a>三、bus总线</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux 认为<font color=red>总线是CPU和一个或多个设备之间信息交互的通道</font>。就设备模型而言，所有设备都是通过总线连接的，<strong>这样的总线有两类</strong>：</p>
<blockquote>
<ul>
<li>第一类是i2c、spi、usb 等这类总线，这类总线有实际的物理总线，它本身就有总线这个概念，我们直接根据功能将其抽象出来成一个个单独的总线。</li>
<li>第二类就是虚拟总线，如i2c控制器、GPIO控制器、UART控制器等，cpu 直接通过寄存器或地址与之进行通信。但是呢我们又想将他们统一到设备模型，因此 platform 这个虚拟总线就诞生了。</li>
</ul>
</blockquote>
<h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-bus-type"><a href="#1-bus-type" class="headerlink" title="1) bus_type"></a>1) bus_type</h3><p>每一个 bus_type 都代表一个 bus</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;		<span class="comment">//总线类型的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *dev_name;		<span class="comment">//当 dev-&gt;init_name 为空时，使用&quot;bus-&gt;dev_name+device ID”的形式，为的设备生成一个名称。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   *<span class="title">dev_root</span>;</span> 		<span class="comment">//bus总线上的设备默认的根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span> <span class="comment">//总线所属设备的默认的属性文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span>	<span class="comment">//默认总线属性文件(一组)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span>	<span class="comment">//该总线下的所有设备的默认属性文件(一组)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span>	<span class="comment">//该总线下的驱动的默认属性文件(一组)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);	<span class="comment">//匹配函数，当任何属于该 bus 的 device 和 device_driver 注册到bus时，调用该接口</span></span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);	<span class="comment">//用于 bus 的 device 对环境变量的添加</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);	<span class="comment">//match成功之后调用这个函数</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);	<span class="comment">//和probe相反</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span> <span class="comment">//描述 bus 在 /sys 中的层次结构，也管理着该总线上的dev和driver以及总线的一些属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-subsys-private"><a href="#2-subsys-private" class="headerlink" title="2) subsys_private"></a>2) subsys_private</h3><p>这个结构被用在两个地方 class 和 bus，在不同的位置有不同的含义，当它出现在 bus下用它描述 bus 在 /sys 中的层次结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span>	 	      <span class="comment">// 该bus 在sysfs中的目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span>	  <span class="comment">// bus目录下的device子目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span>  <span class="comment">// 保存该bus下所有的interface</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span>	<span class="comment">//bus目录下的driver子目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span>	<span class="comment">//bus的设备链表,该bus下的所有device挂接在该节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span>	<span class="comment">//bus的驱动链表,该bus下的所有drivers挂接在该节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;	<span class="comment">//用于控制该bus下的drivers或者device是否自动probe</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span>    <span class="comment">//保存该subsys_private结构所属bus</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span>	<span class="comment">// 在 device_add 中使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">// 当用在class时，保存该subsys_private结构所属的class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、bus-根目录的初始化"><a href="#2、bus-根目录的初始化" class="headerlink" title="2、bus 根目录的初始化"></a>2、bus 根目录的初始化</h2><p>buses_init 在 driver_init 中被调用，用于初始化 bus 的根目录，以后所有的 bus 总线均为该目录的子目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">buses_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_kset = kset_create_and_add(<span class="string">&quot;bus&quot;</span>, &amp;bus_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bus_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    system_kset = kset_create_and_add(<span class="string">&quot;system&quot;</span>, <span class="literal">NULL</span>, &amp;devices_kset-&gt;kobj);</span><br><span class="line">    <span class="keyword">if</span> (!system_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buses_init 会创建以下目录</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">sys/bus</span><br><span class="line">sys/<span class="keyword">system</span></span><br></pre></td></tr></table></figure>
<h2 id="3、bus-总线的注册"><a href="#3、bus-总线的注册" class="headerlink" title="3、bus 总线的注册"></a>3、bus 总线的注册</h2><p>该函数向内核注册一个 bus 总线</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//动态创建一个subsys_private结构priv</span></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    priv-&gt;bus = bus; 	<span class="comment">//初始化priv-&gt;bus</span></span><br><span class="line">    bus-&gt;p = priv;	<span class="comment">//初始化bus-&gt;p</span></span><br><span class="line"></span><br><span class="line">    BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 priv-&gt;subsys.kobj-&gt;name = bus-&gt;name</span></span><br><span class="line">    retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">	</span><br><span class="line">    priv-&gt;subsys.kobj.kset = bus_kset; <span class="comment">//初始化kset</span></span><br><span class="line">    priv-&gt;subsys.kobj.ktype = &amp;bus_ktype; <span class="comment">//初始化ktype </span></span><br><span class="line">    priv-&gt;drivers_autoprobe = <span class="number">1</span>; <span class="comment">//设置默认可以自动匹配probe</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里我们发现并没有设置parent，因此使用bus_kset作为parent，创建sys/bus/bus-&gt;name文件夹</span></span><br><span class="line">    retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在总线所在目录创建 uevent 属性文件</span></span><br><span class="line">    retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在总线所在目录创建 devices 目录</span></span><br><span class="line">    priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    <span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在总线所在目录创建 drivers 目录</span></span><br><span class="line">    priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                         &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    <span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">    __mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">    <span class="comment">//初始化设备链表 klist_devices，该总线上的所有设备将被链入该链表</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">    <span class="comment">//初始化驱动链表 klist_drivers，该总线上的所有驱动将被链入该链表</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在当前总线所在目录创建 drivers_probe 属性文件</span></span><br><span class="line"><span class="comment">    * 在当前总线所在目录创建 drivers_autoprobe 属性文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    retval = add_probe_files(bus);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在当前总线所在目录创建 bus_groups 属性文件(一组)</span></span><br><span class="line">    retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bus_groups_fail;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">    remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">    kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">    bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">    kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">    kfree(bus-&gt;p);</span><br><span class="line">    bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus_register 会创建以下节点：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>bus/xxx</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/u</span>event</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>devices ----- bus下注册的dev将出现在这个目录</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers ----- bus下注册的drv将出现在这个目录</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers_probe</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/xxx/</span>drivers_autoprobe</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;bus_register 创建并初始化 priv-&gt;klist_devices 和 priv-&gt;klist_drivers 这两条由该总线维护的非常重要的两条链表，该总线下的 dev 和 drv 会分别链入这两条链表。</p>
<p><strong>编程实验创建自己的总线</strong><br>在内核中创建一个名为 my_bus 的总线</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_match\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_bus_remove</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_bus_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_bus&quot;</span>,</span><br><span class="line">    .probe = my_bus_probe,</span><br><span class="line">    .match = my_bus_match,</span><br><span class="line">    .remove = my_bus_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_register(&amp;my_bus); <span class="comment">//注册bus总线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_bus_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bus_unregister(&amp;my_bus); <span class="comment">//卸载bus总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_bus_init);</span><br><span class="line">module_exit(my_bus_exit);</span><br></pre></td></tr></table></figure>
<p><strong>模块验证</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># ls</span></span><br><span class="line">amba        container    gpio iio      scsi    spi</span><br><span class="line">clockevents cpu          hid  mmc      sdio    usb</span><br><span class="line">clocksource event_source i2c  platform snd_seq workqueue</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta">#</span></span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># insmod /cache/my_bus.ko</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta">#</span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># ls  <span class="comment">//查看生成了新的总线 my_bus</span></span></span><br><span class="line">amba        container    gpio iio    platform snd_seq workqueue</span><br><span class="line">clockevents cpu          hid  mmc    scsi     spi</span><br><span class="line">clocksource event_source i2c  my_bus sdio     usb</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus <span class="meta"># cd my_bus/ </span></span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus/my_bus <span class="meta"># ls <span class="comment">//查看 my_bus 下生成节点</span></span></span><br><span class="line">devices drivers drivers_autoprobe drivers_probe uevent</span><br><span class="line">XF-E97:<span class="meta-keyword">/sys/</span>bus/my_bus <span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>该模块创建下面节点</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>bus/my_bus</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/u</span>event</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers_probe</span><br><span class="line"><span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers_autoprobe</span><br></pre></td></tr></table></figure>
<h2 id="4、创建属性文件"><a href="#4、创建属性文件" class="headerlink" title="4、创建属性文件"></a>4、创建属性文件</h2><p>内核也提供了在 bus 总线下创建属性文件的接口</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于在bus所在目录创建属性文件</span></span><br><span class="line"><span class="built_in">int</span> bus<span class="constructor">_create_file(<span class="params">struct</span> <span class="params">bus_type</span> <span class="operator">*</span><span class="params">bus</span>, <span class="params">struct</span> <span class="params">bus_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br><span class="line"><span class="comment">//删除在bus所在目录创建的属性文件</span></span><br><span class="line">void bus<span class="constructor">_remove_file(<span class="params">struct</span> <span class="params">bus_type</span> <span class="operator">*</span><span class="params">bus</span>, <span class="params">struct</span> <span class="params">bus_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="二、device设备"><a href="#二、device设备" class="headerlink" title="二、device设备"></a>二、device设备</h1><p>抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。</p>
<h2 id="1、数据结构-1"><a href="#1、数据结构-1" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-device"><a href="#1-device" class="headerlink" title="1) device"></a>1) device</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>    *<span class="title">parent</span>;</span>	 <span class="comment">//父设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>    *<span class="title">p</span>;</span>  <span class="comment">//保存设备链表</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	  <span class="comment">//对应的kobj用于创建dev目录</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *init_name;   <span class="comment">//设备的名称，非常重要，如果不存在则使用&quot;bus-&gt;name + device ID&quot; 如果都不存在则不允许创建设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span> <span class="comment">//设备类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">mutex</span>;</span>  <span class="comment">/* mutex to synchronize calls toits driver. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span>       	<span class="comment">/* 设备挂接的总线 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>       <span class="comment">/* 匹配成功后，链接匹配到的driver */</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data; 	<span class="comment">/* 用于保存私有数据。 */</span></span><br><span class="line">    <span class="keyword">void</span>        *driver_data;   	<span class="comment">/* Driver data, set and get with dev_set get_drvdata */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span>   <span class="title">links</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span>  <span class="title">power</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>    *<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>   *<span class="title">msi_domain</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> *<span class="title">pins</span>;</span> <span class="comment">//pinctrl对应的接口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">msi_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="keyword">int</span>     numa_node;  <span class="comment">/* NUMA node this device is close to */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_map_ops</span> *<span class="title">dma_ops</span>;</span></span><br><span class="line">    u64     *dma_mask;  <span class="comment">/* dma mask (if dma&#x27;able device) */</span></span><br><span class="line">    u64     coherent_dma_mask;<span class="comment">/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   dma_pfn_offset;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">dma_pools</span>;</span>  <span class="comment">/* dma pools (if dma&#x27;ble) */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span> *<span class="title">dma_mem</span>;</span> <span class="comment">/* internal for coherent mem override */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_CMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">cma_area</span>;</span>       <span class="comment">/* contiguous memory area for dma allocations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>  *<span class="title">of_node</span>;</span> <span class="comment">/* associated device tree node */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span>    *<span class="title">fwnode</span>;</span> <span class="comment">/* firmware device node */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">dev_t</span>           devt;   <span class="comment">/* 设备号 */</span></span><br><span class="line">    u32         id; <span class="comment">/* device instance */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span>      devres_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">devres_head</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span>   <span class="title">knode_class</span>;</span> <span class="comment">//链接到dev-&gt;class-&gt;p-&gt;klist_devices节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>        *<span class="keyword">class</span>;</span>		<span class="comment">//所属的class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span>  <span class="comment">/* optional groups */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>    (*release)(struct device *dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iommu_group</span>  *<span class="title">iommu_group</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iommu_fwspec</span> *<span class="title">iommu_fwspec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>            offline_disabled:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span>            offline:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span>            of_node_reused:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-device-private"><a href="#2-device-private" class="headerlink" title="2) device_private"></a>2) device_private</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_children</span>;</span> 	<span class="comment">//用于挂接子设备的 knode_parent</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_parent</span>;</span> 	<span class="comment">//挂接到父设备的 klist_children</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_driver</span>;</span>     <span class="comment">//链入连接的 driver 的 klist_devices 链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span> 	<span class="comment">//链接进入 bus-&gt;p-&gt;klist_devices 链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_probe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>		<span class="comment">//指向所属的 dev</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、device-根目录的初始化"><a href="#2、device-根目录的初始化" class="headerlink" title="2、device 根目录的初始化"></a>2、device 根目录的初始化</h2><p>device文件目录初始化函数，在driver_init中被调用，内核初始化时被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">devices_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在 sys/ 下创建一个名为 devices 目录，deices_kset</span></span><br><span class="line"><span class="comment">    * 在 sys/ 下创建一个名为 dev 的目录，dev_kobj</span></span><br><span class="line"><span class="comment">    * 在 sys/dev/ 下创建一个名为 block 的目录，sysfs_dev_block_kobj</span></span><br><span class="line"><span class="comment">    * 在 sys/dev/ 下创建一个名为 char 的目录，sysfs_dev_char_kobj</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, &amp;device_uevent_ops, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!devices_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    dev_kobj = kobject_create_and_add(<span class="string">&quot;dev&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dev_kobj)</span><br><span class="line">        <span class="keyword">goto</span> dev_kobj_err;</span><br><span class="line">    sysfs_dev_block_kobj = kobject_create_and_add(<span class="string">&quot;block&quot;</span>, dev_kobj);</span><br><span class="line">    <span class="keyword">if</span> (!sysfs_dev_block_kobj)</span><br><span class="line">        <span class="keyword">goto</span> block_kobj_err;</span><br><span class="line">    sysfs_dev_char_kobj = kobject_create_and_add(<span class="string">&quot;char&quot;</span>, dev_kobj);</span><br><span class="line">    <span class="keyword">if</span> (!sysfs_dev_char_kobj)</span><br><span class="line">        <span class="keyword">goto</span> char_kobj_err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> char_kobj_err:</span><br><span class="line">    kobject_put(sysfs_dev_block_kobj);</span><br><span class="line"> block_kobj_err:</span><br><span class="line">    kobject_put(dev_kobj);</span><br><span class="line"> dev_kobj_err:</span><br><span class="line">    kset_unregister(devices_kset);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>devices_init 初始化了 device 的基本根目录，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices</span><br><span class="line">/sys/dev</span><br><span class="line">/sys/dev/block</span><br><span class="line">/sys/dev/<span class="keyword">char</span></span><br></pre></td></tr></table></figure>
<p>bus总线管理着该总线下的所有设备和驱动，他们分别位于 /sys/bus/xxx/device 和 /sys/bus/xxx/driver 下</p>
<h2 id="3、device的注册"><a href="#3、device的注册" class="headerlink" title="3、device的注册"></a>3、device的注册</h2><h3 id="1-device-register"><a href="#1-device-register" class="headerlink" title="1) device_register"></a>1) device_register</h3><p>使用 device_regster 注册 device ，这里以源码的形式分析。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_initialize(dev); <span class="comment">//对dev进行一些初始化</span></span><br><span class="line">    <span class="keyword">return</span> device_add(dev); <span class="comment">//将dev注册进bus</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-device-initialize"><a href="#2-device-initialize" class="headerlink" title="2) device_initialize"></a>2) device_initialize</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_initialize</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dev-&gt;kobj.kset = devices_kset; <span class="comment">//初始化kset</span></span><br><span class="line">    kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype); <span class="comment">//初始化ktypoe</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对一些链表进行初始化</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">    mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">    lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class="line">    spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line">    device_pm_init(dev);</span><br><span class="line">    set_dev_node(dev, <span class="number">-1</span>); 	<span class="comment">//设置该设备节点为-1，一般未注册前默认为-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的初始化可以看出,<font color=green>所有通过device_register注册的dev的dev-&gt;kobj-&gt;list，都将挂接在 devices_kset-&gt;list上</font>(在kobj_add注册时链接) ,<font color=blue>如果没有父设备则设备将使用 devices_kset 作为父设备目录节点</font>，因此可以得出下面结论：</p>
<blockquote>
<ul>
<li><font color=red><strong>所有通过 device_regster 创建的设备都应该是/sys/devices/的子目录</strong></font>
</li>
</ul>
</blockquote>
<h3 id="3-device-add"><a href="#3-device-add" class="headerlink" title="3) device_add"></a>3) device_add</h3><p>这个函数将device注册进bus，同时它也做了很多事情非常多的事情，具体做了什么事情我们跟着源码来看一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_add</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_interface</span> *<span class="title">class_intf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">glue_dir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    dev = get_device(dev); <span class="comment">//增加dev引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (!dev)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">        <span class="comment">/* 动态分配一个 device_private 并且初始化 dev成员*/</span></span><br><span class="line">        error = device_private_init(dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for statically allocated devices, which should all be converted</span></span><br><span class="line"><span class="comment">     * some day, we need to initialize the name. We prevent reading back</span></span><br><span class="line"><span class="comment">     * the name, and force the use of dev_name()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;init_name) &#123;	<span class="comment">// 如果有init_name则设置，设置dev-&gt;kobj-&gt;name 为 init_name</span></span><br><span class="line">        dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, dev-&gt;init_name);</span><br><span class="line">        dev-&gt;init_name = <span class="literal">NULL</span>; <span class="comment">//这里需要注意的是，这个 init_name 被设置为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subsystems can specify simple device enumeration */</span></span><br><span class="line">    <span class="comment">//如果 dev-&gt;kobj-&gt;name 为空且对应的bus设置了dev_name 则使用这个名字+dev-&gt;id作为设备名</span></span><br><span class="line">    <span class="keyword">if</span> (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">        dev_set_name(dev, <span class="string">&quot;%s%u&quot;</span>, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果这没有设置dev-&gt;kobj-name 则直接返回error</span></span><br><span class="line">    <span class="keyword">if</span> (!dev_name(dev)) &#123;</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> name_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;device: &#x27;%s&#x27;: %s\n&quot;</span>, dev_name(dev), __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加 dev-parent 的kobj引用计数</span></span><br><span class="line">    parent = get_device(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回parent-&gt;kobj</span></span><br><span class="line">    kobj = get_device_parent(dev, parent);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kobj)) &#123;</span><br><span class="line">        error = PTR_ERR(kobj);</span><br><span class="line">        <span class="keyword">goto</span> parent_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kobj)</span><br><span class="line">        dev-&gt;kobj.parent = kobj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use parent numa_node */</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE)) <span class="comment">// 一般未注册前默认为-1</span></span><br><span class="line">        set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first, register with generic layer. */</span></span><br><span class="line">    <span class="comment">/* we require the name to be set before, and pass NULL */</span></span><br><span class="line">    <span class="comment">// 注册 dev-&gt;kobj，在 sys/ 下创建相关目录</span></span><br><span class="line">    error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        glue_dir = get_glue_dir(dev);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* notify platform of device entry */</span></span><br><span class="line">    <span class="keyword">if</span> (platform_notify)</span><br><span class="line">        platform_notify(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在dev目录下创建属性文件uevent</span></span><br><span class="line">    error = device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> attrError;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在dev所在目录创建三个链接文件</span></span><br><span class="line"><span class="comment">    * of_node     ---&gt; 设备树生成的节点</span></span><br><span class="line"><span class="comment">    * subsystem   ---&gt; dev-&gt;class</span></span><br><span class="line"><span class="comment">    * device      ---&gt; 父设备目录</span></span><br><span class="line"><span class="comment">    * 同时在所属的class目录下创建指向 dev 目录的链接文件，dev-&gt;init_name</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    error = device_add_class_symlinks(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> SymlinkError;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//该函数用于在 dev下创建所属的 class-&gt;dev_groups, 所属的 type-&gt;groups 和 dev-&gt;groups 指向的属性文件以及属性文件 online</span></span><br><span class="line">    error = device_add_attrs(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> AttrsError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将设备注册进bus，详细分析见后文</span></span><br><span class="line">    error = bus_add_device(dev);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> BusError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电源相关暂时忽略</span></span><br><span class="line">    error = dpm_sysfs_add(dev); </span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> DPMError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电源相关暂时忽略</span></span><br><span class="line">    device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">        <span class="comment">//在设备所在目录下创建属性文件 dev</span></span><br><span class="line">        error = device_create_file(dev, &amp;dev_attr_dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> DevAttrError;</span><br><span class="line">        <span class="comment">//如果存在class则在class所在目录下创建指向dev-&gt;kobj的链接文件&quot;major+minor&quot;,否则在 /sys/char 下创建</span></span><br><span class="line">        error = device_create_sys_dev_entry(dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> SysEntryError;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建设备文件节点 /dev/dev-&gt;init_name</span></span><br><span class="line">        devtmpfs_create_node(dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify clients of device addition.  This call must come</span></span><br><span class="line"><span class="comment">     * after dpm_sysfs_add() and before kobject_uevent().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line">    <span class="comment">//向用户空间发送 uevent 事件 KOBJ_ADD</span></span><br><span class="line">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所挂接的bus上的所有drv，对所有的drv进行匹配，匹配成功则调用相对应的probe函数，详细分析见后文</span></span><br><span class="line">    bus_probe_device(dev);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (parent) <span class="comment">//将 dev-&gt;p-&gt;knode_parent 节点加入 parent-&gt;p-&gt;klist_children</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">                   &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;class) &#123;</span><br><span class="line">        mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">        <span class="comment">/* tie the class to the device */</span></span><br><span class="line">        <span class="comment">// 绑定device和class，将dev-&gt;knode_class 节点链接到dev-&gt;class-&gt;p-&gt;klist_devices</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">                   &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* notify any interfaces that the device is here */</span></span><br><span class="line">        list_for_each_entry(class_intf,</span><br><span class="line">                    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">            <span class="keyword">if</span> (class_intf-&gt;add_dev)</span><br><span class="line">                class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">        mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"> SysEntryError:</span><br><span class="line">    <span class="keyword">if</span> (MAJOR(dev-&gt;devt))</span><br><span class="line">        device_remove_file(dev, &amp;dev_attr_dev);</span><br><span class="line"> DevAttrError:</span><br><span class="line">    device_pm_remove(dev);</span><br><span class="line">    dpm_sysfs_remove(dev);</span><br><span class="line"> DPMError:</span><br><span class="line">    bus_remove_device(dev);</span><br><span class="line"> BusError:</span><br><span class="line">    device_remove_attrs(dev);</span><br><span class="line"> AttrsError:</span><br><span class="line">    device_remove_class_symlinks(dev);</span><br><span class="line"> SymlinkError:</span><br><span class="line">    device_remove_file(dev, &amp;dev_attr_uevent);</span><br><span class="line"> attrError:</span><br><span class="line">    kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);</span><br><span class="line">    glue_dir = get_glue_dir(dev);</span><br><span class="line">    kobject_del(&amp;dev-&gt;kobj);</span><br><span class="line"> Error:</span><br><span class="line">    cleanup_glue_dir(dev, glue_dir);</span><br><span class="line">parent_error:</span><br><span class="line">    put_device(parent);</span><br><span class="line">name_error:</span><br><span class="line">    kfree(dev-&gt;p);</span><br><span class="line">    dev-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-get-device-parent"><a href="#4-get-device-parent" class="headerlink" title="4) get_device_parent"></a>4) get_device_parent</h3><p>这个函数用于获取 dev-&gt;kobj-&gt;parent</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject *<span class="title">get_device_parent</span><span class="params">(struct device *dev, struct device *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;class) &#123;	<span class="comment">//是否设置class</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent_kobj</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">k</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">        <span class="comment">/* block disks show up in /sys/block */</span></span><br><span class="line">        <span class="keyword">if</span> (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent &amp;&amp; parent-&gt;class == &amp;block_class)</span><br><span class="line">                <span class="keyword">return</span> &amp;parent-&gt;kobj;</span><br><span class="line">            <span class="keyword">return</span> &amp;block_class.p-&gt;subsys.kobj;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we have no parent, we live in &quot;virtual&quot;.</span></span><br><span class="line"><span class="comment">         * Class-devices with a non class-device as parent, live</span></span><br><span class="line"><span class="comment">         * in a &quot;glue&quot; directory to prevent namespace collisions.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) <span class="comment">//parent为空</span></span><br><span class="line">            parent_kobj = virtual_device_parent(dev); <span class="comment">//在/sys/devices/目录下创建 virtual 目录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;class &amp;&amp; !dev-&gt;class-&gt;ns_type) <span class="comment">//dev-&gt;class-&gt;ns_type</span></span><br><span class="line">            <span class="keyword">return</span> &amp;parent-&gt;kobj;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent_kobj = &amp;parent-&gt;kobj; <span class="comment">//设置parent_kobj</span></span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;gdp_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find our class-directory at the parent and reference it */</span></span><br><span class="line">        <span class="comment">//如果已经在dev-&gt;class-&gt;p-&gt;glue_dirs下注册了 parent_kobj 则增加它的引用计数，并直接返回</span></span><br><span class="line">        spin_lock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);</span><br><span class="line">        list_for_each_entry(k, &amp;dev-&gt;class-&gt;p-&gt;glue_dirs.<span class="built_in">list</span>, entry)</span><br><span class="line">            <span class="keyword">if</span> (k-&gt;parent == parent_kobj) &#123;</span><br><span class="line">                kobj = kobject_get(k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        spin_unlock(&amp;dev-&gt;class-&gt;p-&gt;glue_dirs.list_lock);</span><br><span class="line">        <span class="keyword">if</span> (kobj) &#123; <span class="comment">//直接返回</span></span><br><span class="line">            mutex_unlock(&amp;gdp_mutex);</span><br><span class="line">            <span class="keyword">return</span> kobj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* or create a new class-directory at the parent device */</span></span><br><span class="line">        <span class="comment">/* 在 parent_kobj 并没有在 dev-&gt;class-&gt;p-&gt;glue_dirs 中，</span></span><br><span class="line"><span class="comment">         * 则在父目录下创建一个名为 dev-&gt;class-&gt;name 的目录，</span></span><br><span class="line"><span class="comment">         * 并将 class-&gt;p-&gt;glue_dirs 作为其kset。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        k = class_dir_create_and_add(dev-&gt;class, parent_kobj);</span><br><span class="line">        <span class="comment">/* do not emit an uevent for this simple &quot;glue&quot; directory */</span></span><br><span class="line">        mutex_unlock(&amp;gdp_mutex);</span><br><span class="line">        <span class="keyword">return</span> k; <span class="comment">//返回dir-&gt;kobj</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subsystems can specify a default root directory for their devices */</span></span><br><span class="line">	<span class="comment">//如果parent为空则且dev-&gt;bus-&gt;dev_root不为空则使用dev-&gt;bus-&gt;dev_root-&gt;kobj作为父节点</span></span><br><span class="line">    <span class="keyword">if</span> (!parent &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_root)</span><br><span class="line">        <span class="keyword">return</span> &amp;dev-&gt;bus-&gt;dev_root-&gt;kobj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent)</span><br><span class="line">        <span class="keyword">return</span> &amp;parent-&gt;kobj; <span class="comment">//返回父节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>class_dir_create_and_add</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject* <span class="title">class_dir_create_and_add</span><span class="params">(struct class *class, struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_dir</span> *<span class="title">dir</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    dir = kzalloc(<span class="keyword">sizeof</span>(*dir), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dir)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    dir-&gt;<span class="class"><span class="keyword">class</span> =</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    kobject_init(&amp;dir-&gt;kobj, &amp;class_dir_ktype);</span><br><span class="line"></span><br><span class="line">    dir-&gt;kobj.kset = &amp;class-&gt;p-&gt;glue_dirs;</span><br><span class="line"></span><br><span class="line">    retval = kobject_add(&amp;dir-&gt;kobj, parent_kobj, <span class="string">&quot;%s&quot;</span>, class-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kobject_put(&amp;dir-&gt;kobj);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;dir-&gt;kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get_device_parent函数需要分为情况讨论<br><strong>设备属于某个class且parent为空</strong></p>
<ol>
<li>创建 /sys/devices/virtual目录，并将其作为父目录parent_kobj </li>
<li>遍历 dev-&gt;class-&gt;p-&gt;glue_dirs 下的所有kobj， 如果存在 parent_kobj，则增加其引用计数并直接返回 parent_kobj</li>
<li>否则在parent_kobj下创建一个dir-&gt;kobj (/sys/dev/vitual/dir-&gt;kobj-&gt;name)，使用传入的class-&gt;name 作为其dir-&gt;kobj-&gt;name, 并将class-&gt;p-&gt;glue_dirs作为其kset。并返回dir-&gt;kobj作为parent_kobj，这种情况会曾加如下目录</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/<span class="keyword">virtual</span> </span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/<span class="class"><span class="keyword">class</span>-&gt;</span>name <span class="comment">//dev-&gt;class-&gt;p-&gt;glue_dirs 下不存在 parent_kobj 则创建这个节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>设备属于某个class且parent不为空</strong></p>
<ol>
<li>如果存在 dev-&gt;class-&gt;ns_type 则直接返回 parent_kobj (这种情况不增加目录)</li>
<li>如果上述不存在，则遍历 dev-&gt;class-&gt;p-&gt;glue_dirs 下的所有kobj， 如果存在parent_kobj，则增加其引用计数并直接返回 parent_kobj</li>
<li>否则在 parent_kobj 下创建一个dir-&gt;kobj，使用传入的class-&gt;name 作为其dir-&gt;kobj-&gt;name, 并将class-&gt;p-&gt;glue_dirs作为其kset。并返回dir-&gt;kobj作为parent_kobj，这种情况会增加如下目录</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">..../parent_kobj-&gt;name/<span class="class"><span class="keyword">class</span>-&gt;</span>name</span><br></pre></td></tr></table></figure>
<p><strong>设备属不属于某个class</strong><br>如果 parent 为空则且 dev-&gt;bus-&gt;dev_root 不为空则使用 dev-&gt;bus-&gt;dev_root-&gt;kobj 作为父节点，否则直接返回 parent-&gt;kobj</p>
<h3 id="5-device-add-class-symlinks"><a href="#5-device-add-class-symlinks" class="headerlink" title="5) device_add_class_symlinks"></a>5) device_add_class_symlinks</h3><p>该函数会创建class与dev之间的连接，首先在传入的dev所在目录创建三个链接文件，of_node、subsystem、device，同时在所属的class目录下创建指向dev目录的链接文件，dev-&gt;init_name</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_add_class_symlinks</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span> =</span> dev_of_node(dev);</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_node) &#123; <span class="comment">//设备树生成的节点</span></span><br><span class="line">        <span class="comment">//在 dev-&gt;kobj 下创建指向of_node-&gt;kobj的链接文件of_node</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;of_node-&gt;kobj,<span class="string">&quot;of_node&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            dev_warn(dev, <span class="string">&quot;Error %d creating of_node link\n&quot;</span>,error);</span><br><span class="line">        <span class="comment">/* An error here doesn&#x27;t warrant bringing down the device */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;class)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在 dev-&gt;kobj 下创建指向 dev-&gt;class-&gt;p-&gt;subsys.kobj 的链接文件&quot;subsystem&quot;</span></span><br><span class="line">    error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">                  &amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,</span><br><span class="line">                  <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_devnode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 dev-&gt;kobj 下创建指向 dev-&gt;parent-&gt;kobj 的链接文件 device</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent &amp;&amp; device_is_not_partition(dev)) &#123; <span class="comment">//默认情况满足条件</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;parent-&gt;kobj,</span><br><span class="line">                      <span class="string">&quot;device&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_subsys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">    <span class="comment">/* /sys/block has directories and does not need symlinks */</span></span><br><span class="line">    <span class="keyword">if</span> (sysfs_deprecated &amp;&amp; dev-&gt;class == &amp;block_class)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link in the class directory pointing to the device */</span></span><br><span class="line">	<span class="comment">//在 dev-&gt;class-&gt;p-&gt;subsys.kobj 下创建指向 dev-&gt;kobj 链接文件 &quot;dev-&gt;init_name&quot;</span></span><br><span class="line">    error = sysfs_create_link(&amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,</span><br><span class="line">                  &amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_device;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_device:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;device&quot;</span>);</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">out_devnode:</span><br><span class="line">    sysfs_remove_link(&amp;dev-&gt;kobj, <span class="string">&quot;of_node&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-device-add-attrs"><a href="#6-device-add-attrs" class="headerlink" title="6) device_add_attrs"></a>6) device_add_attrs</h3><p>该函数用于在dev下创建所属的 class-&gt;dev_groups, 所属的 type-&gt;groups 和 dev-&gt;groups 指向的属性文件以及属性文件 online</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device_add_attrs</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span> =</span> dev-&gt;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span> =</span> dev-&gt;type;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (class) &#123;</span><br><span class="line">        <span class="comment">//创建 class-&gt;dev_groups 属性文件</span></span><br><span class="line">        error = device_add_groups(dev, class-&gt;dev_groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type) &#123;</span><br><span class="line">        <span class="comment">//创建 type-&gt;groups 属性文件</span></span><br><span class="line">        error = device_add_groups(dev, type-&gt;groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> err_remove_class_groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 dev-&gt;groups 属性文件</span></span><br><span class="line">    error = device_add_groups(dev, dev-&gt;groups);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> err_remove_type_groups;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建属性文件 online</span></span><br><span class="line">    <span class="keyword">if</span> (device_supports_offline(dev) &amp;&amp; !dev-&gt;offline_disabled) &#123;</span><br><span class="line">        error = device_create_file(dev, &amp;dev_attr_online);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> err_remove_dev_groups;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_remove_dev_groups:</span><br><span class="line">    device_remove_groups(dev, dev-&gt;groups);</span><br><span class="line"> err_remove_type_groups:</span><br><span class="line">    <span class="keyword">if</span> (type)</span><br><span class="line">        device_remove_groups(dev, type-&gt;groups);</span><br><span class="line"> err_remove_class_groups:</span><br><span class="line">    <span class="keyword">if</span> (class)</span><br><span class="line">        device_remove_groups(dev, class-&gt;dev_groups);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-bus-add-device"><a href="#7-bus-add-device" class="headerlink" title="7) bus_add_device"></a>7) bus_add_device</h3><p>这个函数将 device 注册进入bus</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_device</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> bus_get(dev-&gt;bus);</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;</span>, bus-&gt;name, dev_name(dev));</span><br><span class="line">        <span class="comment">/* 在当前设备所在目录下创建 dev-&gt;dev_attrs 默认属性文件(有就创建没有就不创建) */</span></span><br><span class="line">        error = device_add_attrs(bus, dev);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_put;</span><br><span class="line">        <span class="comment">/* 在当前设备所在目录下创建属性文件  bus-&gt;dev_groups */</span></span><br><span class="line">        error = device_add_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_id;</span><br><span class="line">        <span class="comment">/* 在设备所在bus的devices目录下创建指向设备所在目录的软链接，名字为dev-&gt;name */</span></span><br><span class="line">        error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">                        &amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_groups;</span><br><span class="line">        <span class="comment">/* 在设备所在目录下创建指向设备所在总线的的软链接名为 subsystem */</span></span><br><span class="line">        error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">                &amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_subsys;</span><br><span class="line">        <span class="comment">/* 将设备链入 bus-&gt;p-&gt;klist_devices 链表 */</span></span><br><span class="line">        klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">    sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));</span><br><span class="line">out_groups:</span><br><span class="line">    device_remove_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">out_id:</span><br><span class="line">    device_remove_attrs(bus, dev);</span><br><span class="line">out_put:</span><br><span class="line">    bus_put(dev-&gt;bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus_add_device 会创建以下节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/bus/xxx/devices/dev-&gt;name ----&gt; ..../dev-&gt;name</span><br><span class="line">..../dev-&gt;name/subsystem ----&gt; /sys/bus/xxx</span><br></pre></td></tr></table></figure>
<h3 id="8-bus-probe-device"><a href="#8-bus-probe-device" class="headerlink" title="8) bus_probe_device"></a>8) bus_probe_device</h3><p>如果drivers_autoprobe为1,即可以自动匹配则调用 device_initial_probe(dev)</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void bus<span class="constructor">_probe_device(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> bus_type *bus = dev-&gt;bus;</span><br><span class="line">    <span class="keyword">struct</span> subsys_interface *sif;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        return;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果设置了 bus-&gt;p-&gt;drivers_autoprobe 则进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (bus-&gt;p-&gt;drivers_autoprobe) </span><br><span class="line">        device<span class="constructor">_initial_probe(<span class="params">dev</span>)</span>;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_lock(&amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">    <span class="built_in">list</span><span class="constructor">_for_each_entry(<span class="params">sif</span>, &amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">interfaces</span>, <span class="params">node</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (sif-&gt;add_dev)</span><br><span class="line">            sif-&gt;add<span class="constructor">_dev(<span class="params">dev</span>, <span class="params">sif</span>)</span>;</span><br><span class="line">    mutex<span class="constructor">_unlock(&amp;<span class="params">bus</span>-&gt;<span class="params">p</span>-&gt;<span class="params">mutex</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>device_initial_probe</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_initial_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __device_attach(dev, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__device_attach</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach(struct device *dev, <span class="keyword">bool</span> allow_async)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    device_lock(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver) &#123; <span class="comment">//在初始化dev的时候手动指定了driver，则在这里进行绑定</span></span><br><span class="line">        <span class="keyword">if</span> (device_is_bound(dev)) &#123;  <span class="comment">//判断设备和驱动是否已经绑定</span></span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动绑定设备和驱动</span></span><br><span class="line">        ret = device_bind_driver(dev); </span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        struct device_attach_data data = &#123;</span><br><span class="line">            .dev = dev,</span><br><span class="line">            .check_async = allow_async,</span><br><span class="line">            .want_async = <span class="literal">false</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">            pm_runtime_get_sync(dev-&gt;parent);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//遍历 dev-&gt;bus 上所有的 drv ，对每一个drv 调用 __device_attach_driver 函数</span></span><br><span class="line">        ret = bus_for_each_drv(dev-&gt;bus, <span class="literal">NULL</span>, &amp;data,</span><br><span class="line">                    __device_attach_driver);</span><br><span class="line">        <span class="keyword">if</span> (!ret &amp;&amp; allow_async &amp;&amp; data.have_async) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If we could not find appropriate driver</span></span><br><span class="line"><span class="comment">             * synchronously and we are allowed to do</span></span><br><span class="line"><span class="comment">             * async probes and there are drivers that</span></span><br><span class="line"><span class="comment">             * want to probe asynchronously, we&#x27;ll</span></span><br><span class="line"><span class="comment">             * try them.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dev_dbg(dev, <span class="string">&quot;scheduling asynchronous probe\n&quot;</span>);</span><br><span class="line">            get_device(dev);</span><br><span class="line">            async_schedule(__device_attach_async_helper, dev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pm_request_idle(dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">            pm_runtime_put(dev-&gt;parent);</span><br><span class="line">    &#125;</span><br><span class="line">out_unlock:</span><br><span class="line">    device_unlock(dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>device_bind_driver</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_bind_driver</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建链接文件 .../dev-&gt;driver-&gt;p-&gt;kobj/dev-&gt;kobj-&gt;name</span></span><br><span class="line"><span class="comment">    * 创建链接文件 .../dev-&gt;kobj/driver</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = driver_sysfs_add(dev);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        driver_bound(dev); <span class="comment">//手动绑定</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__device_attach_driver</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach_driver(struct device_driver *drv, <span class="keyword">void</span> *_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attach_data</span> *<span class="title">data</span> =</span> _data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> data-&gt;dev;</span><br><span class="line">    <span class="keyword">bool</span> async_allowed;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check if device has already been claimed. This may</span></span><br><span class="line"><span class="comment">     * happen with driver loading, device discovery/registration,</span></span><br><span class="line"><span class="comment">     * and deferred probe processing happens all at once with</span></span><br><span class="line"><span class="comment">     * multiple threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 调用 drv 所属的 bus 的 match 函数，这里可以看出来如果不初始化 drv-&gt;bus-&gt;match 函数则默认匹配成功。</span></span><br><span class="line"><span class="comment">      static inline int driver_match_device(struct device_driver *drv, struct device *dev)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">          return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = driver_match_device(drv, dev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* no match */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Device match requests probe deferral\n&quot;</span>);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Bus failed to match device: %d&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="comment">/* ret &gt; 0 means positive match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取驱动加载方式是同步加载还是异步加载</span></span><br><span class="line">    async_allowed = driver_allows_async_probing(drv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (async_allowed)</span><br><span class="line">        data-&gt;have_async = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;check_async &amp;&amp; async_allowed != data-&gt;want_async)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用 driver_probe_device</span></span><br><span class="line">    <span class="keyword">return</span> driver_probe_device(drv, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>driver_probe_device</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_probe_device</span><span class="params">(struct device_driver *drv, struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!device_is_registered(dev))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: matched device %s with driver %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">        pm_runtime_get_sync(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    pm_runtime_barrier(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 really_probe 函数</span></span><br><span class="line">    ret = really_probe(dev, drv);</span><br><span class="line">    pm_request_idle(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">        pm_runtime_put(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>really_probe</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -EPROBE_DEFER;</span><br><span class="line">    <span class="keyword">int</span> local_trigger_count = atomic_read(&amp;deferred_trigger_count);</span><br><span class="line">    <span class="keyword">bool</span> test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;</span><br><span class="line">               !drv-&gt;suppress_bind_attrs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTPROF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ts = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (defer_all_probes) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Value of defer_all_probes can be set only by</span></span><br><span class="line"><span class="comment">         * device_defer_all_probes_enable() which, in turn, will call</span></span><br><span class="line"><span class="comment">         * wait_for_device_probe() right after that to avoid any races.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Driver %s force probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atomic_inc(&amp;probe_count);</span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line">    WARN_ON(!list_empty(&amp;dev-&gt;devres_head));</span><br><span class="line"></span><br><span class="line">re_probe:</span><br><span class="line">    dev-&gt;driver = drv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    <span class="comment">// 如果使用了 pinctrl 则会在这里先加载一次，如果 dts 写错了但能编译过了，就是不probe</span></span><br><span class="line">    <span class="comment">// 当移植代码的时候，当我们注册的驱动无法 prob e到设备的时候记得检查一下是否是 dts 的问题，</span></span><br><span class="line">    <span class="comment">// 因为不同个平台的 dts 可能由微小的差别，我就踩过这个坑 =_=</span></span><br><span class="line">    ret = pinctrl_bind_pins(dev);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> pinctrl_bind_failed;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在drv所在目录创建指向dev目录的链接文件，名字使用 dev-&gt;kobj-&gt;name</span></span><br><span class="line"><span class="comment">    * 在dev所在目录创建指向drv目录的连接文件，名字使用 &quot;driver&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, dev_name(dev));</span><br><span class="line">        <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">        ret = dev-&gt;pm_domain-&gt;activate(dev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用 dev-&gt;bus-&gt;probe</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">        TIME_LOG_START();</span><br><span class="line">        ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">        TIME_LOG_END();</span><br><span class="line">        bootprof_probe(ts, dev, drv, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev-&gt;bus-&gt;probe);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123; <span class="comment">//如果 dev-&gt;bus-&gt;probe 不存在则调用 drv-&gt;probe</span></span><br><span class="line">       TIME_LOG_START();</span><br><span class="line">        ret = drv-&gt;probe(dev);</span><br><span class="line">        TIME_LOG_END();</span><br><span class="line">        bootprof_probe(ts, dev, drv, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)drv-&gt;probe);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> probe_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test_remove) &#123;</span><br><span class="line">        test_remove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">            dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">            drv-&gt;remove(dev);</span><br><span class="line"></span><br><span class="line">        devres_release_all(dev);</span><br><span class="line">        driver_sysfs_remove(dev);</span><br><span class="line">        dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">        dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">            dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">        pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> re_probe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pinctrl_init_done(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">        dev-&gt;pm_domain-&gt;sync(dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立设备与驱动的连接</span></span><br><span class="line">    driver_bound(dev);</span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line">         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">probe_failed:</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">        blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                         BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">pinctrl_bind_failed:</span><br><span class="line">    devres_release_all(dev);</span><br><span class="line">    driver_sysfs_remove(dev);</span><br><span class="line">    dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">    dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">        dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">    pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">        <span class="comment">/* Driver requested deferred probing */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        driver_deferred_probe_add(dev);</span><br><span class="line">        <span class="comment">/* Did a trigger occur while probing? Need to re-trigger if yes */</span></span><br><span class="line">        <span class="keyword">if</span> (local_trigger_count != atomic_read(&amp;deferred_trigger_count))</span><br><span class="line">            driver_deferred_probe_trigger();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -ENODEV:</span><br><span class="line">    <span class="keyword">case</span> -ENXIO:</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line">             drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* driver matched but the probe failed */</span></span><br><span class="line">        printk(KERN_WARNING</span><br><span class="line">               <span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">               drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ignore errors returned by -&gt;probe so that the next driver can try</span></span><br><span class="line"><span class="comment">     * its luck.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">    atomic_dec(&amp;probe_count);</span><br><span class="line">    wake_up(&amp;probe_waitqueue);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、device-register总结"><a href="#4、device-register总结" class="headerlink" title="4、device_register总结"></a>4、device_register总结</h2><h3 id="1-检查设备名的合法性"><a href="#1-检查设备名的合法性" class="headerlink" title="1) 检查设备名的合法性"></a>1) 检查设备名的合法性</h3><p>从代码可以看出对于dev来说名字是一个非常重要的参数，首先使用 init_name 作为dev-&gt;kobj的名字同时将init_name设置为空，如果 init_name 初始为空则使用 “bus-&gt;dev_nam + dev-&gt;id” 作为dev-&gt;kobj的名字，<font color=color>如果设备没有设置名字则直接返回错误。</font></p>
<h3 id="2）在sys-创建文件目录的层次关系的创建"><a href="#2）在sys-创建文件目录的层次关系的创建" class="headerlink" title="2）在sys/创建文件目录的层次关系的创建"></a>2）在sys/创建文件目录的层次关系的创建</h3><p>下面列出所有可能出现的情况<br><strong>设备的bus为空，class为空，parent为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/xxx</span><br><span class="line">/sys/devices/xxx/power</span><br><span class="line">/sys/devices/xxx/uevent</span><br><span class="line">/sys/devices/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的bus为空，class为空，parent不为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/.../xxx-&gt;parent/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/power</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/dev <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/.../xxx-&gt;parent/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的bus不为空，class为空，parent为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/xxx</span><br><span class="line">/sys/devices/xxx/power</span><br><span class="line">/sys/devices/xxx/uevent</span><br><span class="line">/sys/devices/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* bus_add_device 创建下面目录 */</span></span><br><span class="line">/sys/bus/xxx-&gt;bus/devices/xxx ---&gt;/sys/devices/xxx	 <span class="comment">//指向设备</span></span><br><span class="line">/sys/devices/xxx/subsystem ---&gt; /sys/bus/xxx-&gt;bus <span class="comment">//指向所挂接的bus总线</span></span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和drv匹配成功创建下面目录</span></span><br><span class="line">/sys/devices/xxx/driver ---&gt; /sys/bus/drivers/xxx-&gt;driver/</span><br><span class="line">/sys/bus/drivers/xxx-&gt;driver/xxx ---&gt; /sys/devices/xxx</span><br></pre></td></tr></table></figure>
<p><strong>设备的bus不为空，class为空，parent不为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/devices/.../xxx-&gt;parent/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/power</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/of_node  <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* bus_add_device 创建下面目录 */</span></span><br><span class="line">/sys/bus/xxx-&gt;bus/devices/xxx ---&gt;/sys/devices/.../xxx-&gt;parent/xxx	 <span class="comment">//指向设备</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/subsystem ---&gt; /sys/bus/xxx-&gt;bus <span class="comment">//指向所挂接的bus总线</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/.../xxx-&gt;parent/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和drv匹配成功创建下面目录</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/xxx/driver ---&gt; /sys/bus/drivers/xxx-&gt;driver/</span><br><span class="line">/sys/bus/drivers/xxx-&gt;driver/xxx ---&gt; /sys/devices/.../xxx-&gt;parent/xxx</span><br></pre></td></tr></table></figure>
<p><strong>设备的 bus 为空，class 不为空，parent 为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dir-&gt;kobj使用xxx-&gt;class-&gt;name做名字</span></span><br><span class="line"></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/uevent</span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/of_node <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device_add_class_symlinks 创建下面目录 */</span></span><br><span class="line">/sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx/subsystem ---&gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">xxx</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span></span></span><br><span class="line"><span class="class">/<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">dev</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span> ---&gt;</span> /sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx</span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * .../dev-&gt;class-&gt;dev_kobj/&quot;major+minor&quot; ---&gt; /sys/devices/virtual/dir-&gt;kobj/xxx 有dev-&gt;class-&gt;dev_kobj和设备号的设备会创建这个节点</span></span><br><span class="line"><span class="comment"> * dev-&gt;class-&gt;dev_kobj 这个属性在class被注册的时候一般被默认设置为 sysfs_dev_char_kobj,即 /sys/dev/char节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/<span class="keyword">virtual</span>/dir-&gt;kobj/xxx <span class="comment">//有设备号会默认创建这个节点</span></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br></pre></td></tr></table></figure>
<p><strong>设备的 bus 为空，class 不为空，parent 不为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dir-&gt;kobj使用xxx-&gt;class-&gt;name做名字</span></span><br><span class="line"></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/uevent</span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/of_node <span class="comment">//如果存在设备树节点则创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device_add_class_symlinks 创建下面目录 */</span></span><br><span class="line">/sys/devices/.../xxx-&gt;parent/dir-&gt;kobj/xxx/subsystem ---&gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">xxx</span>-&gt;</span><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">/<span class="title">sys</span>/<span class="title">devices</span>/<span class="title">xxx</span>-&gt;</span>parent/dir-&gt;kobj/xxx/device ---&gt; dev-&gt;parent-&gt;kobj </span><br><span class="line">/sys/<span class="class"><span class="keyword">class</span>/<span class="title">dev</span>-&gt;</span><span class="class"><span class="keyword">class</span>/<span class="title">xxx</span> ---&gt;</span> /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx</span><br><span class="line"></span><br><span class="line">/sys/devices/xxx/dev  <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * .../dev-&gt;class-&gt;dev_kobj/&quot;major+minor&quot; ---&gt; /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx 有dev-&gt;class-&gt;dev_kobj和设备号的设备会创建这个节点</span></span><br><span class="line"><span class="comment"> * dev-&gt;class-&gt;dev_kobj 这个属性在class被注册的时候一般被默认设置为 sysfs_dev_char_kobj,即 /sys/dev/char节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">/sys/dev/<span class="keyword">char</span>/<span class="string">&quot;major+minor&quot;</span> ---&gt; /sys/devices/xxx-&gt;parent/dir-&gt;kobj/xxx <span class="comment">//有设备号会默认创建这个节点</span></span><br><span class="line"></span><br><span class="line">/dev/xxx <span class="comment">//有设备号的设备会创建这个节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么没有同时出现一个设备同时属于bus和class的情况，通过整理 device_add 创建的目录层次可以发现，bus(class)下的设备都会在注册的的时候在设备目录创建 subsystem ，这个链接文件指向bus(class)，同时也会在bus(class)目录创建指向设备的链接文件。在 <font color = blue>device_add_class_symlinks 函数和 bus_add_device 函数中都会在当前设备下创建 “subsystem” 这个属性文件</font>，很明显存在着冲突，这得出一个结论：<font color = red>内核在向bus注册设备的时候，如果设备同属于class和bus时，设备是无法注册的</font></p>
<h3 id="3）和挂接的bus上的所有drv进行匹配"><a href="#3）和挂接的bus上的所有drv进行匹配" class="headerlink" title="3）和挂接的bus上的所有drv进行匹配"></a>3）和挂接的bus上的所有drv进行匹配</h3><p>匹配流程如下</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">bus_probe_device</span>---&gt;</span></span><br><span class="line">   <span class="function"><span class="title">device_initial_probe</span>(dev) ---&gt;</span> <span class="comment">//如果bus-&gt;p-&gt;drivers_autoprobe被置位则调用这个函数</span></span><br><span class="line">      ---&gt; __device_attach(dev, <span class="literal">true</span>);</span><br><span class="line">               ---&gt; <span class="function"><span class="title">bus_for_each_drv</span>(dev-&gt;</span>bus, NULL, &amp;<span class="keyword">data</span>, __device_attach_driver); <span class="comment">//对于该bus上的每一个drv都调用__device_attach_driver函数</span></span><br><span class="line">                        ---&gt; __device_attach_driver(drv, <span class="keyword">data</span>) </span><br><span class="line">                                ---&gt; driver_match_device(drv, dev);</span><br><span class="line">                                         ---&gt; <span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>match(dev, drv)</span><br><span class="line">                                         ---&gt; driver_probe_device(drv, dev) <span class="comment">//如果匹配成功则调用这个函数</span></span><br><span class="line">                                                 ---&gt; really_probe(dev, drv);</span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">dev</span>-&gt;</span>driver = drv; <span class="comment">//将匹配成功的驱动赋值给对应的设备</span></span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe(dev) <span class="comment">//默认调用这个</span></span><br><span class="line">                                                         ---&gt; <span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">probe</span>(dev) //如果没有设置 dev-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe 函数，则调用这</span><br></pre></td></tr></table></figure>
<p><font color = red> dev在注册的时候会和所挂接bus上的所有drv进行匹配，即调用 drv-&gt;bus-&gt;match(dev, drv) 函数，如果匹配成功则调用所在总线上的probe函数，即 dev-&gt;bus-&gt;probe(dev) 函数 </font>, 从这里也可以看出匹配的规则是灵活的，它由总线决定，<font color = blue>由总线来决定设备和驱动的匹配规则</font>, 比如 platform 总线就规定了5种匹配规则，这里只是提一下，后面的platform设备详述。</p>
<h3 id="4）建立与字符设备的联系"><a href="#4）建立与字符设备的联系" class="headerlink" title="4）建立与字符设备的联系"></a>4）建立与字符设备的联系</h3><p>常用的字符设备就是通过&lt;/font color = red&gt;设备号</fong>与设备模型建立联系的，当我们在设备模型中注册一个dev时，如果存在设备号则会在/dev下创建对应的设备文件，我们可以通过这个文件的设备号，在已经注册的字符设备链表中查询到我们已经注册的字符设备。</p>
<h2 id="5、创建我们自己的设备"><a href="#5、创建我们自己的设备" class="headerlink" title="5、创建我们自己的设备"></a>5、创建我们自己的设备</h2><p>我们之前已经创建了一个my_bus总线，现在在这个基础之上再创建一个my_dev</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">my_dev</span> =</span> &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;my_dev&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_device_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_register(&amp;my_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_device_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_unregister(&amp;my_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_device_init);</span><br><span class="line">module_exit(my_device_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># ls</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># insmod /cache/my_device.ko</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># ls</span></span><br><span class="line">my_dev</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices <span class="comment"># cd my_dev/</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># ls</span></span><br><span class="line">power subsystem uevent</span><br></pre></td></tr></table></figure>
<h2 id="6、在dev下创建属性文件"><a href="#6、在dev下创建属性文件" class="headerlink" title="6、在dev下创建属性文件"></a>6、在dev下创建属性文件</h2><p>属性文件作为用户空间和内核空间交互的常用手段之一，它的重要性不言而喻。 device_register 在 device_initialize 中会将 ktype 初始化为 device_ktype </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">device_ktype</span> =</span> &#123;</span><br><span class="line">    .<span class="built_in">release</span>    = device_release,</span><br><span class="line">    .sysfs_ops  = &amp;dev_sysfs_ops,</span><br><span class="line">    .<span class="keyword">namespace</span>  = device_namespace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> <span class="title">dev_sysfs_ops</span> =</span> &#123;</span><br><span class="line">    .show   = dev_attr_show,</span><br><span class="line">    .store  = dev_attr_store,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到内核已经实现了 device_release 函数当dev引用计数为0时会自动释放掉自己。同样的内核也实现了属性文件中间层的函数 dev_attr_show 和 dev_attr_store</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ssize_t dev_attr_show(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *kobj, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *attr,</span><br><span class="line">                 <span class="built_in">char</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *dev_attr = to_dev_attr(attr); <span class="comment">//获取到更大的结构 device_attribute</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = kobj_to_dev(kobj);</span><br><span class="line">    ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev_attr-&gt;show)</span><br><span class="line">        ret = dev_attr-&gt;show(dev, dev_attr, buf); <span class="comment">//调用 device_attribute 的成员 show 函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= (ssize_t)PAGE_SIZE) &#123;</span><br><span class="line">        print_symbol(<span class="string">&quot;dev_attr_show: %s returned bad count\n&quot;</span>,</span><br><span class="line">                (unsigned long)dev_attr-&gt;show);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ssize_t dev_attr_store(<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span> *kobj, <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span> *attr,</span><br><span class="line">                  <span class="keyword">const</span> <span class="built_in">char</span> *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *dev_attr = to_dev_attr(attr); <span class="comment">//获取到更大的结构 device_attribute</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = kobj_to_dev(kobj);</span><br><span class="line">    ssize_t ret = -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev_attr-&gt;store)</span><br><span class="line">        ret = dev_attr-&gt;store(dev, dev_attr, buf, count);<span class="comment">//调用 device_attribute 的成员 store 函数</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span></span>    attr;</span><br><span class="line">    ssize_t (*show)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *attr,</span><br><span class="line">            <span class="built_in">char</span> *buf);</span><br><span class="line">    ssize_t (*store)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span></span> *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="built_in">char</span> *buf, size_t count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个框架看起来是不是很熟悉，其实前面我们自己在my_dir就已经实现了这个框架了，这里只是换了个壳而已，像前面的 bus，以及后面的 driver 等模型，内核已经帮我们实现了相关框架，我们只需要直接用就行了。创建属性结构的方法太麻烦了，没关系内核也为我们封装了快速创建并初始化 device_attribute 结构的宏了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个可读可写的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_show、name_store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个只读的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_show</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速创建一个只写的 device_attribute 属性结构 dev_attr_name</span></span><br><span class="line"><span class="comment"> * 属性操作函数为， name_store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_WO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name = <span class="constructor">__ATTR_WO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_ULONG_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_ulong</span>, <span class="params">device_store_ulong</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_INT_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_int</span>, <span class="params">device_store_int</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_BOOL_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_var</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> dev_ext_attribute dev_attr_##_name = \</span><br><span class="line">        &#123; <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">device_show_bool</span>, <span class="params">device_store_bool</span>)</span>, &amp;(_var) &#125;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DEVICE_ATTR_IGNORE_LOCKDEP(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> device_attribute dev_attr_##_name =      \</span><br><span class="line">        <span class="constructor">__ATTR_IGNORE_LOCKDEP(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br></pre></td></tr></table></figure>
<p>创建出了 device_attribute 结构，再调用 device_attribute 函数就可以在当前设备下快速创建属性文件。</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> device_create_file(struct device *<span class="built_in">dev</span>,</span><br><span class="line">               const struct device_attribute *<span class="built_in">attr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    if (<span class="built_in">dev</span>) &#123;</span><br><span class="line">        WARN(((<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.mode &amp; S_IWUGO) &amp;&amp; !<span class="built_in">attr</span>-&gt;store),</span><br><span class="line">            <span class="string">&quot;Attribute %s: write permission without &#x27;store&#x27;\n&quot;</span>,</span><br><span class="line">            <span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.name);</span><br><span class="line">        WARN(((<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.mode &amp; S_IRUGO) &amp;&amp; !<span class="built_in">attr</span>-&gt;<span class="built_in">show</span>),</span><br><span class="line">            <span class="string">&quot;Attribute %s: read permission without &#x27;show&#x27;\n&quot;</span>,</span><br><span class="line">            <span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>.name);</span><br><span class="line">        error = sysfs_create_file(&amp;<span class="built_in">dev</span>-&gt;kobj, &amp;<span class="built_in">attr</span>-&gt;<span class="built_in">attr</span>); <span class="comment">//注册属性文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create_file);</span><br></pre></td></tr></table></figure>
<p><strong>编程实现</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;linux/device.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/<span class="keyword">module</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/kernel.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/init.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/<span class="built_in">string</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/sysfs.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;linux/stat.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="constructor">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">extern <span class="keyword">struct</span> bus_type my_bus;</span><br><span class="line">extern <span class="keyword">struct</span> <span class="keyword">class</span> *my_class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> device my_dev = &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;my_dev&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ssize_t my<span class="constructor">_attr_show(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_attribute</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s\n&quot;</span>,attr-&gt;attr.name);</span><br><span class="line">    sprintf(buf, <span class="string">&quot;%s\n&quot;</span>, attr-&gt;attr.name);</span><br><span class="line">    return strlen((<span class="built_in">char</span>*)attr-&gt;attr.name) +<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t my<span class="constructor">_attr_store(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_attribute</span> <span class="operator">*</span><span class="params">attr</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">size_t</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s store : %s\n&quot;</span>,attr-&gt;attr.name, buf);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="constructor">DEVICE_ATTR(<span class="params">my_attr_test</span>, 0664, <span class="params">my_attr_show</span>, <span class="params">my_attr_store</span>)</span>;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> my<span class="constructor">_device_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device<span class="constructor">_register(&amp;<span class="params">my_dev</span>)</span>;</span><br><span class="line">    device<span class="constructor">_create_file(&amp;<span class="params">my_dev</span>,&amp;<span class="params">dev_attr_my_attr_test</span>)</span>; <span class="comment">//注意这里需要添加自己的前缀 dev_attr_</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void my<span class="constructor">_device_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device<span class="constructor">_unregister(&amp;<span class="params">my_dev</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">my_device_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">my_device_exit</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>cat自己创建出的设备节点</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># cat my_attr_test</span></span><br><span class="line">my_attr_test</span><br><span class="line">[  <span class="number">501.905519</span>] &lt;<span class="number">6</span>&gt;.(<span class="number">6</span>)[<span class="number">2845</span>:cat]my_attr_test <span class="regexp">//</span>内核打印</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>ehco自己创建的设备节点</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>devices/my_dev <span class="comment"># echo 123&gt;my_attr_test</span></span><br><span class="line">[  <span class="number">545.227562</span>] &lt;<span class="number">4</span>&gt;.(<span class="number">4</span>)[<span class="number">2821</span>:sh]my_attr_test store : <span class="number">123</span> <span class="regexp">//</span>内核打印</span><br></pre></td></tr></table></figure>
<h1 id="三、driver驱动"><a href="#三、driver驱动" class="headerlink" title="三、driver驱动"></a>三、driver驱动</h1><p>Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。而Linux内核中的驱动开发，基本都围绕该抽象进行（实现所规定的接口函数）。</p>
<h2 id="1、数据结构-2"><a href="#1、数据结构-2" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-device-driver"><a href="#1-device-driver" class="headerlink" title="1) device_driver"></a>1) device_driver</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *name;   <span class="comment">//名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span></span>     *bus; <span class="comment">//挂接的总线</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span></span>       *owner; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *mod_name;  <span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> suppress_bind_attrs;   <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span></span> probe_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span></span>   *of_match_table; <span class="comment">//用设备树匹配时，用于匹配设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span></span> *acpi_match_table;</span><br><span class="line"></span><br><span class="line">    int (*probe) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*remove) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    void (*shutdown) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*suspend) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, pm_message_t state);</span><br><span class="line">    int (*resume) (<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span></span> **groups;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span></span> *pm;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span></span> *p; <span class="comment">//保存相关链表，也保存了kobj</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-driver-private"><a href="#2-driver-private" class="headerlink" title="2) driver_private"></a>2) driver_private</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>          <span class="comment">// 用于创建 driver 所在目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span>   <span class="comment">// 用于链接匹配到的设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span>  <span class="comment">// 链接到bus-&gt;p-&gt;klist_drivers</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module_kobject</span> *<span class="title">mkobj</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span> <span class="comment">// 指向该结构的拥有者</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、driver的注册"><a href="#2、driver的注册" class="headerlink" title="2、driver的注册"></a>2、driver的注册</h2><p>相较于device的注册，driver的注册就比较简单</p>
<ol>
<li>在总线上查找drv，判断drv是否已经注册进bus，防止重复注册</li>
<li>调用bus_add_driver将drv注册进入bus</li>
<li>创建属性文件 drv-&gt;groups</li>
<li>向上层发送uevent事件，KOBJ_ADD</li>
</ol>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">int driver_register(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct device_driver *other;</span><br><span class="line"></span><br><span class="line">    BUG_ON(!<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>p);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> ((drv-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">probe</span> &amp;&amp; drv-&gt;</span>probe) ||</span><br><span class="line">        (<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">remove</span> &amp;&amp; drv-&gt;</span>remove) ||</span><br><span class="line">        (<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span><span class="function"><span class="title">shutdown</span> &amp;&amp; drv-&gt;</span>shutdown))</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">            <span class="string">&quot;bus_type methods\n&quot;</span>, <span class="function"><span class="title">drv</span>-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在总线上查找drv，判断drv是否已经注册进bus，防止重复注册</span></span><br><span class="line">    <span class="function"><span class="title">other</span> = driver_find(drv-&gt;</span><span class="function"><span class="title">name</span>, drv-&gt;</span>bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, <span class="function"><span class="title">drv</span>-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        return -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用bus_add_driver将drv注册进入bus</span></span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建属性文件 drv-&gt;groups</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = driver_add_groups(drv, drv-&gt;</span>groups);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向上层发送uevent事件，KOBJ_ADD</span></span><br><span class="line">    <span class="function"><span class="title">kobject_uevent</span>(&amp;drv-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bus_add_driver</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bus = bus_get(drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out_put_bus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化klist_devices</span></span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    priv-&gt;driver = drv; </span><br><span class="line">    drv-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">    priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset; <span class="comment">//初始化kest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于没有设置 parent 因此使用 bus-&gt;p-&gt;drivers_kset 做父节点，并在这里创建drv目录,</span></span><br><span class="line">    <span class="comment">// 从这里可以知道drv的根目录为 /sys/bus/drv-&gt;bus/drivers/</span></span><br><span class="line">    error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">                     <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_unregister;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将priv-&gt;knode_bus 链接进入priv-&gt;bus-&gt;p-&gt;klist_drivers</span></span><br><span class="line">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否可以自动probe,如果可以，则遍历klist_devices，对其中的每一个dev都调用drv-&gt;bus-&gt;match(dev, drv)函数</span></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123; </span><br><span class="line">        <span class="keyword">if</span> (driver_allows_async_probing(drv)) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: probing driver %s asynchronously\n&quot;</span>,</span><br><span class="line">                drv-&gt;bus-&gt;name, drv-&gt;name);</span><br><span class="line">            async_schedule(driver_attach_async, drv);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            error = driver_attach(drv);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">goto</span> out_unregister;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在drv所在目录创建属性文件 uevent</span></span><br><span class="line">    error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在drv所在目录创建属性文件 drv_groups</span></span><br><span class="line">    error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果支持 bind 则在 drv 所在目录创建属性文件 bind 和 unbind</span></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">        error = add_bind_files(drv);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">/* Ditto */</span></span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">                __func__, drv-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">    kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">    <span class="comment">/* drv-&gt;p is freed in driver_release()  */</span></span><br><span class="line">    drv-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">out_put_bus:</span><br><span class="line">    bus_put(bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、driver-register-总结"><a href="#3、driver-register-总结" class="headerlink" title="3、driver_register 总结"></a>3、driver_register 总结</h2><h3 id="1-在sys-创建对应节点"><a href="#1-在sys-创建对应节点" class="headerlink" title="1) 在sys/创建对应节点"></a>1) 在sys/创建对应节点</h3><p>bus_add_driver 会创建下面节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/sys/bus/xxx/drivers/drv-&gt;name</span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/uevent</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 支持 suppress_bind_attrs */</span></span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/unbind</span><br><span class="line">/sys/bus/xxx/drivers/drv-&gt;name/bind</span><br></pre></td></tr></table></figure>
<h3 id="2-匹配-bus-总线上的设备"><a href="#2-匹配-bus-总线上的设备" class="headerlink" title="2) 匹配 bus 总线上的设备"></a>2) 匹配 bus 总线上的设备</h3><p>除了创建节点之外，如果可以自动probe,如果可以，则遍历klist_devices，对其中的每一个dev都调用drv-&gt;bus-&gt;match(dev, drv)函数，如果匹配成功则调用really_probe(drv),在这个函数中默认先调用函数 dev-&gt;bus-&gt;probe(dev)，如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用 drv-&gt;probe(dev),调用流程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bus_add_driver----&gt;</span><br><span class="line">	driver_attach----&gt; 无论如何最终都会调用这个函数</span><br><span class="line">		bus_for_each_dev----&gt;</span><br><span class="line">			__driver_attach----&gt;</span><br><span class="line">				driver_match_device----&gt;</span><br><span class="line">					drv-&gt;bus-&gt;match(dev, drv) <span class="comment">//如果匹配成功则调用 really_probe</span></span><br><span class="line">					really_probe----&gt;</span><br><span class="line">						dev-&gt;bus-&gt;probe(dev) <span class="comment">//默认调用这个</span></span><br><span class="line">						drv-&gt;probe(dev) <span class="comment">//如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用这个</span></span><br></pre></td></tr></table></figure>
<h2 id="4、注册我们自己的驱动"><a href="#4、注册我们自己的驱动" class="headerlink" title="4、注册我们自己的驱动"></a>4、注册我们自己的驱动</h2><p>在我们创建的bus上注册我们自己的驱动</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">my_bus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_drv_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_drv_remove</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">my_drv</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_drv&quot;</span>,</span><br><span class="line">    .bus = &amp;my_bus,</span><br><span class="line">    .probe = my_drv_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_drv_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    driver_register(&amp;my_drv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    driver_unregister(&amp;my_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_drv_init);</span><br><span class="line">module_exit(my_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># ls</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># insmod /cache/my</span></span><br><span class="line">my_bus.ko       my_device.ko    my_driver.ko</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># insmod /cache/my_driver.ko</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># ls</span></span><br><span class="line">my_drv</span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment">#</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers <span class="comment"># cd my_drv/</span></span><br><span class="line">XF-X2:<span class="regexp">/sys/</span>bus<span class="regexp">/my_bus/</span>drivers/my_drv <span class="comment"># ls</span></span><br><span class="line">bind uevent unbind</span><br></pre></td></tr></table></figure>
<h2 id="5、在driver目录下创建属性文件"><a href="#5、在driver目录下创建属性文件" class="headerlink" title="5、在driver目录下创建属性文件"></a>5、在driver目录下创建属性文件</h2><p>和前面的device下创建属性文件相同，这里只给接口不再赘述</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> driver_attribute &#123;</span><br><span class="line">    <span class="keyword">struct</span> attribute attr;</span><br><span class="line">    ssize_t (*show)(<span class="keyword">struct</span> device_driver *driver, <span class="built_in">char</span> *buf);</span><br><span class="line">    ssize_t (*store)(<span class="keyword">struct</span> device_driver *driver, const <span class="built_in">char</span> *buf,</span><br><span class="line">             size_t count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">DRIVER_ATTR_WO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> driver_attribute driver_attr_##_name = <span class="constructor">__ATTR_WO(<span class="params">_name</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于在当前 driver 下创建属性文件</span></span><br><span class="line">extern <span class="built_in">int</span> __must_check driver<span class="constructor">_create_file(<span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">driver</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">driver_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除属性文件</span></span><br><span class="line">extern void driver<span class="constructor">_remove_file(<span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">driver</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">driver_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="四、class总线"><a href="#四、class总线" class="headerlink" title="四、class总线"></a>四、class总线</h1><p>用于管理同类的设备，常常被我们用来给上层开辟一个属性节点，多用于查看，修改对应的设备信息。</p>
<h2 id="1、数据结构-3"><a href="#1、数据结构-3" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-class"><a href="#1-class" class="headerlink" title="1) class"></a>1) class</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>      *name;                           <span class="comment">// class名称，用来初始化 subsys_private-&gt;susbus.kobj</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span></span>       *owner;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_attribute</span></span>      *class_attrs;       <span class="comment">// 默然属性文件指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的设备属性文件，当注册设备到该 class 上时，会自动在改设备下创建，即该 class 下的所有设备都会注册这个属性文件。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span></span>    **dev_groups;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示class下的设备在 /sys/dev 下的哪个目录，现在有两个目录 char 和 block 默认选择 char。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span></span>          *dev_kobj;              </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当class下的设备发生变化时，会调用class的uevent函数</span></span><br><span class="line">    int (*dev_uevent)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, <span class="class"><span class="keyword">struct</span> <span class="title">kobj_uevent_env</span></span> *env);</span><br><span class="line">    <span class="built_in">char</span> *(*devnode)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, umode_t *mode);</span><br><span class="line"></span><br><span class="line">    void (*class_release)(<span class="class"><span class="keyword">struct</span> <span class="title">class</span></span> *class);</span><br><span class="line">    void (*dev_release)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    int (*suspend)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev, pm_message_t state);</span><br><span class="line">    int (*resume)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line">    int (*shutdown)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span></span> *ns_type;</span><br><span class="line">    <span class="keyword">const</span> void *(*namespace)(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span></span> *pm;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span></span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-subsys-private-1"><a href="#2-subsys-private-1" class="headerlink" title="2) subsys_private"></a>2) subsys_private</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span>	 	  <span class="comment">// 该 class 在sysfs中的目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span>	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">// 保存上层的class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、函数接口"><a href="#2、函数接口" class="headerlink" title="2、函数接口"></a>2、函数接口</h2><h3 id="1-classes-init"><a href="#1-classes-init" class="headerlink" title="1) classes_init"></a>1) classes_init</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">classes_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    class_kset = kset_create_and_add(<span class="string">&quot;class&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//创建 /sys/class 节点</span></span><br><span class="line">    <span class="keyword">if</span> (!class_kset)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）class-create"><a href="#2）class-create" class="headerlink" title="2）class_create"></a>2）class_create</h3><p>用于在内核中创建一个 class</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> class_create(owner, name)       \</span></span><br><span class="line">(&#123;                      \</span><br><span class="line">    static <span class="keyword">struct</span> <span class="type">lock_class_key</span> __key; \</span><br><span class="line">    <span class="built_in">__class_create</span>(owner, name, &amp;__key);    \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">class</span> *<span class="built_in">__class_create</span>(struct module *owner, const char *name,</span><br><span class="line">                 struct lock_class_key *<span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">class</span> *<span class="keyword">cls</span>;</span><br><span class="line">    int retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态创建 class 结构</span></span><br><span class="line">    cls = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*cls), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">error</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cls</span>-&gt;name = name; <span class="comment">//初始化 name</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;owner = owner; <span class="comment">//初始化 owner</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;class_release = class_create_release; <span class="comment">//初始化 默认release函数</span></span><br><span class="line"></span><br><span class="line">    retval = <span class="built_in">__class_register</span>(cls, <span class="built_in">key</span>); <span class="comment">//注册class</span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">cls</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">error</span>:</span><br><span class="line">    <span class="built_in">kfree</span>(cls);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(retval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(__class_create);</span><br></pre></td></tr></table></figure>
<h4 id="a-class-register"><a href="#a-class-register" class="headerlink" title="a. __class_register"></a>a. __class_register</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">__class_register(<span class="params">struct</span> <span class="params">class</span> <span class="operator">*</span><span class="params">cls</span>, <span class="params">struct</span> <span class="params">lock_class_key</span> <span class="operator">*</span><span class="params">key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> subsys_private *cp;</span><br><span class="line">    <span class="built_in">int</span> error;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_debug(<span class="string">&quot;device class &#x27;%s&#x27;: registering\n&quot;</span>, <span class="params">cls</span>-&gt;<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="comment">//动态创建一个 subsys_private 结构</span></span><br><span class="line">    cp = kzalloc(sizeof(*cp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!cp)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    klist<span class="constructor">_init(&amp;<span class="params">cp</span>-&gt;<span class="params">klist_devices</span>, <span class="params">klist_class_dev_get</span>, <span class="params">klist_class_dev_put</span>)</span>;</span><br><span class="line">    <span class="constructor">INIT_LIST_HEAD(&amp;<span class="params">cp</span>-&gt;<span class="params">interfaces</span>)</span>;</span><br><span class="line">    kset<span class="constructor">_init(&amp;<span class="params">cp</span>-&gt;<span class="params">glue_dirs</span>)</span>;</span><br><span class="line">    <span class="constructor">__mutex_init(&amp;<span class="params">cp</span>-&gt;<span class="params">mutex</span>, <span class="string">&quot;subsys mutex&quot;</span>, <span class="params">key</span>)</span>;</span><br><span class="line">    error = kobject<span class="constructor">_set_name(&amp;<span class="params">cp</span>-&gt;<span class="params">subsys</span>.<span class="params">kobj</span>, <span class="string">&quot;%s&quot;</span>, <span class="params">cls</span>-&gt;<span class="params">name</span>)</span>; <span class="comment">//初始化 class 目录名</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(cp);</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the default /sys/dev directory for devices of this class */</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;dev_kobj)</span><br><span class="line">        cls-&gt;dev_kobj = sysfs_dev_char_kobj; <span class="comment">//设置子设备的默认类型为char</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_BLOCK)</span><br><span class="line">    <span class="comment">/* let the block class directory show up in the root of sysfs */</span></span><br><span class="line">    <span class="keyword">if</span> (!sysfs_deprecated<span class="operator"> || </span>cls != &amp;block_class)</span><br><span class="line">        cp-&gt;subsys.kobj.kset = class_kset;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    cp-&gt;subsys.kobj.kset = class_kset; <span class="comment">//设置kset为class_kset 即出现在 /sys/class/目录下 (一般是不会设置class的父kobj的，因此默认使用kset作为父kobj)</span></span><br><span class="line">#endif</span><br><span class="line">    cp-&gt;subsys.kobj.ktype = &amp;class_ktype; <span class="comment">//初始化class的默认ktype</span></span><br><span class="line">    cp-&gt;<span class="keyword">class</span> = cls; </span><br><span class="line">    cls-&gt;p = cp;</span><br><span class="line"></span><br><span class="line">    error = kset<span class="constructor">_register(&amp;<span class="params">cp</span>-&gt;<span class="params">subsys</span>)</span>; <span class="comment">//注册kset创建对应的class节点，/sys/class/xxx</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        kfree(cp);</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line">    error = add<span class="constructor">_class_attrs(<span class="params">class_get</span>(<span class="params">cls</span>)</span>); <span class="comment">//增加引用计数，创建默认属性文件</span></span><br><span class="line">    <span class="keyword">class</span><span class="constructor">_put(<span class="params">cls</span>)</span>;</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL_GPL(<span class="params">__class_register</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="b-device-create"><a href="#b-device-create" class="headerlink" title="b. device_create"></a>b. device_create</h4><p>在 class 下创建对应的设备，返回创建的设备结构。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">struct device *device_create(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">                 dev_t devt, void *drvdata, <span class="keyword">const</span> char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list vargs;</span><br><span class="line">    struct device *dev;</span><br><span class="line"></span><br><span class="line">    va_start(vargs, fmt);</span><br><span class="line">    dev = device_create_vargs(<span class="class"><span class="keyword">class</span>, <span class="type">parent</span>, <span class="type">devt</span>, <span class="type">drvdata</span>, <span class="type">fmt</span>, <span class="type">vargs);</span></span></span><br><span class="line">    va_end(vargs);</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create);</span><br><span class="line"></span><br><span class="line">struct device *device_create_vargs(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">                   dev_t devt, void *drvdata, <span class="keyword">const</span> char *fmt,</span><br><span class="line">                   va_list args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> device_create_groups_vargs(<span class="class"><span class="keyword">class</span>, <span class="type">parent</span>, <span class="type">devt</span>, <span class="type">drvdata</span>, <span class="type">NULL</span>,<span class="type"></span></span></span><br><span class="line">                      fmt, args);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create_vargs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct device *</span><br><span class="line">device_create_groups_vargs(struct <span class="class"><span class="keyword">class</span> *<span class="title">class</span>, <span class="type">struct device *parent</span>,<span class="type"></span></span></span><br><span class="line">               dev_t devt, void *drvdata,</span><br><span class="line">               <span class="keyword">const</span> struct attribute_group **groups,</span><br><span class="line">               <span class="keyword">const</span> char *fmt, va_list args)</span><br><span class="line">&#123;</span><br><span class="line">    struct device *dev = NULL;</span><br><span class="line">    int retval = -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">class</span> == <span class="title">NULL</span> || <span class="title">IS_ERR</span></span>(<span class="class"><span class="keyword">class</span>))</span></span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        goto error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    dev-&gt;devt = devt; <span class="comment">//设置设备号</span></span><br><span class="line">    dev-&gt;<span class="class"><span class="keyword">class</span> = <span class="title">class</span>; //设置设备所属的类</span></span><br><span class="line">    dev-&gt;parent = parent; <span class="comment">//设备的父节点</span></span><br><span class="line">    dev-&gt;groups = groups; <span class="comment">//设置设备的默认</span></span><br><span class="line">    dev-&gt;release = device_create_release;</span><br><span class="line">    dev_set_drvdata(dev, drvdata); <span class="comment">//设置设备的私有数据</span></span><br><span class="line"></span><br><span class="line">    retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    retval = device_add(dev); <span class="comment">//注册设备 </span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        goto error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>device_add 函数在前面已经有很详细的分析，这里不赘述，不过这里再补充说明一点，device_create 会在 /dev/ 目录下创建设备节点是因为设备有设备号，只要是<strong>调用 device_add 注册的设备，只要有设备号就会在 /dev/ 下创建设备节点</strong>,如果忘记的可以搜一搜 devtmpfs_create_node 这个函数，文章前面有提到这个函数</p>
<h2 id="4-属性操作接口"><a href="#4-属性操作接口" class="headerlink" title="4) 属性操作接口"></a>4) 属性操作接口</h2><p>属性文件是 class 重点内容，我们多用 class 来给上层提供接口，属性文件创建接口如下。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速创建 class_attribute</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">CLASS_ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR(<span class="params">_name</span>, <span class="params">_mode</span>, <span class="params">_show</span>, <span class="params">_store</span>)</span></span><br><span class="line">#define <span class="constructor">CLASS_ATTR_RW(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR_RW(<span class="params">_name</span>)</span></span><br><span class="line">#define <span class="constructor">CLASS_ATTR_RO(<span class="params">_name</span>)</span> \</span><br><span class="line">    <span class="keyword">struct</span> class_attribute class_attr_##_name = <span class="constructor">__ATTR_RO(<span class="params">_name</span>)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline <span class="built_in">int</span> __must_check <span class="keyword">class</span><span class="constructor">_create_file(<span class="params">struct</span> <span class="params">class</span> <span class="operator">*</span><span class="params">class</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">class_attribute</span> <span class="operator">*</span><span class="params">attr</span>)</span></span><br></pre></td></tr></table></figure>
<h1 id="五、platform设备"><a href="#五、platform设备" class="headerlink" title="五、platform设备"></a>五、platform设备</h1><p>在计算机中有这样一类设备，它们通过各自的设备控制器，直接和CPU连接，CPU可以通过常规的寻址操作访问它们（或者说访问它们的控制器）。这种连接方式，并不属于传统意义上的总线连接。但设备模型应该具备普适性，因此Linux就虚构了一条Platform Bus，供这些设备挂靠。</p>
<h2 id="1、数据结构-4"><a href="#1、数据结构-4" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><h3 id="1-platform-device"><a href="#1-platform-device" class="headerlink" title="1) platform_device"></a>1) platform_device</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *name;         <span class="comment">//设备名称</span></span><br><span class="line">    <span class="keyword">int</span>     id;</span><br><span class="line">    <span class="keyword">bool</span>        id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   <span class="title">dev</span>;</span>       <span class="comment">// 真正的设备，嵌入在platform_device中</span></span><br><span class="line">    u32     num_resources;     <span class="comment">// 设备资源数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver_override;     <span class="comment">// 如果设置了这个名字，这用这个名字匹配驱动，它的优先级最高</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>    <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-platform-driver"><a href="#2-platform-driver" class="headerlink" title="2) platform_driver"></a>2) platform_driver</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span></span> &#123;</span><br><span class="line">    int (*probe)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    int (*remove)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    void (*shutdown)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    int (*suspend)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *, pm_message_t state);</span><br><span class="line">    int (*resume)(<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span></span> driver;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span></span> *id_table;</span><br><span class="line">    <span class="built_in">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-resource"><a href="#3-resource" class="headerlink" title="3) resource"></a>3) resource</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-of-dev-auxdata"><a href="#4-of-dev-auxdata" class="headerlink" title="4) of_dev_auxdata"></a>4) of_dev_auxdata</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *compatible;</span><br><span class="line">    <span class="keyword">resource_size_t</span> phys_addr;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">void</span> *platform_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、platform-总线的构建"><a href="#2、platform-总线的构建" class="headerlink" title="2、platform 总线的构建"></a>2、platform 总线的构建</h2><p>platform总线是内核提供的虚拟总线，它个构建依赖于前面的，bus，device，driver设备模型。首先内核提供了一个名字叫”platform”的默认总线，它是一个全局结构并且被EXPORT_SYMBOL_GPL导出，如下</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">struct bus_type <span class="attr">platform_bus_type</span> = &#123;</span><br><span class="line">    .<span class="attr">name</span>       = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .<span class="attr">dev_groups</span> = platform_dev_groups,</span><br><span class="line">    .<span class="attr">match</span>      = platform_match,</span><br><span class="line">    .<span class="attr">uevent</span>     = platform_uevent,</span><br><span class="line">    .<span class="attr">pm</span>     = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus_type);</span><br></pre></td></tr></table></figure>
<p>除此之外内核也提供了该总线下的一个设备，名字叫做”platform_bus”</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> platform_bus = </span>&#123;</span><br><span class="line">    .init_name  = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus);</span><br></pre></td></tr></table></figure>
<p><font color=red>这是一个设备结构，并不是bus，虽然他的名字叫做 platform_bus</font>, 我也不知道为啥叫这个名字，第一次读我就以为这是个bus。它作为基本设备，它注册之后内核将会创建出如下节点</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>devices/platform</span><br></pre></td></tr></table></figure>
<p>platform_bus 的结构只初始化了一个名字，为什么要注册一个只有名字的设备在这里，我想是为了方便管理，将它作为以后platform设备的父设备，以后只要是platform设备，都将出现在/sys/devices/platform下，一眼就能找出那些事platform设备。<br>上述的 platform_bus_type 和 platform_bus 是在platform_bus_init 中被注册的，它被driver_init调用，即在内核启动的时候被创建。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __init platform_bus_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">error</span>;</span><br><span class="line"></span><br><span class="line">    early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">error</span> = device_register(&amp;platform_bus); <span class="comment">//创建platform总线</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">error</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">    <span class="keyword">error</span> =  bus_register(&amp;platform_bus_type); <span class="comment">//创建一个名为&quot;platform&quot;的设备</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">error</span>)</span><br><span class="line">        device_unregister(&amp;platform_bus);</span><br><span class="line">    of_platform_register_reconfig_notifier();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后但凡是注册在platform总线上的设备都叫做platform设备，注册在该总线上的驱动叫做platform驱动</p>
<h2 id="3、platform-设备接口"><a href="#3、platform-设备接口" class="headerlink" title="3、platform 设备接口"></a>3、platform 设备接口</h2><p>内核在开机时创建了platform总线，同时也提供了该总线相关操作函数</p>
<h3 id="1-platform-device-register"><a href="#1-platform-device-register" class="headerlink" title="1) platform_device_register"></a>1) platform_device_register</h3><p>使用这个函数注册一个platform设备</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> platform<span class="constructor">_device_register(<span class="params">struct</span> <span class="params">platform_device</span> <span class="operator">*</span><span class="params">pdev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line">#ifdef CONFIG_MTPROF</span><br><span class="line">    unsigned long long ts = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line">    <span class="constructor">TIME_LOG_START()</span>;</span><br><span class="line">    <span class="comment">//对pdev-&gt;dev做一些初始化</span></span><br><span class="line">    device<span class="constructor">_initialize(&amp;<span class="params">pdev</span>-&gt;<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="comment">// 空函数，啥也没干</span></span><br><span class="line">    arch<span class="constructor">_setup_pdev_archdata(<span class="params">pdev</span>)</span>;</span><br><span class="line">    <span class="comment">//真正的注册函数</span></span><br><span class="line">    ret = platform<span class="constructor">_device_add(<span class="params">pdev</span>)</span>;</span><br><span class="line">    <span class="constructor">TIME_LOG_END()</span>;</span><br><span class="line">    bootprof<span class="constructor">_pdev_register(<span class="params">ts</span>, <span class="params">pdev</span>)</span>;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的注册函数是 platform_device_add</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">int platform_device_add(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    int i, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pdev)</span><br><span class="line">        return -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!pdev-&gt;</span>dev.parent)</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>dev.parent = &amp;platform_bus; <span class="comment">//设置设备的父设备为platform_bus</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">pdev</span>-&gt;</span>dev.bus = &amp;platform_bus_type; <span class="comment">//设置bus为platform_bus_type</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">switch</span> (pdev-&gt;</span><span class="function"><span class="title">id</span>) &#123; 设置 pdev-&gt;</span><span class="function"><span class="title">dev</span>-&gt;</span>init_name </span><br><span class="line">    default:</span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s.%d&quot;, pdev-&gt;</span><span class="function"><span class="title">name</span>,  pdev-&gt;</span>id);</span><br><span class="line">        break;</span><br><span class="line">    case PLATFORM_DEVID_NONE:	<span class="comment">// -1</span></span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s&quot;, pdev-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        break;</span><br><span class="line">    case PLATFORM_DEVID_AUTO: 	<span class="comment">// -2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Automatically allocated device ID. We mark it as such so</span></span><br><span class="line"><span class="comment">         * that we remember it must be freed, and we append a suffix</span></span><br><span class="line"><span class="comment">         * to avoid namespace collision with explicit IDs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ret = ida_simple_get(&amp;platform_devid_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            goto err_out;</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id = ret;</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id_auto = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="title">dev_set_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, &quot;%s.%d.auto&quot;, pdev-&gt;</span><span class="function"><span class="title">name</span>, pdev-&gt;</span>id);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span> (i = 0; i &lt; pdev-&gt;</span>num_resources; i++) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> resource *p, *r = &amp;pdev-&gt;</span>resource[i];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (r-&gt;</span><span class="keyword">name</span> == NULL)</span><br><span class="line">            <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">name</span> = dev_name(&amp;pdev-&gt;</span>dev);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">p</span> = r-&gt;</span>parent;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resource_type(r) == IORESOURCE_MEM)</span><br><span class="line">                p = &amp;iomem_resource;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (resource_type(r) == IORESOURCE_IO)</span><br><span class="line">                p = &amp;ioport_resource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &amp;&amp; insert_resource(p, r)) &#123;</span><br><span class="line">            <span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">&quot;failed to claim resource %d\n&quot;</span>, i);</span><br><span class="line">            ret = -EBUSY;</span><br><span class="line">            goto failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;Registering platform device &#x27;%s&#x27;. Parent at %s\n&quot;</span>,</span><br><span class="line">         <span class="function"><span class="title">dev_name</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>), dev_name(pdev-&gt;</span>dev.parent));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向内核注册这个设备</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = device_add(&amp;pdev-&gt;</span>dev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line"> failed:</span><br><span class="line">    <span class="function"><span class="title">if</span> (pdev-&gt;</span>id_auto) &#123;</span><br><span class="line">        <span class="function"><span class="title">ida_simple_remove</span>(&amp;platform_devid_ida, pdev-&gt;</span>id);</span><br><span class="line">        <span class="function"><span class="title">pdev</span>-&gt;</span>id = PLATFORM_DEVID_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> resource *r = &amp;pdev-&gt;</span>resource[i];</span><br><span class="line">        <span class="function"><span class="title">if</span> (r-&gt;</span>parent)</span><br><span class="line">            release_resource(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> err_out:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数设置设备的父设备为platform_bus，以后凡是挂接在 platform 总线上的设备都将使用 platform_bus作为它的父设备。即所有的设备都将在下面目录生成</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/sys/</span>devices<span class="regexp">/platform/</span>xxx</span><br></pre></td></tr></table></figure>
<h3 id="2-platform-driver-register"><a href="#2-platform-driver-register" class="headerlink" title="2) platform_driver_register"></a>2) platform_driver_register</h3><p>同样内核也提供了platform驱动的注册函数</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line">    <span class="variable">__platform_driver_register</span>(drv, THIS_MODULE)</span><br><span class="line"></span><br><span class="line">int <span class="variable">__platform_driver_register</span>(struct platform_driver *drv,</span><br><span class="line">                struct module *<span class="built_in">owner</span>)</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.<span class="built_in">owner</span> = <span class="built_in">owner</span>;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.bus = &amp;platform_bus_type;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.probe = platform_drv_probe;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.remove = platform_drv_remove;</span><br><span class="line">    drv-&gt;<span class="built_in">driver</span>.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将驱动注册进总线</span></span><br><span class="line">    return driver_register(&amp;drv-&gt;<span class="built_in">driver</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(<span class="variable">__platform_driver_register</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出drv的，probe，rmove函数被分别初始化为platform_drv_probe，platform_drv_remove。最后调用driver_register将驱动注册进总线</p>
<p>对于platform设备的注册最后会调用，device_add，它最终会遍历platform_bus_type上所有的drv，并对每一个drv调用platform_match函数。</p>
<p>而对于platform_driver的注册会调用driver_register，它最终会遍历platform_bus_type上左右的dev，对每一个dev都调用platform_match函数。</p>
<p>像这种交叉遍历的方式在内核中很常见，input子系统中也使用这样的方式。也就是无论如何只要总线上有设备，驱动注册的时候就会去与之匹配，同理总线上有驱动，设备注册时就会去与之匹配。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> platform<span class="constructor">_match(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">drv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> platform_device *pdev = <span class="keyword">to</span><span class="constructor">_platform_device(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> platform_driver *pdrv = <span class="keyword">to</span><span class="constructor">_platform_driver(<span class="params">drv</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* when driver_override is set, only bind to the matching driver */</span></span><br><span class="line">	<span class="comment">/* 如果设置了driver_override，则匹配和driver_override相同名字的驱动 */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        return !strcmp(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attempt an of style match first，使用设备树方式匹配 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">of</span><span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then try acpi style match */</span></span><br><span class="line">	<span class="comment">/* 电源相关，跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi<span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then try to match against the id table */</span></span><br><span class="line">	<span class="comment">/* 如果设置了id_table, 则与id_table中的名字进行匹配 */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        return platform<span class="constructor">_match_id(<span class="params">pdrv</span>-&gt;<span class="params">id_table</span>, <span class="params">pdev</span>)</span> != null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">	<span class="comment">/* 比较驱动和设备的名称 */</span></span><br><span class="line">    return (strcmp(pdev-&gt;name, drv-&gt;name)<span class="operator"> == </span><span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个函数可以看出platform设备的匹配方式有 5 种，按照优先级如下：</p>
<ol>
<li>如果设置了driver_override，则匹配和driver_override相同名字的设备，它的优先级最高</li>
<li>使用设备树方式匹配，这是目前比较常用的方式之一</li>
<li>电源相关方式匹配</li>
<li>如果设置了id_table, 则与id_table中的名字进行匹配</li>
<li>最后比较驱动和设备的名称，也是比较常用的方式之一</li>
</ol>
<p>其中比较常用的是设备树和设备驱动名称进行匹配，下面详细分析一下设备树匹配流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">of_driver_match_device</span><span class="params">(struct device *dev, <span class="keyword">const</span> struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of_match_device(drv-&gt;of_match_table, dev) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> struct of_device_id *<span class="title">of_match_device</span><span class="params">(<span class="keyword">const</span> struct of_device_id *matches, <span class="keyword">const</span> struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!matches) || (!dev-&gt;of_node))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> of_match_node(matches, dev-&gt;of_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *__<span class="title">of_match_node</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">matches</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> <span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">best_match</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> score, best_score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!matches)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; matches-&gt;name[<span class="number">0</span>] || matches-&gt;type[<span class="number">0</span>] || matches-&gt;compatible[<span class="number">0</span>]; matches++) &#123;</span><br><span class="line">        score = __of_device_is_compatible(node, matches-&gt;compatible,</span><br><span class="line">                          matches-&gt;type, matches-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">            best_match = matches;</span><br><span class="line">            best_score = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __of_device_is_compatible(<span class="keyword">const</span> struct device_node *device,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *compat, <span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compatible match has highest priority */</span></span><br><span class="line">    <span class="keyword">if</span> (compat &amp;&amp; compat[<span class="number">0</span>]) &#123;</span><br><span class="line">        prop = __of_find_property(device, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>); <span class="comment">/* 查找 compatible 节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (cp = of_prop_next_string(prop, <span class="literal">NULL</span>); cp;</span><br><span class="line">			<span class="comment">//获取该节点的字符串</span></span><br><span class="line">             cp = of_prop_next_string(prop, cp), index++)  </span><br><span class="line">			&#123;</span><br><span class="line">			<span class="comment">//获得的字符串和compat进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (of_compat_cmp(cp, compat, <span class="built_in">strlen</span>(compat)) == <span class="number">0</span>) &#123;</span><br><span class="line">                score = INT_MAX/<span class="number">2</span> - (index &lt;&lt; <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!score)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Matching type is better than matching name */</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp;&amp; type[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!device-&gt;type || of_node_cmp(type, device-&gt;type))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        score += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Matching name is a bit better than not */</span></span><br><span class="line">    <span class="keyword">if</span> (name &amp;&amp; name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!device-&gt;name || of_node_cmp(name, device-&gt;name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        score++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看 of_device_id 这个结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    type[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    compatible[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们用到的是compatible作为匹配的对象，从结构看最对大支持的长度为128个字节。从上述代码可以看出匹配的过程就是匹配drv.id-&gt;compatible 和 dts中的compatible节点比较，hall的dts的节点如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hall: hall&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,hall-gpio-int&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在驱动中如下配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="comment">//创建一个 of_device_id 数组并初始化内部成员。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">hall_switch_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;mediatek,hall-gpio-int&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个platform_driver结构并对里面的driver结构进行初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">hall_driver</span> =</span> &#123;</span><br><span class="line">    .probe = hall_probe,</span><br><span class="line">    .suspend = hall_suspend,</span><br><span class="line">    .resume  = hall_resume,</span><br><span class="line">    .remove = ln4913_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">           .name = <span class="string">&quot;ln4913_Driver&quot;</span>,</span><br><span class="line">           .of_match_table = hall_switch_of_match,</span><br><span class="line">           &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出匹配其实是会遍历 hall_switch_of_match 数组中的compatible描述，也就是说一个驱动可以尝试匹配多个设备，直到匹配到为止。由前面的分析可知一旦匹配成功，就会调用really_probe函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---&gt; really_probe</span><br><span class="line">     ---&gt; dev-&gt;bus-&gt;probe(dev) <span class="comment">//默认点调用这个，明显platform_bus_type，没有设置prob函数</span></span><br><span class="line">     ---&gt; drv-&gt;probe(dev) <span class="comment">//如果没有设置 dev-&gt;bus-&gt;probe 函数，则调用这函数，platform 驱动在注册的时候呢，将其初始化为platform_drv_probe                                                                                                 </span></span><br></pre></td></tr></table></figure>
<p>来看看platform总线提供的probe函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_drv_probe</span><span class="params">(struct device *_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">drv</span> =</span> to_platform_driver(_dev-&gt;driver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span> =</span> to_platform_device(_dev);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = of_clk_set_defaults(_dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = dev_pm_domain_attach(_dev, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != -EPROBE_DEFER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">            ret = drv-&gt;probe(dev); <span class="comment">//最后调用platform_driver结构中的probe函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                dev_pm_domain_detach(_dev, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* don&#x27;t fail if just dev_pm_domain_attach failed */</span></span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;prevent_deferred_probe &amp;&amp; ret == -EPROBE_DEFER) &#123;</span><br><span class="line">        dev_warn(_dev, <span class="string">&quot;probe deferral not supported\n&quot;</span>);</span><br><span class="line">        ret = -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实最终调用了platform_driver结构中的probe函数。</p>
<p>除此之外匹配id也是常用的方式，匹配代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct platform_device_id *<span class="title">platform_match_id</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct platform_device_id *id,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, id-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">            pdev-&gt;id_entry = id;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、创建自己的-platform-设备"><a href="#4、创建自己的-platform-设备" class="headerlink" title="4、创建自己的 platform 设备"></a>4、创建自己的 platform 设备</h2><h3 id="1-用名字进行匹配"><a href="#1-用名字进行匹配" class="headerlink" title="1) 用名字进行匹配"></a>1) 用名字进行匹配</h3><p><strong>注册platform_device</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span>  <span class="title">my_platform_dev</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_platform&quot;</span>, <span class="comment">//名字要和驱动的名字一样</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_device_register(&amp;my_platform_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_device_register(&amp;my_platform_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_dev_init);</span><br><span class="line">module_exit(my_platform_dev_exit);</span><br></pre></td></tr></table></figure>
<p><strong>注册platform_driver</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;my_platform&quot;</span>, <span class="comment">//名字要和device一样</span></span><br><span class="line">              &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_drv_init);</span><br><span class="line">module_exit(my_platform_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">tb8768p1_64_bsp:</span>/cache <span class="meta"># insmod my_platform_drive.ko</span></span><br><span class="line"><span class="symbol">tb8768p1_64_bsp:</span>/cache <span class="meta"># insmod my_platform_device.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核打出my_platform_probe说明匹配成功</span></span><br><span class="line">[ <span class="number">2111.422598</span>] <span class="params">&lt;<span class="number">6</span>&gt;</span>.(<span class="number">5</span>)[<span class="number">3265</span>:insmod]my_platform_probe</span><br></pre></td></tr></table></figure>
<h3 id="2-用设备树方式匹配"><a href="#2-用设备树方式匹配" class="headerlink" title="2) 用设备树方式匹配"></a>2) 用设备树方式匹配</h3><p>dts增加配置</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">my_platform_dts:</span> <span class="class">my_platform_dts </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,my_platform&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注册platform_driver</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;baron&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_platform_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_platform_match</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;mediatek,my_platform&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;my_platform&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">                .of_match_table = my_platform_match,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">              &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_platform_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_platform_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_drv_init);</span><br><span class="line">module_exit(my_platform_drv_exit);</span><br></pre></td></tr></table></figure>
<p><strong>验证结果</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">XF-X2:/cache <span class="comment"># insmod my_platform_drive.ko </span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>加载模块时内核打印出probe</span><br><span class="line">[ <span class="number">1018.455974</span>] &lt;<span class="number">4</span>&gt;.(<span class="number">7</span>)[<span class="number">3165</span>:insmod]my_platform_probe</span><br></pre></td></tr></table></figure>
<h2 id="5、dts如何生成-platform设备"><a href="#5、dts如何生成-platform设备" class="headerlink" title="5、dts如何生成 platform设备"></a>5、dts如何生成 platform设备</h2><p>对于当前的内核，我们一般不会主动去创建一个 platform 设备，我们往往通过设备树的方式添加 platform 设备。 例如 i2c 设备的 dts 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    i2c0: i2c@<span class="number">11007000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">        id = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0</span> <span class="number">0x11007000</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">            &lt;<span class="number">0</span> <span class="number">0x11000080</span> <span class="number">0</span> <span class="number">0x80</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">81</span> IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">        clocks = &lt;&amp;infracfg_ao INFRACFG_AO_I2C0_CG&gt;,</span><br><span class="line">             &lt;&amp;infracfg_ao INFRACFG_AO_AP_DMA_CG&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;main&quot;</span>, <span class="string">&quot;dma&quot;</span>;</span><br><span class="line">        clock-div = &lt;<span class="number">5</span>&gt;;</span><br><span class="line">        mediatek,hs_only;</span><br><span class="line">        mediatek,skip_scp_sema;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该 dts 将会在内核中被解析为一个设备名为 11007000.i2c 的 platform 设备, 解析的规则是什么，跟着源码看一下</p>
<h3 id="1-of-platform-default-populate-init"><a href="#1-of-platform-default-populate-init" class="headerlink" title="1) of_platform_default_populate_init"></a>1) of_platform_default_populate_init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">of_platform_default_populate_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">/* Populate everything else. */</span></span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//解析设备树并创建对应的 platform 设备</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">arch_initcall_sync(of_platform_default_populate_init);</span><br></pre></td></tr></table></figure>
<h3 id="2-of-platform-default-populate"><a href="#2-of-platform-default-populate" class="headerlink" title="2) of_platform_default_populate"></a>2) of_platform_default_populate</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里对传入的参数进行注释</span></span><br><span class="line"><span class="comment">//root = NULL</span></span><br><span class="line"><span class="comment">//of_default_bus_match_table</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * const struct of_device_id of_default_bus_match_table[] = &#123;</span></span><br><span class="line"><span class="comment"> *     &#123; .compatible = &quot;simple-bus&quot;, &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; .compatible = &quot;simple-mfd&quot;, &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; .compatible = &quot;isa&quot;, &#125;,</span></span><br><span class="line"><span class="comment"> * #ifdef CONFIG_ARM_AMBA</span></span><br><span class="line"><span class="comment"> *     &#123; .compatible = &quot;arm,amba-bus&quot;, &#125;,</span></span><br><span class="line"><span class="comment"> * #endif /* CONFIG_ARM_AMBA */</span></span><br><span class="line"> *     &#123;&#125; <span class="comment">/* Empty terminated list */</span></span><br><span class="line"> * &#125;;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//lookup = NULL</span></span><br><span class="line"><span class="comment">//parent = NULL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_platform_default_populate</span><span class="params">(struct device_node *root,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> struct of_dev_auxdata *lookup,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct device *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of_platform_populate(root, of_default_bus_match_table, lookup,</span><br><span class="line">                    parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-of-platform-populate"><a href="#3-of-platform-populate" class="headerlink" title="3) of_platform_populate"></a>3) of_platform_populate</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">int of_platform_populate(<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *root,</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span></span> *matches,</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span></span> *lookup,</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *child;</span><br><span class="line">    int rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// root为空返回根节点</span></span><br><span class="line">    root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;%s()\n&quot;</span>, __func__);</span><br><span class="line">    pr_debug(<span class="string">&quot; starting at: %pOF\n&quot;</span>, root);</span><br><span class="line"></span><br><span class="line">    for_each_child_of_node(root, child) &#123; <span class="comment">//对根节点下的每一个二级节点调用 of_platform_bus_create</span></span><br><span class="line">        rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            of_node_put(child);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">    of_node_put(root);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-of-platform-bus-create"><a href="#4-of-platform-bus-create" class="headerlink" title="4) of_platform_bus_create"></a>4) of_platform_bus_create</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">of_platform_bus_create</span><span class="params">(struct device_node *bus,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct of_device_id *matches,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct of_dev_auxdata *lookup,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct device *parent, <span class="keyword">bool</span> strict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span> *<span class="title">auxdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bus_id = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">void</span> *platform_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure it has a compatible property */</span></span><br><span class="line">    <span class="keyword">if</span> (strict &amp;&amp; (!of_get_property(bus, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>))) &#123; <span class="comment">//检测当前节点是否有 compatible 属性</span></span><br><span class="line">        pr_debug(<span class="string">&quot;%s() - skipping %pOF, no compatible prop\n&quot;</span>,</span><br><span class="line">             __func__, bus);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_node_check_flag(bus, OF_POPULATED_BUS)) &#123;             <span class="comment">// 检测标志位防止重复注册</span></span><br><span class="line">        pr_debug(<span class="string">&quot;%s() - skipping %pOF, already populated\n&quot;</span>,</span><br><span class="line">            __func__, bus);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auxdata = of_dev_lookup(lookup, bus); <span class="comment">// lookup 为 NULL 这里返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (auxdata) &#123;</span><br><span class="line">        bus_id = auxdata-&gt;name;</span><br><span class="line">        platform_data = auxdata-&gt;platform_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_device_is_compatible(bus, <span class="string">&quot;arm,primecell&quot;</span>)) &#123; <span class="comment">//从注释可以看出这里只是为了兼容老的设备树文件</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Don&#x27;t return an error here to keep compatibility with older</span></span><br><span class="line"><span class="comment">         * device tree files.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//真正的 platform 设备创建函数</span></span><br><span class="line">    dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">	<span class="comment">////注意这里会和 dts节点进行匹配，如果匹配不上则会直接返回，因此一般情况下，是不会注册三级节点为设备节点</span></span><br><span class="line">    <span class="keyword">if</span> (!dev || !of_match_node(matches, bus)) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for_each_child_of_node(bus, child) &#123; <span class="comment">//遍历bus的子节点回调 of_platform_bus_create 创建对应的 platform 设备</span></span><br><span class="line">        pr_debug(<span class="string">&quot;   create child: %pOF\n&quot;</span>, child);</span><br><span class="line">        rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            of_node_put(child);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-of-platform-device-create-pdata"><a href="#5-of-platform-device-create-pdata" class="headerlink" title="5) of_platform_device_create_pdata"></a>5) of_platform_device_create_pdata</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct platform_device *<span class="title">of_platform_device_create_pdata</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *bus_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *platform_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct device *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测 dts 中的 status 属性是否为ture，默认为ture</span></span><br><span class="line">    <span class="comment">//检测 OF_POPULATED 防止重复注册</span></span><br><span class="line">    <span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">        of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态创建一个 platform_device 并做简单初始化</span></span><br><span class="line">    <span class="comment">// 检测该设备的 resources 并做相应的初始化</span></span><br><span class="line">    <span class="comment">// 初始化设备的设备节点，如果该设备节点不存在 reg 属性则使用 np-&gt;parent 作为其父设备</span></span><br><span class="line">    <span class="comment">// 如果有设备节点有 reg 属性则使用 &quot;addr.node-&gt;name&quot; 作为该设备的名字,否则使用 &quot;node-&gt;full_name&quot; 作为设备名</span></span><br><span class="line">    dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">    <span class="keyword">if</span> (!dev)</span><br><span class="line">        <span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">    dev-&gt;dev.bus = &amp;platform_bus_type; 	             <span class="comment">//初始化总线类型</span></span><br><span class="line">    dev-&gt;dev.platform_data = platform_data;          <span class="comment">//初始化私有数据这里为NULL</span></span><br><span class="line">    of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123; <span class="comment">//注册 platform 设备</span></span><br><span class="line">        platform_device_put(dev);</span><br><span class="line">        <span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">    of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-of-device-alloc"><a href="#6-of-device-alloc" class="headerlink" title="6) of_device_alloc"></a>6) of_device_alloc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态创建一个 platform_device 并做简单初始化</span></span><br><span class="line"><span class="comment">// 检测该设备的 resources 并做相应的初始化</span></span><br><span class="line"><span class="comment">// 初始化设备的设备节点，如果该设备节点不存在 reg 属性则使用 np-&gt;parent 作为其父设备</span></span><br><span class="line"><span class="comment">// 如果有设备节点有 reg 属性则使用 &quot;addr.node-&gt;name&quot; 作为该设备的名字,否则使用 &quot;node-&gt;full_name&quot; 作为设备名</span></span><br><span class="line"><span class="function">struct platform_device *<span class="title">of_device_alloc</span><span class="params">(struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">char</span> *bus_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct device *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> rc, i, num_reg = <span class="number">0</span>, num_irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>, <span class="title">temp_res</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//动态创建一个 platform_device 并做简单初始化</span></span><br><span class="line">    dev = platform_device_alloc(<span class="string">&quot;&quot;</span>, PLATFORM_DEVID_NONE);</span><br><span class="line">    <span class="keyword">if</span> (!dev)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* count the io and irq resources */</span></span><br><span class="line">	<span class="comment">//检测该设备的 resources 并做相应的初始化</span></span><br><span class="line">    <span class="keyword">while</span> (of_address_to_resource(np, num_reg, &amp;temp_res) == <span class="number">0</span>)</span><br><span class="line">        num_reg++;</span><br><span class="line">    num_irq = of_irq_count(np);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Populate the resource table */</span></span><br><span class="line">    <span class="keyword">if</span> (num_irq || num_reg) &#123;</span><br><span class="line">        res = kzalloc(<span class="keyword">sizeof</span>(*res) * (num_irq + num_reg), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            platform_device_put(dev);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dev-&gt;num_resources = num_reg + num_irq;</span><br><span class="line">        dev-&gt;resource = res;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_reg; i++, res++) &#123;</span><br><span class="line">            rc = of_address_to_resource(np, i, res);</span><br><span class="line">            WARN_ON(rc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (of_irq_to_resource_table(np, res, num_irq) != num_irq)</span><br><span class="line">            pr_debug(<span class="string">&quot;not all legacy IRQ resources mapped for %s\n&quot;</span>,</span><br><span class="line">                 np-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;dev.of_node = of_node_get(np);           <span class="comment">// 初始化并增加设备节点引用计数</span></span><br><span class="line">    dev-&gt;dev.fwnode = &amp;np-&gt;fwnode;                </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有父设备则使用 platform_bus 作为父设备，前面整个过程都没有设置父设备</span></span><br><span class="line">    <span class="comment">// 因此 dts 解析出来的设备将全部位于 /sys/devices/platform/ 下</span></span><br><span class="line">    dev-&gt;dev.parent = parent ? : &amp;platform_bus;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus_id) <span class="comment">//bus_id = NULL 因此调用 of_device_make_bus_id 设置设备名</span></span><br><span class="line">        dev_set_name(&amp;dev-&gt;dev, <span class="string">&quot;%s&quot;</span>, bus_id);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        of_device_make_bus_id(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(of_device_alloc);</span><br></pre></td></tr></table></figure>
<h3 id="7-of-device-make-bus-id"><a href="#7-of-device-make-bus-id" class="headerlink" title="7) of_device_make_bus_id"></a>7) of_device_make_bus_id</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果有设备节点有 reg 属性则使用 &quot;addr.node-&gt;name&quot; 作为该设备的名字</span></span><br><span class="line"><span class="comment">// 如果设备节点没有 reg 属性则使用 node-&gt;full_name 作为设备名，同时设置 node = node-&gt;parent</span></span><br><span class="line">static void <span class="keyword">of</span><span class="constructor">_device_make_bus_id(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> device_node *node = dev-&gt;of_node;</span><br><span class="line">    const __be32 *reg;</span><br><span class="line">    u64 addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct the name, using parent nodes if necessary to ensure uniqueness */</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the address can be translated, then that is as much</span></span><br><span class="line"><span class="comment">         * uniqueness as we need. Make it the first component and return</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        reg = <span class="keyword">of</span><span class="constructor">_get_property(<span class="params">node</span>, <span class="string">&quot;reg&quot;</span>, NULL)</span>; <span class="comment">//获取 reg 属性</span></span><br><span class="line">        <span class="keyword">if</span> (reg<span class="operator"> &amp;&amp; </span>(addr = <span class="keyword">of</span><span class="constructor">_translate_address(<span class="params">node</span>, <span class="params">reg</span>)</span>) != OF_BAD_ADDR) &#123; <span class="comment">//将 reg 表示的物理地址解析出来赋值给 addr</span></span><br><span class="line">            <span class="comment">//如果解析成功则使用 &quot;addr.node-&gt;name&quot; 作为该设备的名字</span></span><br><span class="line">            dev<span class="constructor">_set_name(<span class="params">dev</span>, <span class="params">dev_name</span>(<span class="params">dev</span>)</span> ? <span class="string">&quot;%llx.%s:%s&quot;</span> : <span class="string">&quot;%llx.%s&quot;</span>,</span><br><span class="line">                     (unsigned long long)addr, node-&gt;name,</span><br><span class="line">                     dev<span class="constructor">_name(<span class="params">dev</span>)</span>);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* format arguments only used if dev_name() resolves to NULL */</span></span><br><span class="line">        <span class="comment">// 如果没有 reg 属性则使用 node-&gt;full_name 作为设备名</span></span><br><span class="line">        dev<span class="constructor">_set_name(<span class="params">dev</span>, <span class="params">dev_name</span>(<span class="params">dev</span>)</span> ? <span class="string">&quot;%s:%s&quot;</span> : <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                 kbasename(node-&gt;full_name), dev<span class="constructor">_name(<span class="params">dev</span>)</span>);</span><br><span class="line">        node = node-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8) 总结"></a>8) 总结</h3><ul>
<li>只要dts中的节点有 compatible 属性，将会在内核中将该节点转换为 platform 设备，该设备将出现在 /sys/devices/platform/ 下</li>
<li>如果有设备节点有 reg 属性则使用 “addr.node-&gt;name” 作为该设备的名字</li>
<li>如果设备节点没有 reg 属性则使用 node-&gt;full_name 作为设备名，同时设置 node = node-&gt;parent</li>
</ul>
]]></content>
      <tags>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动-i2c</title>
    <url>/2020/11/23/linux%E9%A9%B1%E5%8A%A8-i2c%E6%A1%86%E6%9E%B6-%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本文借助mtk平台分析linux的i2c框架，mtk平台mt6765，内核版本kernel-4.9，本文只分析linux的i2c框架，不讨论i2c总线协议相关内容.</p>
<a id="more"></a>

<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><h2 id="1、i2c-client"><a href="#1、i2c-client" class="headerlink" title="1、i2c_client"></a>1、i2c_client</h2><p>具体的i2次设备的软件抽象，它拥有所有i2c次设备的信息：</p>
<ol>
<li>包括i2c总线(物理总线)的控制器的硬件描述信息，这些信息通过结构 adapter 来进行描述</li>
<li>以及具体设备的addr信息，中断，以及name，这些信息通过结构 i2c_board_info 来进行描述</li>
</ol>
<p>i2c_client这个结构被注册时候就被注册到 i2c bus 上了，因此我们可以利用 i2c bus 获取到这个结构</p>
<blockquote>
<p><font color = red>说明：i2c有两个总线的概念，一个是设备模型中虚拟的i2c总线，另一个则是实际的物理上的i2c总线，在不说明的情况下默认设备模型中的虚拟总线。</font></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> flags;      <span class="comment">//i2c通信标志位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> addr;       <span class="comment">//次设备，i2c地址7位地址位，flags+addr组成8位地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[I2C_NAME_SIZE];	  <span class="comment">//设备名称，i2c_board_info 的 type 成员，driver 匹配时会用到该名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>  <span class="comment">//指向挂接的总线上的控制器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>      <span class="comment">//设备模型dev结构</span></span><br><span class="line">    <span class="keyword">int</span> irq;                <span class="comment">//用到的中断号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">i2c_slave_cb_t</span> slave_cb; <span class="comment">/* callback for slave mode  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2、i2c-adapter"><a href="#2、i2c-adapter" class="headerlink" title="2、i2c_adapter"></a>2、i2c_adapter</h2><p>i2c适配器，adapter翻译过来就是适配器的意思，这个结构描述了硬件上的i2c总线的控制器信息，<font color = red><strong>注意不是我们理解的设备模型上虚拟的i2c总线，而是实实在在的接在cpu上面的硬件i2c总线的控制器信息</strong></font></p>
<p>其中 algo 链接着该总线的i2c通信相关结构 i2c_algorithm 。 按理来讲通信方式也是总线控制器的一部分为什么要将其分离出来，这样做是为了代码的复用性，如果系统有6个i2c总线则需要写6个通信接口，而区别往往只是一些和控制器某些寄存器的值不同而已，为了提高代码的效率，于是将 i2c_algorithm 独立出来作为一个共有的模块。</p>
<p>很明显作为总线控制器的描述，i2c_adapter 不会描述具体的设备信息，具体的设备信息由中间结构 i2c_board_info 描述，并将其存入 i2c_client 结构。</p>
<p>从上面的描述可以知道 i2c 适配器的数量其实是固定的，硬件有多少个 i2c 总线，就会有多少个 i2c 适配器，例如 mt6765 有6个物理的i2c总线i2c0-i2c6，因此mt6765就有6个i2c适配器。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>       <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">//i2c通信接口</span></span><br><span class="line">    <span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices   */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     i2c总线访问（发送或者接收数据）在传输失败的时候，可以选择重试。retries表示从试的次数。</span></span><br><span class="line"><span class="comment">     另外，有些设备对结果的返回是有时间要求的，因此不能无节制的重试，</span></span><br><span class="line"><span class="comment">     timeout字段（单位为jiffies）在retries基础上，增加了时间限制，超过这个时间，就不能重试了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> timeout;	<span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">int</span> retries;    <span class="comment">//重复次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>  <span class="comment">//设备模型dev，用于在sys/生成目录结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr;	<span class="comment">//i2c总线号，例如，0代表使用i2c0，这个不是我们所说的设备模型里面的i2c总线，是cpu中的i2c物理总线号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">48</span>]; <span class="comment">//adapter的名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span> <span class="comment">//用于管理用户空间创建的i2c设备</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通信方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 作为主设备时的通信函数 *</span></span><br><span class="line"><span class="comment">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);</span></span><br><span class="line"><span class="comment">	/* 作为从设备时的通信函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">int</span> (*reg_slave)(struct i2c_client *client);</span><br><span class="line">    <span class="keyword">int</span> (*unreg_slave)(struct i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3、i2c-board-info"><a href="#3、i2c-board-info" class="headerlink" title="3、i2c_board_info"></a>3、i2c_board_info</h2><p>这个结构用于描述具体的i2c设备的硬件信息，设备地址，通信方式，中断号等。</p>
<ol>
<li>当使用dts创建 i2c_client 时，它作为中间结构，当他把硬件信息传递给真正的设备结构 i2c_client，它的使命也就完成了，dts中的设备信息先在内核中转换为 i2c_board_info 这个结构，然后通过这个结构传给 i2c_client 。</li>
<li>当使用老式的使用总线号创建 i2c_client时，所有的由 i2c_register_board_info 动态创建的 i2c_board_info 描述的设备信息将被链接到 __i2c_board_list 链表进行维护，在加载内核时查询 __i2c_board_list 将 i2c_board_info 描述的信息传给 i2c_client</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>        type[I2C_NAME_SIZE]; <span class="comment">//i2c设备设名称，将被设置到client-&gt;name</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  addr; <span class="comment">//设备地址</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span> <span class="comment">//设备节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span></span><br><span class="line">    <span class="keyword">int</span>     irq; <span class="comment">//中断号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4、i2c-driver"><a href="#4、i2c-driver" class="headerlink" title="4、i2c_driver"></a>4、i2c_driver</h2><p>该结构用来描述虚拟 i2c bus 总线上的 driver ，通过向 i2c bus 注册该结构进行匹配，获取对应的 i2c_client</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_driver &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">     * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;  <span class="comment">//这个方法已经被过时，不应该被使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *); <span class="comment">//当匹配到i2c_client时调用这个函数</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *); <span class="comment">//和probe相反</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">     * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">     * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">     * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">     * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">     * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">     * with the device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> device_driver driver; <span class="comment">//设备模型中的device_driver结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *id_table; <span class="comment">//指向用来和i2c总线上的i2c_client进行匹配的一组 name </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">    <span class="keyword">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *); <span class="comment">//动态扫描的方式注册i2c_client, linux并不推荐这种方式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *address_list; <span class="comment">//动态扫描时使用的一组地址</span></span><br><span class="line">    <span class="keyword">struct</span> list_head clients;  <span class="comment">//用于链接detect动态扫描生成的设备。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5、i2c-device-id"><a href="#5、i2c-device-id" class="headerlink" title="5、i2c_device_id"></a>5、i2c_device_id</h2><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">struct i2c_device_id &#123;</span><br><span class="line">    <span class="function"><span class="title">char</span> <span class="keyword">name</span>[I2C_NAME_SIZE]; //用于匹配的<span class="keyword">name</span>，这个<span class="keyword">name</span>将去匹配 i2c_client-&gt;</span><span class="keyword">name</span></span><br><span class="line">    kernel_ulong_t driver_data; <span class="comment">/* 用于保存驱动的私有数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6、i2c-msg"><a href="#6、i2c-msg" class="headerlink" title="6、i2c_msg"></a>6、i2c_msg</h2><p>linux的i2c通信是以 i2c_msg 作为操作单位</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    <span class="variable">__u16</span> addr; 	<span class="comment">//设备地址</span></span><br><span class="line">    <span class="variable">__u16</span> flags;	<span class="comment">//传输标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD        0x0001  <span class="comment">//设置了这个表示表示本次通信为接收数据，否则为发送数据。</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">//设置了这个表示从设备地址有10bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN      0x0400  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">//在读操作中不需要ack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">//当前i2cmsg忽略i2c器件的ack和nack信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">//读写标志位反过来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">//当前i2c_msg不发送start信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    <span class="variable">__u16</span> len;      <span class="comment">//数据长度，单位为byte</span></span><br><span class="line">    <span class="variable">__u8</span> *buf;      <span class="comment">//数据缓冲区指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="三、内核i2c驱动框架"><a href="#三、内核i2c驱动框架" class="headerlink" title="三、内核i2c驱动框架"></a>三、内核i2c驱动框架</h1><p>li2c总线的硬件结构一般如下图所示</p>
<div align=left> <img width=800 src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/4.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605171541;10245085141&q-key-time=1605171541;10245085141&q-header-list=&q-url-param-list=&q-signature=f24cd44d860eae2aa76aaf53aaaba7c7a9aaa151" > </div>

<p>cpu作为主设备挂接在所有总线上，而对应的设备根据硬件设计挂接在相应的总线上。图所示gsensor挂接在i2c0上，camera挂接在i2c1上，tp挂接在i2c2上。硬件结构非常简单，而linux的实现相对而言复杂度还是蛮高的，向上面的i2c设备 gsensor、camera、tp 等对于总线来讲只是地址上的不同而已，本质上都是i2c设备没有什么不同。 linux-4.9提供6种添加i2c设备的方法，参考 Documentation/i2c/instantiating-devices，下面逐一讨论。</p>
<h2 id="1、使用dts添加i2c设备"><a href="#1、使用dts添加i2c设备" class="headerlink" title="1、使用dts添加i2c设备"></a>1、使用dts添加i2c设备</h2><p>只需在dts文件中添加i2c设备相关节点，内核就会自动创建对应的  i2c_client 结构。 例如:添加两个设备 24c256、pca9532以以100kHz的速度连接到i2c1总线。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">i2c1:</span> <span class="class">i2c@400a0000 </span>&#123;</span><br><span class="line">    <span class="comment">/* ... master properties skipped ... */</span></span><br><span class="line">    clock-frequency = <span class="params">&lt;<span class="number">100000</span>&gt;</span>; <span class="comment">//100KHZ</span></span><br><span class="line"></span><br><span class="line">    <span class="class">flash@50 </span>&#123;</span><br><span class="line">        compatible = <span class="string">&quot;atmel,24c256&quot;</span>;</span><br><span class="line">        reg = <span class="params">&lt;<span class="number">0x50</span>&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">    pca9532:</span> <span class="class">gpio@60 </span>&#123;</span><br><span class="line">        compatible = <span class="string">&quot;nxp,pca9532&quot;</span>;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">        reg = <span class="params">&lt;<span class="number">0x60</span>&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样内核在加载的时候就会自动创建出 name 为 24c256 和 pca9532 的i2c_client结构并将其注册进入i2c bus。它的流程如下所示：</p>
<div align=left> <img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/i2c/i2c%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6dts.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1605671309;10245584909&q-key-time=1605671309;10245584909&q-header-list=&q-url-param-list=&q-signature=6d339c3be8f9cb9e5dc2ab4b199e9f70b72450fc" > </div>

<p>上图展示了整个注册流程，对于驱动工程师来讲非常简单，只需在dts中填充对应的信息就行了。而内核却帮我我们完成了一系类注册流程。而作为驱动工程师不仅仅要做到知其然，还要知其所以然，下面以mtk平台为例分析整个注册流程。</p>
<p>源码路径drivers/i2c/busses/i2c-mtk.c，ic原厂提供i2c函数都被放在drivers/i2c/busses/这个目录</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static s32 __init mt<span class="constructor">_i2c_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_MTK_I2C_ARBITRATION</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = enable<span class="constructor">_arbitration()</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Cannot enalbe arbitration.\n&quot;</span>)</span>;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!map<span class="constructor">_dma_regs()</span>)</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Mapp dma regs successfully.\n&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mt<span class="constructor">_i2c_parse_comp_data()</span>)</span><br><span class="line">        pr<span class="constructor">_info(<span class="string">&quot;Get compatible data from dts successfully.\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_info(<span class="string">&quot; mt_i2c_init driver as platform device\n&quot;</span>)</span>;</span><br><span class="line">    return platform<span class="constructor">_driver_register(&amp;<span class="params">mt_i2c_driver</span>)</span>; <span class="comment">//向内核注册 mt_i2c_driver </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码向内核注册了一个名叫 “mt-i2c” 的 platform 驱动</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_DRV_NAME           <span class="meta-string">&quot;mt-i2c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mtk_i2c_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;mediatek,i2c&quot;</span>, .data = &amp;i2c_common_compat&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mt_i2c_driver</span> =</span> &#123;</span><br><span class="line">    .probe = mt_i2c_probe,</span><br><span class="line">    .<span class="built_in">remove</span> = mt_i2c_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = I2C_DRV_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .pm = &amp;mt_i2c_dev_pm_ops,</span><br><span class="line">        .of_match_table = of_match_ptr(mtk_i2c_of_match),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到它 match 的设备的 compatible 字段是 “mediatek,i2c” ，于是在dts中找对应的设备节点。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">i2c0:</span> <span class="class">i2c0@11007000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">0</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c1:</span> <span class="class">i2c1@11008000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">1</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c2:</span> <span class="class">i2c2@11009000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">2</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c3:</span> <span class="class">i2c3@1100f000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">3</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c4:</span> <span class="class">i2c4@11011000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">4</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c5:</span> <span class="class">i2c5@11016000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">5</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">i2c6:</span> <span class="class">i2c6@1100d000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,i2c&quot;</span>;</span><br><span class="line">    id = <span class="params">&lt;<span class="number">6</span>&gt;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>凡是在dts中具有compatible字段的节点，都会被内核注册为platform设备，例如上面的 i2c0，将会被转换为名字为”11007000.i2c0”的platform设备,再看i2c0到i2c6的节点都有相同的compatible字段”mediatek,i2c”，因此当驱动mt_i2c_driver注册的时候，会分别与之匹配调用对应的 mt_i2c_probe 函数，也就是说会调用6次mt_i2c_probe函数分别注册i2c0到i2c6, 以i2c0为例进行分析。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static int mt_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int cnt = 0;</span></span><br><span class="line">    struct mt_i2c *i2c; <span class="comment">//这个结构中包含了 i2c_adapter 结构</span></span><br><span class="line">    unsigned int clk_src_in_hz;</span><br><span class="line">    struct resource *res;</span><br><span class="line">    const struct of_device_id *of_id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(struct mt_i2c), GFP_KERNEL); </span><br><span class="line">    <span class="keyword">if</span> (i2c == NULL)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取dts中的相关数据其中包括 i2c-&gt;id </span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = mt_i2c_parse_dt(pdev-&gt;</span>dev.of_node, i2c); </span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        return -EINVAL;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev_comp</span> = of_id-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.of_node = pdev-&gt;</span>dev.of_node; <span class="comment">//设置设备节点为 i2c0 根节点</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev</span> = &amp;i2c-&gt;</span>adap.dev; </span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.parent = &amp;pdev-&gt;</span>dev;	<span class="comment">//设置父设备为传入的platform设备&quot;11007000.i2c0&quot;，有此可知所有的i2c_adapter设备都将是platform设备的子设备,都将位于 /sys/devices/110xx000.i2cx/ 之下</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo = &amp;mt_i2c_algorithm; <span class="comment">//这里始化了i2c的通信操作函数，这个函数有mtk原厂实现，这个是平台相关的寄存器操作</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo_data = NULL;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.timeout = <span class="number">2</span> * HZ; <span class="comment">//超时时间2s，从这里可知mtk的i2c超时时间为2s</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.retries = <span class="number">1</span>;	<span class="comment">//mtk平台设置，重复次数1次</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.nr = i2c-&gt;</span>id; <span class="comment">//表示使用的i2c总线号，0表示i2c0</span></span><br><span class="line">    <span class="function"><span class="title">spin_lock_init</span>(&amp;i2c-&gt;</span>cg_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(i2c-&gt;</span><span class="function"><span class="title">adap</span>.<span class="keyword">name</span>, I2C_DRV_NAME, sizeof(i2c-&gt;</span>adap.<span class="keyword">name</span>)); <span class="comment">//初始化adap的名字为mt-i2c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ret = i2c_add_adapter(&amp;i2c-&gt;adap); */</span></span><br><span class="line">    <span class="function"><span class="title">ret</span> = i2c_add_numbered_adapter(&amp;i2c-&gt;</span>adap); <span class="comment">//将adap注册进内核</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略***/</span></span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数，从dts获取相关的平台台相关的硬件信息，通信方式(mt_i2c_algorithm)、硬件总线号(adap.nr)等，以及平台相关的信息，通信超时时间、通信重复次数等，利用这些信息创建并初始化一个 i2c_adapter（包含在mt_i2c中），并将其注册进内核，来看看它的注册过程，它的代码在 drivers/i2c/i2c-core.c</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_add_numbered_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr<span class="operator"> == </span>-<span class="number">1</span>) <span class="comment">/* -1 means dynamically assign bus id */</span></span><br><span class="line">        return i2c<span class="constructor">_add_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="constructor">__i2c_add_numbered_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL_GPL(<span class="params">i2c_add_numbered_adapter</span>)</span>;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> <span class="constructor">__i2c_add_numbered_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> id;</span><br><span class="line"></span><br><span class="line">    mutex<span class="constructor">_lock(&amp;<span class="params">core_lock</span>)</span>;</span><br><span class="line">    id = idr<span class="constructor">_alloc(&amp;<span class="params">i2c_adapter_idr</span>, <span class="params">adap</span>, <span class="params">adap</span>-&gt;<span class="params">nr</span>, <span class="params">adap</span>-&gt;<span class="params">nr</span> + 1, GFP_KERNEL)</span>;</span><br><span class="line">    mutex<span class="constructor">_unlock(&amp;<span class="params">core_lock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">WARN(<span class="params">id</span> &lt; 0, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>)</span>)</span><br><span class="line">        return id<span class="operator"> == </span>-ENOSPC ? -EBUSY : id;</span><br><span class="line"></span><br><span class="line">    return i2c<span class="constructor">_register_adapter(<span class="params">adap</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到其实是调用了内核提供 i2c_register_adapter 函数来进行注册，来看看它干了什么</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    int res = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!is_registered)) &#123;	<span class="comment">//检查adap是否已经注册，防止存重复注册</span></span><br><span class="line">        res = -EAGAIN;</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity checks */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (WARN(!adap-&gt;</span><span class="keyword">name</span>[<span class="number">0</span>], <span class="string">&quot;i2c adapter has no name&quot;</span>)) <span class="comment">//检查 i2c_adapter 的名字，没有名字直接返回</span></span><br><span class="line">        goto out_list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!adap-&gt;</span>algo) &#123;	<span class="comment">// i2c_adapter检查是否有发送接收函数，没有直接返回</span></span><br><span class="line">        <span class="function"><span class="title">pr_err</span>(&quot;adapter &#x27;%s&#x27;: no algo supplied!\n&quot;, adap-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!adap-&gt;</span>lock_ops)</span><br><span class="line">        <span class="function"><span class="title">adap</span>-&gt;</span>lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">rt_mutex_init</span>(&amp;adap-&gt;</span>bus_lock);</span><br><span class="line">    <span class="function"><span class="title">rt_mutex_init</span>(&amp;adap-&gt;</span>mux_lock);</span><br><span class="line">    <span class="function"><span class="title">mutex_init</span>(&amp;adap-&gt;</span>userspace_clients_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;<span class="function"><span class="title">adap</span>-&gt;</span>userspace_clients);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (adap-&gt;</span>timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="function"><span class="title">adap</span>-&gt;</span>timeout = HZ; <span class="comment">//设置如果没设置超时时间则，默认超时时间为1s</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_set_name</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, &quot;i2c-%d&quot;, adap-&gt;</span><span class="function"><span class="title">nr</span>); // 设置 adap-&gt;</span>dev 的名字i2c-<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="title">adap</span>-&gt;</span>dev.bus = &amp;i2c_bus_type; <span class="comment">//设置总线</span></span><br><span class="line">    <span class="function"><span class="title">adap</span>-&gt;</span>dev.type = &amp;i2c_adapter_type;	<span class="comment">//设置 adapter 的设备类型</span></span><br><span class="line">    <span class="function"><span class="title">res</span> = device_register(&amp;adap-&gt;</span>dev); <span class="comment">// 向 i2c_bus_type 总线注册adapter设备 ，将生成 /sys/devices/11007000.i2c0/i2c-0 节点</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="function"><span class="title">pr_err</span>(&quot;adapter &#x27;%s&#x27;: can&#x27;t register device (%d)\n&quot;, adap-&gt;</span><span class="keyword">name</span>, res);</span><br><span class="line">        goto out_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, &quot;adapter [%s] registered\n&quot;, adap-&gt;</span><span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 电源相关忽略 */</span></span><br><span class="line">    <span class="function"><span class="title">pm_runtime_no_callbacks</span>(&amp;adap-&gt;</span>dev);</span><br><span class="line">    <span class="function"><span class="title">pm_suspend_ignore_children</span>(&amp;adap-&gt;</span>dev, <span class="literal">true</span>);</span><br><span class="line">    <span class="function"><span class="title">pm_runtime_enable</span>(&amp;adap-&gt;</span>dev);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    <span class="function"><span class="title">res</span> = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;</span>dev,</span><br><span class="line">                       <span class="function"><span class="title">adap</span>-&gt;</span>dev.parent);</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        <span class="function"><span class="title">dev_warn</span>(&amp;adap-&gt;</span>dev,</span><br><span class="line">             <span class="string">&quot;Failed to create compatibility class link\n&quot;</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    i2c_init_recovery(adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    of_i2c_register_devices(adap); <span class="comment">//遍历设备节点注册对应的 client</span></span><br><span class="line">    i2c_acpi_register_devices(adap); <span class="comment">//百度了一下说acpi是电源管理相关的东西，那就先不管</span></span><br><span class="line">    i2c_acpi_install_space_handler(adap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (adap-&gt;</span>nr &lt; __i2c_first_dynamic_bus_num) </span><br><span class="line">        i2c_scan_static_board_info(adap); <span class="comment">//老的方式注册adap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify drivers */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    <span class="function"><span class="title">idr_remove</span>(&amp;i2c_adapter_idr, adap-&gt;</span>nr);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数对adapte进行了一些错误检查，并进一步对它进行初始化，并将其注册进i2c总线，该函数还会调用 of_i2c_register_devices 创建 dts中对应的 i2c 设备相关的 i2c_client，看看它怎么做的。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">static void of_i2c_register_devices(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    struct device_node *bus, *<span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    struct</span> i2c_client *client;</span><br><span class="line"></span><br><span class="line">    /* Only register child devices if the adapter has a <span class="keyword">node</span> <span class="title">pointer</span> set */</span><br><span class="line">    if (!adap-&gt;dev.of_node) //检测设备节点是否存在</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: walking child nodes\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bus = of_get_child_by_name(adap-&gt;dev.of_node, <span class="string">&quot;i2c-bus&quot;</span>); //mtk平台这个i2c-bus设备节点并不存在。</span><br><span class="line">    if (!bus)</span><br><span class="line">        bus = of_node_get(adap-&gt;dev.of_node); //直接返回i2c0设备节点，在前面被初始化</span><br><span class="line"></span><br><span class="line">    for_each_available_child_of_node(bus, <span class="keyword">node</span><span class="title">) &#123; //遍历 i2c0</span>的设备节点下的子节点</span><br><span class="line">        if (of_node_test_and_set_flag(<span class="keyword">node</span><span class="title">, OF_POPULATED</span>))</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        client = of_i2c_register_device(adap, <span class="keyword">node</span><span class="title">); //对于子节点执行这个函数</span></span><br><span class="line"><span class="title">        if</span> (IS_ERR(client)) &#123;</span><br><span class="line">            dev_warn(&amp;adap-&gt;dev,</span><br><span class="line">                 <span class="string">&quot;Failed to create I2C device for %s\n&quot;</span>,</span><br><span class="line">                 <span class="keyword">node</span><span class="title">-&gt;full_name</span>);</span><br><span class="line">            of_node_clear_flag(<span class="keyword">node</span><span class="title">, OF_POPULATED</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    of_node_put(bus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就是检测adap的硬件总线控制器设备节点是否存在，如果存在则对该总线节点的每一个子节点执行 of_i2c_register_device 函数，来看看它干了什么。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i2c0的子节点</span></span><br><span class="line">&amp;i2c0 &#123;</span><br><span class="line">    cap_touch@<span class="number">24</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;mediatek,cap_touch&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x24</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;pio&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">0</span> IRQ_TYPE_EDGE_FALLING <span class="number">0</span> <span class="number">0</span>&gt;;</span><br><span class="line">        int-gpio = &lt;&amp;pio <span class="number">0</span> <span class="number">0</span>&gt;;</span><br><span class="line">        rst-gpio = &lt;&amp;pio <span class="number">174</span> <span class="number">0</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *of_i2c_register_device(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span></span> *adap,</span><br><span class="line">                         <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *result;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span></span> info = &#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span></span> dev_ad = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> __be32 *addr_be;</span><br><span class="line">    <span class="built_in">u32</span> addr;</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: register %s\n&quot;</span>, node-&gt;full_name);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取节点下的 compatible 字段逗号后面的字符串，如果没有逗号则获取 compatible 字段的字符串，</span></span><br><span class="line">    这里将返回 cap_touch 并将其存入 info.<span class="keyword">type</span></span><br><span class="line">    <span class="keyword">if</span> (of_modalias_node(node, info.<span class="keyword">type</span>, sizeof(info.<span class="keyword">type</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: modalias failure on %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取reg描述&quot;0x24&quot;，即设备地址</span></span><br><span class="line">    addr_be = of_get_property(node, <span class="string">&quot;reg&quot;</span>, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!addr_be || (len &lt; sizeof(*addr_be))) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: invalid reg on %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = be32_to_cpup(addr_be); <span class="comment">//将其转化为16进制的0x24</span></span><br><span class="line">    <span class="keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">        addr &amp;= ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">        info.flags |= I2C_CLIENT_TEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123; <span class="comment">//地址检测</span></span><br><span class="line">        addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">        info.flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i2c_check_addr_validity(addr, info.flags)) &#123; <span class="comment">//地址检测</span></span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: invalid addr=%x on %s\n&quot;</span>,</span><br><span class="line">            addr, node-&gt;full_name);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.addr = addr; <span class="comment">//初始化 i2c_board_info 结构地址</span></span><br><span class="line">    info.of_node = of_node_get(node); <span class="comment">//初始化设备节点为i2c0</span></span><br><span class="line">    info.archdata = &amp;dev_ad; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_get_property(node, <span class="string">&quot;wakeup-source&quot;</span>, NULL))</span><br><span class="line">        info.flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">    result = i2c_new_device(adap, &amp;info); <span class="comment">//创建并注册一个i2c_client,即注册一个新的i2c设备。</span></span><br><span class="line">    <span class="keyword">if</span> (result == NULL) &#123;</span><br><span class="line">        dev_err(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: Failure registering %s\n&quot;</span>,</span><br><span class="line">            node-&gt;full_name);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数创建了一个局部的i2c_board_info结构，从dts中获取到i2c子设备相关信息并将其初始化之后，将作为参数用于创建i2c_client,看看i2c_new_device怎么创建一个新的i2c设备。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">struct i2c_client *</span><br><span class="line">i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client;</span><br><span class="line">    int         status;</span><br><span class="line"></span><br><span class="line">    client = kzalloc(sizeof *client, GFP_KERNEL); <span class="comment">//动态创建一个client结构</span></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>adapter = adap; <span class="comment">//初始化adapter成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.platform_data = info-&gt;</span>platform_data; <span class="comment">// 初始化platform_data成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (info-&gt;</span>archdata)</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.archdata = *info-&gt;</span>archdata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">flags</span> = info-&gt;</span>flags; <span class="comment">//初始化flag成员</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">addr</span> = info-&gt;</span>addr;	 <span class="comment">//初始化设备地址</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">irq</span> = info-&gt;</span>irq;	 <span class="comment">//初始化中断引脚，这里没有初始化，也会在i2c_device_probe中重新，获取相关的中断号。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(client-&gt;</span><span class="function"><span class="title">name</span>, info-&gt;</span><span class="function"><span class="title">type</span>, sizeof(client-&gt;</span><span class="function"><span class="title">name</span>)); //设置<span class="keyword">name</span>为info-&gt;</span>type，即设置为前面获取的cap_touch，这个名字非常重要，因为驱动匹配将使用这个名字。</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">status</span> = i2c_check_addr_validity(client-&gt;</span><span class="function"><span class="title">addr</span>, client-&gt;</span>flags);	<span class="comment">//检测i2c地址</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        <span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">            <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">flags</span> &amp; I2C_CLIENT_TEN ? 10 : 7, client-&gt;</span>addr);</span><br><span class="line">        goto out_err_silent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for address business */</span></span><br><span class="line">    status = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto out_err;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.parent = &amp;client-&gt;</span><span class="function"><span class="title">adapter</span>-&gt;</span>dev; <span class="comment">//设置设备父节点</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>dev.bus = &amp;i2c_bus_type; <span class="comment">//设置总线为i2c总线</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span>dev.type = &amp;i2c_client_type; <span class="comment">//设置设备类型</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.of_node = info-&gt;</span>of_node; <span class="comment">//设置设备节点为i2c0</span></span><br><span class="line">    <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">dev</span>.fwnode = info-&gt;</span>fwnode; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * dev_set_name(&amp;client-&gt;dev, &quot;%d-%04x&quot;, i2c_adapter_id(adap), i2c_encode_flags_to_addr(client));</span></span><br><span class="line"><span class="comment">     * 设置设备名字为 0-0024 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i2c_dev_set_name(adap, client); </span><br><span class="line">    <span class="function"><span class="title">status</span> = device_register(&amp;client-&gt;</span>dev); <span class="comment">//将设备注册进入bus总线，同时会生成节点 /sys/devices/11007000.i2c0/i2c-0/0-0024</span></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto out_err;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span>dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">name</span>, dev_name(&amp;client-&gt;</span>dev));</span><br><span class="line"></span><br><span class="line">    return client;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">    <span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev,</span><br><span class="line">        <span class="string">&quot;Failed to register i2c client %s at 0x%02x (%d)\n&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">client</span>-&gt;</span><span class="function"><span class="title">name</span>, client-&gt;</span>addr, status);</span><br><span class="line">out_err_silent:</span><br><span class="line">    kfree(client);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止就完成了i2c0节点下的cap_touch的设备注册，of_i2c_register_devices函数会遍历i2c0节点下的子节点并依次进行注册。</p>
<p>最后在来对整个注册流程进行一个梳理，对应前面的框图，对于mtk平台对每一个i2c总线节点都会注册一个adapter，在adapter注册的时候后会遍历子节点下的每个i2c设备并创建对应的i2c设备结构client。而在创建过程中会用到一个中间结构 i2c_board_info，它用于描述i2c设备的硬件信息，在注册完成之后就被释放掉。</p>
<h2 id="2、通过总线号添加i2c设备"><a href="#2、通过总线号添加i2c设备" class="headerlink" title="2、通过总线号添加i2c设备"></a>2、通过总线号添加i2c设备</h2><p>这种方法适用于许多I2C总线是系统总线的嵌入式系统。 在这样的系统上，每个I2C总线都有一个事先已知的编号。 因此可以预先声明该总线上的I2C设备。 这是通过调用i2c_register_board_info（）注册的struct i2c_board_info数组完成的，在没有dts之前使用的就是这种方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_BOARD_INFO(dev_type, dev_addr) \</span></span><br><span class="line">    .type = dev_type, .addr = (dev_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct i2c_board_info h4_i2c_board_info[] __initdata = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;isp1301_omap&quot;</span>, <span class="number">0x2d</span>),</span><br><span class="line">        .irq        = OMAP_GPIO_IRQ(<span class="number">125</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;   <span class="comment">/* EEPROM on mainboard */</span></span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;24c01&quot;</span>, <span class="number">0x52</span>),</span><br><span class="line">        .platform_data  = &amp;m24c01,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;   <span class="comment">/* EEPROM on cpu card */</span></span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;24c01&quot;</span>, <span class="number">0x57</span>),</span><br><span class="line">        .platform_data  = &amp;m24c01,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">omap_h4_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (...)</span><br><span class="line">    i2c_register_board_info(<span class="number">1</span>, h4_i2c_board_info,</span><br><span class="line">            ARRAY_SIZE(h4_i2c_board_info));</span><br><span class="line">    (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在I2C总线1上声明了3个设备，包括它们各自的地址和其驱动程序所需的自定义数据。 注册I2C总线查询后，I2C内核将自动实例化I2C设备。以s3c2410为例进行分析,代码路径：drivers/i2c/busses/i2c-s3c2410.c</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static int s3c24xx_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c24xx_i2c *i2c;</span><br><span class="line">    struct s3c2410_platform_i2c *pdata = NULL;</span><br><span class="line">    struct resource *res;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">strlcpy</span>(i2c-&gt;</span><span class="function"><span class="title">adap</span>.<span class="keyword">name</span>, &quot;s3c2410-i2c&quot;, sizeof(i2c-&gt;</span>adap.<span class="keyword">name</span>));</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo = &amp;s3c24xx_i2c_algorithm; </span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.retries = <span class="number">2</span>; <span class="comment">//初始化重复次数</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.class = I2C_CLASS_DEPRECATED; <span class="comment">//不支持自动检测</span></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>tx_setup = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo_data = i2c;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.parent = &amp;pdev-&gt;</span>dev; <span class="comment">//初始化父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.nr = i2c-&gt;</span><span class="function"><span class="title">pdata</span>-&gt;</span>bus_num;</span><br><span class="line">    <span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.of_node = pdev-&gt;</span>dev.of_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 省略部分 ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ret</span> = i2c_add_numbered_adapter(&amp;i2c-&gt;</span>adap); <span class="comment">//注册adapter</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">pm_runtime_disable</span>(&amp;pdev-&gt;</span>dev);</span><br><span class="line">        s3c24xx_i2c_deregister_cpufreq(i2c);</span><br><span class="line">        <span class="function"><span class="title">clk_unprepare</span>(i2c-&gt;</span>clk);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>同样是初始化adapter相关参数并向内核注册adapter</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">        i2c_register_adapter</span><br></pre></td></tr></table></figure>
<p>最后还是调用 i2c_register_adapter 这个函数来看看这种方式调用的是什么函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_register_adapter(<span class="params">struct</span> <span class="params">i2c_adapter</span> <span class="operator">*</span><span class="params">adap</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">        i2c<span class="constructor">_scan_static_board_info(<span class="params">adap</span>)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于前面已经分析过这个函数，就直接给出关键代码，在这句代码中发现一个参数 __i2c_first_dynamic_bus_num 这是一个内核创建的全来表示当前局整型变量用的i2c总线的数量，这个机制的一个特点就是i2c总线的数量是由设备注册的时候添加的。它是什么时候添加的呢？先往下看</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">static void i2c_scan_static_board_info(<span class="name">struct</span> i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_devinfo  *devinfo<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    down_read(<span class="name">&amp;__i2c_board_lock</span>)<span class="comment">;</span></span><br><span class="line">    list_for_each_entry(<span class="name">devinfo</span>, <span class="symbol">&amp;__i2c_board_list</span>, list) &#123;</span><br><span class="line">        if (<span class="name">devinfo-&gt;busnum</span> == adapter-&gt;nr</span><br><span class="line">                <span class="symbol">&amp;&amp;</span> !i2c_new_device(<span class="name">adapter</span>,</span><br><span class="line">                        <span class="symbol">&amp;devinfo-&gt;board_info</span>))</span><br><span class="line">            dev_err(<span class="name">&amp;adapter-&gt;dev</span>,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create device at 0x%02x\n&quot;</span>,</span><br><span class="line">                devinfo-&gt;board_info.addr)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    up_read(<span class="name">&amp;__i2c_board_lock</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个函数很简单，就是遍历 __i2c_board_list 链表，找到其中挂接在 adapter-&gt;nr 上的设备, 然后使用它的设备信息调用 i2c_new_device 创建一个 i2c_client 设备。 设备信息是通过 i2c_register_board_info 注册的，来看一下这个函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_register_board_info(<span class="params">int</span> <span class="params">busnum</span>, <span class="params">struct</span> <span class="params">i2c_board_info</span> <span class="params">const</span> <span class="operator">*</span><span class="params">info</span>, <span class="params">unsigned</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line"></span><br><span class="line">    down<span class="constructor">_write(&amp;<span class="params">__i2c_board_lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;i2c_register_board_info busnum = %d\n&quot;</span>,busnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dynamic bus numbers will be assigned after the last static one */</span></span><br><span class="line">    <span class="keyword">if</span> (busnum &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">        __i2c_first_dynamic_bus_num = busnum + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (status = <span class="number">0</span>; len; len--, info++) &#123;</span><br><span class="line">        <span class="keyword">struct</span> i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">        devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!devinfo) &#123;</span><br><span class="line">            pr<span class="constructor">_debug(<span class="string">&quot;i2c-core: can&#x27;t register boardinfo!\n&quot;</span>)</span>;</span><br><span class="line">            status = -ENOMEM;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devinfo-&gt;busnum = busnum;</span><br><span class="line">        devinfo-&gt;board_info = *info;</span><br><span class="line">        <span class="built_in">list</span><span class="constructor">_add_tail(&amp;<span class="params">devinfo</span>-&gt;<span class="params">list</span>, &amp;<span class="params">__i2c_board_list</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    up<span class="constructor">_write(&amp;<span class="params">__i2c_board_lock</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看见这个函数的功能很简单，当前 busnum 大于 __i2c_first_dynamic_bus_num 则更新 __i2c_first_dynamic_bus_num ，总线数量其实是在添加设备信息的时候添加的。当添加了设备信息之后将该设备信息链接到 __i2c_board_list 全局链表，__i2c_board_list 维护着由 i2c_register_board_info 注册的设备信息。</p>
<blockquote>
<p><strong>整个过程分为两步：</strong></p>
<ol>
<li>首先 arch/arm/mach-xxx 文件调用 i2c_register_board_info 函数 先向 __i2c_board_list 链表添加板子上的设备信息</li>
<li>然后在调用 drivers/i2c/busses/i2c-xxx 文件向内核注册创建并初始化adapter结构并注册进内核，在内核中遍历 __i2c_board_list 使用挂接在对应adapter上的设备信息 i2c_devinfo-&gt;info 创建出对应的i2c_client,调用流程如下:</li>
</ol>
</blockquote>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span> ---&gt;</span></span><br><span class="line">        <span class="function"><span class="title">i2c_register_adapter</span> ---&gt;</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (adap-&gt;</span>nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">                <span class="function"><span class="title">i2c_scan_static_board_info</span>(adap); ---&gt;</span></span><br><span class="line">                    <span class="function"><span class="title">if</span> (devinfo-&gt;</span><span class="function"><span class="title">busnum</span> == adapter-&gt;</span><span class="function"><span class="title">nr</span> &amp;&amp; !i2c_new_device(adapter, &amp;devinfo-&gt;</span>board_info))</span><br></pre></td></tr></table></figure>
<h2 id="3、动态添加i2c设备"><a href="#3、动态添加i2c设备" class="headerlink" title="3、动态添加i2c设备"></a>3、动态添加i2c设备</h2><p>前面的两种方式都是静态的方式添加的，就是在内核加载之前先提供i2c设备信息，在加载的时候创建，而内核也提供了动态加载的方法。一个个典型的例子是电视适配器。它们通常是通过I2C总线连接到主芯片的调谐器，视频解码器，音频解码器等。 由于不会事先知道I2C总线的编号，因此无法使用上述方法1和2。 </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="keyword">struct</span> i2c_board_info sfe4001_hwmon_info = &#123;</span><br><span class="line">    <span class="constructor">I2C_BOARD_INFO(<span class="string">&quot;max6647&quot;</span>, 0x4e)</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sfe4001<span class="constructor">_init(<span class="params">struct</span> <span class="params">efx_nic</span> <span class="operator">*</span><span class="params">efx</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    efx-&gt;board_info.hwmon_client =</span><br><span class="line">        i2c<span class="constructor">_new_device(&amp;<span class="params">efx</span>-&gt;<span class="params">i2c_adap</span>, &amp;<span class="params">sfe4001_hwmon_info</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个方式自己创建出一个 i2c_board_info 结构，并直接调用函数 i2c_new_device 创建一个i2c_client.上面的代码实例化了所讨论的网络适配器上I2C总线上的1个I2C设备，这个方式是动态的添加一个 i2c_client 的方式，使用这个方式的原因是我们事先不知道，我们的设备会挂在哪个i2c总线上。这种情况下还有一种可能就是我们不知道，总线上是否存在这样一个设备，我们想在创建前先检测这个总线是否存在这个设备于是可以使用下面的方式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static const unsigned short normal_i2c<span class="literal">[]</span> = &#123; <span class="number">0x2c</span>, <span class="number">0x2d</span>, I2C_CLIENT_END &#125;;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> usb<span class="constructor">_hcd_nxp_probe(<span class="params">struct</span> <span class="params">platform_device</span> <span class="operator">*</span><span class="params">pdev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *i2c_adap;</span><br><span class="line">    <span class="keyword">struct</span> i2c_board_info i2c_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">    i2c_adap = i2c<span class="constructor">_get_adapter(2)</span>;</span><br><span class="line">    memset(&amp;i2c_info, <span class="number">0</span>, sizeof(<span class="keyword">struct</span> i2c_board_info));</span><br><span class="line">    strlcpy(i2c_info.<span class="keyword">type</span>, <span class="string">&quot;isp1301_nxp&quot;</span>, I2C_NAME_SIZE);</span><br><span class="line">    isp1301_i2c_client = i2c<span class="constructor">_new_probed_device(<span class="params">i2c_adap</span>, &amp;<span class="params">i2c_info</span>, <span class="params">normal_i2c</span>, NULL)</span>;</span><br><span class="line">    i2c<span class="constructor">_put_adapter(<span class="params">i2c_adap</span>)</span>;</span><br><span class="line">    <span class="comment">/***省略部分***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在所讨论的OHCI适配器上的I2C总线上最多实例化1个I2C设备。 它首先尝试在地址0x2c处进行尝试，如果在该位置未找到任何内容，则尝试在地址0x2d中进行处理，如果仍然找不到任何内容，则放弃。这里面有个关键函数 i2c_new_probed_device 来看看这个函数的实现原理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_client *</span><br><span class="line">i2c_new_probed_device(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">              <span class="keyword">struct</span> i2c_board_info *info,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">const</span> *addr_list,</span><br><span class="line">              <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> i2c_adapter *, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!probe)</span><br><span class="line">        probe = i2c_default_probe; <span class="comment">//如果没有probe则使用内核默认的i2c检测函数，这个函数检测当前总线上的设备是否存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; addr_list[i] != I2C_CLIENT_END; i++) &#123;</span><br><span class="line">        <span class="comment">/* Check address validity */</span></span><br><span class="line">        <span class="keyword">if</span> (i2c_check_7bit_addr_validity_strict(addr_list[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dev_warn(&amp;adap-&gt;dev, <span class="string">&quot;Invalid 7-bit address 0x%02x\n&quot;</span>,</span><br><span class="line">                 addr_list[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check address availability (7 bit, no need to encode flags) */</span></span><br><span class="line">        <span class="keyword">if</span> (i2c_check_addr_busy(adap, addr_list[i])) &#123;</span><br><span class="line">            dev_dbg(&amp;adap-&gt;dev,</span><br><span class="line">                <span class="string">&quot;Address 0x%02x already in use, not probing\n&quot;</span>,</span><br><span class="line">                addr_list[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Test address responsiveness */</span></span><br><span class="line">        <span class="keyword">if</span> (probe(adap, addr_list[i])) <span class="comment">//检测当前总线上的设i2c备是否存在。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr_list[i] == I2C_CLIENT_END) &#123;</span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;Probing failed, no device found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;addr = addr_list[i];</span><br><span class="line">    <span class="keyword">return</span> i2c_new_device(adap, info); <span class="comment">//创建i2c_client</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数的功能就是向当前总线上的i2c设备发送一个i2c信息，看看设备是否应答，用来判断是否存在i2c设备 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i2c_default_probe(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">union</span> i2c_smbus_data dummy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0x73</span> &amp;&amp; (adap-&gt;<span class="keyword">class</span> &amp; I2C_CLASS_HWMON)</span><br><span class="line">     &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_BYTE_DATA, &amp;dummy);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!((addr &amp; ~<span class="number">0x07</span>) == <span class="number">0x30</span> || (addr &amp; ~<span class="number">0x0f</span>) == <span class="number">0x50</span>)</span><br><span class="line">     &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_WRITE, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_QUICK, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))</span><br><span class="line">        err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">                     I2C_SMBUS_BYTE, &amp;dummy);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_warn(&amp;adap-&gt;dev, <span class="string">&quot;No suitable probing method supported for address 0x%02X\n&quot;</span>,</span><br><span class="line">             addr);</span><br><span class="line">        err = -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、动态探测I2C总线添加i2c设备"><a href="#4、动态探测I2C总线添加i2c设备" class="headerlink" title="4、动态探测I2C总线添加i2c设备"></a>4、动态探测I2C总线添加i2c设备</h2><p>有时没有足够的有关I2C设备的信息，甚至无法调用i2c_new_probed_device（）。典型的情况是PC主板上的硬件监视芯片。有几十种模型，它们可以存在于25个不同的地址。鉴于那里有大量的主板，几乎不可能建立一个完整的硬件监控芯片清单。幸运的是，这些芯片中的大多数都有制造商和设备ID寄存器，因此可以通过探测来识别它们。也就是我们的detect内核中的机制了。<strong>在这种情况下，既不声明也不显式实例化I2C设备。取而代之的是，i2c-core会在加载驱动程序后立即探测此类设备，如果找到了驱动程序，则会自动实例化I2C设备</strong>。<font color = red><strong>这也就是 adapter 中 class 成员变量的作用了，内核在加载驱动时会使用驱动提供的地址链表 i2c_driver-&gt;address_list，自动去具有同类 class 的 adapter 上探测这个链表上的地址，如果探测到了则实例化驱动</strong></font></p>
<p>为了防止此机制的任何不当行为，适用以下限制：</p>
<ol>
<li>I2C设备驱动程序必须实现detect（）方法，该方法通过从任意寄存器读取来识别支持的设备。</li>
<li>仅对可能具有受支持设备并同意进行探测的总线进行探测。例如，这避免了在电视适配器上探测硬盘监控芯片的麻烦。<br>例：请参阅drivers/hwmon/lm90.c中的lm90_driver和lm90_detect（）</li>
</ol>
<p>那些熟悉2.4内核和早期2.6内核的i2c子系统的人会发现，此方法本质上与此处所做的相似。两个重要区别是：</p>
<ol>
<li>探测只是现在实例化I2C设备的一种方法，而那是那时的唯一方法。<strong>在可能的情况下，应首选方法1、2、3。方法4仅应在没有其他方法的情况下使用，因为它可能会产生不良的副作用。</strong></li>
<li>I2C总线必须明确地说明哪些I2C驱动程序类可以对其进行探测（通过类位域），<strong>而所有I2C总线默认情值为空类，这意味着不进行探测。类位域的目的是限制上述不希望的副作用。</strong></li>
</ol>
<p><font color=red><strong>再一次声明，应尽可能避免使用方法4。显式设备实例化（方法1、2、3）是更可取的，因为它更安全，更快捷。</strong></font></p>
<p>由于内核不推荐使用这种方式就不详细分析了给出调用流程就行了，感兴趣跟着调用流程看看</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>-&gt;</span></span><br><span class="line">    __<span class="function"><span class="title">i2c_add_numbered_adapter</span> ---&gt;</span></span><br><span class="line">        <span class="function"><span class="title">i2c_register_adapter</span> ---&gt;</span></span><br><span class="line">            <span class="function"><span class="title">bus_for_each_drv</span>(&amp;i2c_bus_type, NULL, adap, __process_new_adapter); ---&gt;</span></span><br><span class="line">                <span class="function"><span class="title">i2c_do_add_adapter</span> ---&gt;</span></span><br><span class="line">                    <span class="function"><span class="title">i2c_detect</span> ---&gt;</span></span><br><span class="line">                        <span class="function"><span class="title">i2c_detect_address</span> ---&gt;</span></span><br><span class="line">                            i2c_default_probe <span class="comment">//判断设备是否在这个总线上</span></span><br><span class="line">                            <span class="function"><span class="title">driver</span>-&gt;</span>detect(temp_client, &amp;info); <span class="comment">//调用这个函数，在这个函数和设备通信，获取到设备信息，完善info中的信息。</span></span><br><span class="line">                            i2c_new_device <span class="comment">//创建i2c_client</span></span><br><span class="line">                            <span class="function"><span class="title">list_add_tail</span>(&amp;client-&gt;</span><span class="function"><span class="title">detected</span>, &amp;driver-&gt;</span>clients); <span class="comment">// 将设备链接到 clients</span></span><br></pre></td></tr></table></figure>
<p>这种方式适用于不知道设备被挂在哪个总线上的情况，通过遍历所有的总线，去判断设备是否在总线上,如果存在则调用 driver-&gt;detect 进一步获取设备信息，用于完善info结构，如果设备信息完善则创建 i2c_client。</p>
<h2 id="5、从用户空间添加i2c设备"><a href="#5、从用户空间添加i2c设备" class="headerlink" title="5、从用户空间添加i2c设备"></a>5、从用户空间添加i2c设备</h2><p>通常，内核应该知道连接了哪些I2C设备以及它们位于什么地址。但是，在某些情况下却没有，因此添加了sysfs接口以让用户提供信息。该接口由2个属性文件组成，new_device和delete_device。这两个文件都是只写的，并且必须为它们写正确的参数，以便正确地创建或删除I2C设备。</p>
<p><strong>创建一个i2c设备</strong><br>文件 new_device 用于创建一个i2c设备，具有2个参数：I2C设备的名称（字符串）和I2C设备的地址（一个数字，通常以十六进制表示，以0x开头，但也可以以十进制表示。）例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo eeprom <span class="number">0</span>x50&gt;<span class="regexp">/sys/</span>bus<span class="regexp">/i2c/</span>devices<span class="regexp">/i2c-3/</span>new_device</span><br></pre></td></tr></table></figure>
<p><strong>删除一个i2c设备</strong><br>文件delete_device，用于删除一个i2c设备，具有一个参数：I2C设备的地址。由于在给定的I2C网段上没有两个设备可以住在同一地址，因此该地址足以唯一地标识要删除的设备。例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo <span class="number">0</span>x50&gt;<span class="regexp">/sys/</span>bus<span class="regexp">/i2c/</span>devices<span class="regexp">/i2c-3/</span>delete_device</span><br></pre></td></tr></table></figure>
<p>来看看内核的实现</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> =</span> to_i2c_adapter(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *blank, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct i2c_board_info));</span><br><span class="line"></span><br><span class="line">    blank = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!blank) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Missing parameters\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blank - buf &gt; I2C_NAME_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Invalid device name\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(info.type, buf, blank - buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse remaining parameters, reject extra parameters */</span></span><br><span class="line">    res = <span class="built_in">sscanf</span>(++blank, <span class="string">&quot;%hi%c&quot;</span>, &amp;info.addr, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t parse I2C address\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; <span class="built_in">end</span> != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Extra parameters\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((info.addr &amp; I2C_ADDR_OFFSET_TEN_BIT) == I2C_ADDR_OFFSET_TEN_BIT) &#123;</span><br><span class="line">        info.addr &amp;= ~I2C_ADDR_OFFSET_TEN_BIT;</span><br><span class="line">        info.flags |= I2C_CLIENT_TEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.addr &amp; I2C_ADDR_OFFSET_SLAVE) &#123;</span><br><span class="line">        info.addr &amp;= ~I2C_ADDR_OFFSET_SLAVE;</span><br><span class="line">        info.flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client = i2c_new_device(adap, &amp;info);</span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep track of the added device */</span></span><br><span class="line">    mutex_lock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    list_add_tail(&amp;client-&gt;detected, &amp;adap-&gt;userspace_clients);</span><br><span class="line">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    dev_info(dev, <span class="string">&quot;%s: Instantiated device %s at 0x%02hx\n&quot;</span>, <span class="string">&quot;new_device&quot;</span>,</span><br><span class="line">         info.type, info.addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(new_device, S_IWUSR, <span class="literal">NULL</span>, i2c_sysfs_new_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">i2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span> =</span> to_i2c_adapter(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> addr;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse parameters, reject extra parameters */</span></span><br><span class="line">    res = <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%hi%c&quot;</span>, &amp;addr, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t parse I2C address\n&quot;</span>, <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; <span class="built_in">end</span> != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Extra parameters\n&quot;</span>, <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the device was added through sysfs */</span></span><br><span class="line">    res = -ENOENT;</span><br><span class="line">    mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class="line">              i2c_adapter_depth(adap));</span><br><span class="line">    list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class="line">                 detected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i2c_encode_flags_to_addr(client) == addr) &#123;</span><br><span class="line">            dev_info(dev, <span class="string">&quot;%s: Deleting device %s at 0x%02hx\n&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;delete_device&quot;</span>, client-&gt;name, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">            list_del(&amp;client-&gt;detected);</span><br><span class="line">            i2c_unregister_device(client);</span><br><span class="line">            res = count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        dev_err(dev, <span class="string">&quot;%s: Can&#x27;t find device in list\n&quot;</span>,</span><br><span class="line">            <span class="string">&quot;delete_device&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR_IGNORE_LOCKDEP</span><span class="params">(delete_device, S_IWUSR, <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   i2c_sysfs_delete_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">i2c_adapter_attrs</span>[] =</span> &#123;</span><br><span class="line">    &amp;dev_attr_name.attr,</span><br><span class="line">    &amp;dev_attr_new_device.attr,</span><br><span class="line">    &amp;dev_attr_delete_device.attr,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line">ATTRIBUTE_GROUPS(i2c_adapter);</span><br></pre></td></tr></table></figure>
<p>可以看见其实很简单，就是获取初入的name和addr动态初始化一个info，然后利用 new_device 函数创建一个i2c_client ，这种方式和方式2是一样的，只是将方式2开放给用户空间一个接口。</p>
<h2 id="6、acpi方式添加"><a href="#6、acpi方式添加" class="headerlink" title="6、acpi方式添加"></a>6、acpi方式添加</h2><p>参考: kernel-4.9/Documentation/acpi/enumeration.txt.</p>
<h1 id="三、获取-i2c-client-结构"><a href="#三、获取-i2c-client-结构" class="headerlink" title="三、获取 i2c_client 结构"></a>三、获取 i2c_client 结构</h1><p>有了具体的设备结构 i2c_client, 我们要怎么用呢，比如我想向i2c0上的 cap_touch 发送数据，怎么获取到对应的 i2c_client 结构呢？很简单因为 i2c_client 被挂接到了 i2c 总线上，因此我们只需要向 i2c 总线上注册一个 i2c_driver ，并且使用要用到的 i2c_client 的name作为 i2c_driver 的 i2c_device_id-&gt;name。那么总线就会去匹配和 i2c_device_id-&gt;name 相同 name 的 i2c_client(这是i2c总线的match函数匹配规则)，匹配成功则调用driver的probe成员函数并且将i2c_client作为参数传入，这样我们就获取到了我们想要的具体的 i2c_client 设备结构。 于是想要获取到 cap_touch 的 i2c_client 的示例代码如下（代码并不完整这只是一个伪代码）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> my<span class="constructor">_i2c_probe(<span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_device_id</span> <span class="operator">*</span><span class="params">id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_probe\n&quot;</span>); </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> my<span class="constructor">_i2c_remove(<span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span> <span class="params">client</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;my_drv_remove\n&quot;</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历这里数组中的 i2c_device_id.name 一个一个匹配</span></span><br><span class="line">static const <span class="keyword">struct</span> i2c_device_id my_id_table<span class="literal">[]</span> = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;cap_touch&quot;</span>, <span class="number">0</span> &#125;, <span class="comment">//通过这个名字获取到我们需要的 i2c_client 设备结构 </span></span><br><span class="line">    &#123; NULL, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">struct</span> i2c_driver my_i2c_driver = &#123;</span><br><span class="line">    .probe  = my_i2c_probe,</span><br><span class="line">    .remove = my_i2c_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">           .name = <span class="string">&quot;cap_touch&quot;</span>, <span class="comment">//驱动的name将出现在 /sys/bus/i2c/ 下</span></span><br><span class="line">           &#125;,</span><br><span class="line">	.id_table = my_id_table, <span class="comment">//匹配用到的结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> my<span class="constructor">_i2c_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i2c<span class="constructor">_add_driver(&amp;<span class="params">my_i2c_driver</span>)</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void my<span class="constructor">_i2c_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span><span class="constructor">_init(<span class="params">my_i2c_init</span>)</span>;</span><br><span class="line"><span class="keyword">module</span><span class="constructor">_exit(<span class="params">my_i2c_exit</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>i2c_add_driver 的内部工作原理到底是怎么样的呢，看看源码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#define i2c<span class="constructor">_add_driver(<span class="params">driver</span>)</span> \</span><br><span class="line">    i2c<span class="constructor">_register_driver(THIS_MODULE, <span class="params">driver</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_register_driver(<span class="params">struct</span> <span class="params">module</span> <span class="operator">*</span><span class="params">owner</span>, <span class="params">struct</span> <span class="params">i2c_driver</span> <span class="operator">*</span><span class="params">driver</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">WARN_ON(!<span class="params">is_registered</span>)</span>)</span><br><span class="line">        return -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add the driver to the list of i2c drivers in the driver core */</span></span><br><span class="line">    driver-&gt;driver.owner = owner;</span><br><span class="line">    driver-&gt;driver.bus = &amp;i2c_bus_type; <span class="comment">//初始化总线</span></span><br><span class="line">    <span class="constructor">INIT_LIST_HEAD(&amp;<span class="params">driver</span>-&gt;<span class="params">clients</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment">     * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将驱动注册进入bus总线</span></span><br><span class="line">    res = driver<span class="constructor">_register(&amp;<span class="params">driver</span>-&gt;<span class="params">driver</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    pr<span class="constructor">_debug(<span class="string">&quot;driver [%s] registered\n&quot;</span>, <span class="params">driver</span>-&gt;<span class="params">driver</span>.<span class="params">name</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the adapters that are already present */</span></span><br><span class="line">    <span class="comment">//对应前面提到的 动态探测I2C总线添加i2c设备 内核不推荐使用这种方式。</span></span><br><span class="line">    i2c<span class="constructor">_for_each_dev(<span class="params">driver</span>, <span class="params">__process_new_driver</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用driver_register这个函数将驱动注册进入内核时，会使用设备模型的匹配机制，和总线上的设备进行匹配。简单描述一下调用流程：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">bus_add_driver</span>----&gt;</span></span><br><span class="line">	<span class="function"><span class="title">driver_attach</span>----&gt;</span> 无论如何最终都会调用这个函数</span><br><span class="line">		<span class="function"><span class="title">bus_for_each_dev</span>----&gt;</span></span><br><span class="line">			__<span class="function"><span class="title">driver_attach</span>----&gt;</span></span><br><span class="line">				<span class="function"><span class="title">driver_match_device</span>----&gt;</span></span><br><span class="line">					<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>match(dev, drv) <span class="comment">//如果匹配成功则调用 really_probe</span></span><br><span class="line">					<span class="function"><span class="title">really_probe</span>----&gt;</span></span><br><span class="line">						<span class="function"><span class="title">dev</span>-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe(dev) <span class="comment">//默认点调用这个</span></span><br><span class="line">						<span class="function"><span class="title">drv</span>-&gt;</span><span class="function"><span class="title">probe</span>(dev) //如果没有设置 dev-&gt;</span><span class="function"><span class="title">bus</span>-&gt;</span>probe 函数，则调用这个</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终调用总线上的match函数 i2c_device_match </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_device_match(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">struct</span> <span class="params">device_driver</span> <span class="operator">*</span><span class="params">drv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_client   *client = i2c<span class="constructor">_verify_client(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> i2c_driver   *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">of</span><span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>) <span class="comment">//设备树方式匹配</span></span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi<span class="constructor">_driver_match_device(<span class="params">dev</span>, <span class="params">drv</span>)</span>) <span class="comment">//先不管，后面有机会补充</span></span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    driver = <span class="keyword">to</span><span class="constructor">_i2c_driver(<span class="params">drv</span>)</span>;</span><br><span class="line">    <span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;id_table) <span class="comment">// id_table 进行匹配</span></span><br><span class="line">        return i2c<span class="constructor">_match_id(<span class="params">driver</span>-&gt;<span class="params">id_table</span>, <span class="params">client</span>)</span> != NULL;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从该函数知道，i2c总线提供了3中匹配的方式，无论是什么方式都是获取我们需要的 i2c_client 结构：</p>
<ol>
<li>使用设备树 compatible 字段进行匹配</li>
<li>acpi 方式匹配（这个用了再来补充）</li>
<li>使用 id_table方式进行匹配</li>
</ol>
<p>其中设备树方式在设备模型中已讨论，这种匹配方式只能匹配到设备树中生成的设备，而我们根本不会将 i2c_client 写到设备树中，因此这个匹配方式是匹配不到我们需要的 i2c_client 设备的，我也不知道为什么会写入这种规则，有大佬知道可以告知一下，这里讨论 id_table 方式</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *i2c_match_id(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="keyword">id</span>,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">id</span>-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strcmp(client-&gt;name, <span class="keyword">id</span>-&gt;name) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">id</span>;</span><br><span class="line">        <span class="keyword">id</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看起来很简单，就是比较 i2c_client-&gt;name 和 i2c_device_id-&gt;name 是否相同，如果相同则匹配成功，匹配成功后调用总线对应的 probe 函数 i2c_device_probe</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="built_in">int</span> i2c<span class="constructor">_device_probe(<span class="params">struct</span> <span class="params">device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_client   *client = i2c<span class="constructor">_verify_client(<span class="params">dev</span>)</span>;</span><br><span class="line">    <span class="keyword">struct</span> i2c_driver   *driver;</span><br><span class="line">    <span class="built_in">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line">        <span class="built_in">int</span> irq = -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;of_node) &#123; <span class="comment">//更新irq</span></span><br><span class="line">            irq = <span class="keyword">of</span><span class="constructor">_irq_get_byname(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="string">&quot;irq&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (irq<span class="operator"> == </span>-EINVAL<span class="operator"> || </span>irq<span class="operator"> == </span>-ENODATA)</span><br><span class="line">                irq = <span class="keyword">of</span><span class="constructor">_irq_get(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, 0)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="constructor">ACPI_COMPANION(<span class="params">dev</span>)</span>) &#123;</span><br><span class="line">            irq = acpi<span class="constructor">_dev_gpio_irq_get(ACPI_COMPANION(<span class="params">dev</span>)</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (irq<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">            return irq;</span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">            irq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        client-&gt;irq = irq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver = <span class="keyword">to</span><span class="constructor">_i2c_driver(<span class="params">dev</span>-&gt;<span class="params">driver</span>)</span>; <span class="comment">//获取对应的 i2c_driver 结构</span></span><br><span class="line">    <span class="keyword">if</span> (!driver-&gt;probe<span class="operator"> || </span>!driver-&gt;id_table)</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_WAKE) &#123;</span><br><span class="line">        <span class="built_in">int</span> wakeirq = -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">            wakeirq = <span class="keyword">of</span><span class="constructor">_irq_get_byname(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="string">&quot;wakeup&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (wakeirq<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">                return wakeirq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        device<span class="constructor">_init_wakeup(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wakeirq &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>wakeirq != client-&gt;irq)</span><br><span class="line">            status = dev<span class="constructor">_pm_set_dedicated_wake_irq(<span class="params">dev</span>, <span class="params">wakeirq</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>)</span><br><span class="line">            status = dev<span class="constructor">_pm_set_wake_irq(<span class="params">dev</span>, <span class="params">client</span>-&gt;<span class="params">irq</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            dev<span class="constructor">_warn(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="string">&quot;failed to set up wakeup irq\n&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev<span class="constructor">_dbg(<span class="params">dev</span>, <span class="string">&quot;probe\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="keyword">of</span><span class="constructor">_clk_set_defaults(<span class="params">dev</span>-&gt;<span class="params">of_node</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        goto err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    status = dev<span class="constructor">_pm_domain_attach(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (status<span class="operator"> == </span>-EPROBE_DEFER)</span><br><span class="line">        goto err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    status = driver-&gt;probe(client, i2c<span class="constructor">_match_id(<span class="params">driver</span>-&gt;<span class="params">id_table</span>, <span class="params">client</span>)</span>); <span class="comment">//最终调用i2c_driver下的probe函数，并使用 client 匹配成功的driver-&gt;id_table作为参数</span></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        goto err_detach_pm_domain;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_detach_pm_domain:</span><br><span class="line">    dev<span class="constructor">_pm_domain_detach(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">true</span>)</span>;</span><br><span class="line">err_clear_wakeup_irq:</span><br><span class="line">    dev<span class="constructor">_pm_clear_wake_irq(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>)</span>;</span><br><span class="line">    device<span class="constructor">_init_wakeup(&amp;<span class="params">client</span>-&gt;<span class="params">dev</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_device_probe 函数又根据更新了了一次 irq，并最终调用了注册的  i2c_driver 结构的 probe 成员函数。于是在 probe 函数中我们就获取到了我们需要的 i2c_client 结构。内核也提供了一个demo，参考kernel-4.9，Documentation/i2c/upgrading-clients</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span>   *client;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int example_probe(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *client,</span><br><span class="line">                 <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span></span> *id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> *state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev = &amp;client-&gt;dev;</span><br><span class="line"></span><br><span class="line">    state = kzalloc(sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (state == NULL) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;failed to create our state\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;client = client;</span><br><span class="line">    i2c_set_clientdata(client, state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rest of the initialisation goes here. */</span></span><br><span class="line"></span><br><span class="line">    dev_info(dev, <span class="string">&quot;example client created\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int example_remove(<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span></span> *client)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_state</span></span> *state = i2c_get_clientdata(client);</span><br><span class="line"></span><br><span class="line">    kfree(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span></span> example_idtable[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;example&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(i2c, example_idtable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span></span> example_driver = &#123;</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .owner      = THIS_MODULE,</span><br><span class="line">        .name       = <span class="string">&quot;example&quot;</span>,</span><br><span class="line">        .pm     = &amp;example_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table   = example_idtable,</span><br><span class="line">    .probe      = example_probe,</span><br><span class="line">    .remove     = example_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="四、使用-i2c-client-通信"><a href="#四、使用-i2c-client-通信" class="headerlink" title="四、使用 i2c_client 通信"></a>四、使用 i2c_client 通信</h1><p>获取到 i2c_client 结构之后，就可以使用它来进行i2c通信了，内核使用 i2c_msg 结构装了传输的数据，每次通讯都是以 i2c_msg 为单位的</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    <span class="variable">__u16</span> addr; 	<span class="comment">//设备地址</span></span><br><span class="line">    <span class="variable">__u16</span> flags;	<span class="comment">//传输标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD        0x0001  <span class="comment">//设置了这个表示表示本次通信为接收数据，否则为发送数据。</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">//设置了这个表示从设备地址有10bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN      0x0400  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">//在读操作中不需要ack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">//当前i2cmsg忽略i2c器件的ack和nack信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">//读写标志位反过来</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">//当前i2c_msg不发送start信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    <span class="variable">__u16</span> len;      <span class="comment">//数据长度，单位为byte</span></span><br><span class="line">    <span class="variable">__u8</span> *buf;      <span class="comment">//数据缓冲区指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1、i2c-master-send"><a href="#1、i2c-master-send" class="headerlink" title="1、i2c_master_send"></a>1、i2c_master_send</h2><p>该函数用于向 i2c_client 发送buf指向的数据，数据长度为count字节</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_master_send(<span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    <span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.len = count;</span><br><span class="line">    msg.buf = (<span class="built_in">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">    ret = i2c<span class="constructor">_transfer(<span class="params">adap</span>, &amp;<span class="params">msg</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If everything went ok (i.e. 1 msg transmitted), return #bytes</span></span><br><span class="line"><span class="comment">     * transmitted, else error code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    return (ret<span class="operator"> == </span><span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">EXPORT_SYMBOL(<span class="params">i2c_master_send</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2、i2c-master-recv"><a href="#2、i2c-master-recv" class="headerlink" title="2、i2c_master_recv"></a>2、i2c_master_recv</h2><p>该函数用于向 i2c_client 接收数据长度为count字节的数据，数据被存在buf中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i2c<span class="constructor">_master_recv(<span class="params">const</span> <span class="params">struct</span> <span class="params">i2c_client</span> <span class="operator">*</span><span class="params">client</span>, <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">    <span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr;</span><br><span class="line">    msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">    msg.flags <span class="pattern-match">|= <span class="constructor">I2C_M_RD</span>;</span></span><br><span class="line"><span class="pattern-match">    msg.len = count;</span></span><br><span class="line"><span class="pattern-match">    msg.buf = buf;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    ret = i2c<span class="constructor">_transfer(<span class="params">adap</span>, &amp;<span class="params">msg</span>, 1)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span></span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="constructor">If</span> everything went ok (i.e. 1 msg received), return #<span class="built_in">bytes</span> received,</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="keyword">else</span> error code.</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">    return (ret <span class="operator">==</span> 1) ? count : ret;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">EXPORT_SYMBOL(<span class="params">i2c_master_recv</span>)</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、i2c-transfer"><a href="#3、i2c-transfer" class="headerlink" title="3、i2c_transfer"></a>3、i2c_transfer</h2><p>该函数向 i2c_adapter 所表示的总线上传输 num 个 msgs。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">ret</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ret</span> = 0; <span class="keyword">ret</span> &lt; num; <span class="keyword">ret</span>++) &#123;</span><br><span class="line">            dev_dbg(&amp;adap-&gt;dev,</span><br><span class="line">                <span class="string">&quot;master_xfer[%d] %c, addr=0x%02x, len=%d%s\n&quot;</span>,</span><br><span class="line">                <span class="keyword">ret</span>, (msgs[<span class="keyword">ret</span>].flags &amp; I2C_M_RD) ? &#x27;R&#x27; : &#x27;W&#x27;,</span><br><span class="line">                msgs[<span class="keyword">ret</span>].addr, msgs[<span class="keyword">ret</span>].len,</span><br><span class="line">                (msgs[<span class="keyword">ret</span>].flags &amp; I2C_M_RECV_LEN) ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_atomic() || irqs_disabled()) &#123;</span><br><span class="line">            <span class="keyword">ret</span> = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">ret</span>)</span><br><span class="line">                <span class="comment">/* I2C activity is ongoing. */</span></span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i2c_lock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ret</span> = __i2c_transfer(adap, msgs, num);</span><br><span class="line">        i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>驱动</tag>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言基础知识</title>
    <url>/2020/01/03/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;用于记录 c 语言基础知识,如果没有特别说明本文的所有代码编译环境为 gcc 编译器编译，学习资料来自狄泰软件学院可在淘宝购买学习</p>
<a id="more"></a>

<h1 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a><div align=center>一、基本数据类型</h1><h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><ul>
<li><strong>含义</strong></li>
</ul>
<p>&nbsp; &nbsp;&nbsp;固定内存大小的别名</p>
<ul>
<li><strong>作用</strong></li>
</ul>
<p>&nbsp; &nbsp;&nbsp;创建变量</p>
<table>
<thead>
<tr>
<th>c语言数据类型表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>Storage size</td>
<td>Value range Precision</td>
</tr>
<tr>
<td>char</td>
<td>1 byte</td>
<td>-128 to 127 or 0 to 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 byte</td>
<td>0 to 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 byte</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>int</td>
<td>2 or 4 bytes</td>
<td>-32,768to32,767 or -2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 or 4 bytes</td>
<td>0 to 65,535 or 0 to 4,294,967,295</td>
</tr>
<tr>
<td>short</td>
<td>2 bytes</td>
<td>-32,768 to 32,767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 bytes</td>
<td>0 to 65,535</td>
</tr>
<tr>
<td>long</td>
<td>4 bytes</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 bytes</td>
<td>0 to 4,294,967,295</td>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>1.2E-38 to 3.4E+38 6 decimal places</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>2.3E-308 to 1.7E+308 15 decimal places</td>
</tr>
<tr>
<td>long double</td>
<td>10 byte</td>
<td>3.4E-4932 to 1.1E+4932 19 decimal places</td>
</tr>
</tbody></table>
<h2 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h2><ul>
<li><p><strong>本质</strong><br>&nbsp; &nbsp;&nbsp;一段连续存储空间的别名，大小由创建的数据类型定</p>
</li>
<li><p><strong>作用</strong><br>&nbsp; &nbsp;&nbsp;程序通过变量申请储存空间<br>&nbsp; &nbsp;&nbsp;通过变量名使用储存空间<br>&nbsp; &nbsp;&nbsp;通过变量名区分相同大小相同类型的内存空间</p>
</li>
<li><p><strong>补充</strong><br>&nbsp; &nbsp;&nbsp;sizeof关键字用来计算变量，类型，字符串，数组，或结构体等所占内存空间大小</p>
</li>
<li><p><strong>重新命名一个数据类型</strong><br>&nbsp; &nbsp;&nbsp;通过 typedef 关键字重新命名一个数据类型</p>
</li>
</ul>
<h2 id="3、编程实验"><a href="#3、编程实验" class="headerlink" title="3、编程实验"></a>3、编程实验</h2><h3 id="编程实验1：数据类型与变量"><a href="#编程实验1：数据类型与变量" class="headerlink" title="编程实验1：数据类型与变量"></a>编程实验1：数据类型与变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">short</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(char) = %d\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(short) = %d\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(b) = %d\n\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int) = %d\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(c) = %d\n\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>) = <span class="number">1</span></span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">short</span>) = <span class="number">2</span></span><br><span class="line"><span class="keyword">sizeof</span>(b) = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>) = <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(c) = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="编程实验2：typedef自定义数据类型"><a href="#编程实验2：typedef自定义数据类型" class="headerlink" title="编程实验2：typedef自定义数据类型"></a>编程实验2：typedef自定义数据类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tags_ts</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BYTE b1;</span><br><span class="line">    BYTE b2;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    INT32 i;</span><br><span class="line">&#125;TS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32 i32;</span><br><span class="line">    BYTE b;</span><br><span class="line">    TS ts;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(INT32), (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(i32));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(BYTE),  (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(TS),    (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(ts));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">8</span>, <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h1 id="二、有符号数与无符号数"><a href="#二、有符号数与无符号数" class="headerlink" title="二、有符号数与无符号数"></a><div align=center>二、有符号数与无符号数</h1><h2 id="1、有符号数"><a href="#1、有符号数" class="headerlink" title="1、有符号数"></a>1、有符号数</h2><ul>
<li><strong>声明</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;默认为有符号数，用 signed 关键字声明</li>
<li><strong>数据类型的最高位用来标识数据的符号</strong><br>&nbsp; &nbsp;&nbsp;最高位为1表示这个数为负数<br>&nbsp; &nbsp;&nbsp;最高位为0表示这个数为正数</li>
<li><strong>有符号数的表示方法：在计算机内部用补码表示有符号数</strong><br>&nbsp; &nbsp;&nbsp;正数的补码为正数本身<br>&nbsp; &nbsp;&nbsp;负数的补码为对应的正数的反码加1</li>
</ul>
<h2 id="2、无符号数"><a href="#2、无符号数" class="headerlink" title="2、无符号数"></a>2、无符号数</h2><ul>
<li><strong>声明</strong><br>&nbsp; &nbsp;用 unsigned 关键字声明，不能声明浮点型 float double</li>
<li><strong>特点</strong><br>&nbsp; &nbsp;&nbsp;默认为正数<br>&nbsp; &nbsp;&nbsp;没有符号位<br>&nbsp; &nbsp;&nbsp;最大值 + 1 = 最小值<br>&nbsp; &nbsp;&nbsp;最小值 - 1 = 最大值<br>&nbsp; &nbsp;&nbsp;有符号数与无符号整形数（unsigned int）混合运算，<font color=red>有符号会被转换为无符号数，结果为无符号数</font></li>
</ul>
<h2 id="3、编程实验-1"><a href="#3、编程实验-1" class="headerlink" title="3、编程实验"></a>3、编程实验</h2><h3 id="编程实验1：证明有符号数的表示方法"><a href="#编程实验1：证明有符号数的表示方法" class="headerlink" title="编程实验1：证明有符号数的表示方法"></a>编程实验1：证明有符号数的表示方法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">-5</span>;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)( (c&amp;<span class="number">0x80</span>) !=<span class="number">0</span> ));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)( (s&amp;<span class="number">0x8000</span>) !=<span class="number">0</span> ));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)( (i&amp;<span class="number">0x80000000</span>) !=<span class="number">0</span> ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="编程实验2：有符号数与无符号数的混合运算"><a href="#编程实验2：有符号数与无符号数的混合运算" class="headerlink" title="编程实验2：有符号数与无符号数的混合运算"></a>编程实验2：有符号数与无符号数的混合运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i =    <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((i+j) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i+j &lt; 0\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i+j &gt; 0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">i+j &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="编程实验3：无符号数（最小值-1-最大值）"><a href="#编程实验3：无符号数（最小值-1-最大值）" class="headerlink" title="编程实验3：无符号数（最小值 - 1 = 最大值）"></a>编程实验3：无符号数（最小值 - 1 = 最大值）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">9</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i =%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： 程序死循环打印</span><br></pre></td></tr></table></figure>
<h1 id="三、内存中的浮点数（float-double）"><a href="#三、内存中的浮点数（float-double）" class="headerlink" title="三、内存中的浮点数（float double）"></a><div align=center>三、内存中的浮点数（float double）</h1><h2 id="1、存储方式"><a href="#1、存储方式" class="headerlink" title="1、存储方式"></a>1、存储方式</h2><p>符号位，指数，尾数</p>
<table>
<thead>
<tr>
<th>存储表</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>符号</td>
<td>指数</td>
<td>尾数</td>
</tr>
<tr>
<td>float</td>
<td>1位（第31位）</td>
<td>8位（第23-30位）</td>
<td>23位（第0-22位）</td>
</tr>
<tr>
<td>double</td>
<td>1位（第63位）</td>
<td>11位（第52-62位）</td>
<td>52位（第0-51位）</td>
</tr>
</tbody></table>
<h2 id="2、浮点数转换（十进制）"><a href="#2、浮点数转换（十进制）" class="headerlink" title="2、浮点数转换（十进制）"></a>2、浮点数转换（十进制）</h2><p>&nbsp; &nbsp; 1）将浮点数转换为二进制<br>&nbsp; &nbsp; 2）用科学计数法表示二进制浮点数<br>&nbsp; &nbsp; 3）计算指数偏移后的值 （指数+偏移量）<br>&nbsp; &nbsp; 4）偏移量：   float     127<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double     1023</p>
<h2 id="3、8-25的float的表示"><a href="#3、8-25的float的表示" class="headerlink" title="3、8.25的float的表示"></a>3、8.25的float的表示</h2><ul>
<li><strong>转换为二进制数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;8.25   ==&gt; 1000.01</li>
<li><strong>用科学计数法表示二进制浮点数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;100.01 ==&gt; 1.00001 *2^3</li>
<li><strong>计算指数偏移后的值</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;3 + 127 = 130  ==&gt; 1000 0010</li>
<li><strong>小数部分</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;00001</li>
<li><strong>内存中的表示</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;0x41040000<br>&nbsp;&nbsp;&nbsp;&nbsp;0（符号） 1000 0010（指数） 00001 0000000000000000（小数）</li>
<li><strong>补充知识点：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;十进制小数转为二进制小数（乘2取整）<br>&nbsp;&nbsp;&nbsp;&nbsp;例子：0.25<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.25 x 2 = 0.5      取整是0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 x 2  = 1.0      取整是1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即 0.25 的二进制表示方法为 0.01</li>
</ul>
<h2 id="4、浮点型的秘密（重点）"><a href="#4、浮点型的秘密（重点）" class="headerlink" title="4、浮点型的秘密（重点）"></a>4、浮点型的秘密（重点）</h2><ul>
<li><p><strong>float可以表示的具体数值个数与int类型相同</strong></p>
</li>
<li><p><strong>flaot可表示的数字之间是不连续的，存在间隙</strong></p>
</li>
<li><p><strong>float只是一种近似的表示法，不能作为精确数使用</strong></p>
</li>
<li><p><strong>float的运算速度比int慢的多</strong></p>
</li>
</ul>
<h2 id="5、编程实验"><a href="#5、编程实验" class="headerlink" title="5、编程实验"></a>5、编程实验</h2><h3 id="编程实验1：8-25-float的表示"><a href="#编程实验1：8-25-float的表示" class="headerlink" title="编程实验1：8.25 float的表示"></a>编程实验1：8.25 float的表示</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">8.25</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>* p = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)&amp;f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>, *p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：<span class="number">0x41040000</span></span><br></pre></td></tr></table></figure>
<h3 id="编程实验2：float-类型的不精确性，与不连续性"><a href="#编程实验2：float-类型的不精确性，与不连续性" class="headerlink" title="编程实验2：float 类型的不精确性，与不连续性"></a>编程实验2：float 类型的不精确性，与不连续性</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">123456789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f  = %0.10f\n&quot;</span>, f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f1 = %0.10f\n&quot;</span>, f1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">f  = <span class="number">3.1400001049</span></span><br><span class="line">f1 = <span class="number">123456792.0000000000</span></span><br></pre></td></tr></table></figure>
<h1 id="四、数据类型之间的转换"><a href="#四、数据类型之间的转换" class="headerlink" title="四、数据类型之间的转换"></a><div align=center>四、数据类型之间的转换</h1><h2 id="1、强制类型转换"><a href="#1、强制类型转换" class="headerlink" title="1、强制类型转换"></a>1、强制类型转换</h2><p><strong>(type)var_name</strong><br><strong>(type)vale</strong><br>转换结果：<br>&nbsp;&nbsp;1）目标类型能够容纳目标值:结果不变<br>&nbsp;&nbsp;2）目标类型不能容纳目标值:结果将产生截断保留低位丢掉高位<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：float转换为 int ,直接丢掉小数部分<br>&nbsp;&nbsp;3）不是所有的强制类型转换都能成功，不能转换编译器报错<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：结构体转换为 int 类型</p>
<h2 id="2、隐式类型转换"><a href="#2、隐式类型转换" class="headerlink" title="2、隐式类型转换"></a>2、隐式类型转换</h2><p>编译器主动进行的转换<br>低类型：占用字节数相对较小的变量<br>高类型：占用字节数相对较高的变量<br>1）转换的安全性<br>&nbsp;&nbsp;&nbsp;&nbsp;a）低类型到高类型的转换时是安全的，不会产生截断<br>&nbsp;&nbsp;&nbsp;&nbsp;b）高类型到低类型的转换时是不安全的，会产生截断，产生不正确的结果<br>2）转换发生点：<br>&nbsp;&nbsp;&nbsp;&nbsp;a）算数运算，低类型转换为高类型<br>&nbsp;&nbsp;&nbsp;&nbsp;b）赋值表达式中，表达式中的右值类型转换为左值的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;c）函数调用时，形参转换为实参的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;d）函数返回值，return表达式后面的返回值转换为返回值类型</p>
<img src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/8.png" >

<h2 id="3、编程实验-2"><a href="#3、编程实验-2" class="headerlink" title="3、编程实验"></a>3、编程实验</h2><h3 id="编程实验1：强制类型转换"><a href="#编程实验1：强制类型转换" class="headerlink" title="编程实验1：强制类型转换"></a>编程实验1：强制类型转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_ts</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;TS;</span><br><span class="line"></span><br><span class="line">TS ts;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">0x1122</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = (<span class="keyword">char</span>)s;    <span class="comment">// 0x22</span></span><br><span class="line">    <span class="keyword">int</span>  i = (<span class="keyword">int</span>)s;     <span class="comment">// 0x1122</span></span><br><span class="line">    <span class="keyword">int</span>  j = (<span class="keyword">int</span>)<span class="number">3.123</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;ts; <span class="comment">// 64位机器产生截断，32位机器正常转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  long l = (long)ts; // 转换失败编译报错</span></span><br><span class="line"><span class="comment">//  ts = (TS)s;        // 转换失败编译报错</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = 0x%x\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = 0x%x\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j = 0x%x\n&quot;</span>, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">c = <span class="number">0x22</span></span><br><span class="line">i = <span class="number">0x1122</span></span><br><span class="line">j = <span class="number">0x3</span></span><br><span class="line">p = <span class="number">0x3558018</span></span><br></pre></td></tr></table></figure>
<h3 id="编程实验2：隐式类型转换"><a href="#编程实验2：隐式类型转换" class="headerlink" title="编程实验2：隐式类型转换"></a>编程实验2：隐式类型转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = c;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="keyword">short</span> s = j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %c\n&quot;</span>, c);   <span class="comment">// a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);   <span class="comment">// 97</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j = 0x%x\n&quot;</span>, j); <span class="comment">// 0x11223344</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = 0x%x\n&quot;</span>, s); <span class="comment">// 0x3344</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(c+s):%ld\n&quot;</span>, <span class="keyword">sizeof</span>(c+s)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line">c = a</span><br><span class="line">i = <span class="number">97</span></span><br><span class="line">j = <span class="number">0x11223344</span></span><br><span class="line">s = <span class="number">0x3344</span></span><br><span class="line"><span class="keyword">sizeof</span>(c+s):<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h1 id="五、分支语句"><a href="#五、分支语句" class="headerlink" title="五、分支语句"></a><div align=center>五、分支语句</h1><h2 id="1、if-语句分析"><a href="#1、if-语句分析" class="headerlink" title="1、if 语句分析"></a>1、if 语句分析</h2><ul>
<li><strong>多用于复杂逻辑进行判断</strong></li>
<li><strong>与零值比较注意点</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）bool 型变量应该直接出现在条件中，不要进行比较<br>&nbsp;&nbsp;&nbsp;&nbsp;2）变量和 0 字面常量比较,0 字面常量应该出现在比较符的左边<br>&nbsp;&nbsp;&nbsp;&nbsp;3）float 不能直接和 0 进行比较，需要定义精度</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (<span class="number">6</span> &lt;= i) &amp;&amp; (i &lt;= <span class="number">8</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Perfect!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f1(<span class="number">5</span>);    <span class="comment">// Failed!</span></span><br><span class="line">    f1(<span class="number">9</span>);    <span class="comment">// Perfect!</span></span><br><span class="line">    f1(<span class="number">7</span>);    <span class="comment">// Good!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	Failed!</span><br><span class="line">	Perfect!</span><br><span class="line">	Good!</span><br></pre></td></tr></table></figure>
<h2 id="2、switch-语句分析"><a href="#2、switch-语句分析" class="headerlink" title="2、switch 语句分析"></a>2、switch 语句分析</h2><ul>
<li><strong>多用于多分支判断</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）必须要有 break ，否则会导致分支重叠<br>&nbsp;&nbsp;&nbsp;&nbsp;2）case 语句中的值只能是整形或者字符型<br>&nbsp;&nbsp;&nbsp;&nbsp;3）按字母或者数字顺序排列各条语句<br>&nbsp;&nbsp;&nbsp;&nbsp;4）正常的放在前面，异常的放在后面<br>&nbsp;&nbsp;&nbsp;&nbsp;5）default 必须加上，只用于处理正真异常的情况</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">char</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Compile\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Debug\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Object\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Run\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f2(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// Object</span></span><br><span class="line">    f2(<span class="string">&#x27;d&#x27;</span>); <span class="comment">// Debug</span></span><br><span class="line">    f2(<span class="string">&#x27;e&#x27;</span>); <span class="comment">// Unknown</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	Object</span><br><span class="line">	Debug</span><br><span class="line">	Unknown</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3、循环语句"><a href="#3、循环语句" class="headerlink" title="3、循环语句"></a>3、循环语句</h2><ul>
<li><p><strong>for 先判断，适用于循环次数固定的循环</strong></p>
</li>
<li><p><strong>while 先判断，适用于循环次数不固定的场合</strong></p>
</li>
<li><p><strong>do while 循环至少执行一次循环体</strong></p>
</li>
<li><p><strong>break 和 continue 的区别</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;break 表示终止循环<br>&nbsp;&nbsp;&nbsp;&nbsp;continue 表示终止本次循环，进入下次循环</p>
</li>
<li><p><strong>do while(0) 巧妙使用，释放内存空间，避开内存泄漏</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        dosomething...;</span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dosomething...;</span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dosomething...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六、c语言变量属性"><a href="#六、c语言变量属性" class="headerlink" title="六、c语言变量属性"></a><div align=center>六、c语言变量属性</h1><h2 id="1、auto-关键字"><a href="#1、auto-关键字" class="headerlink" title="1、auto 关键字"></a>1、auto 关键字</h2><ul>
<li><strong>C 语言中局部变量的默认属性</strong></li>
<li><strong>表明被修饰的变量处于栈上</strong></li>
<li><strong>编译器默认所有的局部变量都是 auto</strong></li>
</ul>
<h2 id="2、register-关键字"><a href="#2、register-关键字" class="headerlink" title="2、register 关键字"></a>2、register 关键字</h2><ul>
<li><strong>请求编译器将这个局部变量变量存储在寄存器中</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）如果申明具有全局属性的变量则编译器 error<br>&nbsp;&nbsp;&nbsp;&nbsp;2）cpu 寄存器有限不能长时间占用</li>
<li><strong>只是请求寄存器变量，不一定成功</strong></li>
<li><strong>变量必须是cpu可以接受的值</strong></li>
<li><strong>不能用 &amp; 运算符获取 register 变量的值，否则会报错</strong><blockquote>
<p>存在意义：当时为了解决效率问题，在尽可能需要效率的方，给你效率</p>
</blockquote>
</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>;   <span class="comment">// 向编译器申请将 j 存储于寄存器中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;j);   <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">	a.c:<span class="number">7</span>: error: address of <span class="keyword">register</span> variable ‘j’ requested</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3、static-关键字"><a href="#3、static-关键字" class="headerlink" title="3、static 关键字"></a>3、static 关键字</h2><ul>
<li><strong>指明”静态“属性</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1) 被修饰的局部变量存储在程序的静态区</li>
<li><strong>具有”作用域限定符“作用</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1) 修饰的全局变量作用域只是声明文件中<br>&nbsp;&nbsp;&nbsp;&nbsp;2) 修饰函数的作用域只是声明的文件中</li>
</ul>
<p><strong>编程实验1，修饰局部变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    r++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    r++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> i = <span class="number">0</span>;       <span class="comment">// 显示声明 auto 属性，i 为栈变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;     <span class="comment">// 局部变量 k 的存储区位于静态区，作用域位于 main 中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>, &amp;i);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;j = %p\n&quot;</span>, &amp;k); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f1()); <span class="comment">// 1,1,1,1,1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f2()); <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">&amp;i = <span class="number">0xbfa141cc</span></span><br><span class="line">&amp;k = <span class="number">0x804a020</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>编程实验2，修饰全局变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件 a.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span>  <span class="comment">//使用是这个方式获得static声明的全局变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_j);     <span class="comment">// ERROR</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, getI());  <span class="comment">// 0   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	<span class="number">5</span><span class="number">-2.</span>c:(.text+<span class="number">0xb</span>): undefined reference to `g_j<span class="number">&#x27;</span></span><br><span class="line">说明：</span><br><span class="line">	注释掉 <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_j);正常运行输出 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="4、extern-关键字"><a href="#4、extern-关键字" class="headerlink" title="4、extern 关键字"></a>4、extern 关键字</h2><ul>
<li><strong>用于声明“外部”定义的变量或函数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1）变量在文件的其它地方分配空间<br>&nbsp;&nbsp;&nbsp;&nbsp;2）函数在文件其它地方定义</li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	i = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>“告诉”c++编译器用c方式编译</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5、goto-关键字"><a href="#5、goto-关键字" class="headerlink" title="5、goto 关键字"></a>5、goto 关键字</h2><ul>
<li><strong>高手潜规则 禁用 goto</strong></li>
<li><strong>项目经验 程序的质量与 goto 出现的次数成反比</strong></li>
<li><strong>c 语言是一种面向过程的结构性语言（顺序 选择 循环三种结构组合而成），goto 破坏了程序的结构性</strong></li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> STATUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"></span><br><span class="line">STATUS:</span><br><span class="line">    p[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func(1)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    func(<span class="number">1</span>);  <span class="comment">// 正常运行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func(-1)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    func(<span class="number">-1</span>); <span class="comment">// 内核崩溃</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">begin ...</span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">func(<span class="number">-1</span>)</span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="6、const-只读变量"><a href="#6、const-只读变量" class="headerlink" title="6、const 只读变量"></a>6、const 只读变量</h2><h3 id="1-const-只读变量基本属性"><a href="#1-const-只读变量基本属性" class="headerlink" title="1) const 只读变量基本属性"></a>1) const 只读变量基本属性</h3><ul>
<li><strong>const 变量是只读的，本质还是变量</strong></li>
<li><strong>const 修饰的局部变量在栈上分配空间</strong></li>
<li><strong>const 修饰的全局变量在全局数据区分配空间</strong></li>
<li><strong>const 只在编译期有用，在运行期无用</strong></li>
</ul>
<blockquote>
<p>注意：<br>const 不能声明正真意义的常量，它只告诉编译器， const 修饰的变量不能出现在赋值符号的左边即不能只作为左值使用。现代 c 编译器将 const 修饰的具有全局生命的变量（全局变量/静态变量）储存于只读存储区，修改（指针） const 全局变量将导致程序崩溃,标准c语言编译器 const 修饰的全局变量在全局数据区分配空间，其值依然可以修改(指针)</p>
</blockquote>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_cc = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cc = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;cc;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cc = %d\n&quot;</span>, cc); <span class="comment">// cc = 1</span></span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">3</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cc = %d\n&quot;</span>, cc); <span class="comment">// cc = 3</span></span><br><span class="line">    </span><br><span class="line">    p = (<span class="keyword">int</span>*)&amp;g_cc;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc); <span class="comment">// g_cc = 2</span></span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">4</span>;					<span class="comment">// error</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	cc = <span class="number">1</span></span><br><span class="line">	cc = <span class="number">3</span></span><br><span class="line">	g_cc = <span class="number">2</span></span><br><span class="line">	段错误</span><br></pre></td></tr></table></figure>
<h3 id="2-const-变量常用区域"><a href="#2-const-变量常用区域" class="headerlink" title="2) const 变量常用区域"></a>2) const 变量常用区域</h3><ul>
<li><strong>const 修饰函数参数和函数返回值</strong></li>
<li><strong>const 修饰函数参数表示在函数体内不希望改变参数的值</strong></li>
<li><strong>const 修饰函数返回值表示返回值不可改变，多用于返回指针的情形</strong></li>
</ul>
<h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3) 扩展"></a>3) 扩展</h3><p>c 语言中的字符串字面量存储于只读存储区中，在程序中需要使用 const char* 指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* s = ”hello word”; 	<span class="comment">//字符串字面量</span></span><br></pre></td></tr></table></figure>
<img src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/11.jpg" >

<h2 id="7、volatile-关键字"><a href="#7、volatile-关键字" class="headerlink" title="7、volatile 关键字"></a>7、volatile 关键字</h2><h3 id="1-编译器警告指示字"><a href="#1-编译器警告指示字" class="headerlink" title="1) 编译器警告指示字"></a>1) 编译器警告指示字</h3><ul>
<li><strong>volatile 关键字告诉编译器每次必须去内存中取变量值</strong></li>
<li><strong>volatile 关键字主要修饰可能被多个线程访问的变量</strong></li>
<li><strong>volatile 也可修饰可能被未知因数更改的变量</strong>    </li>
</ul>
<h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2) 小结"></a>2) 小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当变量在多线程的程序中被其他线程中改变（内存中的值被改变），或者在中断中被改变（内存中的值被改变），而在线程（中断）外部不会改变变量的值（不从内存中取值），volatile 会降低程序的效率（需要访存）即在需要的时候使用，不需要的不使用，多用于嵌入式驱动开发中，当我们直接访问某个内存地址时需要加上这个关键字。</p>
<h1 id="七、void-的意义"><a href="#七、void-的意义" class="headerlink" title="七、void 的意义"></a><div align=center>七、void 的意义</h1><h2 id="1、void-修饰函数参数和返回值"><a href="#1、void-修饰函数参数和返回值" class="headerlink" title="1、void 修饰函数参数和返回值"></a>1、void 修饰函数参数和返回值</h2><ul>
<li><strong>如果函数没有返回值，那么应将其申明为 void</strong></li>
<li><strong>如果函数没有参数，那么应将其参数申明为 void</strong></li>
<li><strong>没有函数返回值类型，默认返回值类型为 int</strong></li>
<li><strong>函数 f() 没有参数，f 默认为参数为任意的参数</strong></li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f();</span><br><span class="line">	f(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;f() = %d\n&quot;</span>,f());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	f() = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="2、void-修饰函数返回值和参数是为了表示“无”"><a href="#2、void-修饰函数返回值和参数是为了表示“无”" class="headerlink" title="2、void 修饰函数返回值和参数是为了表示“无”"></a>2、void 修饰函数返回值和参数是为了表示“无”</h2><ul>
<li><strong>void 为抽象类型(概念上的类型没有大小)</strong>        </li>
<li><strong>不能用于定义变量</strong></li>
<li><strong>不能用于定义数组</strong></li>
<li><strong>可以定义 void 类型的指针</strong></li>
<li><strong>任意的指针都是 4 个或者 8 个字节的指针</strong></li>
</ul>
<blockquote>
<p>知识延伸<br>ANSIC:标准 c 语言规范，扩展 c 在 ANSIC上进行扩充<br>gcc 对 void 进行了扩展，void 的大小为 1</p>
</blockquote>
<h2 id="3、void指针的意义"><a href="#3、void指针的意义" class="headerlink" title="3、void指针的意义"></a>3、void指针的意义</h2><ul>
<li><strong>c 语言规定只有相同类型的指针才能相互赋值</strong></li>
<li>*<em>void</em> 指针作为左值用于“接受”任意类型的指针**</li>
<li>*<em>void</em> 指针作为右值使用时需要进行强制类型转换**    </li>
</ul>
<p>*<em>编程实验，void</em> 的使用**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 函数名：MemSet</span></span><br><span class="line"><span class="comment"> * 功能说明：设置一片内存的每个字节为相同的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemSet</span><span class="params">(<span class="keyword">void</span>* src, <span class="keyword">int</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)src;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    MemSet(a, <span class="keyword">sizeof</span>(a), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]); <span class="comment">// 0,0,0,0,0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="八、struct-结构体"><a href="#八、struct-结构体" class="headerlink" title="八、struct 结构体"></a><div align=center>八、struct 结构体</h1><h2 id="1，定义与声明"><a href="#1，定义与声明" class="headerlink" title="1，定义与声明"></a>1，定义与声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">&#125;variable-<span class="built_in">list</span>，*p_tag ;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> 			  结构体关键字</span></span><br><span class="line"><span class="class"><span class="title">tag</span> 	 		  结构体标志</span></span><br><span class="line"><span class="class"><span class="title">variable</span>-<span class="title">list</span>     定义此结构体时声明的变量</span></span><br><span class="line"><span class="class"><span class="title">member</span>-<span class="title">list</span>		  结构体成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>		  结构体的类型</span></span><br><span class="line"><span class="class"><span class="title">p_tag</span>             定义此结构体时声明的指针</span></span><br><span class="line"><span class="class">此结构体在声明的时候创建了两个变量，分别是结构体变量 <span class="title">variable</span>-<span class="title">list</span> 和 指向 <span class="title">NULL</span> 的结构体指针 <span class="title">p_tag</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="keyword">struct</span> <span class="title">tag</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">member-<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">&#125;variable-<span class="built_in">list</span>，*p_tag ;</span><br><span class="line"></span><br><span class="line">与不用<span class="keyword">typedef</span> 的区别</span><br><span class="line">  a）variable-<span class="built_in">list</span> 定义此结构体时声明的结构体类型，等效于 <span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">  <span class="title">b</span>）<span class="title">p_tag</span>         定义此结构体时声明的结构体指针类型，等效于<span class="keyword">struct</span> <span class="title">tag</span>*</span></span><br></pre></td></tr></table></figure>
<h2 id="2，空结构体"><a href="#2，空结构体" class="headerlink" title="2，空结构体"></a>2，空结构体</h2><p>灰色地带，没有对错。实际开发没有人会定义空结构体<br>gcc  编译器空结构体占用的内存为 0<br>bcc，vc10.0 编译器不允许空结构体的存在于c语言里面</p>
<h2 id="3，结构体与柔性数组"><a href="#3，结构体与柔性数组" class="headerlink" title="3，结构体与柔性数组"></a>3，结构体与柔性数组</h2><h3 id="1-柔性数组即大小待定的数组"><a href="#1-柔性数组即大小待定的数组" class="headerlink" title="1) 柔性数组即大小待定的数组"></a>1) 柔性数组即大小待定的数组</h3><p>c语言可以由结构体产生柔性数组<br>c语言中结构体中当最后一个元素是大小未知的数组时,不占内存空间（结构体中大小未知的数组不能单独存在，或存在多个）</p>
<h3 id="2-柔性数组的使用"><a href="#2-柔性数组的使用" class="headerlink" title="2) 柔性数组的使用"></a>2) 柔性数组的使用</h3><img src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/12.png" >

<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoftArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct SoftArray* <span class="title">create_soft_array</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SoftArray</span>* <span class="title">ret</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( size &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = (struct SoftArray*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SoftArray) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">        </span><br><span class="line">        ret-&gt;len = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_soft_array</span><span class="params">(struct SoftArray* sa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(sa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(struct SoftArray* sa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != sa )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sa-&gt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sa-&gt;<span class="built_in">array</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SoftArray</span>* <span class="title">sa</span> =</span> create_soft_array(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    func(sa);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sa-&gt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sa-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    delete_soft_array(sa);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1 id="九、union-联合体"><a href="#九、union-联合体" class="headerlink" title="九、union 联合体"></a><div align=center>九、union 联合体</h1><p>语法上与 struct 相似 union 只会分配最大成员空间，所有成员共享这个空间<br>注意： union 的使用受系统大小端的影响</p>
<pre><code>int i = 1;
0x01    0x00    0x00    0x00
——————————————————&gt;  高地址
小端模式    //低地址存储低位数据

int i = 1;
0x00    0x00    0x00    0x01
——————————————————&gt;  高地址
大端模式    //低地址存储高位数据

取地址规则：取值从低地址开始取值</code></pre>
<p><strong>编程实验</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">SM</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">SM</span> <span class="title">sm</span>;</span></span><br><span class="line">    </span><br><span class="line">    sm.i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sm.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;System Mode: %d\n&quot;</span>, system_mode()); <span class="comment">//返回1小端模式，返回0大端模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：System Mode: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>运行结果说明 gcc 编译器下的编译环境为小端模式，低地址存放低字节</p>
<h1 id="十、enum-枚举类型"><a href="#十、enum-枚举类型" class="headerlink" title="十、enum 枚举类型"></a><div align=center>十、enum 枚举类型</h1><p>enum 是c语言的一种自定义类型<br>enum 值是可以根据需要自定义的整型值</p>
<h2 id="1、定义与声明"><a href="#1、定义与声明" class="headerlink" title="1、定义与声明"></a>1、定义与声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">enu_name</span>			</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    val1 = <span class="number">-1</span>,</span><br><span class="line">    val2 = <span class="number">3</span>,</span><br><span class="line">    val3,</span><br><span class="line">    ...</span><br><span class="line">&#125;enum_val,...;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">	<span class="class"><span class="keyword">enum</span>			  枚举关键字</span></span><br><span class="line"><span class="class">	<span class="title">enu_name</span>          枚举名</span></span><br><span class="line"><span class="class">	<span class="title">val1</span>			  标识符1 =</span> 整型常数<span class="number">-1</span></span><br><span class="line">	val2			  标识符<span class="number">1</span> = 整型常数<span class="number">3</span></span><br><span class="line">	val3			  标识符<span class="number">1</span> = 整型常数<span class="number">4</span></span><br><span class="line">	enum_val          枚举变量</span><br><span class="line">	<span class="keyword">enum</span> enu_name     枚举类型</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>1）枚举中每个成员（标识符）结束符是’,’最后一个可以省略<br>2）第一个定义未初始化的标识符默认为0<br>3）初始化可以赋负数<br>4）连续未赋值的的标识符的值是在前一个标识符的值基础上加1<br>5）enum 类型的变量只能取定义时的离散值<br>6）在c语言中可以定义正真意义上的常量<br>7）本质上枚举类型就是整型</p>
</blockquote>
<h1 id="十一、sizeof-关键字"><a href="#十一、sizeof-关键字" class="headerlink" title="十一、sizeof 关键字"></a><div align=center>十一、sizeof 关键字</h1><p>sizeof 用于计算类型或变量所占内存大小<br>用于类型 sizeof （type）<br>用于变量 sizeof （var） 或者 sizeof var </p>
<blockquote>
<p>注意：<br>1）sizeof 是编译器内置指示符(关键字)而不是函数<br>2）sizeof 在编译期就已经确定，在编译过程中所有的 sizeof 将    被具体的数值所替换，程序的执行过程与 sizeof 没有任何关系</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="keyword">int</span> var = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(var++);</span><br><span class="line">Printf(“var = %d，size = %d”，var，size); </span><br><span class="line"><span class="comment">//输出结果： 0  ， 4</span></span><br></pre></td></tr></table></figure>
<h1 id="十二、typedef-关键字"><a href="#十二、typedef-关键字" class="headerlink" title="十二、typedef 关键字"></a><div align=center>十二、typedef 关键字</h1><p>C语言中用于给已经存在的数据类型重命名<br>语法： typedef  type  new_neme;</p>
<blockquote>
<p>注意：<br>1）本质上不能产生新的类型<br>2）重命名的类型： a）可以在 typedef 语句之后定义； b）不能被 unsigned 和 signed 修饰</p>
</blockquote>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a><div align=center>注释</h1><p>编译器在编译过程中使用空格替换整个注释<br>字符串字面量中的//和/<em>…</em>/ 不代表注释符号<br>/<em>…</em>/不能被嵌套<br>在编译器看来注释和其他程序元素是平等的</p>
<blockquote>
<p>注意：<br>1）注释是对代码的提示，避免臃肿和喧宾夺主<br>2）一目了然的代码避免注释<br>3）不要用缩写来注释代码，这样可能会产生误解<br>4）注释用于阐述原因和意图而不是描述程序的运行过程<br>5）注释应该准确易懂，防止二义性，错误的注释有害无利</p>
</blockquote>
<h1 id="接续符"><a href="#接续符" class="headerlink" title="\ 接续符"></a><div align=center>\ 接续符</h1><p>编译器会将反斜杠剔除，跟在反斜杠后面的字符自动接续到前一行<br>在接续单词时，反斜杠不能有空格，反斜杠下一行也不能有空格<br>接续符适合在定义宏代码块时使用</p>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="\ 转义字符"></a><div align=center>\ 转义字符</h1><p>\n        换行回车<br>\t        横向跳到下一制表位置<br>\v        竖向挑格<br>\b        退格<br>\r        回车，回到行首<br>\f        走纸换页<br>\        反斜杠“\”<br>&#39;        单引号<br>\a        呜铃<br>\ddd      1<del>3 位8进制数所代表的字符<br>\xhh      1</del>2 位16进制数所代表的字符</p>
<blockquote>
<p>小结：a) \ 作为接续符使用可以出现在程序中间; b) \ 作为转义字符使用时需出现单引号或者双引号    之间</p>
</blockquote>
<h1 id="单引号双引号"><a href="#单引号双引号" class="headerlink" title="单引号双引号"></a><div align=center>单引号双引号</h1><p>c语言中的单引号用来表示字符字面量<br>‘a’占1个字节<br>‘a’ + 1 代表’a’的ascll码+1 ，结果为’b’<br>字符字面量被编译为对应的ascll码</p>
<p>c语言中的双引号用来表示字符串字面量<br>“a”占两个字节<br>“a” + 1 表示指针运算，结果指向”a”的结束符’/0’<br>字符串字面量被编译为对应的内存地址</p>
<blockquote>
<p>知识拓展<br>printf的第一个参数被当成字符串内存地址<br>内存的低地址空间不能在程序中随意访问即小于0x08048000的地址，随意访问会产生段错误</p>
</blockquote>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><div align=center>逻辑运算符</h1><h2 id="1、逻辑-和-amp-amp"><a href="#1、逻辑-和-amp-amp" class="headerlink" title="1、逻辑||和&amp;&amp;"></a>1、逻辑||和&amp;&amp;</h2><p>程序中的短路<br>||从左向右开始计算：（或）<br>&nbsp;&nbsp;&nbsp;&nbsp;当遇到为真的条件时停止计算，整个表达式为真<br>&nbsp;&nbsp;&nbsp;&nbsp;所有条件为假时表达式才为假<br>&amp;&amp;从左到右开始计算：（且）<br>&nbsp;&nbsp;&nbsp;&nbsp;当遇到为假的条件时停止计算，整个表达式为假<br>&nbsp;&nbsp;&nbsp;&nbsp;所有条件为真时表达式才为真</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ++i || ++j &amp;&amp; ++k;  <span class="comment">//  ==&gt; (true &amp;&amp; ++i) || (++j &amp;&amp; ++k)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k); <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/13.png" >

<h2 id="2、逻辑-！"><a href="#2、逻辑-！" class="headerlink" title="2、逻辑 ！"></a>2、逻辑 ！</h2><p>！0      返回1<br>！非0     返回0</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">0</span>);			<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">1</span>);			<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">100</span>);		<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">-1000</span>);		<span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="位运算符分析"><a href="#位运算符分析" class="headerlink" title="位运算符分析"></a><div align=center>位运算符分析</h1><p>c语言中的位运算符<br>    &amp;    按位与<br>    |    按位或<br>    ^    按位异或<br>    ~    按位取反<br>    &lt;&lt;    左移<br>    &gt;&gt;    右移</p>
<h2 id="1、左移右移"><a href="#1、左移右移" class="headerlink" title="1、左移右移"></a>1、左移右移</h2><p>1）左移<br>左移运算符 &lt;&lt; 将运算数的二进位左移<br>&nbsp;&nbsp;&nbsp;&nbsp;规则：高位丢弃，低位补0<br>&nbsp;&nbsp;&nbsp;&nbsp;移动一次相当于相当于乘2，运算效率更高<br>2）右移<br>右移运算符 &gt;&gt; 把运算数的二进制数右移<br>&nbsp;&nbsp;&nbsp;&nbsp;规则：高位补符号位，低位丢弃<br>&nbsp;&nbsp;&nbsp;&nbsp;移动一次相当于除二，运算效率更高<br>&nbsp;&nbsp;&nbsp;&nbsp;正数：有余舍弃<br>&nbsp;&nbsp;&nbsp;&nbsp;负数：有余进位</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> &lt;&lt; <span class="number">2</span>);      		<span class="comment">//12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> &gt;&gt; <span class="number">1</span>); 			<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span> &gt;&gt; <span class="number">1</span>); 			<span class="comment">//-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0x01</span> &lt;&lt; <span class="number">2</span> + <span class="number">3</span>);		<span class="comment">//32</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> &lt;&lt; <span class="number">-1</span>); <span class="comment">// oops!	</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>1）左操作数必须为整数类型<br>2）char 和 short 被隐式类型转换为了 int 后进行位移操作<br>3）右操作数的范围必须为[0,31]，如果操作数的值超出范围，则根据编译器的不同而不同，不能得到准确结果</p>
</blockquote>
<blockquote>
<p>扩充：<br>四则算符的优先级高于位运算符，容易出错<br>防错措施： 1）尽量避免位运算符，逻辑运算符，和数学运算符出现在同一个表达式中；2）需要时，尽量使用括号来表达运算次序</p>
</blockquote>
<h2 id="2、位运算与逻辑运算的不同"><a href="#2、位运算与逻辑运算的不同" class="headerlink" title="2、位运算与逻辑运算的不同"></a>2、位运算与逻辑运算的不同</h2><p>位运算没有短路规则，每个操作数都参与运算<br>位运算结果为整数，而不是0或1<br>位运算优先级高于逻辑运算</p>
<h2 id="3、常用技巧"><a href="#3、常用技巧" class="headerlink" title="3、常用技巧"></a>3、常用技巧</h2><p>1.操作一任意一个数据位,将一个char数据中的第三位置位</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">unsigned</span> char a;</span><br><span class="line"><span class="attribute">a</span> &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);  //将该位清零</span><br><span class="line"><span class="attribute">a</span> |= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;     //将该为置位</span><br></pre></td></tr></table></figure>
<p>2.操作一任意一个数据位,将一个int数据中的第3，4位置位</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">unsigned</span> char a;</span><br><span class="line"><span class="attribute">a</span> &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">3</span>);  //将该位清零</span><br><span class="line"><span class="attribute">a</span> |= <span class="number">3</span>&lt;&lt;<span class="number">3</span>;     //将该为置位</span><br></pre></td></tr></table></figure>
<p>运算优先级： 四则运算&gt;位运算&gt;逻辑运算</p>
<h1 id="、-操作符的本质"><a href="#、-操作符的本质" class="headerlink" title=" ++、- -操作符的本质"></a><div align=center> ++、- -操作符的本质</h1><h2 id="1、基本规则"><a href="#1、基本规则" class="headerlink" title="1、基本规则"></a>1、基本规则</h2><p>前置：变量自增（减），取变量值<br>后置：取变量值，变量自增（减）</p>
<p><strong>编程实验</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attr">i</span> = <span class="number">0</span>;</span><br><span class="line">    int <span class="attr">r</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">r</span> = (i++) + (i++) + (i++);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    printf(<span class="string">&quot;r = %d\n&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="attr">r</span> = (++i) + (++i) + (++i);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    printf(<span class="string">&quot;r = %d\n&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc运行结果：</span><br><span class="line"><span class="attr">i</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">i</span> = <span class="number">6</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">vs2010运行结果：</span><br><span class="line"><span class="attr">i</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">i</span> = <span class="number">6</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">java运行结果：</span><br><span class="line"><span class="attr">i</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">i</span> = <span class="number">6</span></span><br><span class="line"><span class="attr">r</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>C语言中只规定了++和—对应指令的相对执行顺序<br>++和—对应的汇编指令不一定连续运行<br>在混合运算中，++和—的汇编指令可能被打断执行<br>++和—参与混合运算结果是不确定的</p>
<h2 id="2、贪心法：-、-表达式的阅读技巧"><a href="#2、贪心法：-、-表达式的阅读技巧" class="headerlink" title="2、贪心法：++、- -表达式的阅读技巧"></a>2、贪心法：++、- -表达式的阅读技巧</h2><p>编译器处理的每个符号应尽可能的多包含字符<br>编译器以从左向右的顺序一个一个尽可能多的读入字符<br>当读入的字符不可能和已读入的字符组成合法符号为止</p>
<p><strong>编程实验</strong></p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = ++i+++i+++i;<span class="regexp">//</span>根据贪心发编译器读入++i++后才运算，==》<span class="number">1</span>++ ==》ERROR</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a+++b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    </span><br><span class="line">    b = b /*p;  <span class="regexp">//</span>根据贪心法，读入b/*之后便认为/*为注释符号，后面的内容全部为注释</span><br><span class="line"></span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">6</span>: error: lvalue required as increment operand</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">14</span>: error: unterminated comment</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">14</span>: error: expected ‘;’ at end of input</span><br><span class="line"><span class="number">5</span>-<span class="number">2</span>.c:<span class="number">14</span>: error: expected declaration <span class="keyword">or</span> statement at end of input</span><br></pre></td></tr></table></figure>
<p>空格可以作为c语言中一个完整的休止符<br>编译器读入空格后立即对之前读入的符号进行处理</p>
<p><strong>编程实验，修改上面代码使它运行通过</strong></p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = ++i + ++i + ++i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a+++b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    </span><br><span class="line">    b = b / *p;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三目运算符（a-b-c）"><a href="#三目运算符（a-b-c）" class="headerlink" title="三目运算符（a?b:c）"></a><div align=center>三目运算符（a?b:c）</h1><p>可以作为逻辑运算的载体（为if条件句的简化形式）<br>规则<br>&nbsp;&nbsp;&nbsp;&nbsp;当a为真的时，返回b的值；否则返回c的值<br>三目运算符（a?b:c）的返回类型<br>&nbsp;&nbsp;&nbsp;&nbsp;1）通过隐式类型转换规则返回b和c中较高的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;2）当b和c不能隐式类型转换到同一类型将出错</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    m = a &lt; b ? a : b;   <span class="comment">// m = a ==&gt; m = 1</span></span><br><span class="line">    </span><br><span class="line">    (a &lt; b ? a : b) = <span class="number">3</span>; <span class="comment">// error</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);	 <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>, m); <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(c ? c : s) );  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(i ? i : d) );  <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(d ? d : p) );  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">5</span><span class="number">-2.</span>c:<span class="number">18</span>: error: lvalue required as left operand of assignment</span><br><span class="line"><span class="number">5</span><span class="number">-2.</span>c:<span class="number">26</span>: error: type mismatch in conditional expression</span><br></pre></td></tr></table></figure>
<h1 id="，逗号表达式"><a href="#，逗号表达式" class="headerlink" title="，逗号表达式"></a><div align=center>，逗号表达式</h1><p>用于将多个式子连接为一个表达式<br>逗号表达式的值为最后一个表达式的值<br>逗号表达式中前 N-1 表达式的值可以没有返回值<br>逗号表达式按照从左向右的顺序计算每个表达式的值:exp1,exp2,exp3,exp4…expN</p>
<p><strong>编程实验，使用逗号表达式检查输入指针的合法性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> assert(s), (*s ? <span class="built_in">strlen</span>(s + <span class="number">1</span>) + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Delphi&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, <span class="built_in">strlen</span>(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">len = <span class="number">6</span></span><br><span class="line">a.out: <span class="number">5</span><span class="number">-2.</span>c:<span class="number">6</span>: <span class="built_in">strlen</span>: Assertion `s<span class="number">&#x27;</span> failed.</span><br><span class="line">已放弃</span><br></pre></td></tr></table></figure>
<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a><div align=center>编译过程</h1><p>编译器的组成：预处理器，编译器，汇编器，链接器<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/14.png" ></p>
<h2 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h2><p>处理所有的注释<br>将所有的#define删除，并且展开所有的宏定义<br>处理条件预编译指令 #if，#ifdef，#elseif，#else，#endif<br>处理#inlude，展开被包含的文件<br>保留编译器需要使用的#pragma指令<br>linux预处理指令示例：<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc -E a.c -o a.i</p>
<h2 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h2><p>对于处理文件进行 词法分析，语法分析，和语义分析<br>&nbsp;&nbsp;&nbsp;&nbsp;a，词法分析：分析关键字，标识符，立即数是否合法<br>&nbsp;&nbsp;&nbsp;&nbsp;b，语法分析：分析表达式是否遵循语法规则<br>&nbsp;&nbsp;&nbsp;&nbsp;c，语义分析：在语法分析的基础上进一步分析表达式是否合法<br>&nbsp;&nbsp;&nbsp;&nbsp;d，分析结束后进行代码优化生成相应的汇编代码文件<br>linux编译指令示例：<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc -S a.c -o a.s </p>
<h2 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h2><p>汇编将源代码转变为机器可执行的二进制语言<br>每条汇编代码语句几乎都对应一条机器指令<br>linux汇编指令示例：<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc -c a.c -o a.o            </p>
<h2 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h2><p>静态链接<br>&nbsp;&nbsp;&nbsp;&nbsp;a）目标文件直接进入可执行程序<br>&nbsp;&nbsp;&nbsp;&nbsp;b）由链接器在链接时将库的内容直接加入到可执行程序中<br>&nbsp;&nbsp;&nbsp;&nbsp;c）Linux 下静态库的创建和使用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i）编译静态库源码：  gcc -c a.c -o a.o<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii）生成静态库文件： ar -q a.a a.o<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii）使用静态库编译：gcc main.c a.a -o main.out<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/15.png" ></p>
<p>动态链接<br>&nbsp;&nbsp;&nbsp;&nbsp;a）在程序启动后才加载目标文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i）可执行程序运行时才动态加载库进行链接<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii）库的内容不会进入可执行程序中<br>&nbsp;&nbsp;&nbsp;&nbsp;b）Linux 下动态库的创建和使用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译动态库源码：gcc -shares a.c -o a.so<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用动态库编译：gcc a.c -ldl -o a.out<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/16.png" ></p>
<blockquote>
<p>知识扩展：关键系统调用<br>dlopen:   打开动态库文件<br>dlsym:     查找动态库中的函数并返回调用地址<br>dlclose:     关闭动态库文件<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/17.png" ></p>
</blockquote>
<h1 id="程序中的宏定义-define"><a href="#程序中的宏定义-define" class="headerlink" title="程序中的宏定义#define"></a><div align=center>程序中的宏定义#define</h1><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><p>1）简单宏定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  宏名  替换文本</span></span><br></pre></td></tr></table></figure>
<p>2）带参宏定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	宏名(参数表)  宏体</span></span><br></pre></td></tr></table></figure>
<h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h2><p>1） 是预处理器的单元的实体之一<br>2） 定义的宏可以出现在程序中的任意位置<br>3） 定义的宏常量可以直接使用<br>4） 定义之后的代码都可以使用这个宏,没有作用域<br>5） 定义宏常量本质为字面量，不占内存空间<br>6） #define 表达式的使用类似于函数<br>7） #define 表达式可以比函数更强大<br>8） #define 表达式比函数更容易出错<br>9） 宏表达式被预处理器处理，编译器不知道宏表达式的存在<br>10）宏表达式用”实参”完全代替形参，不进行任何运算<br>11）宏表达式没有任何调用的开销<br>12）宏表达式中不能出现递归定义<br>13）宏定义效率高于函数<br>14）预处理器不会对宏定义进行语法检测<br>15）宏的使用会带来一定的副作用</p>
<h2 id="3、强大的内置宏"><a href="#3、强大的内置宏" class="headerlink" title="3、强大的内置宏"></a>3、强大的内置宏</h2><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/18.png" >

<p><strong>编程实验</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">MALLOC(<span class="params">type</span>, <span class="params">x</span>)</span> (<span class="keyword">type</span>*)malloc(sizeof(<span class="keyword">type</span>)*x)</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">FREE(<span class="params">p</span>)</span> (free(p), p=NULL)</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">LOG(<span class="params">s</span>)</span> printf(<span class="string">&quot;[%s] &#123;%s:%d&#125; %s \n&quot;</span>, __DATE__, __FILE__, __LINE__, s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span>* p = <span class="constructor">MALLOC(<span class="params">int</span>, 5)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">LOG(<span class="string">&quot;Begin to run main code...&quot;</span>)</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        p<span class="literal">[<span class="identifier">i</span>]</span> = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;%d\n&quot;</span>, p<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">FREE(<span class="params">p</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">LOG(<span class="string">&quot;End&quot;</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="literal">[A<span class="identifier">ug</span> <span class="number">13</span> <span class="number">2019</span>]</span> &#123;<span class="number">5</span>-<span class="number">2.</span>c:<span class="number">15</span>&#125; Begin <span class="keyword">to</span> run main code... </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="literal">[A<span class="identifier">ug</span> <span class="number">13</span> <span class="number">2019</span>]</span> &#123;<span class="number">5</span>-<span class="number">2.</span>c:<span class="number">29</span>&#125; End </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="条件编译使用分析"><a href="#条件编译使用分析" class="headerlink" title="条件编译使用分析"></a><div align=center>条件编译使用分析</h1><p>类似于c语言中的条件语句 if…else…<br>用于控制是否编译某段代码 </p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> 的本质是将已经存在的文件内容嵌入到当前文件中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> 的间接包含同样会产生嵌入文件内容的操作</span></span><br><span class="line"></span><br><span class="line">条件编译可以解决头文件重复包含的编译错误</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADER_FILE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADER_FILE_H_</span></span><br><span class="line">	<span class="comment">//	source code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>...#<span class="meta-keyword">else</span>...#<span class="meta-keyword">endif</span>被预编译处理，而 <span class="meta-keyword">if</span>...<span class="meta-keyword">else</span>...语句被编译器处理必然被编译进目标代码</span></span><br><span class="line">条件编译使我们可以按不同的条件编译不同的代码段，因而可以产生不同的目标代码</span><br></pre></td></tr></table></figure>
<p>实际工作中的条件编译主要用于以下两种情况<br>&nbsp;&nbsp;&nbsp;&nbsp;不同的产品线共用一份代码<br>&nbsp;&nbsp;&nbsp;&nbsp;编译产品的调试版和发布版</p>
<h1 id="error编译分析"><a href="#error编译分析" class="headerlink" title="#error编译分析"></a><div align=center>#error编译分析</h1><p>用于生成一个编译错误消息<br>是一种预编译器指示字<br>用法    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">error</span> message</span></span><br><span class="line">	注：message不需要用引号包围</span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>编译指示字用于自定义程序员特有的编译错误消息,类似#<span class="meta-keyword">warning</span>用于生成编译警告</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> 可用于提示预编译条件是否满足</span></span><br><span class="line">例子：</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span>  __cplusplus</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">error</span>	This file shoud be processed with c++ compiler.</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注：编译过程中的任意错误信息意味着无法生成最终可执行程序。</strong><h1 id="line指示字"><a href="#line指示字" class="headerlink" title="#line指示字"></a><div align=center>#line指示字</h1>用于强制指定新的行号和编译文件名，并对源程序的代码重新编号<br>用法<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="meta">#line  number  filename</span></span><br><span class="line">filename可以省略</span><br><span class="line"><span class="meta">#line的本质是重定义__LINE__和__FILE__</span></span><br></pre></td></tr></table></figure>
<h1 id="pragma指示字"><a href="#pragma指示字" class="headerlink" title="#pragma指示字"></a><div align=center>#pragma指示字</h1><h2 id="1、一般用法："><a href="#1、一般用法：" class="headerlink" title="1、一般用法："></a>1、一般用法：</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> parameter</span></span><br></pre></td></tr></table></figure>
注：不同的 parameter 参数语法各不相同<h2 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h2>1）用于指示编译器完成一些特定的动作<br>2）所定义的很多指示字是编译器特有的<br>3）在不同的编译器间是不可移植的<br>4）预处理器将忽略他不认识的 #pragma 指令<br>5）不同的编译器可能以不同的方式解释同一条#pragma指令<h2 id="3、-pragma-message-“内容”"><a href="#3、-pragma-message-“内容”" class="headerlink" title="3、#pragma message(“内容”)"></a>3、#pragma message(“内容”)</h2>1）message参数在大多数编译器中都有相同的实现<br>2）message参数在编译时输出编译消息到编译窗口中<br>3）message用于条件编译中可提示代码的版本信息<br>例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ANDROID20</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">pragma</span> message(<span class="meta-string">&quot;Complite Android SDK 2.0...&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">注：与<span class="meta">#<span class="meta-keyword">error</span>和#<span class="meta-keyword">warning</span>不同 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> message 不代表程序错误，仅代表一条编译信息</span></span><br></pre></td></tr></table></figure>
<h2 id="4、-pragma-once-关键字"><a href="#4、-pragma-once-关键字" class="headerlink" title="4、#pragma once 关键字"></a>4、#pragma once 关键字</h2>1）用于保证头文件只被编译一次<br>2）是与编译器相关的，不一定被支持<br>3）与#ifdef … #define … #endif的区别<br>&nbsp;&nbsp;&nbsp;&nbsp;a）效率不如#pragma once<br>&nbsp;&nbsp;&nbsp;&nbsp;b）支持性比#pragma once好<br>4）使用时两者结合<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _FLIE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _FLIE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码块</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="5、-pragma-pack关键字（用于指定内存的对齐方式）"><a href="#5、-pragma-pack关键字（用于指定内存的对齐方式）" class="headerlink" title="5、#pragma pack关键字（用于指定内存的对齐方式）"></a>5、#pragma pack关键字（用于指定内存的对齐方式）</h2>1）内存对齐<br>&nbsp;&nbsp;&nbsp;&nbsp;a）不同类型的数据在内存中按照一定的规则排列<br>&nbsp;&nbsp;&nbsp;&nbsp;b）而不是一定的顺的一个接一个的排列<br>2）内存对齐的原因<br>&nbsp;&nbsp;&nbsp;&nbsp;a）CPU对内存的读取不是连续的，而是分块读取的，块的大小只能是 1,2,4,8,16… 字节<br>&nbsp;&nbsp;&nbsp;&nbsp;b）当读取操作的数据未对齐，则需要两次总线周期来访问内存，因此性能会大打折扣<br>&nbsp;&nbsp;&nbsp;&nbsp;c）某些硬件平台只能从规定的相对地址处读取特定类型数据，否则产生硬件异常<br>3）struct 占用的内存大小<br>&nbsp;&nbsp;&nbsp;&nbsp;a）第一个成员起始于0偏移处<br>&nbsp;&nbsp;&nbsp;&nbsp;b）每个成员按其类型大小和pack参数中较小的一个进行对齐<br>&nbsp;&nbsp;&nbsp;&nbsp;c）偏移地址必须能够被对齐参数整除<br>&nbsp;&nbsp;&nbsp;&nbsp;d）结构体成员的大小取其内部长度最大的数据成员作为其大小<br>&nbsp;&nbsp;&nbsp;&nbsp;e）结构体的总长度必须为所有对齐参数的整数倍<br>&nbsp;&nbsp;&nbsp;&nbsp;f）编译器在默认情况下按照4字节对齐<br>例子：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">未使用 <span class="comment">#pragma pack </span></span><br><span class="line">	struct test1		<span class="regexp">//</span>		 内存计算</span><br><span class="line">	&#123;				<span class="regexp">//</span>对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>			<span class="number">1</span></span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">2</span>		  <span class="number">2</span>			<span class="number">2</span></span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">4</span>			<span class="number">1</span></span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">4</span>		  <span class="number">8</span>			<span class="number">4</span> ==&gt; <span class="number">12</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test1) = <span class="number">12</span>;</span><br><span class="line">	struct test1		<span class="regexp">//</span>		 内存计算</span><br><span class="line">	&#123;				<span class="regexp">//</span>对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>		   <span class="number">1</span> </span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">1</span>		   <span class="number">1</span></span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">2</span>		  <span class="number">2</span>		   <span class="number">2</span></span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">4</span>		  <span class="number">4</span>		   <span class="number">4</span>  ==&gt; <span class="number">8</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test2) = <span class="number">8</span>;	</span><br><span class="line">	</span><br><span class="line">使用 <span class="comment">#pragma pack</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#pragma pack(1)												</span></span><br><span class="line">	struct test1		<span class="regexp">//</span>		 内存计算	</span><br><span class="line">	&#123;				<span class="regexp">//</span>对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>		 <span class="number">1</span>				</span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">1</span>		 <span class="number">2</span>				</span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">3</span>		 <span class="number">1</span>				</span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">4</span>		 <span class="number">4</span>	==&gt; <span class="number">8</span>	</span><br><span class="line">	&#125;;	</span><br><span class="line"><span class="comment">#pragma pack()</span></span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test1) = <span class="number">8</span>;			</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">#pragma pack(1)</span></span><br><span class="line">	struct test1		<span class="regexp">//</span>		内存计算</span><br><span class="line">	&#123;				<span class="regexp">//</span>		对齐参数	 偏移地址  	 大小</span><br><span class="line">		char c1;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">0</span>		  <span class="number">1</span>				</span><br><span class="line">		char c2;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">1</span>		  <span class="number">1</span>			</span><br><span class="line">		short s;		<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">2</span>		  <span class="number">2</span>			</span><br><span class="line">		int i;			<span class="regexp">//</span>		    <span class="number">1</span>		  <span class="number">4</span>		  <span class="number">4</span>	==&gt; <span class="number">8</span>		</span><br><span class="line">	&#125;;														</span><br><span class="line">	<span class="comment">#pragma pack()</span></span><br><span class="line"><span class="regexp">//</span>运行结果	sizeof(struct test2) = <span class="number">8</span>;	</span><br></pre></td></tr></table></figure>
<p>例子：微软面试题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>			//		内存计算</span></span><br><span class="line"><span class="class">&#123;</span>					<span class="comment">//		对齐参数		偏移地址		大小</span></span><br><span class="line">	<span class="keyword">short</span> a;	    <span class="comment">//		2			0		 2</span></span><br><span class="line">	<span class="keyword">long</span> b;	    	<span class="comment">//		4			4		 4	 ==&gt; 8</span></span><br><span class="line">&#125;;														</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span>			//			内存计算							</span></span><br><span class="line"><span class="class">&#123;</span>				<span class="comment">//对齐参数	 偏移地址  	大小</span></span><br><span class="line">	<span class="keyword">char</span> c;			<span class="comment">//	1			0		 1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">d</span>;</span>	<span class="comment">//	4			4		 4</span></span><br><span class="line">	<span class="keyword">double</span> e;		<span class="comment">//	8			16		 8	==&gt; 24</span></span><br><span class="line">&#125;;			         </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p>注：gcc编译器暂时不支持 #pragma pack(8) 所以计算结果为20;在不同的编译器可能会有不同的结果</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="# 运算符"></a><div align=center># 运算符</h1><h2 id="1、含义作用"><a href="#1、含义作用" class="headerlink" title="1、含义作用"></a>1、含义作用</h2><p>1）用于在预处理期将宏参数转换为字符串<br>2）作用是在预处理期完成的，因此只在宏定义中有效<br>3）编译器不知道#的转换作用</p>
<h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  STRING(X)  #X</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,STRING(hello <span class="keyword">word</span>));</span><br></pre></td></tr></table></figure>
<h1 id="运算符-1"><a href="#运算符-1" class="headerlink" title="## 运算符"></a><div align=center>## 运算符</h1><h2 id="1、含义作用-1"><a href="#1、含义作用-1" class="headerlink" title="1、含义作用"></a>1、含义作用</h2><p>1）用于在预处理期粘连两个标识符<br>2）##的连接作用是在预处理期完成的<br>3）只在宏定义中有效<br>4）编译器不知道##的连接作用</p>
<h2 id="2、用法-1"><a href="#2、用法-1" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">CONNECT(<span class="params">a</span>,<span class="params">b</span>)</span> a##b</span><br><span class="line"><span class="built_in">int</span> <span class="constructor">CONNECT(<span class="params">a</span>,1)</span>;</span><br><span class="line">a1 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3、-巧妙使用"><a href="#3、-巧妙使用" class="headerlink" title="3、##巧妙使用"></a>3、##巧妙使用</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define STRUCT(type) typedef struct _tag_##type type;\</span></span><br><span class="line">                     struct _tag_<span class="comment">##type</span></span><br><span class="line"></span><br><span class="line">STRUCT(Student)</span><br><span class="line">&#123;</span><br><span class="line">    char* <span class="built_in">name</span>;</span><br><span class="line">    int <span class="built_in">id</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    Student s1;</span><br><span class="line">    Student s2;</span><br><span class="line">    </span><br><span class="line">    s1.<span class="built_in">name</span> = <span class="string">&quot;s1&quot;</span>;</span><br><span class="line">    s1.<span class="built_in">id</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    s2.<span class="built_in">name</span> = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    s2.<span class="built_in">id</span> = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">&quot;s1.name = %s\n&quot;</span>, s1.<span class="built_in">name</span>);</span><br><span class="line">    printf(<span class="string">&quot;s1.id = %d\n&quot;</span>, s1.<span class="built_in">id</span>);</span><br><span class="line">    printf(<span class="string">&quot;s2.name = %s\n&quot;</span>, s2.<span class="built_in">name</span>);</span><br><span class="line">    printf(<span class="string">&quot;s2.id = %d\n&quot;</span>, s2.<span class="built_in">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">    return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针，数组与字符串"><a href="#指针，数组与字符串" class="headerlink" title="指针，数组与字符串"></a><div align=center>指针，数组与字符串</h1><h2 id="1、指针的本质分析"><a href="#1、指针的本质分析" class="headerlink" title="1、指针的本质分析"></a>1、指针的本质分析</h2><h3 id="1-申明"><a href="#1-申明" class="headerlink" title="1) 申明"></a>1) 申明</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">int</span>* p = &amp;i;</span><br></pre></td></tr></table></figure>
<p>p中保存着i的地址<br>指针是变量保存的是所指向的变量的地址</p>
<h3 id="2-号的意义"><a href="#2-号的意义" class="headerlink" title="2) *号的意义"></a>2) *号的意义</h3><p>a）在指针申明时，*表示所申明的变量为指针<br>b）在指针使用时，*表示取指针所指向的内存空间的值<br>c）*类似于一把钥匙，通过这把钥匙可以打开内存，读取内存中的值</p>
<h3 id="3-传值调用与传址调用"><a href="#3-传值调用与传址调用" class="headerlink" title="3)传值调用与传址调用"></a>3)传值调用与传址调用</h3><p>a）当一个函数体内部需要改变实参的值，则需要使用指针参数<br>b）函数调用时实参将复制到形参<br>c）指针适用于复杂数据类型作为参数的函数中</p>
<h3 id="4-指针与常量"><a href="#4-指针与常量" class="headerlink" title="4)指针与常量"></a>4)指针与常量</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>*  p;					<span class="comment">//p可变，  p指向的内容不可变</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">const</span>*  p;					<span class="comment">//p可变，  p指向的内容不可变</span></span><br><span class="line"><span class="built_in">int</span>* <span class="keyword">const</span>  p;					<span class="comment">//p不可变，p指向的内容可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>* <span class="keyword">const</span>  p;		   <span class="comment">//p不可变，p指向的内容不可变  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> 在*p之前，p指向的内容不可变</span><br><span class="line"><span class="keyword">const</span> 在p之前，p不可变</span><br></pre></td></tr></table></figure>
<h2 id="2、数组的概念"><a href="#2、数组的概念" class="headerlink" title="2、数组的概念"></a>2、数组的概念</h2><h2 id="1）声明"><a href="#1）声明" class="headerlink" title="1）声明"></a>1）声明</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int a[x]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="2）说明"><a href="#2）说明" class="headerlink" title="2）说明"></a>2）说明</h3><p>a）数组是相同类型变量的有序集合<br>b）a 代表数组第一个元素的起始地址<br>c）数组包含x个int类型的数据<br>d）这x*4个字节空间的名字为a</p>
<blockquote>
<p>注：a[0],a[1],都是数组中的元素，并非数组元素的名字。数组中的元素没有名字</p>
</blockquote>
<h3 id="3）数组的大小"><a href="#3）数组的大小" class="headerlink" title="3）数组的大小"></a>3）数组的大小</h3><p>a）数组在一片连续内存空间中存储元素<br>b）数组元素的个数可以显示或隐式指定</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> a[<span class="number">5</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;	//显式指定</span><br><span class="line"><span class="attribute">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;	//隐式指定</span><br></pre></td></tr></table></figure>
<h3 id="4）数组的本质"><a href="#4）数组的本质" class="headerlink" title="4）数组的本质"></a>4）数组的本质</h3><p>a）数组是一段连续的内存空间<br>b）数组的空间大小为 *<em>sizeof(arry_type)<em>arry_size</em></em><br>c）数组名可以看做指向数组第一个元素的常量指针<br>d）数组元素的地址和数组元素第一个元素的地址的地址值相同但表示的意义不同</p>
<h3 id="5）编程实验"><a href="#5）编程实验" class="headerlink" title="5）编程实验"></a>5）编程实验</h3><p>a）验证数组名本质不是常量指针</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c 文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span>* a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d\n&quot;</span>, *a);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc环境下编译运行：gcc main.c test.c</span><br><span class="line">运行结果：</span><br><span class="line">&amp;a = <span class="number">0x804a014</span></span><br><span class="line">a = <span class="number">0x1</span></span><br><span class="line">段错误</span><br></pre></td></tr></table></figure>
<p>b）数组名遇到sizeof表示整个数组的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a));   <span class="comment">// 整个数组元素大小 20</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="3、指针的运算"><a href="#3、指针的运算" class="headerlink" title="3、指针的运算"></a>3、指针的运算</h2><h3 id="1）指针与整数的运算规则为"><a href="#1）指针与整数的运算规则为" class="headerlink" title="1）指针与整数的运算规则为"></a>1）指针与整数的运算规则为</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p + n; &lt;——&gt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)p + <span class="function">n*<span class="title">sizeof</span><span class="params">(*p)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：<br>当指针p指向一个同类型的数组元素时：<br>p + 1 将指向当前元素的下一个元素<br>p - 1 将指向当前元素的上一个元素</p>
</blockquote>
<h3 id="2）指针与指针之间的运算"><a href="#2）指针与指针之间的运算" class="headerlink" title="2）指针与指针之间的运算"></a>2）指针与指针之间的运算</h3><p>a)指针之间只支持减法运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p1 - p2 ; &lt;——&gt; ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)p1 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)p2)/<span class="keyword">sizeof</span>(*p1)</span><br></pre></td></tr></table></figure>
<p>b）参与减法运算的指针类型必须相同<br>c）当两个指针指向的元素不在同一个数组中时，结果未定义<br>d）只有当两个指针指向同一个数组中的元素时，指针相减才有意义，其意义为指针所指元素的下标差</p>
<h3 id="3）指针之间的比较运算"><a href="#3）指针之间的比较运算" class="headerlink" title="3）指针之间的比较运算"></a>3）指针之间的比较运算</h3><p>a）指针也可以进行比较运算(&lt;, &lt;= ,&gt;, &gt;=)<br>b）指针关系运算的前提是同时指向同一个数组中的元素<br>c）任意两个指针之间的比较运算( ==, != )无限制<br>d）参与运算的两个指针类型必须相同</p>
<h3 id="4）编程实验"><a href="#4）编程实验" class="headerlink" title="4）编程实验"></a>4）编程实验</h3><p>a）指针运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* p0 = s1;				</span><br><span class="line">    <span class="keyword">char</span>* p1 = &amp;s1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span>* p2 = s2;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;i;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 - p1);   <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 + p2);   <span class="comment">// ERROR</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 - p2);   <span class="comment">// Unknown value</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 - p);	   <span class="comment">// ERROR</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 * p2);   <span class="comment">// ERROR</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p0 / p2);   <span class="comment">// REEOR</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b）指针+数组边界访问数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIM(a) (sizeof(a) / sizeof(*a))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* pBegin = s;</span><br><span class="line">    <span class="keyword">char</span>* pEnd = s + DIM(s); <span class="comment">// Key point</span></span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pBegin = %p\n&quot;</span>, pBegin);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pEnd = %p\n&quot;</span>, pEnd);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size: %d\n&quot;</span>, pEnd - pBegin);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(p=pBegin; p&lt;pEnd; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、数组的访问方式"><a href="#4、数组的访问方式" class="headerlink" title="4、数组的访问方式"></a>4、数组的访问方式</h2><h3 id="1）访问方式"><a href="#1）访问方式" class="headerlink" title="1）访问方式"></a>1）访问方式</h3><p><strong>下标的形式访问数组 a[1];</strong><br>*<em>指针的形式访问数组 <em>(a+1);</em></em></p>
<h3 id="2）下标形式与指针形式的转换"><a href="#2）下标形式与指针形式的转换" class="headerlink" title="2）下标形式与指针形式的转换"></a>2）下标形式与指针形式的转换</h3><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">a[<span class="built_in">n</span>] &lt;——&gt; *(a + <span class="built_in">n</span>) &lt;——&gt; *(<span class="built_in">n</span> + a) &lt;——&gt; <span class="built_in">n</span>[a]</span><br></pre></td></tr></table></figure>
<h3 id="3）两者的优缺点"><a href="#3）两者的优缺点" class="headerlink" title="3）两者的优缺点"></a>3）两者的优缺点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;a）指针以固定增量在数组中移动时，效率高于下标形式。<br>&nbsp;&nbsp;&nbsp;&nbsp;b）指针增量为 1 且硬件具有硬件增量模型时，效率更高</p>
<blockquote>
<p>注意：现代编译器的生成代码优化率已经大大提高，在固定增量时，下标形式的效率已经和指针形式相当；但从可读性和代码维护的角度看，下标形式更优。</p>
</blockquote>
<h3 id="4）编程实验-1"><a href="#4）编程实验-1" class="headerlink" title="4）编程实验"></a>4）编程实验</h3><p>a）指针与数组的访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p = a;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, *(a + i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        i[a] = i + <span class="number">10</span>;  <span class="comment">// ==&gt; *(i+a) ==&gt; *(a+i) ==&gt; a[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p[%d] = %d\n&quot;</span>, i, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b）指针与数组的混合运算练习</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p1 = (<span class="keyword">int</span>*)(&amp;a + <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">int</span>* p2 = (<span class="keyword">int</span>*)((<span class="keyword">int</span>)a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>* p3 = (<span class="keyword">int</span>*)(a + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %x, %d\n&quot;</span>, p1[<span class="number">-1</span>], p2[<span class="number">0</span>], p3[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// p[-1] ==&gt; *( p + (-1) ) ==&gt; *(p-1)  ==&gt;  a[5] ==&gt; 5</span></span><br><span class="line">	<span class="comment">/* 10 00 00 00 20 00 00 00 30 00 00 00 40 00 00 00 50 00 00 00  小端模式存储数据</span></span><br><span class="line"><span class="comment">	   ==&gt; p2[0] ==&gt; 0x02000000</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// p3[1] ==&gt; 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">运行结果： <span class="number">5</span>, <span class="number">2000000</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、a和-amp-a的区别"><a href="#5、a和-amp-a的区别" class="headerlink" title="5、a和&amp;a的区别"></a>5、a和&amp;a的区别</h2><p>a  为数组首元素的地址<br>&amp;a 为整个数组的地址<br>a 和 &amp;a 的区别在于指针运算</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">a<span class="number">+1</span>	==&gt; <span class="comment">(unsigned int)</span>a + sizeof<span class="comment">(*a)</span></span><br><span class="line"></span><br><span class="line">&amp;a + <span class="number">1</span>	==&gt; <span class="comment">(unsigned int)</span><span class="comment">(&amp;a)</span> + sizeof<span class="comment">(*(&amp;a)</span>)  ==&gt; <span class="comment">(unsigned int)</span><span class="comment">(&amp;a)</span> + sizeof<span class="comment">(a)</span></span><br></pre></td></tr></table></figure>
<h2 id="6、数组参数"><a href="#6、数组参数" class="headerlink" title="6、数组参数"></a>6、数组参数</h2><h3 id="a）数组作为参数时，编译器将其编译成对应的指针"><a href="#a）数组作为参数时，编译器将其编译成对应的指针" class="headerlink" title="a）数组作为参数时，编译器将其编译成对应的指针"></a>a）数组作为参数时，编译器将其编译成对应的指针</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;   &lt;==&gt;  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="number">5</span>])</span></span>;  &lt;==&gt;  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：一般情况下，当定义的函数中数组参数时，需要定义另一个参数来表示数组大小。</p>
</blockquote>
<h3 id="b）编程实验"><a href="#b）编程实验" class="headerlink" title="b）编程实验"></a>b）编程实验</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">char</span> a[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func1: sizeof(a) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a));  <span class="comment">// 数组退化为指针 ==&gt; In func1: sizeof(a) = 4</span></span><br><span class="line">    </span><br><span class="line">    *a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    a = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func2: sizeof(b) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(b)); <span class="comment">// 数组退化为指针 ==&gt; In func1: sizeof(a) = 4</span></span><br><span class="line">    </span><br><span class="line">    *b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    func1(<span class="built_in">array</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %c\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// array[0] = a</span></span><br><span class="line">    </span><br><span class="line">    func2(<span class="built_in">array</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %c\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// array[0] = b</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">In func1: <span class="keyword">sizeof</span>(a) = <span class="number">4</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = a</span><br><span class="line">In func2: <span class="keyword">sizeof</span>(b) = <span class="number">4</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = b</span><br></pre></td></tr></table></figure>
<h2 id="7、数组类型"><a href="#7、数组类型" class="headerlink" title="7、数组类型"></a>7、数组类型</h2><h3 id="1）c语言中的数组有自己特定的类型"><a href="#1）c语言中的数组有自己特定的类型" class="headerlink" title="1）c语言中的数组有自己特定的类型"></a>1）c语言中的数组有自己特定的类型</h3><p>数组的类型由元素类型和数组大小共同决定<br>例： int arry[5] 的类型为 int[5]</p>
<h3 id="2）定义数组类型"><a href="#2）定义数组类型" class="headerlink" title="2）定义数组类型"></a>2）定义数组类型</h3><p>c语言通过 typedef 为数组类型重命名</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">type</span>(name)[size];</span><br></pre></td></tr></table></figure>
<p>重定义数组类型：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef int(<span class="type">AINT5</span>)[5];</span><br><span class="line">typedef float(<span class="type">AFLOAT</span>)[10];</span><br></pre></td></tr></table></figure>
<p>数组定义：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">AINT5 iArry<span class="comment">;</span></span><br><span class="line">AFLOAT farry<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="8、数组指针"><a href="#8、数组指针" class="headerlink" title="8、数组指针"></a>8、数组指针</h2><h3 id="1）声明-1"><a href="#1）声明-1" class="headerlink" title="1）声明"></a>1）声明</h3><p>可以通过数组类型定义数组指针：<strong>ArryType* pointer;**<br>也可以直接定义：    **type(*pointer)[n];</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;pointer    为数组指针变量名<br>&nbsp;&nbsp;&nbsp;&nbsp;type    为指向的数组的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;n        为指向的数组的大小</p>
<h3 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h3><p>a）数组指针用于指向一个数组<br>b）数组名是数组首元素的起始地址，但并不是数组的起始地址<br>c）通过将取地址符&amp;作用于数组名可以得到数组的起始地址</p>
<h2 id="9、指针数组"><a href="#9、指针数组" class="headerlink" title="9、指针数组"></a>9、指针数组</h2><p>指针数组是一个普通的数组<br>指针数组中的每一个元素为指针<br>指针数组的定义：<strong>type* pArry[n];**<br>&nbsp;&nbsp;&nbsp;&nbsp;*<em>type</em> 为数组中每个元素的类型</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>PArry 为数组名</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>n      为数组大小</strong></p>
<h2 id="10、二维指针"><a href="#10、二维指针" class="headerlink" title="10、二维指针"></a>10、二维指针</h2><p>指向指针的指针<br>指针会占用一定的内存空间<br>可以定义指针的指针来保存指针的地址</p>
<h3 id="1）二维数组与二级指针"><a href="#1）二维数组与二级指针" class="headerlink" title="1）二维数组与二级指针"></a>1）二维数组与二级指针</h3><p>二维数组在数内存中以一维的方式排布<br>二维数组中的第一维是一维数组<br>二维维数组中的第二维才是具体的值<br>二维数组的数组名可以看做常量指针</p>
<h3 id="2）数组名"><a href="#2）数组名" class="headerlink" title="2）数组名"></a>2）数组名</h3><p>一维数组名代表数组首元素的地址</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a[];     <span class="comment">//a的类型为 int*;</span></span><br></pre></td></tr></table></figure>
<p>二维数组名同样代表数组元素的地址</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> m[<span class="number">2</span>][<span class="number">5</span>]; //m的类型为 int(*)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：1. 二维数组名可以看做是指向一维数组的常量数组指针; 2. 二维数组可以看做是一维数组; 3. 二维数组中的每个元素都是同类型的一维数组; 4. c语言中的数组在函数参数中会退化成指针</p>
</blockquote>
<h3 id="3-二维数组参数"><a href="#3-二维数组参数" class="headerlink" title="3)二维数组参数"></a>3)二维数组参数</h3><p>二维数组参数同样存在退化的问题<br>二维数组可以看做是一维数组<br>二维数组中的每个元素是一维数组<br>二维数组的第一个参数可以省略</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> f(<span class="built_in">int</span> a[<span class="number">5</span>])    &lt;——&gt; <span class="built_in">void</span> f(<span class="built_in">int</span> a[])    &lt;——&gt; <span class="built_in">void</span> f(<span class="built_in">int</span> *a)</span><br><span class="line"><span class="built_in">void</span> g(<span class="built_in">int</span> a[<span class="number">3</span>][<span class="number">3</span>]) &lt;——&gt; <span class="built_in">void</span> g(<span class="built_in">int</span> a[][<span class="number">3</span>]) &lt;——&gt; <span class="built_in">void</span> g(<span class="built_in">int</span> (*a)[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/19.png" >

<h2 id="11、指针阅读技巧解析"><a href="#11、指针阅读技巧解析" class="headerlink" title="11、指针阅读技巧解析"></a>11、指针阅读技巧解析</h2><h3 id="1）基本规则"><a href="#1）基本规则" class="headerlink" title="1）基本规则"></a>1）基本规则</h3><ol>
<li>从最里层的圆括号中未定义的标识符看起</li>
<li>首先往右看，再往左看</li>
<li>遇到圆括号或方括号时可以确定部分类型，并调整方向</li>
<li>重复2，3步骤，直到阅读结束<h3 id="2）实例分析"><a href="#2）实例分析" class="headerlink" title="2）实例分析"></a>2）实例分析</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">int</span> (*p1)(<span class="built_in">int</span>*, <span class="built_in">int</span> (*f)(<span class="built_in">int</span>*)); // ==&gt; P1是一个指针，指向一个函数 ，该函数的类型为 <span class="built_in">int</span> (<span class="built_in">int</span>*,<span class="built_in">int</span>,<span class="built_in">int</span> (*f)(<span class="built_in">int</span>*))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p2[<span class="number">5</span>])(<span class="built_in">int</span>*);				//  ==&gt; p2是一个数组有<span class="number">5</span>个数组元素，每个数组元素都是函数指针，指向的函数类型为 <span class="built_in">int</span>(<span class="built_in">int</span>*)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*(*p3)[<span class="number">5</span>])(<span class="built_in">int</span>*);			//  ==&gt; p3是一个数组指针，指向的数组有<span class="number">5</span>个元素，每个元素的类型为函数指针，指向的函数类型为 <span class="built_in">int</span>(<span class="built_in">int</span>*)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span>*(*(*p4)(<span class="built_in">int</span>*))(<span class="built_in">int</span>*);		//  ==&gt; p4是一个函数指针，该函函数的参数为(<span class="built_in">int</span>*)，返回值为一个函数指针指向的函数类型为 <span class="built_in">int</span>*(<span class="built_in">int</span>*)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*(*p5)(<span class="built_in">int</span>*))[<span class="number">5</span>];			//  ==&gt; p5是一个函数指针，该函数的参数为(<span class="built_in">int</span>*)，函数的返回值为一个数组指针指向的数组类型为<span class="built_in">int</span>[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">	//将p5用typedef简写</span><br><span class="line">	typedef <span class="built_in">int</span>(ArryType)[<span class="number">5</span>];</span><br><span class="line">	typedef ArryType*(FuncType)(<span class="built_in">int</span>*);</span><br><span class="line">	</span><br><span class="line">	FuncType p5;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a><div align=center>野指针</h1><h2 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h2>指针变量中的值是非法的内存地址，进而形成野指针<br>野指针不是 NULL 指针，是指向不可用内存地址的指针<br>NULL 指针并无危害，很好判断也很好调试<br>c语言无法判断一个指针保存的地址是否合法<h2 id="2、野指针的由来"><a href="#2、野指针的由来" class="headerlink" title="2、野指针的由来"></a>2、野指针的由来</h2>1）局部指针变量没有初始化，保存随机值<br>2）指针所指变量在指针之前被销毁<br>3）使用已经释放过得指针<br>4）进行了错误的指针运算，内存越界<br>5）进行了错误的强制类型转换<h2 id="3、怎么避免野指针"><a href="#3、怎么避免野指针" class="headerlink" title="3、怎么避免野指针"></a>3、怎么避免野指针</h2>1）绝不返回局部变量和局部数组地址<br>2）任何变量在定义后必须0初始化<br>3）字符数组必须确认 0 结束符后才能成为字符串<h1 id="常见内存错误"><a href="#常见内存错误" class="headerlink" title="常见内存错误"></a><div align=center>常见内存错误</h1><h2 id="1、常见内存错误"><a href="#1、常见内存错误" class="headerlink" title="1、常见内存错误"></a>1、常见内存错误</h2>1）结构体成员指针未初始化<br>2）结构体指针未分配足够的内存<br>3）内存分配成功但为初始化<br>4）内存操作越界<h2 id="2、怎么避免内存操作错误"><a href="#2、怎么避免内存操作错误" class="headerlink" title="2、怎么避免内存操作错误"></a>2、怎么避免内存操作错误</h2>1）动态内存申请后，应立即检查指针,值是否为NULL<br>2）free 指针过后必须立即赋值为NULL<br>3）任何与内存操作相关的函数都必须带长度信息<br>5）malloc 操作和 free 操作必须匹配，防止内存泄漏和多次释放<br>6）在哪个函数中malloc就要在哪个函数中free<h1 id="C语言中的字符串"><a href="#C语言中的字符串" class="headerlink" title="C语言中的字符串"></a><div align=center>C语言中的字符串</h1><h2 id="1、字符串的概念"><a href="#1、字符串的概念" class="headerlink" title="1、字符串的概念"></a>1、字符串的概念</h2><h3 id="1-字符串是程序中的基本元素之一"><a href="#1-字符串是程序中的基本元素之一" class="headerlink" title="1)字符串是程序中的基本元素之一"></a>1)字符串是程序中的基本元素之一</h3>字符串是有序字符的集合<br>c语言中没有字符串的概念,c语言通过特殊的字符数组模拟字符串<br>c语言中的字符串是以 ‘\0’ 结尾的字符数组<h3 id="2-字符数组与字符串"><a href="#2-字符数组与字符串" class="headerlink" title="2)字符数组与字符串"></a>2)字符数组与字符串</h3>在c语言中，双引号引用的单个或者多个字符是一种特殊的字面量<br>储存于程序的全局只读存储区<br>本质为字符数组，编译器自动在结尾加上’\0’字符<br>字符串字面量可以看做一个常量指针<br>字符串字面量中的字符不可改变<br>字符串字面量至少包含一个字符<br>字符串相关函数均以第一个出现的’\0’作为结束符<br>编译器总是会在字符串字面量的末尾添加’\0’<h3 id="3）编程实验"><a href="#3）编程实验" class="headerlink" title="3）编程实验"></a>3）编程实验</h3>a）验证字符串的本质<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ca[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> sa[] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ss[] = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ca); <span class="comment">// Unknown result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sa); <span class="comment">// world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss); <span class="comment">// hello world!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, str);<span class="comment">// hello world!</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ca = %p\n&quot;</span>, ca); <span class="comment">// Unknown result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sa = %p\n&quot;</span>, sa); <span class="comment">// world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ss = %p\n&quot;</span>, ss); <span class="comment">// hello world!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str = %p\n&quot;</span>, str);<span class="comment">// hello world! </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Hello ����Hello world!</span><br><span class="line">World</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line"></span><br><span class="line">ca = <span class="number">0xbfa1e5d3</span></span><br><span class="line">sa = <span class="number">0xbfa1e5cd</span></span><br><span class="line">ss = <span class="number">0xbfa1e5df</span></span><br><span class="line">str = <span class="number">0x8048620</span>  </span><br><span class="line"></span><br><span class="line">结果分析：str地址明显区别于ca sa ss，因为字符串字面量为常量，而ca sa ss为栈上零时分配空间的字符数组</span><br></pre></td></tr></table></figure>
a）字符串编程练习<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">&quot;abc&quot;</span>[<span class="number">0</span>];       <span class="comment">// b = &#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> c = *(<span class="string">&quot;123&quot;</span> + <span class="number">1</span>);   <span class="comment">// c = &#x27;2&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> t = *<span class="string">&quot;&quot;</span>;            <span class="comment">// t = &#x27;\0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="2、符串的长度"><a href="#2、符串的长度" class="headerlink" title="2、符串的长度"></a>2、符串的长度</h2>字符串的长度就是字符串所包含的字符的个数<br>字符串长度指的是第一个’\0’前出现的字符个数<br>通过’\0’结束符来确定字符串的长度<br>函数 strlen 用于返回字符串的长度<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure>
字符串之间的相等比较需要用 strcmp 完成<br>不可直接用 == 进行字符串直接的比较<br>完全相同的字符串字面量 == 比较结果为false<blockquote>
<p>注意：一些现代编译器能够将相同的字符串字面量映射到同一个无名数组，因此 == 比较结果为true<br>编程时：不编写依赖特殊编译器的代码</p>
</blockquote>
<h2 id="3、snprintf函数"><a href="#3、snprintf函数" class="headerlink" title="3、snprintf函数"></a>3、snprintf函数</h2>snprintf函数本身是可变参数函数，原形如下<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> snprintf(<span class="keyword">char</span>* buffer, <span class="keyword">int</span> buff_size ,<span class="keyword">const</span> <span class="keyword">char</span>* fomart,...)；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：    当函数只有3个参数时，如果第三个参数没有包含格式化信息，函数调用没有问题；相反，如果第三个参数包含了<strong>格式化信息</strong>（%d, %s , %p ,…），但缺少后续对应参数，则程序为不确定</p>
</blockquote>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a><div align=center>动态内存分配</h1><h2 id="1、动态内存分配的意义"><a href="#1、动态内存分配的意义" class="headerlink" title="1、动态内存分配的意义"></a>1、动态内存分配的意义</h2>c语言的一切操作都是基于内存的<br>变量和数组都是内存的别名<br>内存分配由编译器在编译期间决定<br>定义数组的时候必须指定数组的长度<br>数组长度是在编译期就必须确定的<br>需求：<br>&nbsp;&nbsp;&nbsp;&nbsp;程序运行过程中，可能你需要使用一些额外的内存空间<h2 id="2、malloc-和-free"><a href="#2、malloc-和-free" class="headerlink" title="2、malloc 和 free"></a>2、malloc 和 free</h2>1）malloc 和 free 用于执行动态内存的分配和释放<br>&nbsp;&nbsp;&nbsp;&nbsp;a）malloc 分配的是一块连续的内存<br>&nbsp;&nbsp;&nbsp;&nbsp;b）malloc 以字节为单位，并且不带任何类型的信息<br>&nbsp;&nbsp;&nbsp;&nbsp;c）free 用于将动态内存归还系统<br>2）函数原型<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* pointer)</span></span>;</span><br></pre></td></tr></table></figure>
3）使用<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">malloc</span></span>(sizoef(<span class="class"><span class="keyword">type</span>)*<span class="title">size</span>);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>malloc 和 free 是库函数，不是系统调用<br>malloc 实际分配的内存可能比请求的多<br>不能依赖不同平台下的 malloc 行为<br>当请求的动态内存无法满足时，malloc 返回NULL<br>当 free 的参数为 NULL 时，函数直接返回</p>
</blockquote>
<h2 id="3、calloc-和-realloc"><a href="#3、calloc-和-realloc" class="headerlink" title="3、calloc 和 realloc"></a>3、calloc 和 realloc</h2><h3 id="1）calloc"><a href="#1）calloc" class="headerlink" title="1）calloc"></a>1）calloc</h3>calloc 在内存中动态地址分配num个长度为size的连续空间，并且将每一个字节都初始化为0</li>
</ol>
<p><strong>calloc 函数原型</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num ,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">calloc</span></span>(num,sizeof(<span class="class"><span class="keyword">type</span>))</span></span><br></pre></td></tr></table></figure>
<h3 id="2）realloc"><a href="#2）realloc" class="headerlink" title="2）realloc"></a>2）realloc</h3><p>a）realloc 用于修改一个原先已经分配的内存块大小<br>b）在使用realloc之后应该使用其返回值<br>c）当pointer的第一参数为NULL时，等价于malloc<br><strong>函数原型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* pointer,<span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p1</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">malloc</span></span>(sizoef(<span class="class"><span class="keyword">type</span>)*<span class="title">size</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>* <span class="title">p2</span> </span>= (<span class="class"><span class="keyword">type</span>*)<span class="title">realloc</span></span>(p1,new_size);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小知识：内存包含两个信息地址，长度</p>
</blockquote>
<h1 id="程序中栈"><a href="#程序中栈" class="headerlink" title="程序中栈"></a><div align=center>程序中栈</h1><h2 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h2><p>栈是现代计算机程序里最为重要的概念之一<br>栈在程序中用于维护函数调用上下文<br>函数中的参数和局部变量储存在栈上<br>栈保存了一个函数调用所需的维护信息<br>&nbsp;&nbsp;&nbsp;&nbsp;参数<br>&nbsp;&nbsp;&nbsp;&nbsp;返回值<br>&nbsp;&nbsp;&nbsp;&nbsp;局部变量<br>&nbsp;&nbsp;&nbsp;&nbsp;调用上下文<br>&nbsp;&nbsp;&nbsp;&nbsp;…    </p>
<h2 id="2、函数调用的过程使用栈"><a href="#2、函数调用的过程使用栈" class="headerlink" title="2、函数调用的过程使用栈"></a>2、函数调用的过程使用栈</h2><p>调用函数的活动记录位于栈的中部<br>被调用的函数活动记录位于栈的顶部</p>
<h2 id="3、函数调用栈上的数据"><a href="#3、函数调用栈上的数据" class="headerlink" title="3、函数调用栈上的数据"></a>3、函数调用栈上的数据</h2><p>函数调用时,对应的栈空间在函数返回前是专用的<br>函数调用结束后，栈空间将被释放，数据不再有效,无法传递到函数外部</p>
<h1 id="程序中栈程序中的堆"><a href="#程序中栈程序中的堆" class="headerlink" title="程序中栈程序中的堆"></a><div align=center>程序中栈程序中的堆</h1><p>堆是程序中一块预留的内存空间，可由程序自由使用<br>堆中被程序申请使用的内存在被主动释放前一直有效<br>c语言程序中通过函数的调用获得堆空间<br>头文件： malloc.h<br>free:将堆空间返还给系统<br>系统对堆空间的管理方式： 空间链表法，位图法，对象池法等等。</p>
<h1 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a><div align=center>程序与进程</h1><p>程序和进程不同<br>程序是静态概念，变现形式为一个可执行文件<br>进程是动态概念，程序由操作系统加载运行后得到进程<br>每个程序可以对应多个进程<br>每个进程只能对应一个程序<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/20.png" ></p>
<h1 id="程序中的静态存储器"><a href="#程序中的静态存储器" class="headerlink" title="程序中的静态存储器"></a><div align=center>程序中的静态存储器</h1><p>静态储存区随着程序的运行而分配空间<br>静态存储区的生命周期直到程序运行结束<br>在程序的编译期静态存储区的大小就已经确定<br>静态存储区主要用于保存全局变量和静态局部变量<br>静态存储区的信息最终会保存到可执行程序中去</p>
<h1 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a><div align=center>程序的内存布局</h1><p>堆栈段在程序运行后在正式存在，是程序运行的基础</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.text段     存放的是程序中的可执行代码</span></span><br><span class="line"><span class="title">.rodata段   存放着程序中的常量值，如：字符串常量</span></span><br><span class="line"><span class="title">.data段     存放的是已经初始化的全局变量和静态变量</span></span><br><span class="line"><span class="title">.bss段      存放的是未初始化或初始化为0的全局变量和静态变量</span></span><br><span class="line"><span class="title">.comment段  存放注释，不被烧写进程序</span></span><br></pre></td></tr></table></figure>
<h1 id="程序术语对的对应关系"><a href="#程序术语对的对应关系" class="headerlink" title="程序术语对的对应关系"></a><div align=center>程序术语对的对应关系</h1><p>静态存储区通常指程序中的 .bss 和 .data 段<br>只读存储区通常指程序中的 .rodata 段<br>局部变量所占的空间为栈上的空间<br>动态空间为堆的空间<br>程序可执行代码存放与 .text 段</p>
<h1 id="c语言中的函数"><a href="#c语言中的函数" class="headerlink" title="c语言中的函数"></a><div align=center>c语言中的函数</h1><h2 id="1、函数的由来"><a href="#1、函数的由来" class="headerlink" title="1、函数的由来"></a>1、函数的由来</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;程序     =  数据 + 算法<br>&nbsp;&nbsp;&nbsp;&nbsp;c程序 =  数据 + 函数</p>
<h2 id="2、面向过程的程序化设计"><a href="#2、面向过程的程序化设计" class="headerlink" title="2、面向过程的程序化设计"></a>2、面向过程的程序化设计</h2><p>1）面向过程是一种以过程为中心的编程思想<br>2）首先将复杂的问题分解为一个个容易解决的问题<br>3）分解过后的问题可以按照步骤一步步完成<br>4）函数面向过程在c语言中体现<br>5）解决问题的每一个步骤可以用函数来实现<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/21.png" ></p>
<h2 id="3、声明和定义"><a href="#3、声明和定义" class="headerlink" title="3、声明和定义"></a>3、声明和定义</h2><p>1）声明的意义在于告诉编译器程序单元的存在<br>2）定义则明确与指示程序单元的意义<br>3）c语言中通过 extern 进行程序单元的声明<br>4）一些程序单元在申明是可以省略 extern<br>5）严格意义上的声明和定义并不相同</p>
<h2 id="4、函数参数"><a href="#4、函数参数" class="headerlink" title="4、函数参数"></a>4、函数参数</h2><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/22.png" >

<p>函数参数在本质上与局部变量相同在栈上分配空间<br>函数参数的初始值是函数调用时的实参值<br>函数参数求值顺序依赖于编译器的实现</p>
<h2 id="5、程序中的顺序点"><a href="#5、程序中的顺序点" class="headerlink" title="5、程序中的顺序点"></a>5、程序中的顺序点</h2><p>1）程序中存在一定的顺序点<br>&nbsp;&nbsp;&nbsp;&nbsp;a）顺序点指的是程序执行过程中修改变量值的最晚时刻<br>&nbsp;&nbsp;&nbsp;&nbsp;b）在程序达到顺序点的时候，之前所做的一切操作必须完场<br>2）c语言中的顺序点<br>&nbsp;&nbsp;&nbsp;&nbsp;a）每个完整表达式结束时，即分号处<br>&nbsp;&nbsp;&nbsp;&nbsp;b）&amp;&amp; 、|| 、?: 、 以及逗号表达式的每个参数计算后<br>&nbsp;&nbsp;&nbsp;&nbsp;c）函数调用时所有实参求值完成后（进入函数体前）    </p>
<h2 id="6、参数入栈顺序"><a href="#6、参数入栈顺序" class="headerlink" title="6、参数入栈顺序"></a>6、参数入栈顺序</h2><p>1）调用约定<br>&nbsp;&nbsp;&nbsp;&nbsp;a）当函数调用发生时<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数会传递给被调用的函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而返回值会被返回给函数调用者<br>&nbsp;&nbsp;&nbsp;&nbsp;b）调用约定描述参数如何传递到栈中以及栈的维护方式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数传递顺序<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用栈清理<br>&nbsp;&nbsp;&nbsp;&nbsp;c）调用约定是预定义的可以理解为调用协议<br>&nbsp;&nbsp;&nbsp;&nbsp;d）调用约定通常用于库调用和库开发的时候<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从右到左依次入栈： _stdcall , _cdecl , thiscall<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从左到右依次入栈： _pascal , _fastcall<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/23.png" ></p>
<blockquote>
<p>A编译器 ==&gt; 主程序 ==&gt; 库文件 &lt;== B编译器</p>
</blockquote>
<h1 id="c语言中的函数进阶"><a href="#c语言中的函数进阶" class="headerlink" title="c语言中的函数进阶"></a><div align=center>c语言中的函数进阶</h1><h2 id="1、main函数的概念"><a href="#1、main函数的概念" class="headerlink" title="1、main函数的概念"></a>1、main函数的概念</h2><h3 id="1）说明"><a href="#1）说明" class="headerlink" title="1）说明"></a>1）说明</h3><p>c语言中main函数称为主函数<br>一个c程序是从main函数开始执行的</p>
<h3 id="2）mian函数的本质"><a href="#2）mian函数的本质" class="headerlink" title="2）mian函数的本质"></a>2）mian函数的本质</h3><p>main函数是操作系统调用的函数<br>操作系统总是将main函数作为应用程序的开始<br>操作系统将main函数的返回值作为程序退出状态</p>
<h3 id="3）main函数的参数"><a href="#3）main函数的参数" class="headerlink" title="3）main函数的参数"></a>3）main函数的参数</h3><p>程序执行时可以向main函数传递参数</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[],<span class="keyword">char</span>* env[])</span></span>;</span><br><span class="line">argc ——命令行参数个数</span><br><span class="line">argv ——命令行参数数组</span><br><span class="line">env  ——环境变量数组</span><br></pre></td></tr></table></figure>
<h3 id="4-函数参数传递"><a href="#4-函数参数传递" class="headerlink" title="4)函数参数传递"></a>4)函数参数传递</h3><p>c语言中只会以值拷贝的方式传递参数<br>当函数传递数组时:<br>&nbsp;&nbsp;&nbsp;&nbsp;将怎个数组拷贝一份传入数组（错误）<br>&nbsp;&nbsp;&nbsp;&nbsp;将数组名看做常量指针传数组首元素的地址<br>c语言以高效作为最初的设计目标<br>&nbsp;&nbsp;&nbsp;&nbsp;a）参数传递的时候如果拷贝整个数组执行效率将大大下降<br>&nbsp;&nbsp;&nbsp;&nbsp;b）参数位于栈上，太大的数组拷贝将导致栈的溢出<br>现代编译器支持在main函数函数之前调用其他函数</p>
<h2 id="2、函数类型"><a href="#2、函数类型" class="headerlink" title="2、函数类型"></a>2、函数类型</h2><p>c语言中的函数有自己特定的类型<br>函数的类型由返回值，参数类型和参数个数共同决定</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">add</span>(<span class="type">int</span> i, <span class="type">int</span> j) 的类型为 <span class="type">int</span>(<span class="type">int</span> ,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>c语言通过 typedef 为函数类型重命名</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">type</span> name(parameter list)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="3、函数指针"><a href="#3、函数指针" class="headerlink" title="3、函数指针"></a>3、函数指针</h2><p>函数指针用于指向一个函数<br>函数名是执行函数体的入口地址<br>可以通过类型定义函数指针： <strong>FuncType* pointer;**<br>也可以直接定义： **type (*pointer)(parameter list);</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;pointer为函数指针变量名<br>&nbsp;&nbsp;&nbsp;&nbsp;type 为所指函数的返回值类型<br>&nbsp;&nbsp;&nbsp;&nbsp;parameter list 为所指函数的参数类型列表</p>
<h2 id="4、回调函数"><a href="#4、回调函数" class="headerlink" title="4、回调函数"></a>4、回调函数</h2><p>回调函数是利用函数指针实现的一种调用机制<br>回调机制的原理<br>&nbsp;&nbsp;&nbsp;&nbsp;调用者不知道具体时间发生时需要调用的具体函数<br>&nbsp;&nbsp;&nbsp;&nbsp;被调用函数不知道何时被调用，只知道需要完成的任务<br>&nbsp;&nbsp;&nbsp;&nbsp;当具体事件发生时，调用者通过函数指针调用具体函数<br>回调机制中的调用者和被调函数互不依赖</p>
<h1 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a><div align=center>函数可变参数</h1><h2 id="1、c语言中可以定义参数可变的函数"><a href="#1、c语言中可以定义参数可变的函数" class="headerlink" title="1、c语言中可以定义参数可变的函数"></a>1、c语言中可以定义参数可变的函数</h2><p>参数可变函数的实现依赖于 stdarg.h 头文件<br>va_list    参数集合<br>va_start表示参数访问的开始<br>va_arg取具体参数值<br>va_end标识参数访问结束<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/24.png" ></p>
<h2 id="2、可变参数的限制"><a href="#2、可变参数的限制" class="headerlink" title="2、可变参数的限制"></a>2、可变参数的限制</h2><p>1）可变参数必须从头到尾按照顺序逐个访问<br>2）参数列表中至少要存在一个确定的命名参数<br>3）可变参数函数无法确定实际存在的参数的数量<br>4）可变参数函数无法确定参数的实际类型</p>
<blockquote>
<p>注意：    va_arg 中如果指定了错误的类型，那么结果是不可预测的; 可变参数必须顺序访问，无法直接访问中间的参数值</p>
</blockquote>
<h1 id="函数与宏分析"><a href="#函数与宏分析" class="headerlink" title="函数与宏分析"></a><div align=center>函数与宏分析</h1><p>宏是由预处理器直接替换展开的，编译器不知道宏的存在<br>函数是由编译器直接编译的实体，调用行为由编译器决定<br>多次使用宏会导致最终的可执行程序的体积增大<br>函数是跳转执行，内存中只有一份函数体存在<br>宏的效率比函数要高，因为是直接展开，无调用开销<br>函数调用会创建活动记录，效率不如宏<br>可以用函数完成的绝对不用宏<br>宏的定义中不能出现递归定义</p>
<h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a><div align=center>递归函数</h1><h2 id="1、递归的数学思想"><a href="#1、递归的数学思想" class="headerlink" title="1、递归的数学思想"></a>1、递归的数学思想</h2><p>1）递归是一种数学上分而自治的思想<br>2）递归将大型复杂问题转化为与原问题相同但规模较小的问题进行处理<br>3）递归需要有边界条件<br>&nbsp;&nbsp;&nbsp;&nbsp;a）当边界条件不满足时，递归继续进行<br>&nbsp;&nbsp;&nbsp;&nbsp;b）当边界条件满足时，递归停止</p>
<h2 id="2、递归函数"><a href="#2、递归函数" class="headerlink" title="2、递归函数"></a>2、递归函数</h2><p>1）函数体中存在自我调用的函数<br>2）递归函数是递归的数学思想在程序设计中的应用<br>&nbsp;&nbsp;&nbsp;&nbsp;a）递归函数必须有递归出口<br>&nbsp;&nbsp;&nbsp;&nbsp;b）函数的无限递归将导致程序栈溢出而崩溃    </p>
<h2 id="3、递归函数设计技巧"><a href="#3、递归函数设计技巧" class="headerlink" title="3、递归函数设计技巧"></a>3、递归函数设计技巧</h2><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/25.png" >

<h2 id="4、斐波拉契数列递归解法"><a href="#4、斐波拉契数列递归解法" class="headerlink" title="4、斐波拉契数列递归解法"></a>4、斐波拉契数列递归解法</h2><p>1,1,2,3,5,8,13,21,…<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/26.png" ></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int fac(int n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>==n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span>==n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span>&lt;n)</span><br><span class="line">		<span class="keyword">return</span> fac(n-<span class="number">1</span>) + fac(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、汉诺塔问题"><a href="#5、汉诺塔问题" class="headerlink" title="5、汉诺塔问题"></a>5、汉诺塔问题</h2><p>1）将木块借助    B由A柱移动到c柱<br>2）每次只能移动一个木块<br>3）只能出现小木块在大木块之上<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/27.png" ></p>
<p>问题分解<br>&nbsp;&nbsp;&nbsp;&nbsp;将n-1个木块借助C柱移动到B柱<br>&nbsp;&nbsp;&nbsp;&nbsp;将最底层的唯一木块直接移动到C柱<br>&nbsp;&nbsp;&nbsp;&nbsp;将n-1个木块借助A柱由B柱移动到C柱<br><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%E8%AF%AD%E8%A8%80/28.png" ></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void han<span class="constructor">_move(<span class="params">int</span> <span class="params">n</span>,<span class="params">char</span> <span class="params">a</span>, <span class="params">char</span> <span class="params">b</span>, <span class="params">char</span> <span class="params">c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n<span class="operator"> == </span><span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;%c--&gt;%c\n&quot;</span>,a,c);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		han<span class="constructor">_move(<span class="params">n</span>-1,<span class="params">a</span>,<span class="params">c</span>,<span class="params">b</span>)</span>;</span><br><span class="line">		han<span class="constructor">_move(1,<span class="params">a</span>,<span class="params">b</span>,<span class="params">c</span>)</span>;</span><br><span class="line">		han<span class="constructor">_move(<span class="params">n</span>-1,<span class="params">b</span>,<span class="params">a</span>,<span class="params">c</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数设计原则"><a href="#函数设计原则" class="headerlink" title="函数设计原则"></a><div align=center>函数设计原则</h1><p>函数从意义上应该是一个独立的功能模块<br>函数名要在一定程度上反映函数功能<br>函数参数名要能体现参数的意义<br>尽量避免在函数中使用全局变量</p>
<p>当函数参数不应该在函数内部被修改时，应该加上 const 申明修饰<br>如果参数是指针，且仅作为输入参数，则应该加上 const 申明</p>
<p>不能省略返回值的类型<br>如果函数没有返回值，那么应该声明为 void 类型<br>对函数参数检查有效性<br>对于指针参数的检查尤为重要<br>不要返回指向”栈内存”的指针<br>栈内存在函数结束时会被自动释放</p>
<p>函数体的规模要小，尽量控制在”80”行代码之内<br>相同的输入对应相同的输出，避免函数带有”记忆”功能<br>避免函数有过多的参数，参数尽量控制在”4”个以内</p>
<p>有时候函数不需要返回值，但为了支持灵活性，如支持链式表达，可以附加返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="built_in">strcpy</span>(,<span class="string">&quot;android&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>函数名与返回值类型在语意上不可冲突</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> c = getchar();   //getchar 返回值为 <span class="built_in">int</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">EOR</span> == c)			</span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文来自狄泰软件视频自学记录，有兴趣学习可以淘宝搜索“狄泰软件学院”购买视频学习</strong></p>
<h1 id="优秀的代码具有自注性，直接可以读出函数的功能"><a href="#优秀的代码具有自注性，直接可以读出函数的功能" class="headerlink" title="优秀的代码具有自注性，直接可以读出函数的功能"></a>优秀的代码具有自注性，直接可以读出函数的功能</h1>]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile专题</title>
    <url>/2021/08/18/makfile%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>记录 makefile 基本知识，学习资料来自狄泰软件学院可在淘宝购买学习</p>
<a id="more"></a>

<h1 id="一、make-和-makefile"><a href="#一、make-和-makefile" class="headerlink" title="一、make 和 makefile"></a><div align=center>一、make 和 makefile</h1><h2 id="1、make-的本质"><a href="#1、make-的本质" class="headerlink" title="1、make 的本质"></a>1、make 的本质</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;make 是一个应用程序，用于<font color=blue>解析源程序之间的依赖关系</font>，根据依赖关系<font color=red>自动维护</font>编译工作，执行宿主操作系统中的各种命令</p>
<h2 id="2、makefile-的本质"><a href="#2、makefile-的本质" class="headerlink" title="2、makefile 的本质"></a>2、makefile 的本质</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;makefile 是一个描述文件, 可以 <font color=purple>定义一系列的规则</font>来指定源文件编译的先后顺, <font color=orange>拥有特定的语法规则</font>，支持函数定义和函数调用, 能够<font color=blue>直接集成</font>操作系统中的各种命令</p>
<h2 id="3、make-和-makefile之间的关系"><a href="#3、make-和-makefile之间的关系" class="headerlink" title="3、make 和 makefile之间的关系"></a>3、make 和 makefile之间的关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;makefile 中的描述用于指导 make 如何完成工作，make 根据 makefile 中的规则执行命令，最后完成编译输出</p>
<h2 id="4、最简单的-makefle-程序"><a href="#4、最简单的-makefle-程序" class="headerlink" title="4、最简单的 makefle 程序"></a>4、最简单的 makefle 程序</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hello </span>: </span><br><span class="line">	<span class="variable">@echo</span> “hello makefile”</span><br><span class="line"></span><br><span class="line">程序说明：</span><br><span class="line">	hello --&gt; 目标     </span><br><span class="line">	<span class="variable">@echo</span> “hello makefile” -&gt; 实现目标所需要执行的命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：目标后的命令需要用tab键（’\t’）隔开！<br>要运行 makefile 在 linux 下执行以下命令：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">make</span> –<span class="selector-tag">f</span> <span class="selector-tag">mf</span><span class="selector-class">.txt</span> <span class="selector-tag">hello</span></span><br><span class="line"></span><br><span class="line">运行结果：<span class="selector-tag">hello</span> <span class="selector-tag">makefile</span></span><br></pre></td></tr></table></figure>
<p>命令功能说明：以 hello 关键字作为目标查找 mf.txt 文件，并执行 hello 目标处的命令</p>
<h2 id="5、make-程序简写"><a href="#5、make-程序简写" class="headerlink" title="5、make 程序简写"></a>5、make 程序简写</h2><p>上述的命令显示的太长，我们可以对其进行简写,有两种方式：1. <font color=red>make hello</font>, 这句话表示以 hello 为关键字作为目标查找 <font color=dark>makeflie</font> 或 Makefile 文件，并执行 hello 处的命令。2. <font color=red>make</font>，这句话表示查找 makefile 或 Makefile 文件中<font color=purple>最顶层目标</font>，并执行<font color=purple>最顶层目标</font>的命令</p>
<h1 id="二、初识-makefile-的结构"><a href="#二、初识-makefile-的结构" class="headerlink" title="二、初识 makefile 的结构"></a><div align=center>二、初识 makefile 的结构</h1><h2 id="1、makefile-的意义"><a href="#1、makefile-的意义" class="headerlink" title="1、makefile 的意义"></a>1、makefile 的意义</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;makefile 用于定义源文件之间的依赖关系，说明如何编译各个源文件并生成可执行文件，依赖的定义如下</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">targets : prerequisite ; <span class="keyword">command</span>1</span><br><span class="line">	‘\t’ <span class="keyword">command</span>2 <span class="comment">#使用这个方式可以省略分号</span></span><br></pre></td></tr></table></figure>
<p><strong>targets(目标)：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;通常是需要生成的<font color=purple>目标文件名</font>，make 所需执行的命令名称，可以包含多个目标，使用空格对将多个目标隔开</p>
<p><strong>prerequisite(依赖)：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;当前目标所依赖的其他<font color=dark>目标</font>或<font color=blue>文件</font>，可以包含多个依赖，使用空格对将多个依赖隔开，如果省略不写，就意味着只要执行后续的命令那么目标就可以完成了。</p>
<p><strong>command(命令)：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;完成目标所需要执行的命令，规则中的注意事项，[tab]键：’\t’ ，每一个命令必须以[tab]字符开始，[tab]字符告诉 make 此行是一个命令行。<font color=brown>只要命令成功执行完，则认为目标完成</font>。</p>
<p><strong>续行符：‘\’</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;可以将内容分开写到下一行，提高可读性</p>
<h2 id="3、规则"><a href="#3、规则" class="headerlink" title="3、规则"></a>3、规则</h2><img width src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/makefile/makefile%E8%A7%84%E5%88%99.jpg?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1629268646;865629182246&q-key-time=1629268646;865629182246&q-header-list=&q-url-param-list=&q-signature=1c3d5df851ddaf2283419ee996ae55dad55ed2d7">

<p>该图描述了 makefile 的规则，举例说明</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">all </span>: test</span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;make all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">test </span>:</span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;make test&quot;</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">make test</span><br><span class="line">make all</span><br></pre></td></tr></table></figure>
<p>上述 makefile 定义了两条规则，all 这个目标依赖于 test，如果 test 这个依赖表示的目标成立，就执行 echo “make all” 这个命令，如果 test 不成立，就会以 test 为目标查找其规则。 以 test 为目标的规则没有依赖，因此只需要执行 echo “make test” 命令， test 就会成立。<font color=red>test 成立之后，也就是 all 的依赖完成，因此执行 all 规则的命令 @echo “make all”</font></p>
<h2 id="3、第一个-make-的编译案例"><a href="#3、第一个-make-的编译案例" class="headerlink" title="3、第一个 make 的编译案例"></a>3、第一个 make 的编译案例</h2><p>func.c 文件内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>main.c 文件内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile 文件内容如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">hello</span><span class="selector-class">.out</span> : <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span></span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.out</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span> : </span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">-c</span> <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">func</span><span class="selector-class">.o</span> : </span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span> <span class="selector-tag">-c</span> <span class="selector-tag">func</span><span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">-c</span> <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span> <span class="selector-tag">-c</span> <span class="selector-tag">func</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.out</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure>
<p>小技巧：工程开发中可以将最终可执行文件名和 all 同时作为 makefile 中第一条规则</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">hello</span><span class="selector-class">.out</span> <span class="selector-tag">all</span> : <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span> </span><br><span class="line">	<span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.out</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">fun</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure>
<p>当我们想手动编译时执行 make all 就会编译，直接 make 则会检测 hello.out。</p>
<h1 id="三、伪目标"><a href="#三、伪目标" class="headerlink" title="三、伪目标"></a><div align=center>三、伪目标</h1><h2 id="1、伪目标的引入"><a href="#1、伪目标的引入" class="headerlink" title="1、伪目标的引入"></a>1、伪目标的引入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，make 认为<font color=dark>目标对应着一个文件</font>，make <font color=blue>比较目标文件和依赖文件的新旧关系</font>，决定是否执行命令，make 以<font color=purple>文件处理</font>作为第一优先级。但有时候我们希望我们的目录并不是一个文件如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">clean</span> :</span><br><span class="line">	<span class="selector-tag">rm</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">func</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个时候通过 .PHONY 关键字声明一个伪目标, 伪目标不对应任何实际的文件,不管目标的依赖是否更新，命令总是执行, 伪目标的语法如下</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">.PHONY : <span class="type">Target</span> </span><br></pre></td></tr></table></figure>
<p>伪目标的本质是 make 中特殊目标 .PHONY 的依赖，先声明、后使用。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">.PHONY : <span class="type">clean</span> rebuild <span class="keyword">all</span> </span><br><span class="line"></span><br><span class="line">## other rules ## </span><br><span class="line"></span><br><span class="line">rebuile : <span class="type">clean</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">clean : </span><br><span class="line">	rm *o hello.<span class="keyword">out</span></span><br></pre></td></tr></table></figure>
<p>原理：当一个目标的依赖包含伪目标时，伪目标所定义的命令总是会被执行</p>
<h2 id="2、绕开-PHONY-关键字定义伪目标"><a href="#2、绕开-PHONY-关键字定义伪目标" class="headerlink" title="2、绕开 .PHONY 关键字定义伪目标"></a>2、绕开 .PHONY 关键字定义伪目标</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;如果一个规则没有命令或者依赖，并且它的目标不是一个存在的文件名；在执行此规则时，目标总是被认为是最新的。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">clean : <span class="keyword">FORCE</span></span><br><span class="line">	rm *.o hello.<span class="keyword">out</span></span><br><span class="line"><span class="keyword">FORCE</span> :</span><br></pre></td></tr></table></figure>
<h1 id="四、变量和不同的赋值方式"><a href="#四、变量和不同的赋值方式" class="headerlink" title="四、变量和不同的赋值方式"></a><div align=center>四、变量和不同的赋值方式</h1><h2 id="1、makefile中的变量"><a href="#1、makefile中的变量" class="headerlink" title="1、makefile中的变量"></a>1、makefile中的变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; makefile 中支持程序设计语言中<font color=dark>变量的概念</font>，makefile 中变量只代表<font color=purple>文本数据</font>。makefile 中变量命名规则如下所示</p>
<blockquote>
<ol>
<li>变量名大小写敏感</li>
<li>变量名可以包含字符，数字，下划线</li>
<li>不能包含 “:” , “#” , “=” , 或 “ “</li>
<li>makefile 未赋值的变量的值为空值</li>
</ol>
</blockquote>
<h2 id="2、变量的定义和使用"><a href="#2、变量的定义和使用" class="headerlink" title="2、变量的定义和使用"></a>2、变量的定义和使用</h2><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/makefile/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1629172213;88029085813&q-key-time=1629172213;88029085813&q-header-list=&q-url-param-list=&q-signature=340dd806fca1d9e879119a25be61b36aa9e5493a">

<p>修改前面的 makefile 验证</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">TARGET := hello.out</span><br><span class="line"></span><br><span class="line">$(TARGET) : main<span class="selector-class">.o</span> func.o</span><br><span class="line">    $(CC) -o $(TARGET) main<span class="selector-class">.o</span> func.o</span><br><span class="line">main<span class="selector-class">.o</span> : main.c</span><br><span class="line">    $(CC) -o main<span class="selector-class">.o</span> -c main.c</span><br><span class="line">func<span class="selector-class">.o</span> : func.c</span><br><span class="line">    $(CC) -o func<span class="selector-class">.o</span> -c func.c</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.PHONY</span> : rebuild clean all</span><br><span class="line"></span><br><span class="line">rebuile : clean all</span><br><span class="line"></span><br><span class="line">all : $(TARGET)</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm *<span class="selector-class">.o</span> $(TARGET)</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">gcc -o main<span class="selector-class">.o</span> -c main.c</span><br><span class="line">gcc -o func<span class="selector-class">.o</span> -c func.c</span><br><span class="line">gcc -o hello<span class="selector-class">.out</span> main<span class="selector-class">.o</span> func.o</span><br></pre></td></tr></table></figure>
<h2 id="3、makefile中变量的赋值方式"><a href="#3、makefile中变量的赋值方式" class="headerlink" title="3、makefile中变量的赋值方式"></a>3、makefile中变量的赋值方式</h2><h3 id="1-简单赋值"><a href="#1-简单赋值" class="headerlink" title="1)    简单赋值 :="></a>1)    简单赋值 :=</h3><p>程序设计语言中的通用赋值方式, <font color=green>只针对当前语句变量有效</font></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := foo</span><br><span class="line"><span class="symbol">y</span> := $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> := new</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = new</span><br><span class="line">	<span class="symbol">y</span> = foob</span><br></pre></td></tr></table></figure>
<h3 id="2-递归赋值"><a href="#2-递归赋值" class="headerlink" title="2)    递归赋值 ="></a>2)    递归赋值 =</h3><p>赋值操作可能影响多个其他变量, <font color=blue>所有与目标变量相关的其他变量将受到影响</font></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> = foo</span><br><span class="line"><span class="symbol">y</span> = $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> = new</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = new</span><br><span class="line">	<span class="symbol">y</span> = newb</span><br></pre></td></tr></table></figure>
<h3 id="3-条件赋值"><a href="#3-条件赋值" class="headerlink" title="3) 条件赋值 ?="></a>3) 条件赋值 ?=</h3><p>如果变量未定义，使用赋值符号中的值定义变量, <font color=purple>如果变量已经定义，赋值无效</font></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := foo</span><br><span class="line"><span class="symbol">y</span> := $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> ?= new</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = foo</span><br><span class="line">	<span class="symbol">y</span> = foob</span><br></pre></td></tr></table></figure>
<h3 id="4-追加赋值"><a href="#4-追加赋值" class="headerlink" title="4) 追加赋值 +="></a>4) 追加赋值 +=</h3><p>原变量值之后加上一个新值, <font color=dark>原变量值与新值之间由空格隔开</font></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := foo</span><br><span class="line"><span class="symbol">y</span> := $(<span class="symbol">x</span>)b</span><br><span class="line"><span class="symbol">x</span> += $(<span class="symbol">y</span>)</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line">test :</span><br><span class="line">	@echo “<span class="symbol">x</span> = $(<span class="symbol">x</span>)”</span><br><span class="line">	@echo “<span class="symbol">y</span> = $(<span class="symbol">y</span>)”</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">x</span> = foo foob</span><br><span class="line">	<span class="symbol">y</span> = foob</span><br></pre></td></tr></table></figure>
<h1 id="五、预定义变量的使用"><a href="#五、预定义变量的使用" class="headerlink" title="五、预定义变量的使用"></a><div align=center>五、预定义变量的使用</h1><p>在 makefile 中存在一些预定义的变量，常用的有自动变量以及特殊变量</p>
<h2 id="1-自动变量"><a href="#1-自动变量" class="headerlink" title="1. 自动变量"></a>1. 自动变量</h2><p><strong>$@</strong>  当前规则中触发命令被执行的目标, 即当前规则中的目标<br><strong>$^</strong> 当前规则中的所有依赖<br><strong>$&lt;</strong>  当前规则中的第一个依赖</p>
<h2 id="2、自动变量的使用"><a href="#2、自动变量的使用" class="headerlink" title="2、自动变量的使用"></a>2、自动变量的使用</h2><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">PHONY : <span class="keyword">all</span> first second third</span><br><span class="line"></span><br><span class="line"><span class="keyword">all</span> : first second third</span><br><span class="line">	@echo “\<span class="symbol">$</span><span class="symbol">$</span>@ =&gt; <span class="symbol">$</span>@”</span><br><span class="line">	@echo “<span class="symbol">$</span><span class="symbol">$</span>^ =&gt; <span class="symbol">$</span><span class="symbol">$</span>^”</span><br><span class="line">	@echo “<span class="symbol">$</span><span class="symbol">$</span>&lt; =&gt; <span class="symbol">$</span>&lt;”</span><br><span class="line"></span><br><span class="line">first :</span><br><span class="line">second : </span><br><span class="line">third : </span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="symbol">$</span>@ =&gt; <span class="keyword">all</span></span><br><span class="line">	<span class="symbol">$</span>^ =&gt; first second third</span><br><span class="line">	<span class="symbol">$</span>&lt; =&gt; first</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：<br>&nbsp;&nbsp;&nbsp;&nbsp;”$” 对于 makefile 有特殊含义，输出时加上一个 $ 进行转义<br>&nbsp;&nbsp;&nbsp;&nbsp;”$@” 对于Bash Shell 有特殊含义，输出时加上 \ 进行转义</p>
</blockquote>
<p>使用自动变量改写前面的 makefile</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">TARGET := hello.out</span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span>(TARGET) : main.o func.o</span><br><span class="line">    <span class="symbol">$</span>(CC) -o <span class="symbol">$</span>@ <span class="symbol">$</span>^</span><br><span class="line">main.o : main.c</span><br><span class="line">    <span class="symbol">$</span>(CC) -o <span class="symbol">$</span>@ -c <span class="symbol">$</span>^</span><br><span class="line">func.o : func.c</span><br><span class="line">    <span class="symbol">$</span>(CC) -o <span class="symbol">$</span>@ -c <span class="symbol">$</span>^</span><br><span class="line"></span><br><span class="line">.PHONY : rebuild clean <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line">rebuile : clean <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">all</span> : <span class="symbol">$</span>(TARGET)</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm *.o <span class="symbol">$</span>(TARGET)</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">gcc -o main.o -c main.c</span><br><span class="line">gcc -o func.o -c func.c</span><br><span class="line">gcc -o hello.out main.o func.o</span><br></pre></td></tr></table></figure>
<h2 id="3、特殊变量"><a href="#3、特殊变量" class="headerlink" title="3、特殊变量"></a>3、特殊变量</h2><ul>
<li><p><strong>$(MAKE)</strong>: 当前 make 解释器的文件名</p>
</li>
<li><p><strong>$(MAKECMDGOALS)</strong>: 命令中指定的目标名（ make 的命令行参数）</p>
</li>
<li><p><strong>$(MAKEFILE_LIST)</strong>: make 所需要处理的 makefile 文件列表, 当前 makefile 的文件名总是位于列表的最后, 文件名之间以空格进行划分</p>
</li>
<li><p><strong>$(MAKE_VERSION)</strong>: 当前 make 解释器的版本</p>
</li>
<li><p><strong>$(CURDIR)</strong>: 当前 make 解释器的工作目录</p>
</li>
<li><p><strong>$(.VARIABLES)</strong>: 所有已经定义的变量名列表，其中包括预定义变量和自定义变量</p>
</li>
</ul>
<p>编程实验 1</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">.PHONY : all out test <span class="keyword">first</span> <span class="keyword">second</span> <span class="keyword">third</span></span><br><span class="line"></span><br><span class="line">all out : <span class="keyword">first</span> <span class="keyword">second</span> <span class="keyword">third</span></span><br><span class="line">    @echo <span class="string">&quot;$(MAKE)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;$(MAKECMDGOALS)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;$(MAKEFILE_LIST)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">first</span> :</span><br><span class="line">    @echo <span class="string">&quot;first&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">second</span> :</span><br><span class="line">    @echo <span class="string">&quot;second&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">third</span> :</span><br><span class="line">    @echo <span class="string">&quot;third&quot;</span></span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">    @$(MAKE) <span class="keyword">first</span></span><br><span class="line">    @$(MAKE) <span class="keyword">second</span></span><br><span class="line">    @$(MAKE) <span class="keyword">third</span></span><br><span class="line"></span><br><span class="line">运行 make 结果：</span><br><span class="line"><span class="keyword">first</span></span><br><span class="line"><span class="keyword">second</span></span><br><span class="line"><span class="keyword">third</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"> makefile</span><br><span class="line"></span><br><span class="line">运行 make test 结果</span><br><span class="line">make[<span class="number">1</span>]: Entering <span class="built_in">directory</span> <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line"><span class="keyword">first</span></span><br><span class="line">make[<span class="number">1</span>]: Leaving <span class="built_in">directory</span> <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line">make[<span class="number">1</span>]: Entering <span class="built_in">directory</span> <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line"><span class="keyword">second</span></span><br><span class="line">make[<span class="number">1</span>]: Leaving <span class="built_in">directory</span> <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line">make[<span class="number">1</span>]: Entering <span class="built_in">directory</span> <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line"><span class="keyword">third</span></span><br><span class="line">make[<span class="number">1</span>]: Leaving <span class="built_in">directory</span> <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br></pre></td></tr></table></figure>
<p>编程实验 2</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.PHONY : test1 test2</span><br><span class="line"></span><br><span class="line">test1 :</span><br><span class="line">    @echo <span class="string">&quot;$(MAKE_VERSION)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;$(CURDIR)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;$(.VARIABLES)&quot;</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">4.1</span> </span><br><span class="line">/home/book/c/mkfile </span><br><span class="line">&lt;D ?F .SHELLFLAGS CWEAVE ?D @D @F MAKE_VERSION CURDIR SHELL RM CO <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span><span class="keyword">mod</span> _ PREPROCESS.F <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>m <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>o OUTPUT_OPTION <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>cpp MAKEFILE_LIST GNUMAKEFLAGS <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>p XDG_DATA_DIRS DBUS_SESSION_BUS_ADDRESS CC CHECKOUT,v LESSOPEN CPP <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>cc SSH_CONNECTION PATH LD TEXI2DVI YACC SSH_TTY XDG_RUNTIME_DIR ARFLAGS <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>r LINT <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>f <span class="module-access"><span class="module"><span class="identifier">LINT</span>.</span></span>c <span class="module-access"><span class="module"><span class="identifier">YACC</span>.</span></span>m <span class="module-access"><span class="module"><span class="identifier">YACC</span>.</span></span>y AR .FEATURES TANGLE LS_COLORS GET %F DISPLAY COMPILE.F CTANGLE .LIBPATTERNS LINK.C PWD LINK.S <span class="module-access"><span class="module"><span class="identifier">PREPROCESS</span>.</span></span>r *D <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>c <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>s HOME LESSCLOSE LOGNAME ^D MAKELEVEL <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>m MAKE SHLVL AS PREPROCESS.S <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>p XDG_SESSION_ID USER FC .DEFAULT_GOAL %D WEAVE MAKE_COMMAND <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>cpp F77 OLDPWD .VARIABLES PC *F <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>def LEX ARCH MAKEFLAGS MFLAGS SSH_CLIENT MAIL <span class="module-access"><span class="module"><span class="identifier">LEX</span>.</span></span>l <span class="module-access"><span class="module"><span class="identifier">LEX</span>.</span></span>m +D <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>r MAKE_TERMOUT +F M2C CROSS_COMPILE MAKEFILES <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>cc &lt;F CXX COFLAGS COMPILE.C ^F COMPILE.S LINK.F SUFFIXES <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>c <span class="module-access"><span class="module"><span class="identifier">COMPILE</span>.</span></span>s .INCLUDE_DIRS .RECIPEPREFIX MAKEINFO MAKE_TERMERR OBJC MAKE_HOST TEX LANG TERM F77FLAGS <span class="module-access"><span class="module"><span class="identifier">LINK</span>.</span></span>f</span><br></pre></td></tr></table></figure>

<h1 id="六、变量的高级主题"><a href="#六、变量的高级主题" class="headerlink" title="六、变量的高级主题"></a><div align=center>六、变量的高级主题</h1><h2 id="1-常用语法"><a href="#1-常用语法" class="headerlink" title="1. 常用语法"></a>1. 常用语法</h2><h3 id="1）-变量值的替换"><a href="#1）-变量值的替换" class="headerlink" title="1） 变量值的替换"></a>1） 变量值的替换</h3><p>使用<font color=blue>指定字符（串）</font>替换变量中的<font color=green>后缀字符（串）</font>，语法格式如下</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$(var:<span class="attribute">a</span>=b) 或 <span class="variable">$&#123;var:a=b&#125;</span></span><br></pre></td></tr></table></figure>
<p>替换表达式中<font color=red>不能有任何的空格</font>，make 中支持使用 <font color=purple>${}</font> 对变量进行取值</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">src := a.cc b.cc c.cc</span><br><span class="line">obj := $(src:cc=o)</span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo ”obj =&gt; $(obj)”</span><br><span class="line"></span><br><span class="line">输出结果：obj = &gt; a.o b.o c.o</span><br></pre></td></tr></table></figure>
<h3 id="2）变量的模式替换"><a href="#2）变量的模式替换" class="headerlink" title="2）变量的模式替换"></a>2）变量的模式替换</h3><p><font color=blue>使用 % 保留变量值中的指定字符</font>，替换其他字符,语法格式如下</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">var</span>:a%b=<span class="symbol">x</span>%<span class="symbol">y</span>)或$&#123;<span class="keyword">var</span>:a%b=<span class="symbol">x</span>%<span class="symbol">y</span>&#125;</span><br></pre></td></tr></table></figure>
<p>替换表达式中<font color=dark>不能有任何的空格</font>, make 中支持使用 <font color=purple>${}</font> 对变量进行取值</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">src :<span class="operator">=</span> a<span class="number">1</span>b.<span class="keyword">c</span> a<span class="number">2</span>b.<span class="keyword">c</span> a<span class="number">3</span>b.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">obj :<span class="operator">=</span> $(src:a<span class="variable">%b.c</span><span class="operator">=</span><span class="keyword">x</span><span class="variable">%y</span>)</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	<span class="title">@echo</span> <span class="string">&quot;obj =&gt; $(obj)&quot;</span></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	obj <span class="operator">=</span>&gt; <span class="keyword">x</span><span class="number">1</span>y <span class="keyword">x</span><span class="number">2</span>y <span class="keyword">x</span><span class="number">3</span>y</span><br></pre></td></tr></table></figure>
<h3 id="3）规则中的模式替换"><a href="#3）规则中的模式替换" class="headerlink" title="3）规则中的模式替换"></a>3）规则中的模式替换</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">targets : <span class="type">targets</span>-pattern : <span class="type">prereq</span>-pattern</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	…</span><br></pre></td></tr></table></figure>
<p>当 targets(目标) 的依赖的规则不存在时，通过 targets-pattern 从 targets 中匹配子目标,再通过 prereq-pattern 从子目标生成依赖, 进而构成完整的规则, 举例说明如下。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">.PHONY : rebuild clean <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line">CC :<span class="built_in">=</span> gcc</span><br><span class="line">TARGET :<span class="built_in">=</span> hello.out</span><br><span class="line">OBJS :<span class="built_in">=</span> main.o <span class="keyword">func</span>.o</span><br><span class="line"></span><br><span class="line">$(TARGET) : $(OBJS)</span><br><span class="line">    $(CC) -o $@ $^</span><br><span class="line"></span><br><span class="line">##############################</span><br><span class="line">$(OBJS) : <span class="comment">%.o : %.c   // 规则中的模式替换</span></span><br><span class="line">    $(CC) -o $@ -c $^</span><br><span class="line">#############################</span><br><span class="line"></span><br><span class="line">rebuild : clean <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">all</span> : $(TARGET)</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm -rf *.o $(TARGET)</span><br></pre></td></tr></table></figure>
<p>上述 makefile 等价于</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">.PHONY : rebuild clean <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line">CC :<span class="built_in">=</span> gcc</span><br><span class="line">TARGET :<span class="built_in">=</span> hello.out</span><br><span class="line">OBJS :<span class="built_in">=</span> main.o <span class="keyword">func</span>.o</span><br><span class="line"></span><br><span class="line">$(TARGET) : $(OBJS)</span><br><span class="line">    $(CC) -o $@ $^</span><br><span class="line"></span><br><span class="line">##############################</span><br><span class="line">mian.o : main.c</span><br><span class="line">	gcc -o mian.o -c mian.c</span><br><span class="line"><span class="keyword">func</span>.o : <span class="keyword">func</span>.c</span><br><span class="line">	gcc -o <span class="keyword">func</span>.o -c <span class="keyword">func</span>.o</span><br><span class="line">#############################</span><br><span class="line"></span><br><span class="line">rebuild : clean <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">all</span> : $(TARGET)</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm -rf *.o $(TARGET)</span><br></pre></td></tr></table></figure>
<p>除此之外呢，我们还可以省略掉 targets 如下所示</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">.PHONY : rebuild clean <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line">CC :<span class="built_in">=</span> gcc</span><br><span class="line">TARGET :<span class="built_in">=</span> hello.out</span><br><span class="line">OBJS :<span class="built_in">=</span> main.o <span class="keyword">func</span>.o</span><br><span class="line"></span><br><span class="line">$(TARGET) : $(OBJS)</span><br><span class="line">    $(CC) -o $@ $^</span><br><span class="line"></span><br><span class="line">##############################</span><br><span class="line"><span class="comment">%.o : %.c   // 规则中的模式替换</span></span><br><span class="line">    $(CC) -o $@ -c $^</span><br><span class="line">#############################</span><br><span class="line"></span><br><span class="line">rebuild : clean <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">all</span> : $(TARGET)</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm -rf *.o $(TARGET)</span><br></pre></td></tr></table></figure>
<p>示例代码在大部分情况可以理解为等价的，特殊情况如下</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">%.o : %.c   </span><br><span class="line">    $(CC) -o $@ -c $^</span><br><span class="line"></span><br><span class="line">$(OBJS) : %.o : %.c   <span class="comment">// 规则中的模式替换</span></span><br><span class="line">    $(CC) -o $@ -c $^</span><br></pre></td></tr></table></figure>
<p>当他们同时存在的时候，$(CC) -o $@ -c $^ 代码会被执行两次。并且 $(OBJS) : %.o : %.c 的规则会被替换为 %.o : %.c 的规则</p>
<h3 id="4）变量值的嵌套引用"><a href="#4）变量值的嵌套引用" class="headerlink" title="4）变量值的嵌套引用"></a>4）变量值的嵌套引用</h3><p>一个变量名之中可以包含对其他变量的引用，嵌套引用的本质是使用一个变量表示另一个变量</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">x := y</span><br><span class="line">y := z</span><br><span class="line">a := $($(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo &quot;a ==&gt; $(a)&quot;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	a ==&gt; z</span><br></pre></td></tr></table></figure>
<h3 id="5）命令行变量"><a href="#5）命令行变量" class="headerlink" title="5）命令行变量"></a>5）命令行变量</h3><p>运行 make 时，在命令行定义变量，命令行变量<font color=dark>默认覆盖 makefile 中定义的变量</font></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">hm := hello makefile</span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo “hm =&gt; $(hm)”</span><br><span class="line"></span><br><span class="line">执行：make hm := cmd</span><br><span class="line"></span><br><span class="line">运行结果：hm =&gt; cmd</span><br></pre></td></tr></table></figure>
<h3 id="6）override-关键字"><a href="#6）override-关键字" class="headerlink" title="6）override 关键字"></a>6）override 关键字</h3><p>用于指示 makefile 中定义的变量<font color=blue>不能被覆盖</font>, 变量的定义和赋值都要用到 override 关键字</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">override var := test</span><br><span class="line"><span class="keyword">test </span>: </span><br><span class="line">	@echo “var =&gt; $(var)”</span><br><span class="line"></span><br><span class="line">执行：make var:=cmd</span><br><span class="line"></span><br><span class="line">执行结果：hm =&gt; test</span><br></pre></td></tr></table></figure>
<h3 id="7）define关键字"><a href="#7）define关键字" class="headerlink" title="7）define关键字"></a>7）define关键字</h3><p>用于在 makefile 中定义多行变量, 多行变量的定义从变量名开始到 endef 结束, 可以使用 override 关键字防止变量被覆盖, define 定义的变量<font color=purple>等价于</font>使用 = 定义的变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">define foo</span><br><span class="line">I’m fool:</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">override define <span class="keyword">cmd</span></span><br><span class="line"><span class="bash">@<span class="built_in">echo</span> <span class="string">&quot;run cmd begin ...&quot;</span></span></span><br><span class="line">@echo <span class="string">&quot;run cmd end ...&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	@echo <span class="string">&quot;$(foo)&quot;</span></span><br><span class="line">	$(<span class="keyword">cmd</span><span class="bash">)</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	I’m fool:</span><br><span class="line">	<span class="keyword">run</span><span class="bash"> cmd begin ...</span></span><br><span class="line">	<span class="keyword">run</span><span class="bash"> cmd end ...</span></span><br></pre></td></tr></table></figure>
<h2 id="2、环境变量（全局变量）"><a href="#2、环境变量（全局变量）" class="headerlink" title="2、环境变量（全局变量）"></a>2、环境变量（全局变量）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;makefile 中能够直接使用环境变量的值，<font color=red>定义了同名变量</font>，默认环境变量将被覆盖。运行 make 时<font color=blue>指定 “-e” 选项</font>使用系统默认环境变量。环境变量可以在所有的 makefile 中使用，过多的依赖环境变量会使系统的移植性降低。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;变量在不同的 makefile 中的传递方式有三种：<font color=purple>直接在外部定义环境变量进行传递</font>、使用 <font color=brown>export</font> 定义变量进行传递(定义临时环境变量)、定义 make <font color=dark>命令行变量进行传递</font>(推荐)。</p>
<p>编程实验, makefile 文件如下</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">PWD :<span class="built_in">=</span> pwd                    # 修改系统环境变量</span><br><span class="line">export var :<span class="built_in">=</span> D.T.Software    # 定义临时环境变量</span><br><span class="line">version :<span class="built_in">=</span> v1                 # 普通变量</span><br><span class="line">user :<span class="built_in">=</span>baron                  # 普通变量</span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">    @echo <span class="string">&quot;PWD ==&gt; $(PWD)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;make another file ...&quot;</span></span><br><span class="line">    $(MAKE) -f makefile2</span><br><span class="line">    $(MAKE) -f makefile2 user:<span class="built_in">=</span>$(user)  # 将 user 这个变量通过 make 进行传递</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>makefile2 文件如下</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">test </span>:</span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;PWD ==&gt; $(PWD)&quot;</span></span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;var = $(var)&quot;</span></span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;version = $(version)&quot;</span></span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;user = $(user)&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">PWD ==&gt; <span class="keyword">pwd</span></span><br><span class="line"><span class="keyword">make</span> another <span class="keyword">file</span> ...</span><br><span class="line"><span class="keyword">make</span> -<span class="keyword">f</span> makefile2</span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Entering directory <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line">PWD ==&gt; <span class="keyword">pwd</span></span><br><span class="line">var = D.T.Software</span><br><span class="line"><span class="keyword">version</span> =</span><br><span class="line">user =</span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Leaving directory <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line"><span class="keyword">make</span> -<span class="keyword">f</span> makefile2 user:=baron</span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Entering directory <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br><span class="line">PWD ==&gt; <span class="keyword">pwd</span></span><br><span class="line">var = D.T.Software</span><br><span class="line"><span class="keyword">version</span> =</span><br><span class="line">user = baron</span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Leaving directory <span class="string">&#x27;/home/book/c/mkfile&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、目标变量（局部变量）"><a href="#3、目标变量（局部变量）" class="headerlink" title="3、目标变量（局部变量）"></a>3、目标变量（局部变量）</h2><p>作用域只在<font color=red>指定目标</font>及<font color=purple>连带规则中</font></p>
<p><strong>语法格式</strong></p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">target : <span class="keyword">variable</span><span class="number">_n</span>ame := <span class="keyword">variable</span>-<span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p><strong>举例说明</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">var <span class="symbol">:</span>= D.T.Software</span><br><span class="line">test : var <span class="symbol">:</span>= test-var</span><br><span class="line"></span><br><span class="line">test : test1</span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;test:&quot;</span></span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;var =&gt; $(var)&quot;</span></span><br><span class="line"></span><br><span class="line">test1 <span class="symbol">:</span></span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;test1:&quot;</span></span><br><span class="line">    <span class="variable">@echo</span> <span class="string">&quot;var ==&gt; $(var)&quot;</span></span><br><span class="line"></span><br><span class="line">test2 : </span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;test2:&quot;</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var ==&gt; $(var)&quot;</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">book<span class="variable">@100ask</span><span class="symbol">:~/c/mkfile</span><span class="variable">$ </span>make</span><br><span class="line">test1</span><br><span class="line">var ==&gt; test-var</span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line">var =&gt; test-var</span><br><span class="line">book<span class="variable">@100ask</span><span class="symbol">:~/c/mkfile</span>$</span><br><span class="line">book<span class="variable">@100ask</span><span class="symbol">:~/c/mkfile</span><span class="variable">$ </span>make test2</span><br><span class="line"><span class="symbol">test2:</span></span><br><span class="line">var ==&gt; D.T.Software</span><br></pre></td></tr></table></figure>
<h2 id="4、模式变量（局部变量）"><a href="#4、模式变量（局部变量）" class="headerlink" title="4、模式变量（局部变量）"></a>4、模式变量（局部变量）</h2><p>模式变量是目标变量的扩展，<font color=brown>作用域只在符合模式的目标及连带规则中</font></p>
<p><strong>语法格式</strong></p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">%target : <span class="keyword">variable</span><span class="number">_n</span>ame := <span class="keyword">variable</span>-<span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p><strong>举例说明</strong></p>
<p>当前要定义一个名为 new 的局部变量，new 的作用域是所有已 e 结尾的目标及连带规则。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> := TDelphi</span><br><span class="line">%e : <span class="keyword">override</span> <span class="keyword">new</span> := test-<span class="keyword">new</span></span><br><span class="line">rule :</span><br><span class="line">    <span class="keyword">@echo</span> <span class="string">&quot;rule:&quot;</span></span><br><span class="line">    <span class="keyword">@echo</span> <span class="string">&quot;new =&gt; $(new)&quot;</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">rule:</span><br><span class="line"><span class="keyword">new</span> =&gt; test-<span class="keyword">new</span></span><br></pre></td></tr></table></figure>
<h1 id="七、条件判断语句"><a href="#七、条件判断语句" class="headerlink" title="七、条件判断语句"></a><div align=center>七、条件判断语句</h1><h2 id="1、makefile中的条件判断语句"><a href="#1、makefile中的条件判断语句" class="headerlink" title="1、makefile中的条件判断语句"></a>1、makefile中的条件判断语句</h2><p>可以<font color=brown>根据条件值</font>来决定 make 的执行、可以<font color=blue>比较</font>两个不同变量或变量和常量值。基本形式如下：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">ifxxx (arg1,arg2) <span class="meta">#注意括号里面不能使用空格</span></span><br><span class="line"> <span class="meta"># for true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="meta"># for false</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>其他合法形式</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">ifxxx <span class="string">&quot;arg1&quot;</span> <span class="string">&quot;arg2&quot;</span></span><br><span class="line">ifxxx <span class="string">&quot;arg1&quot;</span> &#x27;arg2&#x27;</span><br><span class="line">ifxxx &#x27;arg1&#x27; <span class="string">&quot;arg2&quot;</span></span><br><span class="line">ifxxx &#x27;arg1&#x27; <span class="string">&quot;arg2&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、条件判断关键字"><a href="#2、条件判断关键字" class="headerlink" title="2、条件判断关键字"></a>2、条件判断关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq  ($(x),$(y))</td>
<td>判断参数是否相等，相等为 true ，否则为 false</td>
</tr>
<tr>
<td>ifneq ($(x),$(y))</td>
<td>判断参数是否不相等，不相等则为 true，否则为false</td>
</tr>
<tr>
<td>ifdef  x</td>
<td>判断变量是否有值，有值为 true，否则为false</td>
</tr>
<tr>
<td>ifndef x</td>
<td>判断变量是否没有值，没有为 true，否则为false</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：条件判断语句只能用与控制 make 中实际执行的语句；但是，不能控制规则中命令的执行过程。</p>
</blockquote>
<h2 id="3、工程使用小结"><a href="#3、工程使用小结" class="headerlink" title="3、工程使用小结"></a>3、工程使用小结</h2><ul>
<li>条件判断语句之前可以有空格，<font color=red>但不能有tab字符 (‘t&#39;)</font></li>
<li>在条件判断语句中<font color=blue>不要用自动变量</font> ($@,$^,$&lt;)</li>
<li>一条完整的条件语句<font color=purple>必须</font>位于同一个 makefile 中</li>
<li>条件判断类似于 c 语言中的宏，<font color=brown>预处理阶段有效，执行阶段无效</font></li>
<li>make 在加载 makefile 时首先计算表达式的值（<font color=green>赋值方式不同计算方式不同</font>）,根据判断语句的表达式决定执行的内容</li>
</ul>
<h2 id="5、举例说明"><a href="#5、举例说明" class="headerlink" title="5、举例说明"></a>5、举例说明</h2><h3 id="1）条件判断关键字程序实例"><a href="#1）条件判断关键字程序实例" class="headerlink" title="1）条件判断关键字程序实例"></a>1）条件判断关键字程序实例</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">.PHONY : test  </span><br><span class="line">	  </span><br><span class="line">var1 := cmd</span><br><span class="line">var2 := $(var1)</span><br><span class="line"></span><br><span class="line">test:  </span><br><span class="line">    ife<span class="string">q ($(var1)</span>,$(var2)) <span class="comment"># 注意最前面不是 table 隔开是 4 个空格</span></span><br><span class="line">	@echo <span class="string">&quot;var1 == var2&quot;</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">	@echo <span class="string">&quot;var1 != var2&quot;</span></span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">    ifne<span class="string">q ($(var1)</span>,$(var2))</span><br><span class="line">	@echo <span class="string">&quot;var1 != var2&quot;</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">	@echo <span class="string">&quot;var1 == var2&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    ifdef var1</span><br><span class="line">	@echo <span class="string">&quot;var1 is NOT empty&quot;</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	@echo <span class="string">&quot;var1 is empty&quot;</span></span><br><span class="line">    endif</span><br><span class="line">	</span><br><span class="line">    ifndef var1</span><br><span class="line">	@echo <span class="string">&quot;var1 is empty&quot;</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	@echo <span class="string">&quot;var1 is NOT empty&quot;</span></span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var1 == var2</span><br><span class="line">	var1 == var2</span><br><span class="line">	var1 is NOT empty</span><br><span class="line">	var1 is NOT empty</span><br></pre></td></tr></table></figure>
<h3 id="2）条件判断关键字异常分析"><a href="#2）条件判断关键字异常分析" class="headerlink" title="2）条件判断关键字异常分析"></a>2）条件判断关键字异常分析</h3><h4 id="a）异常情况1"><a href="#a）异常情况1" class="headerlink" title="a）异常情况1"></a>a）异常情况1</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(</span>var3)</span><br><span class="line"></span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var3</span> </span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var4</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is defined&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is NOT defined&quot;</span>    </span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var3 is NOT <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br><span class="line">	var4 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br></pre></td></tr></table></figure>
<p><strong>运行结果分析</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们所期望的运行结果是 var3 与 var4 都是未定义，但这里运行结果表示 var4 的值为定义。</p>
<p><strong>原因分析</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;产生这个结果的原因就是，make 在加载 makefile 时首先计算表达式的值，由于我们使用的赋值表达式为 = 因此，makfile 在预处理 ifdef var4 时无法确定 var4 的值是否定义，因此 make 解释器在这里默认为 var4 的值为已定义的值。</p>
<h4 id="b）异常情况2"><a href="#b）异常情况2" class="headerlink" title="b）异常情况2"></a>b）异常情况2</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(</span>var3)</span><br><span class="line"></span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var3</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var4</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">var3 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var3 is NOT <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br><span class="line">	var4 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br></pre></td></tr></table></figure>
<h4 id="c）异常情况3"><a href="#c）异常情况3" class="headerlink" title="c）异常情况3"></a>c）异常情况3</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(</span>var3)</span><br><span class="line">var3 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var3</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span><span class="function"><span class="keyword">def</span> <span class="title">var4</span></span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;var4 is NOT defined&quot;</span></span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	var3 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br><span class="line">	var4 is <span class="function"><span class="keyword">def</span><span class="title">ined</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：a为不对 var3 赋值, b、c 为 var 赋值的位置不同产生的结果不同</p>
</blockquote>
<h1 id="八、函数的定义以及调用"><a href="#八、函数的定义以及调用" class="headerlink" title="八、函数的定义以及调用"></a><div align=center>八、函数的定义以及调用</h1><h2 id="1、makefile-支持函数的概念"><a href="#1、makefile-支持函数的概念" class="headerlink" title="1、makefile 支持函数的概念"></a>1、makefile 支持函数的概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;make 解释器<font color=purple>提供了一系列的函数</font>供 makefile 调用。在 makefile 中<font color=dark>支持自定义函数实现</font>，并调用执行。通过 <font color=blue>define</font> 关键字实现自定义函数</p>
<h2 id="2、自定义函数语法"><a href="#2、自定义函数语法" class="headerlink" title="2、自定义函数语法"></a>2、自定义函数语法</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">define func1</span><br><span class="line">	<span class="meta">@echo</span> “My name <span class="keyword">is</span> $(<span class="number">0</span>)”</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define func2</span><br><span class="line">	<span class="meta">@echo</span> “My name <span class="keyword">is</span> $(<span class="number">0</span>)”</span><br><span class="line">	<span class="meta">@echo</span> “Param =&gt; $(<span class="number">1</span>)”</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>函数调用：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test </span>: </span><br><span class="line">	$(call func1)</span><br><span class="line">	$(call func2,D.T.Software)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数通过call关键字调用，$(0)、$(1)、$(3)、…代表依次传入的参数</p>
</blockquote>
<h2 id="3、深入理解自定义函数"><a href="#3、深入理解自定义函数" class="headerlink" title="3、深入理解自定义函数"></a>3、深入理解自定义函数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;自定义函数是<font color=red>一个多行变量</font>，无法直接调用。自定义函数是一个<font color=blue>过程调用</font>，没有任何返回值。自定义函数<font color=brown>用于定义命令集合</font>，并应用于规则中</p>
<h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4. 实例分析"></a>4. 实例分析</h2><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">define func1</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define func2</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; $(1)&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	$(func1)</span><br><span class="line">	$(func2)</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	$(<span class="built_in">call</span> func1)</span><br><span class="line">	$(<span class="built_in">call</span> func2, Delphi)</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	My <span class="built_in">name</span> is </span><br><span class="line">	My <span class="built_in">name</span> is </span><br><span class="line">	<span class="built_in">Param</span> =&gt; </span><br><span class="line">	</span><br><span class="line">	My <span class="built_in">name</span> is func1</span><br><span class="line">	My <span class="built_in">name</span> is func2</span><br><span class="line">	<span class="built_in">Param</span> =&gt;  Delphi</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;函数调用的本质就是宏替换的过程，<font color=red>通过 call 可以将相应的 “形参” 替换成 “实参” </font> $(0)、$(1)、$(3)、…，因此上述代码在运行的时候等价于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">define func1</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is <span class="subst">$(0)</span>&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define func2</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is <span class="subst">$(0)</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; <span class="subst">$(1)</span>&quot;</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">.PHONY : <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> :</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is func1&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;My name is func2&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;Param =&gt; Delphi&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="九、变量与函数的综合示例"><a href="#九、变量与函数的综合示例" class="headerlink" title="九、变量与函数的综合示例"></a><div align=center>九、变量与函数的综合示例</h1><h2 id="1、实战需求"><a href="#1、实战需求" class="headerlink" title="1、实战需求"></a>1、实战需求</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=dark>自动生成 target 文件夹</font>存放可执行文件, <font color=blue>自动生成 bojs 文件夹</font>存放编译生成的目标文件（*.o），支持<font color=purple>调试版本</font>的编译选项，考虑代码的扩展性</p>
<h2 id="2、工具原料"><a href="#2、工具原料" class="headerlink" title="2、工具原料"></a>2、工具原料</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">wildcard</span> <span class="params">_pattern</span>)</span></span><br></pre></td></tr></table></figure>
<p>获取当前工作目录中满足 _pattern 的文件或目录列表</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">addprefix</span> <span class="params">_prefix</span>, <span class="params">_names</span>)</span></span><br></pre></td></tr></table></figure>
<p>给名字列表 _name 中的每一个名字增加前缀 _prefix </p>
<h2 id="3、关键技巧"><a href="#3、关键技巧" class="headerlink" title="3、关键技巧"></a>3、关键技巧</h2><ul>
<li><strong>1) 自动获取当前目录小的文件列表（函数调用）</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>2) 根据源文件列表生成目标文件列表（变量的值替换）</strong></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">OBJS :</span>= $(<span class="attr">SRCS:</span>.c=.o)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3) 对每个目标文件加上前缀路径（函数调用）</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> apth/,<span class="variable">$(OBJS)</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="4、编译规则的依赖"><a href="#4、编译规则的依赖" class="headerlink" title="4、编译规则的依赖"></a>4、编译规则的依赖</h2><img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/1.png" >

<h2 id="5-编程实现"><a href="#5-编程实现" class="headerlink" title="5. 编程实现"></a>5. 编程实现</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line">MKDIR := mkdir</span><br><span class="line"></span><br><span class="line">DIR_OBJS := objs</span><br><span class="line">DIR_TARGETS := target</span><br><span class="line"></span><br><span class="line">DIR := <span class="variable">$(DIR_OBJS)</span> <span class="variable">$(DIR_TARGETS)</span></span><br><span class="line"></span><br><span class="line">TARGET := <span class="variable">$(DIR_TARGETS)</span>/hello.out</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_OBJS)</span>/,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line">.PHONY := rebuild clean all</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(DIR)</span> <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line">    @echo <span class="string">&quot;Target File ==&gt; <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR)</span> :</span><br><span class="line">    <span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OBJS)</span>/%.o : %.c</span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -g -c <span class="variable">$^</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$^</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(DIR)</span></span><br><span class="line"></span><br><span class="line">rebuild : clean all</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在当前目录下创建 objs target 文件，编译链接当前目录下 .c 文件，将生成的 .o 文件存放到 objs 文件夹，生成的可执行文件 app.out 存放在 target 文件夹，最后运行可执行程序 app.out 。其中当 DEBUG=true 时添加编译选项 -g 实现调试功能</p>
<h1 id="十、include-关键字"><a href="#十、include-关键字" class="headerlink" title=" 十、include 关键字"></a><div align=center> 十、include 关键字</h1><h2 id="1-include-关键字的处理方式"><a href="#1-include-关键字的处理方式" class="headerlink" title="1. include 关键字的处理方式"></a>1. include 关键字的处理方式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在当前目录搜索或指定目录搜索目标文件</p>
<h3 id="1）搜索成功"><a href="#1）搜索成功" class="headerlink" title="1）搜索成功"></a>1）搜索成功</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;类似于 c 语言中 include 关键字，<font color=blue>将文件内容直接搬到</font> makefile 中, 编程实验如下</p>
<p>test.txt 文件中的内容</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">test </span>:</span><br><span class="line">	<span class="variable">@echo</span> <span class="string">&quot;this is test&quot;</span></span><br></pre></td></tr></table></figure>
<p>makefile 内容</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">.PHONY : <span class="keyword">all</span> clean</span><br><span class="line"></span><br><span class="line">include test.txt </span><br><span class="line"> </span><br><span class="line"><span class="keyword">all</span> :</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;this is all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">make</span> <span class="keyword">all</span> 运行结果：</span><br><span class="line">	this <span class="keyword">is</span> test</span><br></pre></td></tr></table></figure>
<h3 id="2）搜索失败"><a href="#2）搜索失败" class="headerlink" title="2）搜索失败"></a>2）搜索失败</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;产生警告，以<font color=dark>文件作为目标查找并执行相应规则</font>，当文件名对应的规则不存在时，最终产生错误</p>
<h4 id="a）规则存在"><a href="#a）规则存在" class="headerlink" title="a）规则存在"></a>a）规则存在</h4><p>test.txt 文件不存在</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">include test.txt </span><br><span class="line"> </span><br><span class="line"><span class="keyword">all</span> :</span><br><span class="line">	@echo <span class="string">&quot;this is all&quot;</span></span><br><span class="line"></span><br><span class="line">test.txt :</span><br><span class="line">	@echo <span class="string">&quot;test.txt is not exist&quot;</span></span><br><span class="line"></span><br><span class="line">make <span class="keyword">all</span> 运行结果：</span><br><span class="line">	makefile:<span class="number">2</span>: test.txt: 没有那个文件或目录</span><br><span class="line">	test.txt <span class="keyword">is</span> <span class="keyword">not</span> exist</span><br><span class="line">	this <span class="keyword">is</span> <span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<h4 id="b）规则不存在"><a href="#b）规则不存在" class="headerlink" title="b）规则不存在"></a>b）规则不存在</h4><p>test.txt 文件不存在</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">include</span> <span class="selector-tag">test</span><span class="selector-class">.txt</span> </span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">all</span> :</span><br><span class="line">	<span class="keyword">@echo</span> <span class="string">&quot;this is all&quot;</span></span><br><span class="line"></span><br><span class="line">make all 运行结果：</span><br><span class="line">	<span class="attribute">makefile:</span><span class="number">2</span>: test.<span class="attribute">txt:</span> 没有那个文件或目录</span><br><span class="line">	<span class="attribute">make:</span> *** 没有规则可以创建目标“test.txt”。 停止。</span><br></pre></td></tr></table></figure>
<h2 id="2-include关键字使用总结"><a href="#2-include关键字使用总结" class="headerlink" title="2. include关键字使用总结"></a>2. include关键字使用总结</h2><h3 id="1）当目标文件不存在"><a href="#1）当目标文件不存在" class="headerlink" title="1）当目标文件不存在"></a>1）当目标文件不存在</h3><img src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/3.png" >

<h3 id="2）当目标文件存在"><a href="#2）当目标文件存在" class="headerlink" title="2）当目标文件存在"></a>2）当目标文件存在</h3><img src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/4.png" >

<h3 id="3-减号-的使用"><a href="#3-减号-的使用" class="headerlink" title="3) 减号 - 的使用"></a>3) 减号 - 的使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;使用减号 - 不但关闭了 include 发出的警告，同时关闭了错误；<font color=red>当错误发生时 make 将忽略这些错误</font>。</p>
<h1 id="十一、自动生成依赖关系"><a href="#十一、自动生成依赖关系" class="headerlink" title="十一、自动生成依赖关系"></a><div align=center>十一、自动生成依赖关系</h1><h2 id="1、编译行为带来的缺陷"><a href="#1、编译行为带来的缺陷" class="headerlink" title="1、编译行为带来的缺陷"></a>1、编译行为带来的缺陷</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;预处理器直接将头文件中的代码直接插入源文件，编译器只通过预处理后的源文件产生目标文件，因此，规则中<font color = red>以源文件为依赖，修改头文件后，命令可能无法执行</font></p>
<h2 id="2-、解决方案"><a href="#2-、解决方案" class="headerlink" title="2.、解决方案"></a>2.、解决方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=blue>可以将头文件作为依赖条件出现于每一个目标对应的规则中</font>，当头文件改动，<font color = brown>任何源文件都将被重新编译</font>（编译低效），但是这种方案当项目中头文件数量巨大时，<font color=green>makefile 将很难维护</font></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于上述方案存在的缺陷，思考是否可以<font color=dark>自动生成</font>依赖解决,通过命令<font color=purple>自动生成</font>对头文件的依赖，将生成的依赖<font color=blue>自动包含</font>进 makefile 中，当头文件改动后，自动确认需要重新编译的文件。</p>
<h2 id="3、预备知识"><a href="#3、预备知识" class="headerlink" title="3、预备知识"></a>3、预备知识</h2><p>自动生成依赖文件需要一些预备知识</p>
<h3 id="1-sed-流编辑器"><a href="#1-sed-流编辑器" class="headerlink" title="1) sed 流编辑器"></a>1) sed 流编辑器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;sed 是一个流编辑器，用于流文本的修改（增/删/查/改），sed 可以用于流文本中的字符串替换，sed 字符串替换方式为：<font color=dark>sed ‘s:src:des:g’</font>。sed 字符串替换实例如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line"><span class="keyword">test </span>:</span><br><span class="line">	@echo &quot;test = &gt; abc+abc=abc&quot; | sed &#x27;s:abc:xyz:g&#x27;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	test =&gt; xyz+xyz=xyz</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp; sed 还支持正则表达式，在 sed 中可以用正则表达式匹配替换目标，并且可以使用匹配的目标生成替换结果</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">sed &#x27;s,<span class="symbol">\(</span>.*<span class="symbol">\)</span><span class="symbol">\.</span>o[ :]*,objs/<span class="symbol">\1</span>.o : ,g&#x27;</span><br></pre></td></tr></table></figure>
<p>该表达式的结果为将流文本中的.o文件加上路径前缀 objs/</p>
<h3 id="2-gcc-关键编译选项"><a href="#2-gcc-关键编译选项" class="headerlink" title="2) gcc 关键编译选项"></a>2) gcc 关键编译选项</h3><p>获取目标的完整依赖关系，即包含 “” 和 &lt;&gt; 两者的头文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -M <span class="keyword">test</span>.c</span><br></pre></td></tr></table></figure>
<pre><code>获取目标的部分依赖关系，即用 &quot;&quot; 包含的头文件</code></pre>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gcc -MM <span class="keyword">test</span>.c</span><br></pre></td></tr></table></figure>
<h3 id="3-拆分目标的依赖"><a href="#3-拆分目标的依赖" class="headerlink" title="3) 拆分目标的依赖"></a>3) 拆分目标的依赖</h3><p>将目标的完整依赖拆分为多个部分依赖</p>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/2.png" >

<h3 id="4-make-中的命令执行机制"><a href="#4-make-中的命令执行机制" class="headerlink" title="4) make 中的命令执行机制"></a>4) make 中的命令执行机制</h3><p>规则中的每个命令默认是在一个新的进程中执行（shell）</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	<span class="keyword">mkdir</span> <span class="keyword">test</span></span><br><span class="line">	<span class="keyword">cd</span> <span class="keyword">test</span> </span><br><span class="line">	<span class="keyword">mkdir</span> subtest</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>运行结果</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;期待的运行结果为，创建一个文件夹 test，在 test 中创建子文件夹 subtest，但实际运行结果为在当前目录下创建出两个文件夹分别为 test 和 subtest</p>
</li>
<li><p><strong>运行结果分析</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;make 创建一个进程执行 mkdir test，执行完后进程结束，回到当前目录。make 又创建一个进程执行 cd test，执行完后进程结束，回到当前目录。make 再次创建一个进程执行 mkdir subtest，执行完后进程结束，回到当前目录。因此最终结果在当前目录下创建两个文件夹 test 和 subtest。</p>
</li>
<li><p><strong>解决方案</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;set-e 指定发生错误后立即退出执行。可以通过分号 ; 和接续符 \ 将多个命令组合成一个命令。组合的命令一次在同一个进程中被执行，无论是否出错。</p>
</li>
<li><p><strong>代码修改</strong></p>
</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	<span class="keyword">set</span> -<span class="keyword">e</span>; \</span><br><span class="line">	<span class="keyword">mkdir</span> <span class="keyword">test</span>; \</span><br><span class="line">	<span class="keyword">cd</span> <span class="keyword">test</span>; \</span><br><span class="line">	<span class="keyword">mkdir</span> subtest</span><br></pre></td></tr></table></figure>
<h2 id="4、自动生成依赖关系"><a href="#4、自动生成依赖关系" class="headerlink" title="4、自动生成依赖关系"></a>4、自动生成依赖关系</h2><h3 id="1）自动生成依赖文件"><a href="#1）自动生成依赖文件" class="headerlink" title="1）自动生成依赖文件"></a>1）自动生成依赖文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过 include 指令包含所有的 .dep 依赖文件，当 .dep 依赖文件不存在时，使用规则自动生成</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line">MKDIR := mkdir</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">DEPS := $(SRCS:.c=.dep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	@echo all</span><br><span class="line"></span><br><span class="line">%.dep : %.c</span><br><span class="line">	@echo <span class="string">&quot;Creating <span class="variable">$@</span>...&quot;</span></span><br><span class="line">	set -e;\</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$^</span> | sed &#x27;s,\(.*\)\.o[ :]*,objs/\1.o : ,g&#x27; &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> *.dep</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	Creating func.dep ...</span><br><span class="line">	Creating main.dep ...</span><br><span class="line">	make: Nothing to be done for &#x27;objs/main.o&#x27;.</span><br></pre></td></tr></table></figure>
<h3 id="2-集中管理-dep-文件"><a href="#2-集中管理-dep-文件" class="headerlink" title="2) 集中管理 .dep 文件"></a>2) 集中管理 .dep 文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当 include 发现 .dep 文件不存在，<font color=dark>通过规则和命令创建 deps 文件夹</font>，<font color=blue>将所有的 .dep 文件创建到 deps 文件夹</font>，<font color=purple>.dep 文件中记录目标文件的依赖关系</font></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -fr</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">DIR_DEPS := deps</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">DEPS := $(SRCS:.c=.dep)</span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_DEPS)</span>/,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">	@echo <span class="string">&quot;all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>:</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>/%.dep : <span class="variable">$(DIR_DEPS)</span> %.c</span><br><span class="line">	@echo <span class="string">&quot;Creating <span class="variable">$@</span> ...&quot;</span></span><br><span class="line">	@set -e; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM -E <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$^</span>)</span> | sed &#x27;s,\(.*\)\.o[ :]*,objs/\1.o : ,g&#x27; &gt; <span class="variable">$@</span></span><br><span class="line">	 </span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_DEPS)</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">	mkdir deps</span><br><span class="line">	Creating deps/sub.dep ...</span><br><span class="line">	Creating deps/add.dep ...</span><br><span class="line">	Creating deps/a.dep ...</span><br><span class="line">	Creating deps/sub.dep ...</span><br><span class="line">	all	</span><br></pre></td></tr></table></figure>
<h3 id="3-一些-dep-文件会被重复创建多次"><a href="#3-一些-dep-文件会被重复创建多次" class="headerlink" title="3) 一些 .dep 文件会被重复创建多次"></a>3) 一些 .dep 文件会被重复创建多次</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;deps 文件夹的时间属性会因为依赖文件创建而发生改变，make 发现 deps 文件夹比对应的目标更新，触发相应规则的重新解析和命令的执行</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决方案</strong>,添加宏代码块进行判断，当不存在 deps 文件添加文件依赖关系，否则取消文件依赖关系</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">ifeq ($(wildcard $(DIR_DEPS)), )</span><br><span class="line">$(DIR_DEPS)/%.dep : $(DIR_DEPS) %.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">$(DIR_DEPS)/%.dep : %.c</span><br></pre></td></tr></table></figure>
<h3 id="4-自动生成依赖的最终实现"><a href="#4-自动生成依赖的最终实现" class="headerlink" title="4) 自动生成依赖的最终实现"></a>4) 自动生成依赖的最终实现</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -fr</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">DIR_DEPS := deps</span><br><span class="line">DIR_OBJS := objs</span><br><span class="line">DIR_EXE  := exes</span><br><span class="line">DIRS := <span class="variable">$(DIR_OBJS)</span> <span class="variable">$(DIR_EXE)</span></span><br><span class="line"></span><br><span class="line">APP = <span class="variable">$(DIR_EXE)</span>/app.out</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">DEPS := $(SRCS:.c=.dep)</span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_DEPS)</span>/,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_OBJS)</span>/,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line">	</span><br><span class="line">all : <span class="variable">$(APP)</span></span><br><span class="line">	./<span class="variable">$(APP)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span> : <span class="variable">$(DIRS)</span> <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;target ==&gt; <span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIRS)</span> :</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OBJS)</span>/%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$^</span>)</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>,<span class="string">&quot;all&quot;</span>)</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>:</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_DEPS)</span>)</span>, )</span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>/%.dep : <span class="variable">$(DIR_DEPS)</span> %.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="variable">$(DIR_DEPS)</span>/%.dep : %.c</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">	@echo <span class="string">&quot;Creating <span class="variable">$@</span> ...&quot;</span></span><br><span class="line">	@set -e; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM -E <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$^</span>)</span> | sed &#x27;s,\(.*\)\.o[ :]*,objs/\1.o : ,g&#x27; &gt; <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_DEPS)</span> <span class="variable">$(DIRS)</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;代码存在问题，当头文件中包含其他头文件时可能出现修改头文件，make 无法执行的情况。解决方案，将依赖文件名，作为目标加入自动生成的依赖关系中，通过 include 加载依赖文件时判断是否执行规则，在规则执行时重新生成依赖关系文件，最后加载新的依赖文件。即修改上述代码 52 行,在冒号前加入 $@</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">$(CC) -MM -E $(<span class="keyword">filter</span> %.c, $^) | sed <span class="string">&#x27;s,\(.*\)\.o[ :]*,objs/\1.o $@: ,g&#x27;</span> &gt; $@</span><br></pre></td></tr></table></figure>
<h1 id="十二、make-的隐式规则"><a href="#十二、make-的隐式规则" class="headerlink" title="十二、make 的隐式规则"></a><div align=center>十二、make 的隐式规则</h1><h2 id="1、makfile-中出现同名目标时"><a href="#1、makfile-中出现同名目标时" class="headerlink" title="1、makfile 中出现同名目标时"></a>1、makfile 中出现同名目标时</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=red>所有的依赖合并在一起，成为目标的最终依赖</font>。当多处出现同一目标命令时，make 发出警告。<font color=purple>所有之前定义的命令被最后定义的命令取代.</font></p>
<blockquote>
<p>注意事项：<br>当使用 include 关键字包含其他文件时，<font color=brown>需要确保被包含文件中的同名目标只有依赖</font>，<font color=blue>没有命令否则</font>，同名文件将被覆盖！</p>
</blockquote>
<h2 id="2、隐式规则"><a href="#2、隐式规则" class="headerlink" title="2、隐式规则"></a>2、隐式规则</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=green>make 提供了一些常用的，预定义的规则实现</font>。make 提供了生成目标文件的隐式规则，隐式规则会使用预定义变量完成编译工作，改变预定义变量将部分改变隐式规则的行为，当存在自定义规则时，不在使用隐式规则，当相应目标的规则未提供时，make 尝试使用隐式规则。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">app.out : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$^</span></span><br><span class="line">    @echo <span class="string">&quot;Target ==&gt; <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">运行结果:</span></span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o func.o func.c</span><br><span class="line">cc -o app.out main.o func.o</span><br><span class="line">rm -f main.o func.o</span><br><span class="line">Target ==&gt; app.out</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 上述 makefile 没有 $(OBJS) 的规则，为什么能正常运行，就是因为 make 的标准库中提供了对应的规则，当 make 发现目标的依赖不存在时，尝试通过依赖名逐一查找隐式规则，并且通过依赖名推到可能需要的源文件。最后根据文件后缀自动推导编译命令。</p>
<h2 id="3、隐式规则的副作用"><a href="#3、隐式规则的副作用" class="headerlink" title="3、隐式规则的副作用"></a>3、隐式规则的副作用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color=dark>编译行为难以控制</font>，大量使用隐式规则可能产生意想不到的编译行为。<font color=purple>编译效率低下</font>，make 从隐式规则和自定义规则中选择最终使用的规则。<font color=blue>隐式规则链</font>，当依赖目标存在时，make 会极力组合各种隐式规则对目标进行创建，进而产生意料之外的编译行为！查看隐式规则的方式如下。</p>
<p>查看所有规则</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make -p</span></span><br></pre></td></tr></table></figure>
<p>查看具体规则</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">make</span> -<span class="keyword">p</span> | <span class="keyword">grep</span> <span class="string">&quot;XXX&quot;</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;除此之外还可以使用前面提到的 .VARIABLES 预定义变量查看 make 的自定义变量。我们可以通过下面方式禁用隐式规则。<font color=dark>在 makefile 中自定义规则</font>，<font color=brown>在 makefile 中自定义模式（如：%.o : %.c）</font>，<font color=blue>全局禁用：make -r</font>。</p>
<h2 id="4、后缀规则"><a href="#4、后缀规则" class="headerlink" title="4、后缀规则"></a>4、后缀规则</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;后缀规则是旧式的“模式规则”，可以通过后缀描述的方式自定义规则</p>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/5.png">

<p>&nbsp;&nbsp;&nbsp;&nbsp;双后缀规则，定义一对文件后缀（依赖文件后缀和目标文件后缀）</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">.cpp.o</span> &lt;==&gt; %<span class="string">.o</span> : %<span class="string">.cpp</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;单后缀规则，定义单个后缀文件（源文件后缀）</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">.c  &lt;==&gt; <span class="meta">%</span> : <span class="meta">%</span>.c</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;后缀规则需要注意，后缀规则中<font color=red>不允许有依赖</font>。后缀规则<font color=brown>必须有命令</font>，否则无意义。后缀规则将逐步被模式规则取代。</p>
<h1 id="十三、makefile-中的路径搜索"><a href="#十三、makefile-中的路径搜索" class="headerlink" title="十三、makefile 中的路径搜索"></a><div align=center>十三、makefile 中的路径搜索</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;项目中的 makefile <font color=red>必须能够正确的定位源文件和依赖文件</font>，最终编译生成可执行程序。常用的源代码管理方式如下</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">Project</span><br><span class="line">   |</span><br><span class="line"><span class="string">   </span>|</span><br><span class="line">   |<span class="string">---------&gt;Module1</span></span><br><span class="line"><span class="string">   </span>|<span class="string">             </span>|</span><br><span class="line">   |<span class="string">             </span>|<span class="string">---------&gt;inc</span></span><br><span class="line"><span class="string">   </span>|<span class="string">             </span>|</span><br><span class="line">   |<span class="string">             </span>|<span class="string">---------&gt;src</span></span><br><span class="line"><span class="string">   </span>|</span><br><span class="line">   |<span class="string">---------&gt;Module2</span></span><br><span class="line"><span class="string">                </span>|</span><br><span class="line">                |<span class="string">---------&gt;inc</span></span><br><span class="line"><span class="string">                </span>|</span><br><span class="line">                |<span class="string">---------&gt;src</span></span><br></pre></td></tr></table></figure>
<h2 id="1、特殊的预定义变量-VPATH（全大写）"><a href="#1、特殊的预定义变量-VPATH（全大写）" class="headerlink" title="1、特殊的预定义变量 VPATH（全大写）"></a>1、特殊的预定义变量 VPATH（全大写）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;VPATH 变量的值用于<font color=dark>指示 make 如何查找文件</font>，<font color=blue>不同文件夹可作为 VPATH 的值同时出现</font>，<font color=brown>文件夹的名字需要使用分隔符进行区分</font></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">VPATH :</span>= inc src （空格）</span><br><span class="line"><span class="attr">VPATH :</span>= inc;src （分号）</span><br><span class="line"><span class="attr">VPATH :</span>= <span class="attr">inc:</span>src （冒号）</span><br></pre></td></tr></table></figure>
<h3 id="1）make-对于-VAPATH-值得处理方式"><a href="#1）make-对于-VAPATH-值得处理方式" class="headerlink" title="1）make 对于 VAPATH 值得处理方式"></a>1）make 对于 VAPATH 值得处理方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当前文件夹找不到需要的文件时，VPATH会被使用，<font color=green>make 会在 VPATH 指定的文件夹中依次搜索文件</font>，当多个文件夹存在同名文件时，<font color=purple>选择第一次搜索到的文件</font></p>
<blockquote>
<p><strong>注意事项：</strong><br>   VPATH 只能决定 make 的搜索路径，无法决定命令的搜索路径<br>   <font color=red>对于特定的编译命令（gcc），需要独立指定编译搜索路径</font><br>   <strong>语法：gcc -I include-path</strong></p>
</blockquote>
<h3 id="2）VAPATH-使用实例"><a href="#2）VAPATH-使用实例" class="headerlink" title="2）VAPATH 使用实例"></a>2）VAPATH 使用实例</h3><p>.c 文件存放于 src 文件夹，.o 文件存放于 inc 文件夹，make 自动搜索相关路径生成可执行文件 app.out</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">APP := app.out</span><br><span class="line"></span><br><span class="line">DIR_INC := inc</span><br><span class="line">DIR_SRC := src</span><br><span class="line"></span><br><span class="line">VPATH := inc src</span><br><span class="line"></span><br><span class="line">CFLAGS := -I<span class="variable">$(DIR_INC)</span></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(APP)</span> </span><br><span class="line">	@echo <span class="string">&quot;target ==&gt; <span class="variable">$(APP)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span> : a.o sub.o add.o</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line">	</span><br><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> *.o *.out</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于当多个文件夹存在同名文件时，选择第一次搜索到的文件这也会带来问题, 当 inc 文件意外出现源文件（c/cpp文件），那可能出现编译错误！可以使用 <font color=blue>vpath</font> 为不同类型的文件指定不同的搜索路径。</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">vpath</span> <span class="built_in">Pattern</span> <span class="built_in">Directory</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在 Directory 下搜索符合 Pattern 的规则文件，将上述 VPATH 修改为 vpath</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vpath %</span>.h inc</span><br><span class="line"><span class="built_in">vpath %</span>.c src</span><br></pre></td></tr></table></figure>
<h2 id="2、取消搜索规则"><a href="#2、取消搜索规则" class="headerlink" title="2、取消搜索规则"></a>2、取消搜索规则</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;取消已经设置的某个搜索规则</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">vpath <span class="built_in">Pattern</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;示例</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">vpath %.h <span class="keyword">inc</span>  <span class="meta"># 在 inc 中搜索 .h 文件</span></span><br><span class="line">Vpath %h       <span class="meta"># 不在 inc 中搜索 .h 文件</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;取消所有已经设置的规则</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vpath</span></span><br></pre></td></tr></table></figure>
<h2 id="3、问题分析"><a href="#3、问题分析" class="headerlink" title="3、问题分析"></a>3、问题分析</h2><ul>
<li><p><strong>当 VPATH 和 vpath 关键字同时出现，make 会如何处理？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;make 首先在当前文件夹下搜索需要的文件，如果失败: make首先在 vpath 提供的路径下寻搜索目标文件。当搜索失败时，转而搜索 VPATH 指定的文件夹</p>
</li>
<li><p><strong>当使用 vpath 对同一个 Pattern 指定多个文件夹时，make 会如何处理？</strong><br>make 首先在当前文件夹搜索需要的文件，如果失败：make 以自上而下的顺序搜索 vpath 指定的文件夹。当找到目标文件，搜索结束</p>
</li>
</ul>
<blockquote>
<p>小贴士：<br>在实际工程开发中优先选择 vpath 关键字预防 make 隐式规则的副作用</p>
</blockquote>
<ul>
<li><strong>通过 VPATH 变量指定搜索路径后，make 如何决定目标文件的最终位置？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;当 app.out 完全不存在，make 在<font color=purple>当前文件夹</font>下创建 app.out。<font color=dark>当 src 文件中存在 app.out</font>，<font color=blue>所有目标依赖的新旧关系不变，make 不会创建 app.out</font>。当依赖文件被更新，make 在<font color=purple>当前文件夹</font>下创建 app.out</li>
</ul>
<blockquote>
<p><strong>解决方案</strong><br>使用 GPATH 特殊变量指定目标文件夹 <font color=red>GPATH := src</font><br>当 app.out 完全不存在,make 默认在当前文件夹创建 app.out。当 app.out 存在于 src，且依赖文件被更新。make 在 src 中创建 app.out</p>
</blockquote>
<h2 id="4、工程建议"><a href="#4、工程建议" class="headerlink" title="4、工程建议"></a>4、工程建议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;尽量使用 vpath 为不同文件指定搜索路径、不要在源代码文件夹中生成目标文件、为编译得到的结果创立独立的文件夹、避免 VTPAH 和 GPATH 特殊变量的使用、只要使用 VPATH 就要考虑是否使用 GPATH</p>
<h2 id="5、路径搜索的综合示例"><a href="#5、路径搜索的综合示例" class="headerlink" title="5、路径搜索的综合示例"></a>5、路径搜索的综合示例</h2><h3 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1) 需求分析"></a>1) 需求分析</h3><ul>
<li>工程项目中<font color=red>不希望</font>源码文件夹在编译过程中被改动（只读文件夹）</li>
<li>在编译时<font color=blue>自动创建文件夹</font>（build）用于存放编译的结果</li>
<li>编译过程能够<font color=purple>自动搜索需要的文件</font></li>
<li>makefile 易于扩展，<font color=brown>能够复用于相同类型的项目</font></li>
<li>支持<font color=green>调试版本</font>的编译选项</li>
</ul>
<img width=800 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/6.png">

<h3 id="2-工具原料"><a href="#2-工具原料" class="headerlink" title="2) 工具原料"></a>2) 工具原料</h3><p>获取 $(DIR) 文件夹中满足 _pattern 的文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR)</span>/_pattern)</span></span><br></pre></td></tr></table></figure>
<p>去除 _names 中每一个文件名的路径前缀</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">notdir</span> <span class="params">_names</span>)</span></span><br></pre></td></tr></table></figure>
<p>将 _text 中符合 _pattern 的部分替换为 replacement</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">patsubst</span> <span class="params">_pattern</span>, <span class="params">replacement</span>, <span class="params">_text</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-关键技巧"><a href="#3-关键技巧" class="headerlink" title="3) 关键技巧"></a>3) 关键技巧</h3><p>自动获取源文件列表（函数调用）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> src/*.c)</span></span><br></pre></td></tr></table></figure>
<p>根据源文件列表生成目标文件列表（变量值的替换）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">OBJS :</span>= $(<span class="attr">SRCS:</span>.c=.o)</span><br></pre></td></tr></table></figure>
<p>替换每一个目标的路径前缀（函数调用）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> src/%,build/%,<span class="variable">$(OBJS)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="4-编程实现"><a href="#4-编程实现" class="headerlink" title="4) 编程实现"></a>4) 编程实现</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line">DIR_INC := inc</span><br><span class="line">DIR_SRC := src</span><br><span class="line">DIR_BUILDS := build</span><br><span class="line"></span><br><span class="line">TYPE_INT := .h</span><br><span class="line">TYPE_SRC := .c</span><br><span class="line">TYPE_OBJ := .o</span><br><span class="line"></span><br><span class="line">DEBUG := </span><br><span class="line"></span><br><span class="line">LFLAGS := </span><br><span class="line">CFLAGS := -I <span class="variable">$(DIR_INC)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">APP := <span class="variable">$(DIR_BUILDS)</span>/app.out</span><br><span class="line"></span><br><span class="line">SCRS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_SRC)</span>/*<span class="variable">$(TYPE_SRC)</span>)</span></span><br><span class="line">OBJS := $(SCRS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_OBJ)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%,<span class="variable">$(DIR_BUILDS)</span>/%,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line">HDRS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_INC)</span>/*<span class="variable">$(TYPE_INC)</span>)</span></span><br><span class="line">HDRS := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(HDRS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_SRC)</span> <span class="variable">$(DIR_SRC)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(DIR_BUILDS)</span> <span class="variable">$(APP)</span> </span><br><span class="line">	./<span class="variable">$(APP)</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIR_BUILDS)</span> :</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;target ==&gt; <span class="variable">$(APP)</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(LFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_BUILDS)</span>/%<span class="variable">$(TYPE_OBJ)</span> : %<span class="variable">$(TYPE_SRC)</span> <span class="variable">$(HDRS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_BUILDS)</span></span><br></pre></td></tr></table></figure>
<h1 id="十四、打造专业的编译环境"><a href="#十四、打造专业的编译环境" class="headerlink" title="十四、打造专业的编译环境"></a><div align=center>十四、打造专业的编译环境</h1><h2 id="1、大型项目目录结构-无第三库"><a href="#1、大型项目目录结构-无第三库" class="headerlink" title="1、大型项目目录结构(无第三库)"></a>1、大型项目目录结构(无第三库)</h2><img width=800 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/7.jpg">

<h2 id="2、需要打造的编译环境"><a href="#2、需要打造的编译环境" class="headerlink" title="2、需要打造的编译环境"></a>2、需要打造的编译环境</h2><ul>
<li>源码文件夹在编译时<font color=red>不希望</font>被改动（只读文件夹）</li>
<li>在编译时<font color = blue>自动创建文件夹</font>（build）用于存放编译结果</li>
<li>编译过程中自动生成依赖关系，<font color=purple>自动搜索需要的文件</font></li>
<li>每个模块可以拥有自己<font color=brown>独立的编译方式</font></li>
<li>支持<font color=green>调试版本</font>的编译选项</li>
</ul>
<h2 id="3、项目架构设计分析"><a href="#3、项目架构设计分析" class="headerlink" title="3、项目架构设计分析"></a>3、项目架构设计分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;项目根据功能被划分为多个不同模块, 每个模块的代码用一个文件夹进行管理,文件夹由 inc, src, makfile 构成。每个模块的对外函数声明统一放置于 common/inc 中，如：common.h xxfunc.h</p>
<h3 id="1）实现阶段分析"><a href="#1）实现阶段分析" class="headerlink" title="1）实现阶段分析"></a>1）实现阶段分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由项目的目录结构将整个 makefile 的实现分为两个阶段编译（Compile）和链接（Link）</p>
<ul>
<li><strong>Compile 阶段将每个文件中的代码编译成静态库文件</strong></li>
</ul>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/8.jpg">

<p>&nbsp;&nbsp;&nbsp;&nbsp;因此 Compile 阶段，我们需要完成可用于各个模块可编译的 makefile 文件，每个模块的编译结果为静态库文件（.a文件）</p>
<ul>
<li><strong>link 阶段将每个模块的静态库文件链接生成最终可执行程序</strong></li>
</ul>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/9.jpg">

<p>&nbsp;&nbsp;&nbsp;&nbsp;因此 link 阶段，我们需要完成整编译个工程的 makefile 文件，调用模块的 makefile 编译生成静态库文件链接所有的静态库文件，最终得到可执行程序</p>
<h4 id="a-Compile-阶段实现"><a href="#a-Compile-阶段实现" class="headerlink" title="a. Compile 阶段实现"></a>a. Compile 阶段实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;关键的实现要点有三个，自动生成依赖关系（gcc -MM），自动搜索需要的文件（vpath），将目标打包为静态库文件（ar crs） 。模块中的 makefile 构成如下。</p>
<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/10.jpg">

<p>&nbsp;&nbsp;&nbsp;&nbsp;编程实现</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">DIR_SRC := src</span><br><span class="line">DIR_INC := inc</span><br><span class="line">DIR_BUILD := /home/book/code/build</span><br><span class="line">DIR_COMMON_INC := /home/book/code/common/inc</span><br><span class="line"></span><br><span class="line">TYPE_INC := .h</span><br><span class="line">TYPE_SRC := .c</span><br><span class="line">TYPE_OBJ := .o</span><br><span class="line">TYPE_DEP := .dep</span><br><span class="line"></span><br><span class="line">AR := ar</span><br><span class="line">ARFLAGS := crs</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -I<span class="variable">$(DIR_INC)</span> -I<span class="variable">$(DIR_COMMON_INC)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">MODULE := <span class="variable">$(<span class="built_in">realpath</span> .)</span>       <span class="comment"># 获取当前路径下的绝对路径</span></span><br><span class="line">MODULE := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(MODULE)</span>)</span></span><br><span class="line"></span><br><span class="line">DIR_OUTPUT := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE)</span>)</span></span><br><span class="line"></span><br><span class="line">OUTPUT := <span class="variable">$(MODULE)</span>.a</span><br><span class="line">OUTPUT := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(OUTPUT)</span>)</span></span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_SRC)</span>/*<span class="variable">$(TYPE_SRC)</span>)</span></span><br><span class="line">OBJS := $(SRCS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_OBJ)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%,<span class="variable">$(DIR_OUTPUT)</span>/%,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line">DEPS := $(SRCS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_DEP)</span>)</span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%, <span class="variable">$(DIR_OUTPUT)</span>/%,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_COMMON_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_SRC)</span> <span class="variable">$(DIR_SRC)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all :  <span class="variable">$(OUTPUT)</span></span><br><span class="line">    @echo <span class="string">&quot;Success! Target ==&gt; <span class="variable">$(OUTPUT)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(AR)</span> <span class="variable">$(ARFLAGS)</span> <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OUTPUT)</span>/%<span class="variable">$(TYPE_OBJ)</span> : %<span class="variable">$(TYPE_SRC)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$(<span class="built_in">filter</span> %<span class="variable">$(TYPE_SRC)</span>,<span class="variable">$^</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OUTPUT)</span>/%<span class="variable">$(TYPE_DEP)</span> : %<span class="variable">$(TYPE_SRC)</span></span><br><span class="line">    @echo <span class="string">&quot;Creating <span class="variable">$@</span> ...&quot;</span></span><br><span class="line">    @set -e; \</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -MM -E <span class="variable">$(<span class="built_in">filter</span> %<span class="variable">$(TYPE_SRC)</span>,<span class="variable">$^</span>)</span> | sed &#x27;s,\(.*\)\.o[ :]*,<span class="variable">$(DIR_OUTPUT)</span>/\1.o <span class="variable">$@</span>: ,g&#x27; &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<h4 id="b-Link-阶段实现"><a href="#b-Link-阶段实现" class="headerlink" title="b. Link 阶段实现"></a>b. Link 阶段实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Link 阶段需要考虑的事情主要有四个，如何自动创建 build 文件夹以及子文件夹？如何进入每个模块进行编译？编译成功后如何链接所有的模块静态库？当前模块中有哪些模块？对于前三个问题比较简单分别是 使用 mkdir 创建 build 文件夹及子文件夹。使用 cd 命令进入模块编译。编译成功后使用 gcc 链接所有模块的静态库文件。需要解决的注意问题是第四个问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在实际的工程里面，项目中各个模块在设计阶段就已经基本确定，因此在在之后的开发过程中不会频繁的随意增加或者减少。因此可以直接<font color = red>定义变量模块名列表（模块变量名）</font>，<font color=brown>利用 shell 的 for 循环遍历模块变量名</font>，<font color = purple>在 for 循环中进入模块文件夹进行编译</font>，<font color=blue>循环结束后链接所有的模块静态库文件</font></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在 makefile 中插入 shell 的 for 循环的方式如下，需要注意的是 makefile 中嵌入 shell 代码时，<font color=dark>如果需要使用 shell 变量的值，必须在变量前面加上 $$ 。</font></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">MODULES := common <span class="string">\</span></span><br><span class="line">           main <span class="string">\</span></span><br><span class="line">           <span class="built_in">module</span></span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">    @for dir <span class="keyword">in</span> $(MODULES);<span class="string">\</span></span><br><span class="line">    <span class="keyword">do</span><span class="string">\</span></span><br><span class="line">        echo $$dir;<span class="string">\</span></span><br><span class="line">    done</span><br><span class="line">    @echo <span class="string">&quot;Compile Success ...&quot;</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;链接时需要注意，gcc 在进行静态库的链接时<font color = blue>必须遵循严格的依赖关系</font></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-o</span> <span class="selector-tag">app</span><span class="selector-class">.out</span> <span class="selector-tag">x</span><span class="selector-class">.a</span> <span class="selector-tag">y</span><span class="selector-class">.a</span> <span class="selector-tag">z</span><span class="selector-class">.a</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中的依赖关系必须为：x.a –&gt; y.a –&gt; z.a ，默认情况下遵循<font color=brown>自左向右的依赖关系</font>。如果不清楚库间的依赖关系，可以<font color=purple>使用 -Xlinker 自动确定依赖关系</font></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gcc -o app<span class="selector-class">.out</span> -Xlinker <span class="string">&quot;-(&quot;</span> z<span class="selector-class">.a</span> y<span class="selector-class">.a</span> x<span class="selector-class">.a</span> -Xlinker <span class="string">&quot;-)&quot;</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;编程实现 Link 阶段</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all compile link</span><br><span class="line"></span><br><span class="line">MODULES := common \</span><br><span class="line">           main \</span><br><span class="line">           module</span><br><span class="line">        </span><br><span class="line">CC := gcc </span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line">LFLAGS :=</span><br><span class="line"></span><br><span class="line">DIR_PROJECT := <span class="variable">$(<span class="built_in">realpath</span> .)</span></span><br><span class="line">DIR_BUILD := build</span><br><span class="line">DIR_BUILD_SUB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULES)</span>)</span></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addsuffix</span> .a,<span class="variable">$(MODULES)</span>)</span>    <span class="comment"># 增加后缀 .a</span></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE_LIB)</span>)</span></span><br><span class="line"></span><br><span class="line">APP := app.out</span><br><span class="line">APP := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(APP)</span>)</span></span><br><span class="line"></span><br><span class="line">all : compile link</span><br><span class="line"></span><br><span class="line">link : <span class="variable">$(MODULE_LIB)</span></span><br><span class="line">	@echo <span class="string">&quot;Bengin to link ...&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(APP)</span> -Xlinker <span class="string">&quot;-(&quot;</span> <span class="variable">$^</span> -Xlinker <span class="string">&quot;-)&quot;</span> <span class="variable">$(LFLAGS)</span></span><br><span class="line">	@echo <span class="string">&quot;Success Target ==&gt; <span class="variable">$@</span> ...&quot;</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span></span><br><span class="line">	@echo <span class="string">&quot;Compile Begin ...&quot;</span></span><br><span class="line">	@set -e;\</span><br><span class="line">	for dir in <span class="variable">$(MODULES)</span>;\</span><br><span class="line">	do\</span><br><span class="line">		cd $$dir &amp;&amp; make all DEBUG:=<span class="variable">$(DEBUG)</span> &amp;&amp; cd ..;\</span><br><span class="line">	done</span><br><span class="line">	@echo <span class="string">&quot;Compile Success ...&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span> :</span><br><span class="line">	<span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(DIR_BUILD)</span> </span><br></pre></td></tr></table></figure>
<h3 id="2-编译优化"><a href="#2-编译优化" class="headerlink" title="2) 编译优化"></a>2) 编译优化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上述 makefile 存在两个潜在问题，首先是所有模块 makefile 中使用编译路径均为写死的绝对路径，一旦项目文件夹移动，编译必将失败</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;针对这个问题在工程 makefile 中获取项目的源码目录，根据项目源码路径：拼接得到编译文件夹路径 DIR_BUILD，拼接得到全局头文件路径 DIR_COMMON_INC。通过定义命令行变量将路径传递给模块 makefile。优化后的代码如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all compile link rebuild</span><br><span class="line"></span><br><span class="line">MODULES := common \</span><br><span class="line">           main \</span><br><span class="line">           module</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line">DIR_PROJECT := <span class="variable">$(<span class="built_in">realpath</span> .)</span></span><br><span class="line">DIR_BUILD := build</span><br><span class="line">DIR_COMMON_INC := common/inc</span><br><span class="line">DIR_BUILD_SUB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULES)</span>)</span></span><br><span class="line"></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addsuffix</span> .a, <span class="variable">$(MODULES)</span>)</span> <span class="comment"># 增加后缀 .a</span></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE_LIB)</span>)</span></span><br><span class="line"></span><br><span class="line">APP := app.out</span><br><span class="line">APP := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(APP)</span>)</span></span><br><span class="line"></span><br><span class="line">all : compile <span class="variable">$(APP)</span></span><br><span class="line">    @echo <span class="string">&quot;Target <span class="variable">$(APP)</span> success!&quot;</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span></span><br><span class="line">    @echo <span class="string">&quot;compile begin ...&quot;</span></span><br><span class="line">    @set -e;\</span><br><span class="line">    for dir in <span class="variable">$(MODULES)</span>; \</span><br><span class="line">    do \</span><br><span class="line">        cd $$dir &amp;&amp; \</span><br><span class="line">        <span class="variable">$(MAKE)</span> all \ <span class="comment"># 传递路径给子 makefile</span></span><br><span class="line">            DEBUG:=<span class="variable">$(DEBUG)</span> \</span><br><span class="line">            DIR_BUILD:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(DIR_BUILD)</span>)</span> \ </span><br><span class="line">            DIR_COMMON_INC:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(DIR_COMMON_INC)</span>)</span> &amp;&amp; \</span><br><span class="line">        cd .. ;\</span><br><span class="line">    done</span><br><span class="line">    @echo <span class="string">&quot;compile success!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span> :</span><br><span class="line">    <span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">link <span class="variable">$(APP)</span> : <span class="variable">$(MODULE_LIB)</span></span><br><span class="line">    @echo <span class="string">&quot;begin to link !&quot;</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(APP)</span>  -Xlinker <span class="string">&quot;-(&quot;</span> <span class="variable">$(MODULE_LIB)</span> -Xlinker <span class="string">&quot;-)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;link success!&quot;</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(DIR_BUILD)</span></span><br><span class="line"></span><br><span class="line">rebuild : clean all</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;第二个问题就是，所有 makefile 模块完全相同，<font color=dark>当模块 makefile 需要改动时，将涉多处相同改动</font>。针对这个问题，可以将模块 makefile 差分为两个模板文件 <font color=blue>mod-cfg.mk</font> <font color = red>定义为可能改变的变量</font>，<font color=blue>mod-rule.mk</font> <font color=purple>定义相对稳定的变量和规则</font>。默认情况下，模块 makefile <font color=brown>复用模板文件实现功能 (include)</font>。这个解决方案需要，通过命令行变量进行模板文件位置的传递。优化后的 makefile 如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于各个模块下的 makefile </p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">include $(MOD_CFG)</span><br><span class="line"></span><br><span class="line"><span class="meta"># Custmization Begin</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># DIR_SRC := src</span></span><br><span class="line"><span class="meta"># DIR_INC := inc</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># TYPE_INC := .h</span></span><br><span class="line"><span class="meta"># TYPE_SRC := .c</span></span><br><span class="line"><span class="meta"># TYPE_OBJ := .o</span></span><br><span class="line"><span class="meta"># TYPE_DEP := .dep</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Custmization End</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include $(CMD_CFG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include $(MOD_RULE)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;工程目录下的 makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PHONY : all compile link rebuild</span><br><span class="line"></span><br><span class="line">MODULES := common \</span><br><span class="line">           main \</span><br><span class="line">           module</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line">DIR_PROJECT := <span class="variable">$(<span class="built_in">realpath</span> .)</span></span><br><span class="line">DIR_BUILD := build</span><br><span class="line">DIR_COMMON_INC := common/inc</span><br><span class="line">DIR_BUILD_SUB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULES)</span>)</span></span><br><span class="line"></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addsuffix</span> .a, <span class="variable">$(MODULES)</span>)</span> <span class="comment"># 增加后缀 .a</span></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE_LIB)</span>)</span></span><br><span class="line"></span><br><span class="line">MOD_CFG := mod-cfg.mk</span><br><span class="line">MOD_RULE := mod-rule.mk</span><br><span class="line">CMD_CFG := cmd-cfg.mk</span><br><span class="line"></span><br><span class="line">APP := app.out</span><br><span class="line">APP := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(APP)</span>)</span></span><br><span class="line"></span><br><span class="line">all : compile <span class="variable">$(APP)</span></span><br><span class="line">    @echo <span class="string">&quot;Target <span class="variable">$(APP)</span> success!&quot;</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span></span><br><span class="line">    @echo <span class="string">&quot;compile begin ...&quot;</span></span><br><span class="line">    @set -e;\</span><br><span class="line">    for dir in <span class="variable">$(MODULES)</span>; \</span><br><span class="line">    do \</span><br><span class="line">        cd $$dir &amp;&amp; \</span><br><span class="line">        <span class="variable">$(MAKE)</span> all \</span><br><span class="line">            DEBUG:=<span class="variable">$(DEBUG)</span> \</span><br><span class="line">            DIR_BUILD:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(DIR_BUILD)</span>)</span> \</span><br><span class="line">            DIR_COMMON_INC:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(DIR_COMMON_INC)</span>)</span> \</span><br><span class="line">            MOD_CFG:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(MOD_CFG)</span>)</span> \</span><br><span class="line">            MOD_RULE:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(MOD_RULE)</span>)</span>\</span><br><span class="line">            CMD_CFG:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(CMD_CFG)</span>)</span>&amp;&amp; \</span><br><span class="line">        cd .. ;\</span><br><span class="line">    done</span><br><span class="line">    @echo <span class="string">&quot;compile success!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span> :</span><br><span class="line">    <span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">link <span class="variable">$(APP)</span> : <span class="variable">$(MODULE_LIB)</span></span><br><span class="line">    @echo <span class="string">&quot;begin to link !&quot;</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(APP)</span>  -Xlinker <span class="string">&quot;-(&quot;</span> <span class="variable">$(MODULE_LIB)</span> -Xlinker <span class="string">&quot;-)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;link success!&quot;</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(DIR_BUILD)</span></span><br><span class="line"></span><br><span class="line">rebuild : clean all</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可能改变的变量 mod-cfg.mk</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">DIR_SRC := src</span><br><span class="line">DIR_INC := inc</span><br><span class="line"></span><br><span class="line">TYPE_INC := .h</span><br><span class="line">TYPE_SRC := .c</span><br><span class="line">TYPE_OBJ := .o</span><br><span class="line">TYPE_DEP := .dep</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;定义相对稳定的变量和规则 mod-rule.mk</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">MODULE := <span class="variable">$(<span class="built_in">realpath</span> .)</span>       <span class="comment"># 获取当前路径下的绝对路径</span></span><br><span class="line">MODULE := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(MODULE)</span>)</span></span><br><span class="line"></span><br><span class="line">DIR_OUTPUT := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE)</span>)</span></span><br><span class="line"></span><br><span class="line">OUTPUT := <span class="variable">$(MODULE)</span>.a</span><br><span class="line">OUTPUT := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(OUTPUT)</span>)</span></span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(DIR_SRC)</span>/*<span class="variable">$(TYPE_SRC)</span>)</span></span><br><span class="line">OBJS := $(SRCS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_OBJ)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%,<span class="variable">$(DIR_OUTPUT)</span>/%,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line">DEPS := $(SRCS:<span class="variable">$(TYPE_SRC)</span>=<span class="variable">$(TYPE_DEP)</span>)</span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(DIR_SRC)</span>/%, <span class="variable">$(DIR_OUTPUT)</span>/%,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_INC)</span> <span class="variable">$(DIR_COMMON_INC)</span></span><br><span class="line"><span class="keyword">vpath</span> %<span class="variable">$(TYPE_SRC)</span> <span class="variable">$(DIR_SRC)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all :  <span class="variable">$(OUTPUT)</span></span><br><span class="line">    @echo <span class="string">&quot;Success! Target ==&gt; <span class="variable">$(OUTPUT)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(AR)</span> <span class="variable">$(ARFLAGS)</span> <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OUTPUT)</span>/%<span class="variable">$(TYPE_OBJ)</span> : %<span class="variable">$(TYPE_SRC)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$(<span class="built_in">filter</span> %<span class="variable">$(TYPE_SRC)</span>,<span class="variable">$^</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_OUTPUT)</span>/%<span class="variable">$(TYPE_DEP)</span> : %<span class="variable">$(TYPE_SRC)</span></span><br><span class="line">    @echo <span class="string">&quot;Creating <span class="variable">$@</span> ...&quot;</span></span><br><span class="line">    @set -e; \</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -MM -E <span class="variable">$(<span class="built_in">filter</span> %<span class="variable">$(TYPE_SRC)</span>,<span class="variable">$^</span>)</span> | sed &#x27;s,\(.*\)\.o[ :]*,<span class="variable">$(DIR_OUTPUT)</span>/\1.o <span class="variable">$@</span>: ,g&#x27; &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;定义相对稳定的命令 cmd-cfg.mk</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">AR := ar</span><br><span class="line">ARFLAGS := crs</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">LFLAGS :=</span><br><span class="line">CFLAGS := -I<span class="variable">$(DIR_INC)</span> -I<span class="variable">$(DIR_COMMON_INC)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;经过上述的拆分，已经解决了各个模块下的 makfile 复用的问题。但是对于工程 makefile 模块可以进一步进行优化。 可以拆分命令变量、项目变量、以及其他变量和规则到不同文件。</p>
<ul>
<li>cmd-cfg.mk ：定义命令相关变量</li>
<li>pro-cfg.mk ：定义项目变量以及编译路径变量等</li>
<li>pro-rule.mk ：定义其他变量和规则</li>
<li>最后的工程 makefile 通过包含拆分后的文件构成 (include)</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;优化后的 makeflie 如下, 首先是定义命令相关变量 cmd-cfg.mk</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">AR := ar</span><br><span class="line">ARFLAGS := crs</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">LFLAGS :=</span><br><span class="line">CFLAGS := -I<span class="variable">$(DIR_INC)</span> -I<span class="variable">$(DIR_COMMON_INC)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,true)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">MKDIR := mkdir</span><br><span class="line">RM := rm -rf</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;定义项目变量以及编译路径变量等 pro-cfg.mk</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">MODULES</span> :<span class="string">= common \</span></span><br><span class="line">           <span class="attr">main</span> <span class="string">\</span></span><br><span class="line">           <span class="attr">module</span></span><br><span class="line"></span><br><span class="line"><span class="attr">MOD_CFG</span> :<span class="string">= mod-cfg.mk</span></span><br><span class="line"><span class="attr">MOD_RULE</span> :<span class="string">= mod-rule.mk</span></span><br><span class="line"><span class="attr">CMD_CFG</span> :<span class="string">= cmd-cfg.mk</span></span><br><span class="line"></span><br><span class="line"><span class="attr">DIR_BUILD</span> :<span class="string">= build</span></span><br><span class="line"><span class="attr">DIR_COMMON_INC</span> :<span class="string">= common/inc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">APP</span> :<span class="string">= app.out</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;定义其他变量和规则 pro-rule.mk</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PHONY : all compile link rebuild</span><br><span class="line"></span><br><span class="line">DIR_PROJECT := <span class="variable">$(<span class="built_in">realpath</span> .)</span></span><br><span class="line">DIR_BUILD_SUB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULES)</span>)</span></span><br><span class="line"></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addsuffix</span> .a, <span class="variable">$(MODULES)</span>)</span> <span class="comment"># 增加后缀 .a</span></span><br><span class="line">MODULE_LIB := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(MODULE_LIB)</span>)</span></span><br><span class="line"></span><br><span class="line">APP := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_BUILD)</span>/,<span class="variable">$(APP)</span>)</span></span><br><span class="line"></span><br><span class="line">all : compile <span class="variable">$(APP)</span></span><br><span class="line">    @echo <span class="string">&quot;Target <span class="variable">$(APP)</span> success!&quot;</span></span><br><span class="line"></span><br><span class="line">compile : <span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span></span><br><span class="line">    @echo <span class="string">&quot;compile begin ...&quot;</span></span><br><span class="line">    @set -e;\</span><br><span class="line">    for dir in <span class="variable">$(MODULES)</span>; \</span><br><span class="line">    do \</span><br><span class="line">        cd $$dir &amp;&amp; \</span><br><span class="line">        <span class="variable">$(MAKE)</span> all \</span><br><span class="line">            DEBUG:=<span class="variable">$(DEBUG)</span> \</span><br><span class="line">            DIR_BUILD:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(DIR_BUILD)</span>)</span> \</span><br><span class="line">            DIR_COMMON_INC:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(DIR_COMMON_INC)</span>)</span> \</span><br><span class="line">            MOD_CFG:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(MOD_CFG)</span>)</span> \</span><br><span class="line">            MOD_RULE:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(MOD_RULE)</span>)</span>\</span><br><span class="line">            CMD_CFG:=<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(DIR_PROJECT)</span>/,<span class="variable">$(CMD_CFG)</span>)</span>&amp;&amp; \</span><br><span class="line">        cd .. ;\</span><br><span class="line">    done</span><br><span class="line">    @echo <span class="string">&quot;compile success!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DIR_BUILD)</span> <span class="variable">$(DIR_BUILD_SUB)</span> :</span><br><span class="line">    <span class="variable">$(MKDIR)</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">link <span class="variable">$(APP)</span> : <span class="variable">$(MODULE_LIB)</span></span><br><span class="line">    @echo <span class="string">&quot;begin to link !&quot;</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(APP)</span>  -Xlinker <span class="string">&quot;-(&quot;</span> <span class="variable">$(MODULE_LIB)</span> -Xlinker <span class="string">&quot;-)&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;link success!&quot;</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(DIR_BUILD)</span></span><br><span class="line"></span><br><span class="line">rebuild : clean all</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;最后工程 makefile 的内容就很简单了</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> pro-cfg.mk   <span class="comment"># 定义命令相关变量</span></span><br><span class="line"><span class="keyword">include</span> cmd-cfg.mk   <span class="comment"># 定义项目变量以及编译路径变量等</span></span><br><span class="line"><span class="keyword">include</span> pro-rule.mk  <span class="comment"># 定义其他变量和规则</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;到这里一个大型项目的编译环境就基本打造完成了。大型项目的编译环境是由不同的 makefile 构成的。编译环境的设计需要<font color=blue>依据项目的整体架构设计</font>。整个项目的编译可以<font color=dark>分解为不同阶段</font>。根据不同的阶段有针对性的对 makefile 进行设计。<font color=brown>makefile 也需要考虑复用性和维护性等基本程序特性。</font></p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>番外篇-mipi dsi 协议</title>
    <url>/2021/04/27/mipi%20%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp; 阅读 MIPI Alliance Standard for Display Serial Interface V1.0 不照搬全文，有部分个人理解，可能会有内容删减。</p>
<a id="more"></a>

<h2 id="一、MIPI联盟显示系列接口的标准"><a href="#一、MIPI联盟显示系列接口的标准" class="headerlink" title="一、MIPI联盟显示系列接口的标准"></a>一、MIPI联盟显示系列接口的标准</h2><p>显示串行接口 (DSI) 规范定义了主机处理器和外围设备之间的协议，这些协议符合 MIPI 联盟的移动设备接口规范。 DSI 规范建立在现有标准的基础上，采用了 MIPI 联盟标准中为 DBI-2 [2]、DPI-2 [3] 和 DCS [1] 定义的像素格式和命令集。</p>
<p>本规范规定了接口协议以及信号时序关系的描述，但没有规定电器规格和物理规格。此外此规范不包含 DPI-2 和 DBI-2 等传统接口。设备使用的辅助总线(i2c,spi等)本规范虽然不排斥，但也不包含在内。</p>
<p>显示串行接口(DSI)定义了外设与移动设备之间的<strong>高速串行接口</strong>，通常用于显示模块显示，例如 lcd 的的显示。通过这个接口可以提高设备的性能，降低设备的功耗，减少设备需要的引脚，同时提高可维护性和兼容性。</p>
<h2 id="1、相关术语"><a href="#1、相关术语" class="headerlink" title="1、相关术语"></a>1、相关术语</h2><p>“shall” 表示必须严格遵守的强制要求</p>
<p>“must” 仅用于描述不可避免的情况</p>
<p>“will” 仅仅用于陈述</p>
<p>“should” 表示在多种可能性中推荐一种比较合适的。</p>
<p>“may” 表示可能被允许</p>
<p>“can” 表示可以、等于、能够</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1) 定义"></a>1) 定义</h3><p><strong>Forward Direction(正向传输)：</strong> 从发送时钟一侧到接收时钟一侧的传输，相对于高速串行时钟的方向定义的信号方向。</p>
<p><strong>Half duplex(半双工):</strong> 在一条通道上进行双向数据传输，允许传输和接收，但一次只能在一个方向。</p>
<p><strong>HS Transmission(高速传输):</strong> 在 HS 模式下正向发送一个或多个数据包。 HS 传输在数据包传输之前和之后由 LP-11 状态定界。</p>
<p><strong>Host Processor(主机处理器):</strong> 提供移动设备核心功能的硬件和软件。</p>
<p><strong>Lane:</strong> 由两组互补的差分通道组成，用于传输数据或时钟信号</p>
<p><strong>Lane Interconnect:</strong> 用于差分高速信号和低功耗单端信号的双线点对点互连。</p>
<p><strong>Lane Module:</strong> 用于在 lane 上发送或接受数据</p>
<p><strong>Link(链路):</strong> 两个设备之间包含一个时钟通道和至少一个数据通道的完整连接。</p>
<p><strong>LP Transmission(低功耗传输):</strong> 在 LP 模式或 Escape 模式中发送一个或多个数据包。 LP 传输在数据包传输之前和之后由 LP-11 状态分隔</p>
<p><strong>Packet:</strong> 遵守一定协议的数据格式。字节是构成数据包的基本数据单位。</p>
<p><strong>Payload:</strong> 仅应用数据——删除了所有链接同步、标头、ECC 和校验和以及其他与协议相关的信息。 这是主机处理器和外设之间传输的“核心”</p>
<p><strong>PHY :</strong> 组成 lane 的物理链路</p>
<p><strong>PHY Configuration(PHY配置)：</strong> 一个 PHY 配置至少包含两个通道：一个时钟通道和一个或多个数据通道。</p>
<p><strong>Reverse Direction:</strong> 反向是正向的相反方向。 请参阅Forward Direction 的说明。</p>
<p><strong>Virtual Channel:(虚拟通道)</strong> 此规范支持最多四个外设的多个独立数据流。 每个外设的数据流是一个虚拟通道。 这些数据流可以交错并作为顺序数据包发送，每个数据包专用于特定的外围设备或通道。数据包协议包括将每个数据包定向到其预期外围设备的信息。</p>
<p><strong>Word Count:</strong> 字节数</p>
<h2 id="二、DSI-Introduction"><a href="#二、DSI-Introduction" class="headerlink" title="二、DSI Introduction"></a>二、DSI Introduction</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;DSI 指定了主机处理器和显示模块等外围设备之间的接口。它通过采用 DPI-2、DBI-2 和 DCS 标准中指定的像素格式和命令集，以现有 MIPI 联盟标准为基础。下图显示了一个简化的 DSI 接口。从概念上来说，它像外围设备发送像素或者命令，并且可以从外围设备读回状态或像素信息。它和传统的区别在于它将所有像素数据，命令，和时间序列化打包发送。从而减少了控制信号等并行线。从系统或软件的角度来看，序列化和反序列化操作应该是透明的。最明显也不可避免的问题就是，将并行数据转换回串行数据会增加外设响应时间。使用帧缓冲可以降低这样的延时。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/linux-lcd%E9%A9%B1%E5%8A%A8/phy.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627537718;10267451318&q-key-time=1627537718;10267451318&q-header-list=&q-url-param-list=&q-signature=89144ae577f1caef44f403c264e871f3a1cad840" width="70%" height="70%" alt="Figure 1 DSI Transmitter and Receiver Interface">

<h3 id="1、DSI-Layer-Definitions"><a href="#1、DSI-Layer-Definitions" class="headerlink" title="1、DSI Layer Definitions"></a>1、DSI Layer Definitions</h3><p>DSI 从概念上可以划分为以下几个功能层。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/linux-lcd%E9%A9%B1%E5%8A%A8/mipi%20dsi%20%E5%88%86%E5%B1%82.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627540599;10267454199&q-key-time=1627540599;10267454199&q-header-list=&q-url-param-list=&q-signature=d3f218ebfbb9e9a5f599fd2b2c9db5f499c745a9" width="70%" height="70%" alt="Figure 2 DSI Layers">

<h4 id="1）PHY-Layer"><a href="#1）PHY-Layer" class="headerlink" title="1）PHY Layer"></a>1）PHY Layer</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;PHY 层指定了传输介质，输入输出电路，通信过程中 “1” 和 “0” 采取时机。它也指定了传输开始 SoT 和传输结束 EoT 的通信协议，其中也包括发送和接受的特定信息。位级和字节级同步机制作为 PHY 的一部分包含在内</p>
<h4 id="2）Lane-Management-Layer"><a href="#2）Lane-Management-Layer" class="headerlink" title="2）Lane Management Layer"></a>2）Lane Management Layer</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;通道管理层(Lane Management Layer), 可以根据应用的需求，数据通道可以旋转1-4组lane，发送端该层则用于管理将数据分发到各个通道，接收端该该层将收到的信号进行组合恢复到原有的状态，即分发器功能与合并功能.</p>
<h4 id="3-Protocol-Layer"><a href="#3-Protocol-Layer" class="headerlink" title="3) Protocol Layer"></a>3) Protocol Layer</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;协议层(Low Level Protocol)规定了通过接口的位和字节的序列和值。 它指定如何将字节组织到称为数据包的定义组中。该协议定义了每个数据包所需的标头，以及如何生成和解释标头信息。 接口的发送端将报头和错误校验信息附加到正在发送的数据中。 在接收端，报头被剥离并由接收器中的相应逻辑解释。 错误检查信息可用于测试传入数据的完整性。 DSI 协议还记录了如何标记数据包以使用单个 DSI 将多个命令或数据流交织到不同的目的地。</p>
<h4 id="4-Application-Layer"><a href="#4-Application-Layer" class="headerlink" title="4) Application Layer"></a>4) Application Layer</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;应用层(Application Layer)该层描述了数据流中包含的数据的更高级别的编码和解释。 根据显示子系统架构，它可能由具有规定格式的像素或由显示模块内的显示控制器解释的命令组成。 DSI 规范描述了像素值、命令和命令参数到数据包组件中字节的映射.</p>
<h3 id="2、Command-and-Video-Modes"><a href="#2、Command-and-Video-Modes" class="headerlink" title="2、Command and Video Modes"></a>2、Command and Video Modes</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;符合 DSI 的外设支持两种基本操作模式：Command Modes 和 Video Modes 。使用哪种模式取决于外设的架构和功能。模式定义反映了 DSI 用于显示互连的主要预期用途，但无意限制 DSI 在其他应用程序中运行。通常，外设既能进行命令模式操作也能进行视频模式操作。一些视频模式显示器还包括命令模式操作的简化形式，其中显示器可以从缩小尺寸或部分帧缓冲区刷新其屏幕，并且可以关闭与主机处理器的接口 (DSI) 以降低功耗</p>
<h4 id="1-Command-Mode"><a href="#1-Command-Mode" class="headerlink" title="1) Command Mode"></a>1) Command Mode</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Command Mode 用于向外设发送数据和命令，例如包含显示控制器的外设，显示控制器可以包括本地寄存器和帧缓冲器。系统使用 Command Mode 读写寄存器和 frame buffer memory. 处理器通过向显示控制器发送命令、参数和数据来间接控制外设的活动。处理器还可以读取显示模块状态信息或帧存储器的内容.Command Mode 需要双向接口。</p>
<h4 id="2-Video-Mode-Operation"><a href="#2-Video-Mode-Operation" class="headerlink" title="2) Video Mode Operation"></a>2) Video Mode Operation</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Video Mode 指以实时像素流的形式从处理器传输到外围设备的操作。在正常操作中，显示模块依赖主机处理器以足够的带宽提供图像数据，以避免显示图像中出现闪烁或其他可见伪影。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;一些 Video Mode 架构可能包括一个简单的时序控制器和部分帧缓冲器，用于在待机或低功耗模式下保持部分屏幕或较低分辨率的图像。这允许关闭接口以降低功耗。</p>
<p>为了降低复杂性和成本，仅在视频模式下运行的系统可以使用单向数据路径。</p>
<h4 id="3-Virtual-Channel-Capability"><a href="#3-Virtual-Channel-Capability" class="headerlink" title="3) Virtual Channel Capability"></a>3) Virtual Channel Capability</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;用于支持多个显示器同时显示，DSI 允许多达 4 个虚拟通道，使多个外设的流量能够共享一个公共 DSI 链路。在一些高分辨率显示器设计中，多个物理驱动器服务于普通显示面板的不同区域。每个驱动程序都与自己的显示控制器集成在一起，该控制器通过 DSI 连接到主机处理器。使用虚拟通道，显示控制器将数据定向到各个驱动程序，无需多个接口或复杂的多路复用方案。</p>
<h2 id="三、DSI-Physical-Layer"><a href="#三、DSI-Physical-Layer" class="headerlink" title="三、DSI Physical Layer"></a>三、DSI Physical Layer</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;本节简要概述了DSI中使用的物理层，处理器和外设使用使用 clock + 一个或多个串行数据线来传输信息。通过总线发送高速串行数据的行为叫做 HS transmission 或者 burst</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%203%20Basic%20HS%20Transmission%20Structure.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627900224;10267813824&q-key-time=1627900224;10267813824&q-header-list=&q-url-param-list=&q-signature=dd85b03ed2114936af5cf10dbd1907ca3c04f2b1" width="90%" height="90%" alt="Figure 3 Basic HS Transmission Structure">


<p>D-PHY 低级协议规定最小数据单位为一个字节，一次传输包含整数个字节</p>
<h3 id="1、Data-Flow-Control"><a href="#1、Data-Flow-Control" class="headerlink" title="1、Data Flow Control"></a>1、Data Flow Control</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;协议层和 PHY 层之间没有握手，允许协议层在传输进行时限制进出 PHY 层的数据传输。 数据包的发送和接收应完整无间断。 链路两端的协议层和数据缓冲应始终具有等于或大于 PHY 层电路的带宽。 一个实际的结果是系统实现者应该确保接收器的带宽能力等于或大于发射器的带宽能力。</p>
<h3 id="2、Bidirectionality-and-Low-Power-Signaling-Policy"><a href="#2、Bidirectionality-and-Low-Power-Signaling-Policy" class="headerlink" title="2、Bidirectionality and Low Power Signaling Policy"></a>2、Bidirectionality and Low Power Signaling Policy</h3><p>DSI 实现的物理层由一到四个数据通道和一个时钟通道组成。 在 Command Mode 系统中，数据 lane 0 应该是双向的； 其他的数据 lane 应该是单向的。 在 Video Mode 系统中，数据 lane 0 可以是双向的或单向的；其他的数据 lane 应该是单向的。 有关详细信息，请参阅第 3 和 4 节。对于这两种接口类型，时钟通道只能由主处理器驱动，而不能由外设驱动。</p>
<p>正向的低功率传输应该使用数据 lane 0，数据 lane 0 上的反向传输应使用 Low Power Mode。外围设备应能够在 Low Power Mode 或 High Speed Mode 下接收任何传输。 请注意，在 LP 模式下传输时，传输带宽会大大减少。</p>
<p>对于双向通道，应仅使用低功耗 (LP) 模式在外设到处理器或反向传输数据。 有关不同传输模式的详细信息，请参阅 D-PHY 的 MIPI 联盟标准 [4]。 </p>
<p>PHY 和协议层之间的接口有几个控制总线方向的信号。 当主机发送器需要来自外设的响应时，例如 返回 READ 数据或状态信息，它在传输的最后一个数据包期间向其 PHY 报告 TurnRequest。 这告诉 PHY 层在 EoT 序列之后声明总线转向 (BTA) 命令。</p>
<p>当外设接收到 Bus Turn-Around 命令时，其 PHY 层将 TurnRequest 响应为协议层的输入。 这告诉接收协议层它应该准备向处理器发送响应。 通常，刚接收到的数据包会告诉协议层一旦总线可用于传输到处理器时要发送什么信息。</p>
<p>在发送其响应后，外设类似地使用 TurnRequest 将总线控制权交还给处理器到其自己的 PHY 层。</p>
<h3 id="3、Command-Mode-Interfaces"><a href="#3、Command-Mode-Interfaces" class="headerlink" title="3、Command Mode Interfaces"></a>3、Command Mode Interfaces</h3><p>在 Command Mode 下运行的 DSI 处理器的最低物理层要求是：</p>
<ul>
<li>Data Lane Module: CIL-MUYY (HS-TX, LP-TX, LP-RX, and LP-CD)</li>
<li>Clock Lane Module: CIL-MCNN (HS-TX, LP-TX)</li>
</ul>
<p>在命令模式下运行的 DSI 外设的最低物理层要求是:</p>
<ul>
<li>Data Lane Module: CIL-SUYY (HS-RX, LP-RX, LP-TX, and LP-CD)</li>
<li>Clock Lane Module: CIL-SCNN (HS-RX, LP-RX)</li>
</ul>
<p>双向链路应支持反向 Escape Mode 和正向 Escape Mode</p>
<h3 id="4、Video-Mode-Interfaces"><a href="#4、Video-Mode-Interfaces" class="headerlink" title="4、Video Mode Interfaces"></a>4、Video Mode Interfaces</h3><p>在 Video Mode 下运行的 DSI 发射机的最低物理层要求是：</p>
<ul>
<li>Data Lane Module: CIL-MUNN (HS-TX, LP-TX)</li>
<li>Clock Lane Module: CIL-MCNN (HS-TX, LP-TX)</li>
</ul>
<p>在 Video Mode 下运行的 DSI 接收器的最低物理层要求是：</p>
<ul>
<li>Data Lane Module: CIL-SUNN (HS-RX, LP-RX)</li>
<li>Data Lane Module: CIL-SUNN (HS-RX, LP-RX)</li>
</ul>
<p>所有 DSI 实现都应支持所有数据 lane 上的  forward escape ULPM</p>
<h4 id="5、Bidirectional-Control-Mechanism"><a href="#5、Bidirectional-Control-Mechanism" class="headerlink" title="5、Bidirectional Control Mechanism"></a>5、Bidirectional Control Mechanism</h4><p>总线转向由 token-passing 机制控制：主机处理器发送 Bus Turn- Around (BTA) 请求，该请求向外设传达其释放或停止驱动数据路径的意图，在此之后外设可以传输数据路径一个或多个数据包返回到主机处理器。</p>
<h4 id="6、Clock-Management"><a href="#6、Clock-Management" class="headerlink" title="6、Clock Management"></a>6、Clock Management</h4><p>DSI 时钟是从主机处理器到外设的信号。 在某些系统中，它可能具有多种功能：</p>
<p>DSI Bit Clock：在整个链路中，DSI 时钟用作源同步位时钟，用于在接收器 PHY 中捕获串行数据位。 在传输数据时，该时钟应处于活动状态。</p>
<p>Byte Clock: 利用 DSI时钟在协议层和应用层之间生成的时钟，在 HS 传输过程中，每个字节的数据都伴随着一个字节时钟。</p>
<p>Application Clock(s):  DSI Bit Clock 的分频版本可用于外设的其他时钟功能。这些“应用时钟”可能需要在没有串行数据传输时运行，或者它们可能需要持续运行（连续时钟）以支持外设的活动电路。例如：一些 mipi 转 rgb ic 可能会用到这个时钟。</p>
<p>对于连续时钟行为，时钟通道保持高速模式，在 HS 数据包传输之间生成活动时钟信号。 对于非连续时钟行为，时钟通道在 HS 数据包传输之间进入 LP-11 状态。</p>
<h4 id="7、Clock-Requirements"><a href="#7、Clock-Requirements" class="headerlink" title="7、Clock Requirements"></a>7、Clock Requirements</h4><p>所有 DSI 发送器和接收器都应支持时钟通道上的连续时钟行为，并可选择支持非连续时钟行为。 DSI 处理器应支持需要它的系统的连续时钟，并具有关闭串行时钟的能力以降低功耗。</p>
<p>请注意，处理器控制所需的时钟操作模式,主机协议和应用程序控制 Clock Lane 操作模式(High Speed or Low Power mode). 系统设计人员负责了解连接到 DSI 的外设的时钟要求，并根据这些要求控制时钟行为。</p>
<p>请注意，在低功耗信号模式下，LP 时钟在功能上嵌入在数据信号中。 当 LP 数据传输结束时，时钟有效地停止并且后续的 LP 时钟不可用于外设。 如果外设需要额外的时钟来推进其逻辑状态、通过顺序缓冲区或类似方式移动数据，则可能需要向 LP 传输添加“虚拟”数据字节以影响状态机的前进进程或推进数据 通过时序逻辑。</p>
<p>BTA 的握手过程只允许主机处理器和外设之间的 Escape Mode 时钟频率存在有限的不匹配。处理器和外设之间的 Escape Mode 频率比不得超过 3:2。处理器负责控制自己的时钟频率以匹配外设。处理器 LP 时钟频率应在外围 LP 时钟频率的 67% 到 150% 的范围内。因此，外设实现者应指定外设的标称 LP 时钟频率和保证精度。</p>
<h4 id="8、Clock-Power-and-Timing"><a href="#8、Clock-Power-and-Timing" class="headerlink" title="8、Clock Power and Timing"></a>8、Clock Power and Timing</h4><p>D-PHY 的 MIPI 联盟标准 [4] 中的附加时序要求指定了数据信号的功率状态和时钟信号的功率状态之间的时序关系。 主机处理器有责任观察这种时序关系。 如果 DSI 时钟连续运行，则这些时序要求不适用。</p>
<h2 id="四、Multi-Lane-Distribution-and-Merging"><a href="#四、Multi-Lane-Distribution-and-Merging" class="headerlink" title="四、Multi-Lane Distribution and Merging"></a>四、Multi-Lane Distribution and Merging</h2><p>DSI 是一种通道可扩展的规范。 需要比一个数据通道提供更多带宽的应用程序可以将数据路径扩展到两个、三个或四个通道的宽度，并在峰值总线带宽上获得近似线性的增长。 该规范明确记录了应用程序数据和串行位流之间的映射，以确保使用多个通道的主机处理器和外设之间的兼容性。</p>
<p>多通道实现应使用单个公共时钟信号，由所有数据通道共享。</p>
<p>从概念上讲，PHY 和更高功能块之间是一个支持多通道操作的层。 在发送器中，如图 4 所示，该层在 N 条通道上分配一个数据包字节序列，其中每个通道都是一个独立的逻辑块和接口电路。 在接收器中，如图 5 所示，该层收集来自 N 个通道的传入字节，并将这些字节合并为完整的数据包，以传递到以下数据包分解器中。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%204%20Lane%20Distributor%20Conceptual%20Overview.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627956464;10267870064&q-key-time=1627956464;10267870064&q-header-list=&q-url-param-list=&q-signature=639b8d645102c8ad7b58aed023837eb21849d2ed" width="60%" height="60%" alt="Figure 4 Lane Distributor Conceptual Overview">

<p>Lane Distributor 接受任意字节长度的 HS 传输，缓冲 N 个字节，其中 N 是接口中实现的 Lanes 的数量，并在 N 个 Lanes 上并行发送 N 个字节的组。 在发送数据之前，所有通道并行执行 SoT 序列，以向其相应的接收单元指示数据包的第一个字节开始。 在 SoT 之后，车道从第一个数据包开始并行发送一组 N 个字节，遵循循环过程。 例如，对于双通道系统，数据包的字节 0 进入通道 0，字节 1 进入通道 1，字节 2 进入通道 0，字节 3 进入通道 1，依此类推。 </p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%205%20Lane%20Merger%20Conceptual%20Overview.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627956670;10267870270&q-key-time=1627956670;10267870270&q-header-list=&q-url-param-list=&q-signature=46261455356456e4a9b2615e784f4f8a1ccb0980" width="60%" height="60%" alt="Figure 5 Lane Merger Conceptual Overview">

<h3 id="1、Multi-Lane-Interoperability-and-Lane-number-Mismatch"><a href="#1、Multi-Lane-Interoperability-and-Lane-number-Mismatch" class="headerlink" title="1、Multi-Lane Interoperability and Lane-number Mismatch"></a>1、Multi-Lane Interoperability and Lane-number Mismatch</h3><p>使用的通道数应为静态参数。 它应在系统设计或初始配置时固定，不得动态更改。 通常，外设的带宽要求及其相应的通道配置确定了系统中使用的通道数。 </p>
<p>处理器应配置为支持外设所需的相同通道数。 具体而言，具有 N-Lane 能力 (N &gt; 1) 的处理器应能够使用较少的通道进行操作，以确保与具有 M 通道的外围设备的互操作性，其中 N &gt; M。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%206%20Four-Lane%20Transmitter%20with%20Two-Lane%20Receiver%20Example.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627957336;10267870936&q-key-time=1627957336;10267870936&q-header-list=&q-url-param-list=&q-signature=ed399f4fe3e72b78252bda15adbc3bdb470f5f47" width="80%" height="80%" alt="Figure 6 Four-Lane Transmitter with Two-Lane Receiver Example">

<h4 id="1-Clock-Considerations-with-Multi-Lane"><a href="#1-Clock-Considerations-with-Multi-Lane" class="headerlink" title="1) Clock Considerations with Multi-Lane"></a>1) Clock Considerations with Multi-Lane</h4><p>在 EoT，协议层应根据最后一个活动通道模块的时序要求对公共 DSI 时钟信号进行控制。 如果协议层将 DSI 时钟置于 HS 传输之间的 LPS 中以节省功率，则它应遵守 DSI 时钟相对于 EoT 序列期间所有串行数据信号的时序要求.在 SoT 之前，应同样遵守与所有串行数据信号相关的 DSI 时钟启动的时序要求。 </p>
<h4 id="2-Bi-directionality-and-Multi-Lane-Capability"><a href="#2-Bi-directionality-and-Multi-Lane-Capability" class="headerlink" title="2) Bi-directionality and Multi-Lane Capability"></a>2) Bi-directionality and Multi-Lane Capability</h4><p>外设通常对将数据返回到主机处理器没有大量的带宽要求。 为了保持设计简单并提高互操作性，所有符合 DSI 的系统都只能在 LP 模式下使用通道 0 将数据从外设返回到主机处理器。</p>
<h4 id="3-SoT-and-EoT-in-Multi-Lane-Configurations"><a href="#3-SoT-and-EoT-in-Multi-Lane-Configurations" class="headerlink" title="3) SoT and EoT in Multi-Lane Configurations"></a>3) SoT and EoT in Multi-Lane Configurations</h4><p>由于 HS 传输由任意数量的字节组成，这些字节可能不是通道数的整数倍，因此某些通道可能会先于其他通道用完数据。 因此，Lane Management layer 在缓冲最后一组少于 N 个字节时，将其“有效数据”信号无效到所有没有进一步数据的通道中。</p>
<p>尽管所有 Lanes 都同时以并行 SoT 启动，但每个 Lane 独立运行，并且可能在其他 Lanes 之前完成 HS 传输，提前一个周期（字节）发送 EoT。</p>
<p>Link 接收端的 N 个 PHY 并行收集字节并将它们馈送到 Lane Management layer。 Lane Management layer 重建传输中的原始字节序列。图 7 和图 8 说明了 HS 传输可以针对不同通道数和数据包长度终止的各种方式。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%207%20Two%20Lane%20HS%20Transmission%20Example.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627958691;10267872291&q-key-time=1627958691;10267872291&q-header-list=&q-url-param-list=&q-signature=de8ea11cf706162c17ada819b47f06045bd5742a" width="80%" height="80%" alt="Figure 7 Two Lane HS Transmission Example">

<p>注意多通道实现的特殊情况，有 N 个通道，它可能偶尔发送一个短的 HS 传输，其中数据包长度小于 N。在这种情况下，没有要传输的数据的通道应保留在 LPS 中</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%208%20Three%20Lane%20HS%20Transmission%20Example.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1627958828;10267872428&q-key-time=1627958828;10267872428&q-header-list=&q-url-param-list=&q-signature=fbac701716e9a294782b808a0554510b60805b09" width="80%" height="80%" alt="Figure 8 Three Lane HS Transmission Example">

<h2 id="五、DSI-Protocol"><a href="#五、DSI-Protocol" class="headerlink" title="五、DSI Protocol"></a>五、DSI Protocol</h2><p>在 DSI 链路的发射机侧，并行数据、信号事件和命令在协议层转换为数据包，遵循本节中记录的数据包组织。 协议层附加数据包协议信息和报头，然后通过通道管理层向 PHY 发送完整的字节。 数据包由 PHY 序列化并通过串行链路发送。 DSI 链路的接收端执行与发送端相反的操作，将数据包分解为并行数据、信号事件和命令。</p>
<p>如果有多个通道，通道管理层会将字节分配到单独的 PHY，每个通道一个 PHY，如第 6 节所述。数据包协议和格式与所使用的通道数量无关。</p>
<h3 id="1、Multiple-Packets-per-Transmission"><a href="#1、Multiple-Packets-per-Transmission" class="headerlink" title="1、Multiple Packets per Transmission"></a>1、Multiple Packets per Transmission</h3><p>第一种是单独传输，一次传输可能包含一个数据包。但是这种情况如果要传输许多数据包并且据包分开发送，LPS 和高速模式之间频繁切换的开销将严重限制带宽。</p>
<p>第二种是单次传输，一次传输多个数据，DSI 协议允许连接多个数据包，这大大提高了有效带宽。这对于外设初始化等事件很有用，在这些事件中，许多寄存器可能会在系统启动时加载单独的写命令。图 9 说明了单独发送的多个数据包，并在单个 HS 传输中作为串联数据包发送。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%209%20Multiple%20Packet%20HS%20Transmission%20Example.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1628059834;10267973434&q-key-time=1628059834;10267973434&q-header-list=&q-url-param-list=&q-signature=6f7ce3df7a2acb448d2c16d5f407c5849438f0fc" width="80%" height="80%" alt="Figure 9 Multiple Packet HS Transmission Example">

<h3 id="2、Packet-Composition"><a href="#2、Packet-Composition" class="headerlink" title="2、Packet Composition"></a>2、Packet Composition</h3><p>数据包的第一个字节，即数据标识符 (DI)，包括指定数据包长度的信息。 例如，在显示应用中的视频模式系统中，数据包的逻辑单元可以是一条水平显示线。 命令模式系统发送命令和相关参数集，参数数量取决于命令类型。数据包的大小可分为两类：</p>
<p>短数据包使用数据类型字段指定有效传送数据，长度为 2 到 9 个字节。有关有效传送数据，请参见表 16 和表 18。大多数命令模式命令和相关参数都使用短数据包。其他短数据包传达事件，如 H Sync 和 V Sync 。因为它们是短数据包，所以它们可以将准确的时序信息传送到外设的逻辑。</p>
<p>长数据包使用两字节字数字段指定有效传送数据。 有效传送数据的长度可以从 0 到 216 - 1 个字节。 因此，一个 Long 数据包的长度可能高达 65,541 字节。 长数据包允许传输大块的像素或其他数据。</p>
<p>命令模式操作的一个特例是视频速率（更新）流，它采用传输到外围设备的任意长的像素或其他数据流的形式。 由于所有 DSI 事务都使用数据包，因此视频流应分解为单独的数据包。 这种“打包”可以通过硬件或软件来完成。 然后外围设备可以将数据包重新组合成连续的视频流以供显示。</p>
<p>Set Maximum Return Packet Size 命令允许主机处理器限制来自外设的响应数据包的大小。 有关命令的说明，请参阅第 8.8.8.3 节。</p>
<h3 id="3、Endian-Policy"><a href="#3、Endian-Policy" class="headerlink" title="3、Endian Policy"></a>3、Endian Policy</h3><p>所有分组数据都以字节形式穿过接口。 按顺序，发送器应先发送数据 LSB，最后发送MSB。 对于具有多字节字段的数据包，除非在数据包定义中指明，最低有效字节应首先传输。</p>
<h3 id="4、General-Packet-Structure"><a href="#4、General-Packet-Structure" class="headerlink" title="4、General Packet Structure"></a>4、General Packet Structure</h3><p>为低级协议通信定义了两种数据包结构：长数据包和短数据包。 对于这两种数据包结构，数据标识符始终是数据包的第一个字节。</p>
<h4 id="1-Long-Packet-Format"><a href="#1-Long-Packet-Format" class="headerlink" title="1) Long Packet Format"></a>1) Long Packet Format</h4><p>长数据包由 32 位数据包头 (PH)、具有可变字节数的有效传送数据和 16 位数据包尾 (PF)。</p>
<p><strong>数据包头 (PH)：</strong></p>
<ul>
<li>数据标识符（DI）1byte：含虚拟数据通道VC[7:6]和数据类型DT[5:0]</li>
<li>字节数（WC）2 byte：要传送的数据，长度固定两个字节</li>
<li>误差校正码（ECC）1byte：可以把一个位的错误纠正</li>
</ul>
<p><strong>有效传送数据：</strong></p>
<ul>
<li>6 ~ 65541 bytes 可变数据长度，最大字节 = 2^16</li>
</ul>
<p><strong>数据包页脚（2 byte）：</strong></p>
<ul>
<li>用于校验</li>
</ul>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%2010%20Long%20Packet%20Structure.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1628063036;10267976636&q-key-time=1628063036;10267976636&q-header-list=&q-url-param-list=&q-signature=b15a0ae687429b35488b06b2880bf4f4244baa06" width="80%" height="80%" alt="Figure 10 Long Packet Structure">

<p>数据标识符定义了数据的虚拟通道和具有可变字节数的有效传送数据。 有关数据类型的说明，请参阅第 8.8 至 8.10 节</p>
<p>字数定义了有效传送数据中从包头结束到包尾开始之间的字节数。 包头和包尾均不应包含在字数统计中。</p>
<p>纠错码 (ECC) 字节允许在包头中纠正单比特错误和检测 2 比特错误。 这包括数据标识符和字数统计字段。</p>
<p>一旦接收器读取了有效传送数据，它就会读取数据包页脚中的校验和。 主机处理器应始终在数据包页脚中计算和传输校验和。 计算校验和不需要外设。 还要注意零字节有效传送数据的特殊情况：如果有效载荷的长度为 0，则校验和计算结果为 (FFFFh)。 如果未计算校验和，则数据包页脚将由两个全零字节 (0000h) 组成。 有关计算校验和的更多信息，请参见第 9 节。</p>
<p>在一般情况下，有效传送数据的长度应为字节的倍数。 此外，每种数据格式都可能对有效传送数据的长度施加额外的限制，例如 四个字节的倍数。</p>
<p>每个字节应首先传输最低有效位。 有效传送数据可以以仅受数据格式要求限制的任何字节顺序传输。 字数和校验和等多字节元素应首先传输最低有效字节。</p>
<h4 id="2-Short-Packet-Format"><a href="#2-Short-Packet-Format" class="headerlink" title="2) Short Packet Format"></a>2) Short Packet Format</h4><p><strong>短数据包</strong>：4byte 固定长度，主要用于传输命令，读写寄存器</p>
<ul>
<li>数据标识符(DI) 1byte：含虚拟数据通道[7:6]和数据类型[5:0]</li>
<li>数据包 2byte: 要传送的数据</li>
<li>误差校正码(CEE) 1byte: 可以把一个位的错误纠正</li>
</ul>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%2011%20Short%20packet%20Structure.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1628063105;10267976705&q-key-time=1628063105;10267976705&q-header-list=&q-url-param-list=&q-signature=8f06749371745d54498d2996a689923d0244cd09" width="80%" height="80%" alt="Figure 11 Short packet Structure">

<h3 id="5、Common-Packet-Elements"><a href="#5、Common-Packet-Elements" class="headerlink" title="5、Common Packet Elements"></a>5、Common Packet Elements</h3><p>描述长包和短包的共有元素</p>
<h4 id="1-Data-Identifier-Byte"><a href="#1-Data-Identifier-Byte" class="headerlink" title="1) Data Identifier Byte"></a>1) Data Identifier Byte</h4><p>任何数据包的第一个字节是 DI（数据标识符）字节。 图 12 显示了数据标识符 (DI) 字节的组成。</p>
<p><strong>DI[7:6]:</strong> 这两个位识别指向四个虚拟通道中的一个的数据。</p>
<p>一个处理器可以使用标记命令或数据块为多达四个外设提供服务，使用针对不同外设的数据包的报头的虚拟通道 ID 字段。 虚拟通道 ID 通过将数据包复用到公共传输通道上，使一个串行流能够为两个或多个虚拟外设提供服务。 请注意，在单个传输中发送的数据包每个都有自己的虚拟通道分配，并且可以定向到不同的外围设备。 尽管 DSI 协议允许与多个外设进行通信，但该规范仅涉及主机处理器与单个外设的连接。 连接到多个物理外围设备的实现细节超出了本文档的范围。 </p>
<p><strong>DI[5:0]:</strong> 这六个位指定了数据类型。</p>
<p>数据类型字段指定了数据包内容的大小、格式以及在某些情况下的解释。 例如，在最小情况下，DT 字段是数据包内容。 通过指定数据包大小，它通知接收者在数据包的剩余部分中预期有多少字节。 这是必要的，因为没有特殊的数据包开始/结束同步代码来指示数据包的开始和结束。 这允许数据包传送任意数据，但它也需要数据包头来明确指定数据包的大小。 当接收逻辑倒计时到数据包结束时，它应假定下一个数据要么是新数据包的标头，要么是 EoT（传输结束）序列。 </p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%2012%20Data%20Identifier%20Byte.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1628063360;10267976960&q-key-time=1628063360;10267976960&q-header-list=&q-url-param-list=&q-signature=6f96cb13042d5866d5b38af127cf41f864ce34a8" width="50%" height="50%" alt="Figure 12 Data Identifier Byte">

<p>Virtual Channel Identifier – VC field, DI[7:6]</p>
<h4 id="2-Error-Correction-Code"><a href="#2-Error-Correction-Code" class="headerlink" title="2) Error Correction Code"></a>2) Error Correction Code</h4><p>纠错码允许在包头中纠正单比特错误和检测 2 比特错误。 主机处理器应始终计算并传输 ECC 字节。 计算 ECC 字节不需要外设。 如果不使用 ECC，则应传输一个全零 (00h) 的字节。</p>
<h3 id="6、Interleaved-Data-Streams"><a href="#6、Interleaved-Data-Streams" class="headerlink" title="6、Interleaved Data Streams"></a>6、Interleaved Data Streams</h3><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%2013%20Interleaved%20Data%20Stream%20Example.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1628064032;10267977632&q-key-time=1628064032;10267977632&q-header-list=&q-url-param-list=&q-signature=1efe21a07a5ab974951db520fcec3f9076f7d636" width="70%" height="70%" alt="Figure 13 Interleaved Data Stream Example">

<p>多通道的一种应用是在单个显示模块上使用两个或多个独立驱动器 IC 的高分辨率显示器。 每个驱动器 IC 仅寻址显示设备上的一部分列。 每个驱动程序 IC 仅捕获并显示针对该驱动程序的数据包内容，而忽略其他数据包。 参见图 14。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/mipi/Figure%2014%20Logical%20Channel%20Block%20Diagram%20%28Receiver%20Case%29.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1628064215;10267977815&q-key-time=1628064215;10267977815&q-header-list=&q-url-param-list=&q-signature=1cf0da05d9274f169f9c0415c4ce1accf82aa88c" width="70%" height="70%" alt="Figure 14 Logical Channel Block Diagram (Receiver Case)">

<h4 id="1-Interleaved-Data-Streams-and-Bi-directionality"><a href="#1-Interleaved-Data-Streams-and-Bi-directionality" class="headerlink" title="1) Interleaved Data Streams and Bi-directionality"></a>1) Interleaved Data Streams and Bi-directionality</h4><p>当多个外设具有双向功能时，应有一种清晰明确的方法将 READ 数据、事件和状态从预期外设返回到主机处理器。 BTA 和虚拟通道 ID 的组合确保不会混淆期望哪个外设响应来自外设的任何请求。 </p>
<p>双向性的结果是来自主机处理器的任何传输都不得包含超过一个需要外设响应的数据包。 无论通过链路连接到主机处理器的外设数量如何，这都适用。</p>
<h3 id="7、Processor-to-Peripheral-Direction-Processor-Sourced-Packet-Data-Types"><a href="#7、Processor-to-Peripheral-Direction-Processor-Sourced-Packet-Data-Types" class="headerlink" title="7、Processor to Peripheral Direction (Processor-Sourced) Packet Data Types"></a>7、Processor to Peripheral Direction (Processor-Sourced) Packet Data Types</h3><table>
<thead>
<tr>
<th>Data&nbsp;Type, Hex</th>
<th>Data&nbsp;Type,&nbsp;binary</th>
<th>Description</th>
<th>Packet&nbsp;Size</th>
</tr>
</thead>
<tbody><tr>
<td>0x01</td>
<td>00 00001</td>
<td>Sync Event, V Sync Start</td>
<td>Short</td>
</tr>
<tr>
<td>0x11</td>
<td>01 0001</td>
<td>Sync Event, V Sync End</td>
<td>Short</td>
</tr>
<tr>
<td>0x21</td>
<td>10 0001</td>
<td>Sync Event, H Sync Start</td>
<td>Short</td>
</tr>
<tr>
<td>0x31</td>
<td>11 0001</td>
<td>Sync Event, H Sync End</td>
<td>Short</td>
</tr>
<tr>
<td>0x02</td>
<td>00 0010</td>
<td>Color Mode(CM) Off Command</td>
<td>Short</td>
</tr>
<tr>
<td>0x12</td>
<td>01 0010</td>
<td>Color Mode(CM) On Command</td>
<td>Short</td>
</tr>
<tr>
<td>0x22</td>
<td>10 0010</td>
<td>Shut Down Peripheral Command</td>
<td>Short</td>
</tr>
<tr>
<td>0x32</td>
<td>11 0010</td>
<td>Turn On Peripheral Command</td>
<td>Short</td>
</tr>
<tr>
<td>x3h and xBh</td>
<td>xx x011</td>
<td>TGeneric WRITE, 0-7 parameters, bits 5:3 = parameter count</td>
<td>Short</td>
</tr>
<tr>
<td>x4h and xCh</td>
<td>xx x100</td>
<td>Generic READ, 0-7 parameters, bits 5:3 = parameter count</td>
<td>Short</td>
</tr>
<tr>
<td>x5h and xDh</td>
<td>xx x101DCS WRITE, 0-6 parameters, bits 5:3 = parameter count + 1</td>
<td>Short</td>
<td></td>
</tr>
<tr>
<td>0x06</td>
<td>00 0110</td>
<td>DCS READ, no parameters</td>
<td>Short</td>
</tr>
<tr>
<td>0x37</td>
<td>00 0110</td>
<td>Set Maximum Return Packet Size</td>
<td>Short</td>
</tr>
<tr>
<td>0x09</td>
<td>00 1001</td>
<td>Null Packet, no data</td>
<td>Short</td>
</tr>
<tr>
<td>0x19</td>
<td>01 1001</td>
<td>Blanking Packet, no data</td>
<td>Short</td>
</tr>
<tr>
<td>0x29</td>
<td>10 1001</td>
<td>Generic Non-image Packet</td>
<td>Short</td>
</tr>
<tr>
<td>0x39</td>
<td>11 1001</td>
<td>DCS Long Write/write_LUT Command Packet</td>
<td>Short</td>
</tr>
<tr>
<td>0x0E</td>
<td>00 1110</td>
<td>Packed Pixel Stream, 16-bit RGB, 5-6-5 Format</td>
<td>Short</td>
</tr>
<tr>
<td>0x1E</td>
<td>01 1110</td>
<td>Packed Pixel Stream, 18-bit RGB, 6-6-6 Format</td>
<td>Short</td>
</tr>
<tr>
<td>0x2E</td>
<td>10 1110</td>
<td>Loosely Packed Pixel Stream, 18-bit RGB, 6-6-6 Format</td>
<td>Short</td>
</tr>
<tr>
<td>0x3E</td>
<td>11 1110</td>
<td>Packed Pixel Stream, 24-bit RGB, 8-8-8 Format</td>
<td>Short</td>
</tr>
<tr>
<td>x0h and xFh, unspecified</td>
<td>xx 0000</br>xx 1111</td>
<td>DO NOT USE</br>All unspecified codes are reserved</td>
<td>Short</td>
</tr>
</tbody></table>
<h3 id="8、Processor-to-Peripheral-Transactions-–-Detailed-Format-Description"><a href="#8、Processor-to-Peripheral-Transactions-–-Detailed-Format-Description" class="headerlink" title="8、Processor-to-Peripheral Transactions – Detailed Format Description"></a>8、Processor-to-Peripheral Transactions – Detailed Format Description</h3><h4 id="1-Sync-Event-H-Start-H-End-V-Start-V-End-Data-Type-xx-0001-x1h"><a href="#1-Sync-Event-H-Start-H-End-V-Start-V-End-Data-Type-xx-0001-x1h" class="headerlink" title="1) Sync Event (H Start, H End, V Start, V End), Data Type = xx 0001 (x1h)"></a>1) Sync Event (H Start, H End, V Start, V End), Data Type = xx 0001 (x1h)</h4><p>同步事件是两字节的数据包（一个命令字节，一个 ECC 字节），因此可以在时间上准确地表示同步脉冲的开始和结束等事件。 由于“开始”和“结束”是独立且不同的事件，同步脉冲的长度以及相对于活动像素数据的位置，前后肩延时可准确传达至外设。同步事件定义如下：</p>
<ul>
<li>Data Type = 00 0001 (01h) V Sync Start</li>
<li>Data Type = 01 0001 (11h) V Sync End</li>
<li>Data Type = 10 0001 (21h) H Sync Start</li>
<li>Data Type = 11 0001 (31h) H Sync End</li>
</ul>
<p>为了尽可能准确地表示时序信息，V Sync Start 事件表示 VSA 的开始，并且还暗示 VSA 第一行的 H Sync Start 事件。 类似地，V Sync End 事件意味着 VSA 最后一行的 H Sync Start 事件。</p>
<p>如果需要传送准确的脉冲长度信息，同步事件应该成对发生，即同步开始和同步结束。 或者，如果只需要单个时间点（事件），则可以将单个同步事件（通常为同步开始）传输到外设。 同步事件可以与 blanking packets 连接以准确传达行间定时，并避免为每个事件在 LPS 和 HS 之间切换的开销。 但是请注意，将数据线保持在 HS 模式下会产生功率损失。</p>
<p>不需要传统同步/消隐/像素定时的显示模块应以高速突发传输像素数据，然后将总线置于低功耗模式，以降低功耗。 推荐的突发大小是像素的扫描线，可以临时存储在显示模块上的行缓冲区中。 </p>
<h4 id="2-Color-Mode-On-Command-Data-Type-00-0010-02h"><a href="#2-Color-Mode-On-Command-Data-Type-00-0010-02h" class="headerlink" title="2) Color Mode On Command, Data Type = 00 0010 (02h)"></a>2) Color Mode On Command, Data Type = 00 0010 (02h)</h4><p>Color Mode On 是一个单字节数据包命令（两个字节带有 ECC），它将 Video Mode 显示模块切换到低色彩模式以节省电量。</p>
<h4 id="3-Color-Mode-Off-Command-Data-Type-01-0010-12h"><a href="#3-Color-Mode-Off-Command-Data-Type-01-0010-12h" class="headerlink" title="3) Color Mode Off Command, Data Type = 01 0010 (12h)"></a>3) Color Mode Off Command, Data Type = 01 0010 (12h)</h4><p>Color Mode Off 是一个单字节数据包（两个字节带有 ECC）命令，它将 Video Mode 显示模块从低颜色模式返回到正常显示操作。</p>
<h4 id="4-Shutdown-Peripheral-Command-Data-Type-10-0010-22h"><a href="#4-Shutdown-Peripheral-Command-Data-Type-10-0010-22h" class="headerlink" title="4) Shutdown Peripheral Command, Data Type = 10 0010 (22h)"></a>4) Shutdown Peripheral Command, Data Type = 10 0010 (22h)</h4><p>Shutdown Peripheral 命令是一个两字节的数据包（一个命令字节，一个 ECC 字节），用于关闭视频模式显示模块中的显示以节省电量。 请注意，接口应保持通电以接收开启或唤醒命令。</p>
<h4 id="5-Turn-On-Peripheral-Command-Data-Type-11-0010-32h"><a href="#5-Turn-On-Peripheral-Command-Data-Type-11-0010-32h" class="headerlink" title="5) Turn On Peripheral Command, Data Type = 11 0010 (32h)"></a>5) Turn On Peripheral Command, Data Type = 11 0010 (32h)</h4><p>打开外设命令是一个单字节数据包（带有 ECC 的两个字节），用于打开视频模式显示模块中的显示器以进行正常显示操作。 </p>
<h4 id="6-Generic-Short-WRITE-Packet-0-to-7-Parameters-Data-Type-xx-x011-x3h-and-xBh"><a href="#6-Generic-Short-WRITE-Packet-0-to-7-Parameters-Data-Type-xx-x011-x3h-and-xBh" class="headerlink" title="6) Generic Short WRITE Packet, 0 to 7 Parameters, Data Type = xx x011 (x3h and xBh)"></a>6) Generic Short WRITE Packet, 0 to 7 Parameters, Data Type = xx x011 (x3h and xBh)</h4><p>通用短写命令是一种短包类型，用于将通用数据发送到外设。 该数据包内容的格式和解释超出了本规范的范围。 系统设计人员有责任确保主机处理器和外设就此类数据的格式和解释达成一致。</p>
<p>完整的数据包可能长达九个字节，包括一个 ECC 字节。 超出标头 (DI) 字节的字节数由 3 位字段 DT[5:3] 明确指定 </p>
<h4 id="7-Generic-READ-Request-0-to-7-Parameters-Data-Type-xx-x100-x4h-and-xCh"><a href="#7-Generic-READ-Request-0-to-7-Parameters-Data-Type-xx-x100-x4h-and-xCh" class="headerlink" title="7) Generic READ Request, 0 to 7 Parameters, Data Type = xx x100 (x4h and xCh)"></a>7) Generic READ Request, 0 to 7 Parameters, Data Type = xx x100 (x4h and xCh)</h4><p>通用读请求是一个短包，从外设请求数据。 这个包的参数和返回数据的格式和解释超出了本规范的范围。 系统设计人员有责任确保主机处理器和外设就此类数据的格式和解释达成一致。</p>
<h4 id="11-Video-Mode-Interface-Timing"><a href="#11-Video-Mode-Interface-Timing" class="headerlink" title="11) Video Mode Interface Timing"></a>11) Video Mode Interface Timing</h4><p>视频模式外设需要实时传输像素数据。 本节规定了此类显示模块的 DSI 流量的格式和时序</p>
<p>处理器应支持本节中的所有流量序列。 视频模式外围设备应至少支持本节中的流量序列之一。 外围设备不应要求任何有关流量序列或数据包定时的附加约束。 外设供应商应记录表 19 中列出的所有相关时序参数。</p>
<p>在下图中，BLLP 被定义为视频数据包（例如像素流和同步事件数据包）不会主动传输到外围设备的时间段。</p>
<p>要启用 PHY 同步，主机处理器应定期结束 HS 传输并将数据通道驱动到 LP 状态。 这种转换应该每帧至少发生一次； 在本节的图中显示为 LPM。 建议在水平消隐时间内每条扫描线返回 LP 状态一次。 无论 BLLP 周期的频率如何，主机处理器都负责满足所有记录在案的外设时序要求。 请注意，在较低频率下， BLLP 周期将接近或变为零，并且突发模式将与非突发模式无法区分。</p>
<p>在 BLLP 期间，DSI Link 可以执行以下任何操作：</p>
<ul>
<li>保持空闲模式，LP-RX 主机处理器为 LP-11 状态和 LP-RX</li>
<li>使用转义模式将一个或多个非视频数据包从主机处理器传输到外设</li>
<li>使用 HS 模式将从处理器向外围设备发送一个或多个非视频数据包</li>
<li>如果之前的处理器到外设传输以 BTA 结束，则使用转义模式将一个或多个数据包从外设传输到处理器</li>
<li>使用不同的虚拟通道 ID 在 HS 模式下将一个或多个数据包从主机处理器传输到不同的外设</li>
</ul>
]]></content>
      <tags>
        <tag>lcm - mipi</tag>
      </tags>
  </entry>
  <entry>
    <title>c++基础知识</title>
    <url>/2020/02/05/c++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>用于记录c++基础知识，后面再排版，学习资料来自狄泰软件学院可在淘宝购买学习</p>
<a id="more"></a>
<h1 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a><div align=center>const 关键字</h1><h2 id="1、c-在c的基础上对const做了进化处理"><a href="#1、c-在c的基础上对const做了进化处理" class="headerlink" title="1、c++在c的基础上对const做了进化处理"></a>1、c++在c的基础上对const做了进化处理</h2><ul>
<li><strong>当碰见const声明时，在符号表中放入常量</strong></li>
<li><strong>编译过程中发现使用常量则直接以符号表中的值替换</strong></li>
<li><strong>编译过程如发现下述情况则给对应的常量分配储存空间</strong><br>&nbsp; &nbsp;&nbsp;对const全局常量使用 extern<br>&nbsp; &nbsp;&nbsp;对const常量使用 &amp; 操作符</li>
<li>*注意**<br>c++编译器虽然可能会为 const 常量分配空间，但不会使用空间中的值。<h2 id="2、符号表"><a href="#2、符号表" class="headerlink" title="2、符号表"></a>2、符号表</h2>编译器在编译的过程当中所产生的一张表，是编译器内部的数据结构<img width=600 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c%2B%2B/1.png" >

</li>
</ul>
<p><strong>c++中const常量类似于宏定义</strong><br>&nbsp; &nbsp;&nbsp;const int c = 5; ≈ #define c 5</p>
<h2 id="3、c-中的const与宏定义的区别"><a href="#3、c-中的const与宏定义的区别" class="headerlink" title="3、c++中的const与宏定义的区别"></a>3、c++中的const与宏定义的区别</h2><p>const 常量是<strong>被编译器处理</strong><br>编译器对const常亮进行<strong>类型检查</strong>和<strong>作用域检查</strong><br>宏定义由<strong>预处理器处理</strong>，是<strong>单纯的文本替换</strong><br>宏<strong>没有类型以及作用域的概念</strong>， const 有<strong>作用域和类型的概念</strong></p>
<h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><div align=center>布尔类型</h1><h2 id="1、占用内存"><a href="#1、占用内存" class="headerlink" title="1、占用内存"></a>1、占用内存</h2><p>一个字节</p>
<h2 id="2、取值：-true-和-false"><a href="#2、取值：-true-和-false" class="headerlink" title="2、取值： true 和 false"></a>2、取值： true 和 false</h2><p>true    ： 代表真值，编译器内部用 1 表示<br>false    ： 代表非真值，编译器内部用 0 表示<br>c++编译器会将非0值转换为 true ， 0 值转换为 false</p>
<h2 id="3、布尔类型是c-中的基础数据类型"><a href="#3、布尔类型是c-中的基础数据类型" class="headerlink" title="3、布尔类型是c++中的基础数据类型"></a>3、布尔类型是c++中的基础数据类型</h2><p>可以定义bool类型的<strong>全局变量</strong><br>可以定义bool类型的<strong>常量</strong><br>可以定义bool类型的<strong>指针</strong><br>可以定义bool类型的<strong>数组</strong><br>…</p>
<h1 id="C-中的引用"><a href="#C-中的引用" class="headerlink" title="C++中的引用"></a><div align=center>C++中的引用</h1><h2 id="1、变量名"><a href="#1、变量名" class="headerlink" title="1、变量名"></a>1、变量名</h2><p>  变量是一段实际连续存储空间的别名<br>  程序中通过变量来申请并命名存储空间<br>  通过变量的名字可以使用存储空间</p>
<h2 id="2、引用"><a href="#2、引用" class="headerlink" title="2、引用"></a>2、引用</h2><p>引用可以看作已经定义的变量的别名<br>引用的语法：type &amp; name = var ;<br>例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">int</span> &amp; b = a; 		<span class="comment">// b为a的别名</span></span><br><span class="line">b = <span class="number">5</span>;				<span class="comment">//操作b就是操作a</span></span><br></pre></td></tr></table></figure>
<p>注意：<br>&nbsp; &nbsp;普通引用在定义时必须用同类类型的变量进行初始化。</p>
<h2 id="3、引用的意义"><a href="#3、引用的意义" class="headerlink" title="3、引用的意义"></a>3、引用的意义</h2><p>引用做为变量的别名而存在,因此在一些场合可以代替指针<br>引用相对于指针了来说具有更好的可读性与实用性</p>
<p>swap函数对比</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span>					</span></span><br><span class="line"><span class="function"></span>&#123;												</span><br><span class="line">	<span class="keyword">int</span> t = a;										</span><br><span class="line">	a = b;											</span><br><span class="line">	b = t;											</span><br><span class="line">&#125;												</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = *t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：函数中的引用不需要初始化</strong></p>
<h2 id="4、特殊的引用（const引用）"><a href="#4、特殊的引用（const引用）" class="headerlink" title="4、特殊的引用（const引用）"></a>4、特殊的引用（const引用）</h2><p>在c++中可以声明const引用<br>语法：const type&amp; name = var;<br>const 引用让变量拥有只读属性</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>&amp; b = a;</span><br><span class="line"><span class="built_in">int</span>* p = (<span class="built_in">int</span>*)&amp;b;</span><br><span class="line"></span><br><span class="line">b = <span class="number">5</span>;			<span class="comment">// Error , 只读变量</span></span><br><span class="line">*p = <span class="number">5</span>;		    <span class="comment">//ok, 修改变量a的值</span></span><br></pre></td></tr></table></figure>
<p>当使用常量对const引用进行初始化时，c++编译器会为常量值分配空间，并将引用名作为这段空间的别名</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>&amp; b = <span class="number">1</span>;		<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">int</span>* p = (<span class="built_in">int</span>*) &amp;b;</span><br><span class="line">b = <span class="number">5</span>;   <span class="comment">//Error , 只读变量</span></span><br><span class="line">*p = <span class="number">5</span>;  <span class="comment">//ok , 修改变量a的值</span></span><br></pre></td></tr></table></figure>
<p>结论：使用常量对const引用初始化后将得到一个只读变量<br>思考：引用有自己的存储空间吗？(有、本质为指针)</p>
<h2 id="5、引用的本质"><a href="#5、引用的本质" class="headerlink" title="5、引用的本质"></a>5、引用的本质</h2><p>引用在c++中的内部实现是一个指针常量</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>&amp; <span class="keyword">name</span>; 	 		   </span><br><span class="line"></span><br><span class="line">void f(int&amp; a)						</span><br><span class="line"><span class="comment">&#123;											</span></span><br><span class="line"><span class="comment">	a = 5;									</span></span><br><span class="line"><span class="comment">&#125;</span>										</span><br><span class="line"></span><br><span class="line"><span class="keyword">Type</span>* <span class="keyword">const</span> <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line">void (int * <span class="keyword">const</span> a)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	*a = 5;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;1) c++编译器在编译过程中用常量指针作为内部实现，因此引用所占用的内存空间大小与指针相同。<br>&nbsp; &nbsp;&nbsp; &nbsp;2) 从使用角度，引用只是一个别名，c++为了实用性而隐藏了引用的储存空间这一细节</p>
<p>C++中的引用旨在在多数情况下代替指针<br>&nbsp; &nbsp;&nbsp; &nbsp;功能性：可以满足多数需要使用指针的场合<br>&nbsp; &nbsp;&nbsp; &nbsp;安全性：可以避开大部分由于指针操作不当而带来的内存错误<br>&nbsp; &nbsp;&nbsp; &nbsp;操作性：简单易用，又不失功能强大</p>
<p><strong>绝对不要返回动态局部变量的引用</strong></p>
<h2 id="6、三目运算符（-a-lt-b-a-b-）"><a href="#6、三目运算符（-a-lt-b-a-b-）" class="headerlink" title="6、三目运算符（ a &lt; b ? a : b ）"></a>6、三目运算符（ a &lt; b ? a : b ）</h2><p>c语言中的三目运算符返回的是变量值<strong>不能作为左值使用</strong><br>c++中三目运算符可直接返回变量本身<strong>即可作为右值，也可作为左值使用</strong></p>
<p>注意：<br>&nbsp; &nbsp;&nbsp; &nbsp;三目运算符可能返回值的值如果有一个值是常量值，则不能作为左值使用</p>
<p>总结：<br>&nbsp; &nbsp;&nbsp; &nbsp;当三目运算符的可能返回都是变量时，返回的是变量的引用<br>&nbsp; &nbsp;&nbsp; &nbsp;当三目运算符可能返回的值中有常量时，返回是变量的值</p>
<p>例子：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">int a = <span class="number">0</span>;</span><br><span class="line">int <span class="keyword">b </span>= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">( a &lt; <span class="keyword">b? </span>a : <span class="keyword">b) </span>= <span class="number">3</span><span class="comment">;	//正确，返回a或b的引用，可做左值</span></span><br><span class="line">( a &lt; <span class="keyword">b? </span>a : <span class="number">1</span>) = <span class="number">3</span><span class="comment">;	//错误，返回1或b的值，不可做左值</span></span><br></pre></td></tr></table></figure>
<h1 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a><div align=center>函数参数的默认值</h1><p>C++可以在函数声明时为参数提供一个默认值<br>当函数调用时没有提供参数的值，则使用默认值 </p>
<h2 id="1-函数默认参数的规则"><a href="#1-函数默认参数的规则" class="headerlink" title="1.函数默认参数的规则"></a>1.函数默认参数的规则</h2><p>函数默认参数指定方式</p>
<blockquote>
<p>函数参数的默认值<strong>在函数声明中指定</strong>,多使用这种方式</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数参数的默认值<strong>在函数定义中指定</strong>，很少或不建议使用</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设计函数时，参数的默认值必须从右向左提供<br>函数调用时使用了默认值，则后续参数必须使用默认值<br>调用函数时，从左向右匹配</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"> <span class="built_in">int</span> x, <span class="built_in">int</span> y = <span class="number">1</span>, <span class="built_in">int</span> z = <span class="number">2</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span>(<span class="number">0</span>);			<span class="comment">// x = 0, y = 1, z = 2</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">2</span>,<span class="number">3</span>);		<span class="comment">// x = 2, y = 3, z = 2</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);		<span class="comment">// x = 3, y = 2, z = 1</span></span><br></pre></td></tr></table></figure>
<h2 id="2-函数占位参数"><a href="#2-函数占位参数" class="headerlink" title="2.函数占位参数"></a>2.函数占位参数</h2><p>在c++中可以为函数提供占位参数<br>占位参数只有参数类型声明，而没有参数申明<br>一般情况下，在函数体内部无法使用占位参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(1,2)</span>;		//<span class="title">ok</span></span></span><br></pre></td></tr></table></figure>
<p>占位参数与默认参数结合起来使用,兼容c语言程序中可能出现的不规范写法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">c: void <span class="function"><span class="title">fun</span><span class="params">()</span></span>  &lt;----&gt; c++: void <span class="function"><span class="title">fun</span><span class="params">(int = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="函数重载（Over-load）"><a href="#函数重载（Over-load）" class="headerlink" title="函数重载（Over load）"></a><div align=center>函数重载（Over load）</h1><p>同一个标识符在不同的上下文有不同的意义，高级语言无限接近自然语言，重载来自于自然语言的动词+名词。</p>
<h2 id="1-函数重载（Function-Over-load）"><a href="#1-函数重载（Function-Over-load）" class="headerlink" title="1.函数重载（Function Over load）"></a>1.函数重载（Function Over load）</h2><p>用同一个函数名定义不同的函数,当函数名和不同的参数搭配时函数的含义不同<br>函数重载必须至少满足下面一个条件;<strong>参数的个数不同、参数的类型不同、参数的顺序不同</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> char* s)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> strlen(s);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">const</span> char* s, <span class="keyword">int</span> a)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> strlen(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-函数重载可能会与使用默认参数的函数冲突（c-特性冲出）"><a href="#2-函数重载可能会与使用默认参数的函数冲突（c-特性冲出）" class="headerlink" title="2.函数重载可能会与使用默认参数的函数冲突（c++特性冲出）"></a>2.函数重载可能会与使用默认参数的函数冲突（c++特性冲出）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c = 5)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-编译器调用重载函数的的规则"><a href="#3-编译器调用重载函数的的规则" class="headerlink" title="3.编译器调用重载函数的的规则"></a>3.编译器调用重载函数的的规则</h2><p><strong>将所用同名函数作为候选者，尝试寻找可行的后选函数</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;精确匹配实参<br>&nbsp; &nbsp;&nbsp; &nbsp;通过默认参数能够匹配实参<br>&nbsp; &nbsp;&nbsp; &nbsp;通过默认类型转换匹配实参<br><strong>匹配失败</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;最终寻找到的候选函数不唯一，则出现二义性，编译失败<br>&nbsp; &nbsp;&nbsp; &nbsp;无法匹配所有候选者，函数未定义，编译失败</p>
<h2 id="4-函数重载的注意事项"><a href="#4-函数重载的注意事项" class="headerlink" title="4.函数重载的注意事项"></a>4.函数重载的注意事项</h2><p>重载函数在本质上是<strong>相互独立的不同函数</strong><br>重载函数的<strong>函数类型不同</strong><br>函数<strong>返回值</strong>不能作为函数重载的依据<br>函数重载是由<strong>函数名和参数列表决定！</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">add</span>(<span class="type">int</span> a, <span class="type">int</span> b)        // <span class="type">int</span> (<span class="type">int</span> ,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">add</span>(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span> c)  // <span class="type">int</span> (<span class="type">int</span> ,<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%p\n&quot;,( <span class="type">int</span>(*)(<span class="type">int</span> ,<span class="type">int</span>))<span class="keyword">add</span>);      // <span class="number">0x8048494</span></span><br><span class="line">	printf(&quot;%p\n&quot;,( <span class="type">int</span>(*)(<span class="type">int</span> ,<span class="type">int</span>,<span class="type">int</span>))<span class="keyword">add</span>);   //<span class="number">0x80484a2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-重载与指针"><a href="#5-重载与指针" class="headerlink" title="5.重载与指针"></a>5.重载与指针</h2><p>将重载函数名赋值给指针时<br>&nbsp; &nbsp;&nbsp; &nbsp;根据重载规则挑选与函数指针参数列表一致的候选者<br>&nbsp; &nbsp;&nbsp; &nbsp;严格匹配候选者的函数类型与函数指针的函数类型<br>注意：<br>&nbsp; &nbsp;&nbsp; &nbsp;函数重载必然发生在同一个作用域中<br>&nbsp; &nbsp;&nbsp; &nbsp;编译器需要用参数列表或函数类型进行函数选择<br>&nbsp; &nbsp;&nbsp; &nbsp;无法直接通过函数名得到重载函数的入口地址</p>
<h2 id="6-c-和c相互调用"><a href="#6-c-和c相互调用" class="headerlink" title="6.c++和c相互调用"></a>6.c++和c相互调用</h2><p>实际工程中c++和c代码相互调用是不可避免的<br>c++编译器能够兼容c语言编译方式<br>c++编译器优先使用c++编译方式<br>extern关键字强制让c++编译器进行c方式编译<br>extern 代码块中不能存在重载函数</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">extern “C”</span><br><span class="line">&#123;</span><br><span class="line">	<span class="regexp">//</span> <span class="keyword">do</span> c-style compilation here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证一段c代码只会以c的方式被编译</p>
<blockquote>
<p>__cplusplus是c++编译器内置的标准宏定义<br>__cplusplus的意义是确保c代码以统一的方式被编译成目标文件</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// C-Style Compilation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;c++编译器不能以c的方式编译重载函数<br>&nbsp; &nbsp;&nbsp; &nbsp;编译方式决定函数名被编译后的目标名<br>&nbsp; &nbsp;&nbsp; &nbsp;c++编译方式将函数名和参数列表编译成目标名<br>&nbsp; &nbsp;&nbsp; &nbsp;c编译方式只将函数名作为目标名进行编译</p>
<h1 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title=" 动态分配内存"></a><div align=center> 动态分配内存</h1><h2 id="1-c-中的动态分配内存"><a href="#1-c-中的动态分配内存" class="headerlink" title="1.c++中的动态分配内存"></a>1.c++中的动态分配内存</h2><p>c++中通过new关键字进行动态内存申请<br>c++中的动态内存申请是基于类型进行的<br>delete关键字用于释放内存</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">变量申请：								数组申请：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Type</span>* Pointer = <span class="keyword">new</span> <span class="built_in">Type</span>;				<span class="built_in">Type</span>* pointer = <span class="keyword">new</span> <span class="built_in">Type</span>[N];</span><br><span class="line"><span class="comment">//......										//......</span></span><br><span class="line"><span class="keyword">delete</span> pointer;							<span class="keyword">delete</span>[] pointer;</span><br></pre></td></tr></table></figure>
<h2 id="2-new-关键字与-mallloc-函数的区别"><a href="#2-new-关键字与-mallloc-函数的区别" class="headerlink" title="2.new 关键字与 mallloc 函数的区别"></a>2.new 关键字与 mallloc 函数的区别</h2><p>new关键字是c++的一部分<br>malloc 是由c库提供的函数<br>new 以具体类型为单位进行内存分配<br>malloc 以字节为单位进行内存分配<br>new 在申请单个类型变量时可以进行初始化<br>malloc 不具备内存初始化的特性</p>
<h2 id="3-new关键字的初始化"><a href="#3-new关键字的初始化" class="headerlink" title="3.new关键字的初始化"></a>3.new关键字的初始化</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">float</span>* f = <span class="keyword">new</span> <span class="keyword">float</span>(<span class="number">2.0f</span>);</span><br><span class="line"><span class="keyword">char</span>* pc = <span class="keyword">new</span> <span class="keyword">char</span>(‘c’);</span><br></pre></td></tr></table></figure>
<h2 id="4-c-中的命名空间"><a href="#4-c-中的命名空间" class="headerlink" title="4.c++中的命名空间"></a>4.c++中的命名空间</h2><p>在C语言中只有一个全局作用域<br>&nbsp; &nbsp;&nbsp; &nbsp;C语言中所有标识符共享一个作用域<br>&nbsp; &nbsp;&nbsp; &nbsp;标识符之间可能发生冲突<br>C++中提出了命名空间的概念<br>&nbsp; &nbsp;&nbsp; &nbsp;命名空间将全局作用域分成不同的部分<br>&nbsp; &nbsp;&nbsp; &nbsp;命名空间可以相互嵌套<br>&nbsp; &nbsp;&nbsp; &nbsp;全局作用域也叫默认命名空间<br>&nbsp; &nbsp;&nbsp; &nbsp;无论怎么划分本质还是全局作用域</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">定义</span><br><span class="line"><span class="keyword">namespace</span> <span class="symbol">Name</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> <span class="symbol">Internal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  ...  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*	...  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名空间的使用<br>&nbsp; &nbsp;&nbsp; &nbsp;使用整个命名空间：using namespace name;<br>&nbsp; &nbsp;&nbsp; &nbsp;使用命名空间中的变量：using name::variable;<br>&nbsp; &nbsp;&nbsp; &nbsp;使用默认命名空间中的变量：::variable;</p>
<h1 id="新型的类型转换方式"><a href="#新型的类型转换方式" class="headerlink" title="新型的类型转换方式"></a><div align=center>新型的类型转换方式</h1><h2 id="1-C语言中的强制类型转换"><a href="#1-C语言中的强制类型转换" class="headerlink" title="1.C语言中的强制类型转换"></a>1.C语言中的强制类型转换</h2><p>(type )( Expression )<br>type( Expression )<br>C强制类型转换存在问题<br>&nbsp; &nbsp;&nbsp; &nbsp;过于粗暴;任意类型之间都可以进行转换，编译器很难判断其正确性<br>&nbsp; &nbsp;&nbsp; &nbsp;难于定位;在源码中无法快速定位所有使用强制类型转换的语句</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">void</span>(PF)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">sturcut <span class="type">Point</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">0x12345</span>;</span><br><span class="line">PF* pf = PF* (v);</span><br><span class="line"><span class="type">char</span> c = <span class="type">char</span> (v);</span><br><span class="line"><span class="type">Point</span>* p = (<span class="type">Point</span>*) v; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-c-将强制类型转换分为4种不同的类型"><a href="#2-c-将强制类型转换分为4种不同的类型" class="headerlink" title="2.c++将强制类型转换分为4种不同的类型"></a>2.c++将强制类型转换分为4种不同的类型</h2><ul>
<li><strong>static_cast强制类型转换（静态类型转换）</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于基本类型之间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;不能用于基本类型指针间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;用于有继承关系类对象之间的转换和类指针之间的转换</li>
<li><strong>const_cast 强制类型转换</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于除去变量的只读属性<br>&nbsp; &nbsp;&nbsp; &nbsp;强制转换的目标类型必须是指针或引用</li>
<li><strong>reinterpret_cast 强制类型转换</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于指针类型间的强制转换<br>&nbsp; &nbsp;&nbsp; &nbsp;用于整数和指针类型间的强制类型转换</li>
<li><strong>dynamic_cast 强制类型转换</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;用于有继承关系的类指针间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;用于有交叉关系的类指针间的转换<br>&nbsp; &nbsp;&nbsp; &nbsp;具有类型检查功能<br>&nbsp; &nbsp;&nbsp; &nbsp;需要虚函数的支持<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">static_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0x12345</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;i;</span><br><span class="line">    <span class="keyword">char</span>* pc = &amp;c;</span><br><span class="line">    </span><br><span class="line">    c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br><span class="line">    pc = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(pi); <span class="comment">//ERROR 不能用于指针间的转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">const_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; k = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(j);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; y = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> z = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(x); <span class="comment">//ERROR 目标类型必须是引用或者指针</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k = %d\n&quot;</span>, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">    </span><br><span class="line">    y = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;x = %p\n&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;y = %p\n&quot;</span>, &amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinterpret_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;i;</span><br><span class="line">    <span class="keyword">char</span>* pc = &amp;c;</span><br><span class="line">    </span><br><span class="line">    pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(pi);</span><br><span class="line">    pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pc);</span><br><span class="line">    pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(i);   </span><br><span class="line">    c = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>&gt;(i); <span class="comment">// ERROR 指针与指针或指针与整数间的转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamic_cast_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;i;</span><br><span class="line">    <span class="keyword">char</span>* pc = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">char</span>*&gt;(pi); <span class="comment">//ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    static_cast_demo();</span><br><span class="line">    const_cast_demo();</span><br><span class="line">    reinterpret_cast_demo();</span><br><span class="line">    dynamic_cast_demo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于const的疑问"><a href="#关于const的疑问" class="headerlink" title="关于const的疑问"></a><div align=center>关于const的疑问</h1><h2 id="1-const常量的辨别标准"><a href="#1-const常量的辨别标准" class="headerlink" title="1.const常量的辨别标准"></a>1.const常量的辨别标准</h2>在<strong>编译期间不能直接确定初始值的 const 标识符</strong>，都会被做只读变量处理<br>只有<strong>字面量初始化</strong>的 const常量才会进入符号表<br>使用其<strong>他变量初始化的 const常量仍然是只读变量</strong><br>被<strong>volatile修饰的 const常量</strong>不会进入符号表<br>const引用的类型与初始化变量的类型<br>&nbsp; &nbsp;&nbsp; &nbsp;相同：初始化变量成为只读变量<br>&nbsp; &nbsp;&nbsp; &nbsp;不同：生成一个新的只读变量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">1</span>;      <span class="comment">//常量值进入符号表，字面量初始化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;    <span class="comment">//只读变量，相同类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>&amp; nrx = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(rx);  <span class="comment">//普通变量</span></span><br><span class="line">    </span><br><span class="line">    nrx = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);         <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rx = %d\n&quot;</span>, rx);       <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nrx = %d\n&quot;</span>, nrx);     <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;x = %p\n&quot;</span>, &amp;x);       <span class="comment">// 0xbf8e8a88</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;rx = %p\n&quot;</span>, &amp;rx);     <span class="comment">// 0xbf8e8a88</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;nrx = %p\n&quot;</span>, &amp;nrx);   <span class="comment">// 0xbf8e8a88</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">2</span>;       <span class="comment">//只读变量</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;y);  </span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);         <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);         <span class="comment">// 0xbf8e8a7c</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> z = y;               <span class="comment">//只读变量</span></span><br><span class="line">    </span><br><span class="line">    p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;z);</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = %d\n&quot;</span>, z);        <span class="comment">// 7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);        <span class="comment">// 0xbf8e8a74</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; rc = c;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; trc = c;           <span class="comment">//新的只读变量</span></span><br><span class="line">    </span><br><span class="line">    rc = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %c\n&quot;</span>, c);        <span class="comment">// C = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rc = %c\n&quot;</span>, rc);      <span class="comment">// rc = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;trc = %c\n&quot;</span>, trc);    <span class="comment">// trc = c</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-引用与指针"><a href="#2-引用与指针" class="headerlink" title="2.引用与指针"></a>2.引用与指针</h2></li>
<li><strong>指针</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;指针是一个变量，值为一个内存地址，不需要初始化，可以保存不同的地址，通过指针可以访问对应内存地址中的值，指针可以被const修饰成为常量或者只读变量</li>
<li><strong>引用</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;引用只是一个变量的新名字，对引用的操作（赋值，取地址等）都会传递到代表的变量上；const引用使其代表的变量具有只读属性；引用必须在定义时初始化，之后无法代表其他变量</li>
<li><strong>从c++语言的角度来看</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;引用与指针没有任何关系；引用是变量的新名字，操作引用就是操作对应的变量</li>
<li><strong>从c++编译器的角度来看</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;为了支持新概念“引用”必须要有一个有效的方案；在编译器内部，使用指针常量来实现“引用”；因此，“引用”在定义时必须初始化</li>
<li><strong>在工程项目开发中</strong><br>&nbsp; &nbsp;&nbsp; &nbsp;当c++编译时，直接站在使用的角度看待引用，与指针毫无关系，引用就是变量的别名,当对c++代码进行调试分析时，一些特殊情况，可以考虑站在c++编译器角度来看待引用</li>
<li><strong>C++不支持引用数组</strong><br>数组的本质为一段连续的内存空间，引用会打断这种连续性，c++为了更好的兼容c语言因此，c++不支持引用数组<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SV</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; x;</span><br><span class="line">    <span class="keyword">int</span>&amp; y;</span><br><span class="line">    <span class="keyword">int</span>&amp; z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>* pc = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>);</span><br><span class="line">    SV sv = &#123;a, b, *pc&#125;;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="built_in">array</span>[] = &#123;a, b, *pc&#125;; <span class="comment">// &amp;array[1] - &amp;array[0] = ?  Expected ==&gt; 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;sv.x = %p\n&quot;</span>, &amp;sv.x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;sv.y = %p\n&quot;</span>, &amp;sv.y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;sv.z = %p\n&quot;</span>, &amp;sv.z);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进阶面向对象"><a href="#进阶面向对象" class="headerlink" title="进阶面向对象"></a><div align=center>进阶面向对象</h1><h2 id="1-面向对象的基本概念"><a href="#1-面向对象的基本概念" class="headerlink" title="1.面向对象的基本概念"></a>1.面向对象的基本概念</h2>面向对象的意义在于，将日常生活中习惯的思维方式引入程序设计中，将需求中的概念直观映射到解决方案中，以模块为中心构建可复用的软件系统，提高软件产品的可维护性<h2 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2.类和对象"></a>2.类和对象</h2></li>
<li>*类：**指的一类的事物，是一个抽象的概念，类是一种模型，这种模型可以创建出不同的对象实体</li>
<li>*对象：**指的是属于某个类的具体实体，对象实体是类模型的一个具体实例<blockquote>
<p>一个类可以有很多对象，而一个 对象必然属于某个类</p>
</blockquote>
</li>
</ul>
<h2 id="3-类和对象的意义"><a href="#3-类和对象的意义" class="headerlink" title="3.类和对象的意义"></a>3.类和对象的意义</h2><p>类用于描述一类事物所特有的<font color=#DC143C size=3>属性和行为</font><br>&nbsp; &nbsp;&nbsp; &nbsp;如：电脑拥有cpu，内存和硬盘并且可以开机和运行程序<br>对象是具体的事物，拥有<font color=#DEB887 size=3>所属类中描述的一切行为和属性</font><br>&nbsp; &nbsp;&nbsp; &nbsp;如：每一只老虎都有不同的体重，不同的食量不同的性格</p>
<h2 id="4-一些有趣的问题"><a href="#4-一些有趣的问题" class="headerlink" title="4.一些有趣的问题"></a>4.一些有趣的问题</h2><p>类一定存在实际的对象吗？<br>不一定，恐龙对象不存在</p>
<p>类的对象数目是确定的吗？<br>不确定，老虎的数目不确定，皇帝类每一时期只有一个</p>
<p>类一定都是源于生活中吗？<br>不一定</p>
<p>类都是独立的吗？类之间存在关系吗？<br>不独立，类之间存在相互关系</p>
<p>对象实例一定只属于一个类吗？<br>不一定</p>
<p>对象实例可能完全相同吗？<br>不确定</p>
<h2 id="5-类之间的基本关系"><a href="#5-类之间的基本关系" class="headerlink" title="5.类之间的基本关系"></a>5.类之间的基本关系</h2><p>继承：从已存在的类细分出来的类和原类之间具有继承关系（is-a）；继承的类（子类）拥有原类（父类的所有属性和行为）<br>组合：一些类的存在必须依赖于其他的类，这种关系叫组合；组合的类在某一局部上由其他的类组成，将其他类的对象当做当前类的成员使用，当前类的对象与成员对象的生命周期相同，成员对象在用法上与普通对象完全一致</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Biology</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> living;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> :</span> Biology &#123;</span><br><span class="line">    <span class="keyword">bool</span> movable;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findFood</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span> :</span> Biology &#123;</span><br><span class="line">    <span class="keyword">bool</span> growable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Beast</span> :</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> :</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类与封装的概念"><a href="#类与封装的概念" class="headerlink" title="类与封装的概念"></a><div align=center>类与封装的概念</h1><h2 id="1-类通常分为两个部分"><a href="#1-类通常分为两个部分" class="headerlink" title="1.类通常分为两个部分"></a>1.类通常分为两个部分</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;类的实现细节，当创建类时，才需要考虑其内部实现细节；类的使用方式，当使用类时，不需要考虑其内部的实现细节</p>
<h2 id="2-类的封装"><a href="#2-类的封装" class="headerlink" title="2.类的封装"></a>2.类的封装</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;根据经验：并不是类的每个属性都是对外公开的；女孩不希望外人知道自己的体重和年龄；男孩子不希望外人知道自己的身高和收入。而一些类的属性是对外公开的；人的姓名，学历，国籍，等。因此必须在类的表示法中定义属性和行为的公开级别，类似于文件系统中的文件的权限</p>
<h2 id="3-C-中类的封装"><a href="#3-C-中类的封装" class="headerlink" title="3.C++中类的封装"></a>3.C++中类的封装</h2><p>成员变量：C++中用于表示类属性的变量<br>成员函数：C++中用于表示类行为的函数<br>C++中可以给成员变量和成员函数定义访问级别<br>&nbsp; &nbsp;&nbsp; &nbsp;Public：成员变量和成员函数可以在类的内部和外界访问调用<br>&nbsp; &nbsp;&nbsp; &nbsp;Private：成员变量和成员函数只能在类的内部被访问和调用</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Biology</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> living;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> :</span> Biology </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> movable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span> :</span> Biology </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> growable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Beast</span> :</span> Animal </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> :</span> Animal </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m sleeping...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m working...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Girl</span> :</span> Human</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        age = <span class="number">22</span>;</span><br><span class="line">        weight = <span class="number">48</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a girl, I&#x27;m %d years old.\n&quot;</span>, age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;My weight is %d kg.\n&quot;</span>, weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Boy</span> :</span> Human</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> salary;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">height</span> = <span class="number">175</span>;</span><br><span class="line">        salary = <span class="number">9000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a boy, my height is %d cm.\n&quot;</span>, <span class="built_in">height</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;My salary is %d RMB.\n&quot;</span>, salary);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Girl g;</span><br><span class="line">    Boy b;</span><br><span class="line">    </span><br><span class="line">    g.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    b.age = <span class="number">19</span>;</span><br><span class="line">    b.weight = <span class="number">120</span>;</span><br><span class="line">    <span class="comment">//b.height = 180;  //ERROR 私有成员无法访问</span></span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-类成员的作用域"><a href="#4-类成员的作用域" class="headerlink" title="4.类成员的作用域"></a>4.类成员的作用域</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;类成员的作用域都在类的内部外部无法直接访问；成员函数可以直接访问成员变量和调用成员函数；类的外部可以通过类变量访问public成员；类成员的作用域与访问级别没有关系（针对于外部访问）；C++中struct定义的类中的所有成员默认为public<br>&nbsp; &nbsp;&nbsp; &nbsp;想要访问类的成员变量或者成员函数都必须通过类的对象来进行，有了类的对像之后就可以访问类的成员变量和成员函数，是否访问成功还得看这个变量或者成员函数的访问级别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i = <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    Test test;</span><br><span class="line">    </span><br><span class="line">    test.j = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);              <span class="comment">// i = 2;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;::i = %d\n&quot;</span>, ::i);          <span class="comment">// ::i = 1;</span></span><br><span class="line">    <span class="comment">// printf(&quot;test.i = %d\n&quot;, test.i);    // Error</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test.j = %d\n&quot;</span>, test.j);    <span class="comment">// test.j = 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test.getI() = %d\n&quot;</span>, test.getI());  <span class="comment">// test.getI() = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的真正形态"><a href="#类的真正形态" class="headerlink" title="类的真正形态"></a><div align=center>类的真正形态</h1><h2 id="1-C-使用class关键字定义类"><a href="#1-C-使用class关键字定义类" class="headerlink" title="1.C++使用class关键字定义类"></a>1.C++使用class关键字定义类</h2><p>在用struct定义类时，所有成员的默认访问级别为public；在使用class定义类时，所有成员的默认访问级别为private</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// defualt to public</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// defualt to public</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// defualt to private</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// defualt to private</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    </span><br><span class="line">    a.i = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a.getI() = %d\n&quot;</span>, a.getI());</span><br><span class="line">    </span><br><span class="line">    b.i = <span class="number">4</span>;                                 <span class="comment">//ERROR</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b.getI() = %d\n&quot;</span>, b.getI());     <span class="comment">//ERROR</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-C-的类支持声明和实现的分离"><a href="#2-C-的类支持声明和实现的分离" class="headerlink" title="2.C++的类支持声明和实现的分离"></a>2.C++的类支持声明和实现的分离</h2><p>将类的实现和定义分开；.h头文件中只有类的声明，成员变量和成员函数的声明；.cpp源文件中完成类的其他实现，成员函数的具体实现</p>
<h2 id="3-类实例"><a href="#3-类实例" class="headerlink" title="3.类实例"></a>3.类实例</h2><p>需求：开发一个用于四则运算的的类<br>提供setOperator函数设置运算类型<br>提供setParamater函数设置运算参数<br>提供result函数进行运算<br>&nbsp; &nbsp;&nbsp; &nbsp;其返回值表示运算的合法性<br>&nbsp; &nbsp;&nbsp; &nbsp;通过引用参数返回结果</p>
<ul>
<li><p><strong>头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _OPERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OPERATOR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> mOp;</span><br><span class="line">    <span class="keyword">double</span> mP1;</span><br><span class="line">    <span class="keyword">double</span> mP2;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">setOperator</span><span class="params">(<span class="keyword">char</span> op)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(<span class="keyword">double</span> p1, <span class="keyword">double</span> p2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">result</span><span class="params">(<span class="keyword">double</span>&amp; r)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>类函数的具体实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Operator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Operator::setOperator</span><span class="params">(<span class="keyword">char</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>( (op == <span class="string">&#x27;+&#x27;</span>) || (op == <span class="string">&#x27;-&#x27;</span>) || (op == <span class="string">&#x27;*&#x27;</span>) || (op == <span class="string">&#x27;/&#x27;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">        mOp = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Operator::setParameter</span><span class="params">(<span class="keyword">double</span> p1, <span class="keyword">double</span> p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mP1 = p1;</span><br><span class="line">    mP2 = p2;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Operator::result</span><span class="params">(<span class="keyword">double</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">switch</span>( mOp )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>( (<span class="number">-0.000000001</span> &lt; mP2) &amp;&amp; (mP2 &lt; <span class="number">0.000000001</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = mP1 / mP2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            r = mP1 + mP2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            r = mP1 * mP2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            r = mP1 - mP2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>调用类的功能</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Operator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Operator op;</span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    op.setOperator(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    op.setParameter(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( op.result(r) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r = %lf\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calculate error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对象的构造"><a href="#对象的构造" class="headerlink" title="对象的构造"></a><div align=center>对象的构造</h1><h2 id="1、对象的本质"><a href="#1、对象的本质" class="headerlink" title="1、对象的本质"></a>1、对象的本质</h2><p>从程序设计的角度，对象只是变量，因此在<strong>栈</strong>上创建对象时，成员变量初始值为<strong>随机值</strong>、在<strong>堆</strong>上创建对象时，成员变量的初始值为<strong>随机值</strong>、在<strong>全局静态存储区</strong>创建对象时，成员变量初始值为<strong>0</strong></p>
</li>
<li><p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test gt; <span class="comment">//全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.i = %d\n&quot;</span>,gt.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.j = %d\n&quot;</span>,gt.getJ());</span><br><span class="line"></span><br><span class="line">	Test t1; <span class="comment">//局部对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d\n&quot;</span>,t1.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.j = %d\n&quot;</span>,t1.getJ());</span><br><span class="line"></span><br><span class="line">	Test *pt = <span class="keyword">new</span> Test; <span class="comment">//堆空间里面的零时对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;i = %d\n&quot;</span>,pt-&gt;getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;j = %d\n&quot;</span>,pt-&gt;getJ());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pt;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译结果：</span><br><span class="line">gt.i = <span class="number">0</span></span><br><span class="line">gt.j = <span class="number">0</span></span><br><span class="line">t1.i = <span class="number">-858993460</span></span><br><span class="line">t1.j = <span class="number">-858993460</span></span><br><span class="line">pt-&gt;i = <span class="number">-842150451</span></span><br><span class="line">pt-&gt;j = <span class="number">-842150451</span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象的初始化"><a href="#2、对象的初始化" class="headerlink" title="2、对象的初始化"></a>2、对象的初始化</h2></li>
</ul>
<p>生活中的对象都是在初始化之后上市的，初始化状态（出厂设置）是对象普遍存在的一个状态。c++中可以定义与类名相同的特殊成员函数，这种特殊的成员函数叫做构造函数。通过构造函数可以对对象进行初始化。</p>
<h2 id="3、-构造函数"><a href="#3、-构造函数" class="headerlink" title="3、 构造函数"></a>3、 构造函数</h2><p>构造函数与类名相同并且没有返回值、构造函数没有任何返回类型的声明、构造函数在对象定义时自动被调用</p>
<p><strong>编程实验</strong><br>通过构造函数初始化对象的成员变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">	Test() <span class="comment">//构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		j = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test gt; <span class="comment">//全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.i = %d\n&quot;</span>,gt.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;gt.j = %d\n&quot;</span>,gt.getJ());</span><br><span class="line"></span><br><span class="line">	Test t1; <span class="comment">//局部对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d\n&quot;</span>,t1.getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.j = %d\n&quot;</span>,t1.getJ());</span><br><span class="line"></span><br><span class="line">	Test *pt = <span class="keyword">new</span> Test; <span class="comment">//堆空间里面的零时对象</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;i = %d\n&quot;</span>,pt-&gt;getI());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pt-&gt;j = %d\n&quot;</span>,pt-&gt;getJ());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pt;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">gt.i = <span class="number">1</span></span><br><span class="line">gt.j = <span class="number">2</span></span><br><span class="line">t1.i = <span class="number">1</span></span><br><span class="line">t1.j = <span class="number">2</span></span><br><span class="line">pt-&gt;i = <span class="number">1</span></span><br><span class="line">pt-&gt;j = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="1）带有参数的构造函数"><a href="#1）带有参数的构造函数" class="headerlink" title="1）带有参数的构造函数"></a>1）带有参数的构造函数</h3><p>构造函数可以根据需要定义参数<br>一个类可以存在多个重载的构造函数<br>构造函数的重载遵循C++重载的规则</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(int v)</span><br><span class="line">	&#123;</span><br><span class="line">		// use v to initialize member</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象定义和对象声明不同<br>对象定义-申请对象的空间并调用构造函数<br>对象声明-告诉编译器存在这样一个对象</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test </span>t; // 定义对象并调用构造函数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//告诉编译器存在名为 t 的 Test 对象</span><br><span class="line">	extern Test t;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>编程实验</strong><br>构造函数的自动调用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Test(<span class="keyword">int</span> v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(int v)\n&quot;</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Test t;			<span class="comment">//调用Test()</span></span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">//调用Test(int v)</span></span><br><span class="line">	Test t2 = <span class="number">1</span>;	<span class="comment">//调用Test(int v)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Test()</span><br><span class="line">Test(<span class="keyword">int</span> v)</span><br><span class="line">Test(<span class="keyword">int</span> v)</span><br></pre></td></tr></table></figure>
小贴士：<br>赋值与初始化是不同的<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;	<span class="comment">//用1初始化i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">//用100初始化j</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;		<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="2）构造函数的调用"><a href="#2）构造函数的调用" class="headerlink" title="2）构造函数的调用"></a>2）构造函数的调用</h3></li>
</ul>
<p>手工调用构造函数初始化对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span><br><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">int</span> m_value;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Test()</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">		m_value = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Test(int v), v = %d\n&quot;</span>,v);</span><br><span class="line">		m_value = v;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">int</span> get<span class="constructor">Value()</span></span><br><span class="line">	&#123;</span><br><span class="line">		return m_value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	Test ta<span class="literal">[<span class="number">3</span>]</span> = &#123;<span class="constructor">Test()</span>,<span class="constructor">Test(1)</span>,<span class="constructor">Test(2)</span>&#125;; <span class="comment">// 手动调用构造函数初始化对象数组的成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;ta[%d].m_value = %d\n&quot;</span>,i,ta<span class="literal">[<span class="identifier">i</span>]</span>.get<span class="constructor">Value()</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test t = <span class="constructor">Test(3)</span>;	<span class="comment">//手动调用构造函数初始化对象</span></span><br><span class="line"></span><br><span class="line">	printf(<span class="string">&quot;t.m_value = %d\n&quot;</span>,t.get<span class="constructor">Value()</span>);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="constructor">Test()</span></span><br><span class="line"><span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span>, v = <span class="number">1</span></span><br><span class="line"><span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span>, v = <span class="number">2</span></span><br><span class="line">ta<span class="literal">[<span class="number">0</span>]</span>.m_value = <span class="number">0</span></span><br><span class="line">ta<span class="literal">[<span class="number">1</span>]</span>.m_value = <span class="number">1</span></span><br><span class="line">ta<span class="literal">[<span class="number">2</span>]</span>.m_value = <span class="number">2</span></span><br><span class="line"><span class="constructor">Test(<span class="params">int</span> <span class="params">v</span>)</span>, v = <span class="number">3</span></span><br><span class="line">t.m_value = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="3）小实例"><a href="#3）小实例" class="headerlink" title="3）小实例"></a>3）小实例</h3><p>开发一个数组类结局原生数组的安全性问题<br>-提供函数获取数组长度<br>-提供函数获取数组元素<br>-提供函数设置数组元素</p>
<ul>
<li><strong>头文件</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><strong>函数功能实现</strong><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;StdAfx.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;intarry.h&quot;</span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="built_in">new</span> <span class="type">int</span>[len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> IntArry::length()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> IntArry::<span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span>&amp; <span class="keyword">value</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret = ( <span class="number">0</span>&lt;= <span class="keyword">index</span>) &amp;&amp; (<span class="keyword">index</span> &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">value</span> = m_pointer[<span class="keyword">index</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> IntArry::<span class="keyword">set</span>(<span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> <span class="keyword">value</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret = ( <span class="number">0</span>&lt;= <span class="keyword">index</span>) &amp;&amp; (<span class="keyword">index</span> &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[<span class="keyword">index</span>] = <span class="keyword">value</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IntArry::free()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>主函数测试</strong><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="function">IntArry <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">set</span>(i,i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(a.<span class="built_in">get</span>(i,value))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a.<span class="built_in">free</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="4、特殊的构造函数"><a href="#4、特殊的构造函数" class="headerlink" title="4、特殊的构造函数"></a>4、特殊的构造函数</h2></li>
</ul>
<h3 id="1）无惨构造函数"><a href="#1）无惨构造函数" class="headerlink" title="1）无惨构造函数"></a>1）无惨构造函数</h3><p>没有参数的构造函数，当类中<strong>没有定义任意构造函数</strong>时，编译器<strong>默认提供一个无参拷贝构造函数</strong>，并且其函数体为空</p>
<h3 id="2）拷贝构造函数"><a href="#2）拷贝构造函数" class="headerlink" title="2）拷贝构造函数"></a>2）拷贝构造函数</h3><p>参数为 const class_name&amp; 的构造函数，当类中<strong>没有定义拷贝构造函数</strong>时，<strong>编译器默认提供一个拷贝构造函数</strong>，简单的进行成员变量的值复制(浅拷贝)。</p>
<blockquote>
<p>拷贝构造函数的意义<br>兼容C语言的初始化方式，初始化行为能够符合预期的逻辑。</p>
</blockquote>
<h4 id="a-浅拷贝"><a href="#a-浅拷贝" class="headerlink" title="a. 浅拷贝"></a>a. 浅拷贝</h4><p>拷贝后对象的物理状态相同，编译器提供的拷贝构造函数只进行浅拷贝</p>
<ul>
<li><strong>编程实验</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">getP</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line">	Test(<span class="keyword">int</span> v)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		j = <span class="number">2</span>;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">		*p = v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Test t2 = t1;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d, t1.j = %d,t1.p = %p\n&quot;</span>,t1.getI(),t1.getJ(),t1.getP());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t2.i = %d, t2.j = %d,t2.p = %p\n&quot;</span>,t2.getI(),t2.getJ(),t2.getP());</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">free</span>();</span><br><span class="line">	<span class="comment">//t2.free(); //多次释放造成内存泄漏 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">t1.i = <span class="number">1</span>, t1.j = <span class="number">2</span>,t1.p = <span class="number">01323488</span></span><br><span class="line">t2.i = <span class="number">1</span>, t2.j = <span class="number">2</span>,t2.p = <span class="number">01323488</span></span><br></pre></td></tr></table></figure>
运行结果分析，函数中没有拷贝构造函数因此，默认提供了一个拷贝构造函数如下<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Test(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	i = t.i;</span><br><span class="line">	j = t.j;</span><br><span class="line">	p = t.p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因此得到的指针t1.p 与 t2.p指向同一个内存空间，对象 t2 并没有新生成一个堆空间的int大小的内存。所以分别运行两个对象的free释放函数会造成内存空间的重复释放，导致内存泄漏，编译报错。</li>
</ul>
<h4 id="b-深拷贝"><a href="#b-深拷贝" class="headerlink" title="b. 深拷贝"></a>b. 深拷贝</h4><p>拷贝后对象的逻辑状态相同</p>
<ul>
<li><strong>编程实验</strong><br>手动提供拷贝构造函数实现深拷贝<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> j;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">getP</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line"></span><br><span class="line">	Test(<span class="keyword">int</span> v)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">1</span>;</span><br><span class="line">		j = <span class="number">2</span>;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">		*p = v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test(<span class="keyword">const</span> Test&amp; t) <span class="comment">//手动提供构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		i = t.i;</span><br><span class="line">		j = t.j;</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">		*p = *t.p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Test t2 = t1;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.i = %d, t1.j = %d,t1.p = %p\n&quot;</span>,t1.getI(),t1.getJ(),t1.getP());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t2.i = %d, t2.j = %d,t2.p = %p\n&quot;</span>,t2.getI(),t2.getJ(),t2.getP());</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">free</span>();</span><br><span class="line">	t2.<span class="built_in">free</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">t1.i = <span class="number">1</span>, t1.j = <span class="number">2</span>,t1.p = <span class="number">00</span>CF3488</span><br><span class="line">t2.i = <span class="number">1</span>, t2.j = <span class="number">2</span>,t2.p = <span class="number">00</span>CF34C8</span><br></pre></td></tr></table></figure>
第24行手动提供拷贝构造函数实现深拷贝，通过28,29行操作实现深拷贝</li>
</ul>
<h3 id="3）什么时候需要深拷贝"><a href="#3）什么时候需要深拷贝" class="headerlink" title="3）什么时候需要深拷贝"></a>3）什么时候需要深拷贝</h3><p>成员指向了动态内存空间<br>成员打开了外存中的文件<br>成员使用了系统中的网络端口</p>
<h3 id="4）数组类的改进"><a href="#4）数组类的改进" class="headerlink" title="4）数组类的改进"></a>4）数组类的改进</h3><p><strong>intarry.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	IntArry(<span class="keyword">const</span> IntArry&amp; obj); <span class="comment">//添加拷贝构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>intarry.c文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">const</span> IntArry&amp; obj) <span class="comment">//手动实现深拷贝</span></span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = obj.m_pointer[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = obj.m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntArry::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		value = m_pointer[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IntArry::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试函数</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">IntArry <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">set</span>(i, i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(a.<span class="built_in">get</span>(i, value))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	IntArry b = a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; b.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(b.<span class="built_in">get</span>(i, value))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;b[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a.<span class="built_in">free</span>();</span><br><span class="line">	b.<span class="built_in">free</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h1><p>用于初始化类对象中的成员变量</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ClassName:</span>:ClassName():</span><br><span class="line">	m1(<span class="built_in">v1</span>), m2(<span class="built_in">v1</span>,<span class="built_in">v2</span>), m3(<span class="built_in">v3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// some other initialize opreration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1、初始化列表的初始顺序"><a href="#1、初始化列表的初始顺序" class="headerlink" title="1、初始化列表的初始顺序"></a>1、初始化列表的初始顺序</h2><p>-成员的初始化顺序与成员的申明顺序相同<br>-成员的初始化顺序与初始化列表中的位置无关<br>-初始化列表先于构造函数的函数体执行</p>
<p><strong>编程实验</strong><br>验证初始化列表的初始顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Value(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Value m2;  <span class="comment">//初始化列表先初始化这个变量</span></span><br><span class="line">	Value m3;</span><br><span class="line">	Value m1; <span class="comment">//初始化列表最后初始化这个变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test() : m1(<span class="number">1</span>),m2(<span class="number">2</span>),m3(<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getCI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ci;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">Test</span><br></pre></td></tr></table></figure>
<h2 id="2、类中的const成员"><a href="#2、类中的const成员" class="headerlink" title="2、类中的const成员"></a>2、类中的const成员</h2><p>类中的const成员会被分配内存空间<br>类中的const成员的本质是只读变量<br>类中的const成员只能在初始化列表中指定初始化值<br>编译器无法直接得到const成员的初始值，因此无法进入符号表成为真正意义上的常量</p>
<p><strong>编程实验</strong><br>类中的const成员变量本质为只读变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test() : ci(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getCI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ci;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCI</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;ci); <span class="comment">//通过指针修改ci的值</span></span><br><span class="line"></span><br><span class="line">		*p = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t.ci = %d\n&quot;</span>,t.getCI());</span><br><span class="line"></span><br><span class="line">	t.setCI(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t.ci = %d\n&quot;</span>,t.getCI());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">t.ci = <span class="number">0</span></span><br><span class="line">t.ci = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化与赋值不同<br>初始化：对<strong>正在创建的对象</strong>进行初始值设置<br>赋值：对<strong>已经存在的对象</strong>进行值的设置</p>
</blockquote>
<h1 id="对象的构造顺序"><a href="#对象的构造顺序" class="headerlink" title="对象的构造顺序"></a>对象的构造顺序</h1><p><strong>1. 局部对象</strong><br>当程序执行流到达对象定义的语句时进行构造<br><strong>2. 堆对象的构造顺序</strong><br>堆对象的构造与new关键字以及程序执行流有关<br><strong>3. 全局对象的构造顺序</strong><br>对象的构造顺序是不确定的，不同的编译器使用不同规则的构造顺序</p>
<blockquote>
<p>尽量避免使用全局变量与全局对象，以及全局对象之间的依赖</p>
</blockquote>
<h1 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h1><p>C++类中定义的一个特殊的清理函数，析构函数的功能与构造函数相反</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">~ClassName()</span><br></pre></td></tr></table></figure>
<p>-析构函数没有参数也没有返回值类型声明<br>-析构函数在对象销毁值自动被调用</p>
<p><strong>编程实验</strong><br>验证析构函数的自动调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#123; <span class="comment">//定义对象的作用域</span></span><br><span class="line">		Test t; <span class="comment">// 对象被销毁后自动调用析构函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>析构函数的定义准则<br>当类中定义了构造函数，并且构造函数使用了系统资源（内存申请，文件打开，等）则需要自定义析构函数<br>析构函数时对象释放系统资源的保障</p>
</blockquote>
<h1 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h1><h2 id="1、临时对象的产生"><a href="#1、临时对象的产生" class="headerlink" title="1、临时对象的产生"></a>1、临时对象的产生</h2><p>直接调用构造函数将产生一个<strong>临时对象</strong><br>临时对象的<strong>生命周期只有一条语句的时间</strong><br>临时对象的作用于<strong>只在一条语句中</strong><br>临时对象时c++中<strong>值得谨惕</strong>的灰色地带</p>
<p><strong>编程实验</strong><br>验证临时对象</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		Test(<span class="number">1</span>);<span class="comment">//直接调用构造函数产生零时对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Test t; </span><br><span class="line">	t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">mi = <span class="number">-858993460</span></span><br></pre></td></tr></table></figure>
<p>运行结果分析：本来第16行调用构造函数的目的是初始化mi，使得mi的值为1，但运行结果为一个随机值，产生的原因就是16行直接调用有参数的构造函数得到了一个临时对象。16行的临时对象的生命周期只有16行这条语句，过了这条语句之后这个临时对象就被析构。这个临时对象同时没有名字，所以临时对象的作用域也只有这一条语句。因此16行这条语句没有半毛钱作用。16行代码等价于一条空语句。</p>
<p>解决方案，提供一个私有的初始化函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//提供私有的init函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mi = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		init(<span class="number">1</span>); <span class="comment">//调用私有的init初始化函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Test t; </span><br><span class="line">	t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">mi = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>深入验证临时对象</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mi = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(int i)\n&quot;</span>);</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">		init(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main begin \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Test().<span class="built_in">print</span>();  <span class="comment">//直接调用构造函数产生临时对象 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	Test(<span class="number">3</span>).<span class="built_in">print</span>(); <span class="comment">//直接调用构造函数产生临时对象 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main end... \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">Main <span class="built_in">begin</span></span><br><span class="line">Test()</span><br><span class="line">mi = <span class="number">1</span></span><br><span class="line">~Test()</span><br><span class="line"></span><br><span class="line">Test(<span class="keyword">int</span> i)</span><br><span class="line">mi = <span class="number">3</span></span><br><span class="line">~Test()</span><br><span class="line">Main <span class="built_in">end</span>...</span><br></pre></td></tr></table></figure>
<p>运行结果分析：37行与39行直接调用构造函数产生临时对象，因此Test()/Test(3)为临时生成的对象，可以直接调用他们的成员函数print。同时也验证了临时对象的生命周期为一条语句的时间。</p>
<h2 id="2、临时对象的优化"><a href="#2、临时对象的优化" class="headerlink" title="2、临时对象的优化"></a>2、临时对象的优化</h2><p>现代C++编译器在不影响最终执行结果的前提下，会尽力减少临时对象的产生</p>
<p>代码分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mi = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(int i)\n&quot;</span>);</span><br><span class="line">		mi = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">		init(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mi = %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">	Test(<span class="keyword">const</span> Test&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		mi = obj.mi;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Test(const Test&amp; obj): %d\n&quot;</span>,mi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Test(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main begin \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Test t = Test(<span class="number">1</span>);	<span class="comment">// ==&gt; Test t = 1;</span></span><br><span class="line"></span><br><span class="line">	Test t3 = func();	<span class="comment">// ==&gt; Test t3 = Test(3) ==&gt; Test t3 = 3;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Main end... \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第47,49行运行个过程应该如下</p>
<ol>
<li>生成临时对象</li>
<li>用临时对象初始化t对象</li>
<li>调用拷贝构造函数</li>
</ol>
<p>但实际的运行结果发现并没有拷贝构造函数的调用，产生这个结果的原因就是编译器为了杜绝临时对象的产生因此对代47,49行码进行了优化，优化后的代码如下</p>
</blockquote>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test </span>t = 1;</span><br><span class="line"><span class="keyword">Test </span>t3 = 3;</span><br></pre></td></tr></table></figure>
<p>所以代码没有调用拷贝构造函数</p>
<p><strong>注意：</strong><br>临时对象时性能的瓶颈，也是bug的来源之一<br>实际工程开发中需要人为的避开临时对象</p>
<h1 id="经典问题分析"><a href="#经典问题分析" class="headerlink" title="经典问题分析"></a>经典问题分析</h1><h2 id="1、构造函数与析构函数的调用顺序"><a href="#1、构造函数与析构函数的调用顺序" class="headerlink" title="1、构造函数与析构函数的调用顺序"></a>1、构造函数与析构函数的调用顺序</h2><h3 id="1）单个对象创建时"><a href="#1）单个对象创建时" class="headerlink" title="1）单个对象创建时"></a>1）单个对象创建时</h3><ol>
<li>调用父类的构造过程</li>
<li>调用成员变量的构造函数（调用顺序与声明顺序相同）</li>
<li>调用自身类的构造函数</li>
</ol>
<p>析构函数与对应构造函数的调用顺序相反</p>
<p><strong>编程实验</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span><br><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Member</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	const <span class="built_in">char</span>* ms;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Member(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">s</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Member(const char* s): %s\n&quot;</span>,s);</span><br><span class="line">		ms = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="constructor">Member()</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;~Member(): %s\n&quot;</span>,ms);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Member mA;</span><br><span class="line">	Member mB;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Test()</span>: m<span class="constructor">B(<span class="string">&quot;mB&quot;</span>)</span>, m<span class="constructor">A(<span class="string">&quot;mA&quot;</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="constructor">Test()</span></span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">	Test t;</span><br><span class="line">	&#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="constructor">Member(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">s</span>)</span>: mA</span><br><span class="line"><span class="constructor">Member(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">s</span>)</span>: mB</span><br><span class="line"><span class="constructor">Test()</span></span><br><span class="line">~<span class="constructor">Test()</span></span><br><span class="line">~<span class="constructor">Member()</span>: mB</span><br><span class="line">~<span class="constructor">Member()</span>: mA</span><br></pre></td></tr></table></figure>
<h3 id="2）栈对象和全局对象"><a href="#2）栈对象和全局对象" class="headerlink" title="2）栈对象和全局对象"></a>2）栈对象和全局对象</h3><p>对于栈对象和全局对象，类似于入栈于出栈的顺序，最后构造的对象被最先析构</p>
<h3 id="3）堆对象"><a href="#3）堆对象" class="headerlink" title="3）堆对象"></a>3）堆对象</h3><p>堆对象的构造发生在new关键字调用的时候，析构则是发生在使用delete的时候，与delete的使用顺序有关。</p>
<h2 id="2、const对象"><a href="#2、const对象" class="headerlink" title="2、const对象"></a>2、const对象</h2><p>const能够修饰对象<br>const修饰的对象为只读对象<br>只读对象的成员变量不允许改变<br>只读对象是编译阶段的概念，运行期无效</p>
<h3 id="1）C-中的const成员函数"><a href="#1）C-中的const成员函数" class="headerlink" title="1）C++中的const成员函数"></a>1）C++中的const成员函数</h3><p>const对象<strong>只能调用const的成员函数</strong><br>const成员函数中<strong>只能调用const成员函数</strong><br>const成员函数<strong>不能直接改写成员变量的值</strong></p>
<p>const成员函数的定义</p>
<blockquote>
<p>Type ClassName::function(type p) const</p>
</blockquote>
<p>类中的声明和实际的成员函数中都必须带const关键字</p>
<h2 id="3、对象的构成"><a href="#3、对象的构成" class="headerlink" title="3、对象的构成"></a>3、对象的构成</h2><p>问题：成员函数和成员变量都是隶属于具体的对象吗</p>
<p><strong>从面向对象的角度</strong><br>-对象由属性（成员变量），和方法（成员函数）构成<br><strong>从程序运行角度</strong><br>-对象有由数据和函数组成<br>*数据可以位于栈，堆和全局数据区<br>*函数只能位于代码段</p>
<blockquote>
<p>结论:<br>每一个对象拥有自己独立的属性（成员变量）<br>所有的对象共享创建他的的类的方法（成员函数）<br>方法能够直接访问对象的属性<br>方法中的隐藏参数 this用于指代当前对象</p>
</blockquote>
<ul>
<li><strong>成员函数只有一套，他能直接访问任何所属类对象的成员变量</strong></li>
</ul>
<p><strong>编程实验</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i);</span><br><span class="line">	Test(<span class="keyword">const</span> Test&amp; obj);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMi</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	mi = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">const</span> Test&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	mi = obj.mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test::getMi</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this = %p\n\n&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t1.getMi() = %d\n&quot;</span>,t1.getMi());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;t1 = %p\n&quot;</span>,&amp;t1);</span><br><span class="line">	t1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t2.getMi() = %d\n&quot;</span>,t2.getMi());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;t2 = %p\n&quot;</span>,&amp;t2);</span><br><span class="line">	t2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t3.getMi() = %d\n&quot;</span>,t3.getMi());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;t3 = %p\n&quot;</span>,&amp;t3);</span><br><span class="line">	t3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的静态成员变量与成员函数"><a href="#类的静态成员变量与成员函数" class="headerlink" title="类的静态成员变量与成员函数"></a>类的静态成员变量与成员函数</h1><h2 id="1、类的静态成员变量"><a href="#1、类的静态成员变量" class="headerlink" title="1、类的静态成员变量"></a>1、类的静态成员变量</h2><p>静态成员变量属于整个类所有<br>所有对象共享类的静态成员变量<br>静态成员变量的生命周期不依赖与任何对象<br>可以通过对象名访问公有(public)静态成员变量<br>可以通过类名直接访问公有(public)静态成员变量</p>
<ul>
<li><strong>静态成员变量的特性</strong></li>
</ul>
<p>-在定义时直接通过static关键字修饰<br>-静态成员变量需要在类外单独分配空间<br>-静态成员变量在程序内部位于全局数据区</p>
<ul>
<li><strong>定义静态成员变量的语法规则</strong><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Type</span> <span class="type">ClassName::VarName </span>= value;</span><br></pre></td></tr></table></figure>
<h2 id="2、类的静态成员函数"><a href="#2、类的静态成员函数" class="headerlink" title="2、类的静态成员函数"></a>2、类的静态成员函数</h2></li>
</ul>
<p>静态成员函数是类中特殊的成员函数<br>静态成员函数属于整个类所有<br>可以通过类名直接访问共有静态成员函数<br>可以通过对象名访问公有静态成员函数</p>
<h3 id="1）静态成员函数的定义"><a href="#1）静态成员函数的定义" class="headerlink" title="1）静态成员函数的定义"></a>1）静态成员函数的定义</h3><p>直接通过static关键字修饰生源函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test::func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编程体验</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticSetI</span><span class="params">(Demo&amp; d,<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Demo::getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Demo::staticFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;staticFunc: %s\n&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Demo::staticSetI</span><span class="params">(Demo&amp; d,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	d.i = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Demo::staticFunc(<span class="string">&quot;main begin...&quot;</span>); <span class="comment">//直接通过类名调用静态成员函数</span></span><br><span class="line"></span><br><span class="line">	Demo d;</span><br><span class="line">	d.staticSetI(d,<span class="number">1</span>); <span class="comment">//通过对象名访问静态成员函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;d.i = %d\n&quot;</span>,d.getI());</span><br><span class="line"></span><br><span class="line">	Demo::staticFunc(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">staticFunc: main <span class="built_in">begin</span>...</span><br><span class="line">d.i = <span class="number">1</span></span><br><span class="line">staticFunc: main <span class="built_in">end</span>...</span><br></pre></td></tr></table></figure>
<h3 id="2）普通与静态成员函数对比"><a href="#2）普通与静态成员函数对比" class="headerlink" title="2）普通与静态成员函数对比"></a>2）普通与静态成员函数对比</h3><table>
<thead>
<tr>
<th>静态成员函数vs普通成员函数</th>
<th>静态成员函数</th>
<th>普通成员函数</th>
</tr>
</thead>
<tbody><tr>
<td>所有对象共享</td>
<td><div align=center>Yes</td>
<td><div align=center>Yes</td>
</tr>
<tr>
<td>隐含this指针(函数)</td>
<td><div align=center>No</td>
<td><div align=center>Yes</td>
</tr>
<tr>
<td>访问普通成员变量(函数)</td>
<td><div align=center>No</td>
<td><div align=center>Yes</td>
</tr>
<tr>
<td>通过类名直接调用</td>
<td><div align=center>Yes</td>
<td><div align=center>No</td>
</tr>
<tr>
<td>通过对象名直接调用</td>
<td><div align=center>Yes</td>
<td><div align=center>Yes</td>
</tr>
</tbody></table>
<h2 id="3、小实例"><a href="#3、小实例" class="headerlink" title="3、小实例"></a>3、小实例</h2><p>需求：统计在程序运行期间某个类的对象数目，保证程序的安全性（不能使用全局变量），随时可以获取当前对象的数目</p>
<p><strong>编程实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> mCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		mCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		mCount--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test::mCount = <span class="number">0</span>; <span class="comment">//定义静态成员变量，并初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t0;</span><br><span class="line">	Test t1;</span><br><span class="line">	Test t2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test::mCount = %d\n&quot;</span>,Test::getCount()); <span class="comment">//通过类名访问静态函数得到mCount</span></span><br><span class="line">	</span><br><span class="line">	Test* pt = <span class="keyword">new</span> Test;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test::mCount = %d\n&quot;</span>,Test::getCount());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pt;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test::mCount = %d\n&quot;</span>,Test::getCount());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Test::mCount = <span class="number">3</span></span><br><span class="line">Test::mCount = <span class="number">4</span></span><br><span class="line">Test::mCount = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h1 id="二阶构造模式"><a href="#二阶构造模式" class="headerlink" title="二阶构造模式"></a>二阶构造模式</h1><h2 id="1、半成品对象"><a href="#1、半成品对象" class="headerlink" title="1、半成品对象"></a>1、半成品对象</h2><p>-初始化操作不能按照预期完成而得到的对象<br>-半成品对象是合法的C++对象，也是Bug重要来源</p>
<blockquote>
<p>构造函数能决定的知识对象的初始状态，而不是对象的诞生</p>
</blockquote>
<h2 id="2、划分构造过程"><a href="#2、划分构造过程" class="headerlink" title="2、划分构造过程"></a>2、划分构造过程</h2><ul>
<li><strong>资源无关的初始化操作</strong><br>不可能出现异常情况的操作</li>
<li><strong>需要使用系统资源的操作</strong><br>可能出现异常情况，如：内存申请，访问文件</li>
</ul>
<p>二阶构造能够确保创建的对象都是完整初始化的</p>
<h2 id="4、二阶构造示例"><a href="#4、二阶构造示例" class="headerlink" title="4、二阶构造示例"></a>4、二阶构造示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseCons</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TwoPhaseCons()&#123;  <span class="comment">//第一阶段构造函数</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">construct</span><span class="params">()</span></span>&#123; <span class="comment">//第二阶段构造函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> TwoPhaseCons* <span class="title">NewInstance</span><span class="params">()</span></span>; <span class="comment">//对象创建函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TwoPhaseCons* <span class="title">TwoPhaseCons::NewInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TwoPhaseCons* ret = <span class="keyword">new</span> TwoPhaseCons;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若二阶构造失败，返回NULL</span></span><br><span class="line">	<span class="keyword">if</span>(!(ret &amp;&amp; ret-&gt;construct()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> ret;</span><br><span class="line">		ret = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TwoPhaseCons* p = TwoPhaseCons::NewInstance();</span><br><span class="line">	TwoPhaseCons* p1 = TwoPhaseCons::NewInstance();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p1 = %p\n&quot;</span>,p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化数组类的实现"><a href="#优化数组类的实现" class="headerlink" title="优化数组类的实现"></a>优化数组类的实现</h2><p><strong>intarry.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">construct</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> IntArry* <span class="title">NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span>; <span class="comment">//</span></span><br><span class="line">	IntArry(<span class="keyword">const</span> IntArry&amp; obj);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>intarry.c文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">int</span> len) <span class="comment">//一阶构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::construct</span><span class="params">()</span> <span class="comment">//二阶构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( m_pointer )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">const</span> IntArry&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = obj.m_pointer[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = obj.m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IntArry* <span class="title">IntArry::NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArry* ret = <span class="keyword">new</span> IntArry(len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(ret &amp;&amp; ret-&gt;construct()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] ret;</span><br><span class="line">		ret = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntArry::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		value = m_pointer[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IntArry::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试c文件</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArry* a = IntArry::NewIntArry(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		a-&gt;<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;a-&gt;length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">			a-&gt;<span class="built_in">get</span>(i,value);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>,i,value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="被遗弃的友元"><a href="#被遗弃的友元" class="headerlink" title="被遗弃的友元"></a>被遗弃的友元</h1><p>友元是C++中的一种关系<br>友元关系发生在函数与类之间或者类与类之间<br>友元关系是单项的，不能传递</p>
<ul>
<li><p><strong>友元的用法</strong><br>在类中以friend关键字声明友元<br>类的友元可以是其他类或者具体函数<br>友元不是类的一部分<br>友元不收类中访问级别的限制<br>友元可以直接访问具体类的所有成员</p>
</li>
<li><p><strong>友元的语法</strong><br>在类中用friend关键字对函数或类进行声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Piont</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Point&amp; p)</span></span>; <span class="comment">//声明了友元关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Point&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.x = <span class="number">1</span>; <span class="comment">//可以直接访问类的私有成员变量</span></span><br><span class="line">	p.y = <span class="number">2</span>; <span class="comment">//可以直接访问类的私有成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>友元的尴尬</strong><br>友元是为了兼顾C语言的高效而诞生的<br>友元直接破坏了面向对象的封装特性<br>友元在实际产品中的高效是得不偿失的<br>友元在现代软件工程中已经逐渐被遗弃（对比c语言的goto语句）</p>
</li>
</ul>
<blockquote>
<p>注意事项：<br>友元不具备传递性<br>类的友元可以是其他类的成员函数<br>类的友元可以是某个完整的类：所有的成员函数都是友元</p>
</blockquote>
<p>插图</p>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClassC(<span class="keyword">const</span> <span class="keyword">char</span>* n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClassB(<span class="keyword">const</span> <span class="keyword">char</span>* n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getClassCName</span><span class="params">(ClassC&amp; c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;c.n = %s\n&quot;</span>,c.n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClassA(<span class="keyword">const</span> <span class="keyword">char</span>* n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getClassBName</span><span class="params">(ClassB&amp; b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;b.n = %s\n&quot;</span>,b.n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    //友元没有传递性，无法直接访问 c 的成员函数</span></span><br><span class="line"><span class="comment">	void getClassCName(ClassC&amp; c)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		//友元没有传递性，无法直接访问 c 的成员变量</span></span><br><span class="line"><span class="comment">		printf(c.n = %s\n&quot;,c.n);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ClassC <span class="title">c</span><span class="params">(<span class="string">&quot;C&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">ClassB <span class="title">b</span><span class="params">(<span class="string">&quot;B&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">ClassA <span class="title">a</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	b.getClassCName(c);</span><br><span class="line">	a.getClassBName(b);</span><br><span class="line">	<span class="comment">//a.getClassCName(c); </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类中的重载"><a href="#类中的重载" class="headerlink" title="类中的重载"></a>类中的重载</h1><p>类中成员函数可以进行重载<br>-构造函数的重载<br>-普通成员函数的重载<br>-静态成员函数的重载</p>
<p>重载函数的本质为多个不同的函数<br>函数名和参数列表是唯一表示<br>函数重载必须发生在同一个作用域中</p>
<p>重载的意义<br>-通过函数名对函数功能进行提示<br>-通过参数列表对函数用法进行提示<br>-扩展系统中已经存在的函数功能</p>
<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>通过operator关键字可以定义特殊的函数<br>operator的本质是通过函数重载操作符</p>
<p>语法</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Type</span> <span class="type">operatorSign(const </span><span class="keyword">Type</span> <span class="type">p1, </span>const <span class="keyword">Type</span> <span class="type">p2)</span></span><br><span class="line"><span class="type">&#123;</span></span><br><span class="line"><span class="type">	</span><span class="keyword">Type</span> <span class="type">ret;</span></span><br><span class="line"><span class="type"></span></span><br><span class="line"><span class="type">	</span><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sign: 为系统中预定义的操作符，如：+，-，*，/,等</span><br></pre></td></tr></table></figure>
<p>编程实验</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p1, <span class="keyword">const</span> Complex&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	ret.a = p1.a + p2.a;</span><br><span class="line">	ret.b = p1.b + p2.b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Complex c = a + b; <span class="comment">// operator+(a,b)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.a = %d, c.b = %d\n&quot;</span>,c.getA(),c.getB());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">c.a = <span class="number">2</span>, c.b = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>将操作符重载函数定义为类的成员函数<br>-比全局操作符重载函数少一个参数（左操作数）<br>-不需要依赖友元就可以完成操作符重载<br>-编译器有限在成员函数中寻找操作符重载函数</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Type</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="keyword">Type</span> operator <span class="built_in">Sign</span>(<span class="keyword">const</span> <span class="keyword">Type</span>&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">Type</span> <span class="keyword">ret</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编程实验</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	ret.a = <span class="keyword">this</span>-&gt;a + p.a;</span><br><span class="line">	ret.b = <span class="keyword">this</span>-&gt;b + p.b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Complex c = a+b; <span class="comment">// a.operator+(b)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.a = %d, c.b = %d\n&quot;</span>,c.getA(),c.getB());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">c.a = <span class="number">2</span>, c.b = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="实现一个复数类"><a href="#实现一个复数类" class="headerlink" title="实现一个复数类"></a>实现一个复数类</h2><p>复数类应该有的操作<br>-运算：+,-,*,/<br>-比较：==，！=<br>-赋值：=<br>-求模：modulus</p>
<p><strong>编程实现</strong><br>利用操作符重载<br>统一复数与实数的运算方式<br>统一复数与实数的比较方式</p>
<p><strong>complex.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMPLEX_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMPLEX_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>);</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getB</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getModulus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">operator</span> + (Complex&amp; c);</span><br><span class="line">	Complex <span class="keyword">operator</span> - (Complex&amp; c);</span><br><span class="line">	Complex <span class="keyword">operator</span> * (Complex&amp; c);</span><br><span class="line">	Complex <span class="keyword">operator</span> / (Complex&amp; c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (Complex&amp; c);</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> != (Complex&amp; c);</span><br><span class="line"></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>complex.c文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Complex::Complex(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Complex::getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Complex::getB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Complex::getModulus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> + (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> na = a + c.a;</span><br><span class="line">	<span class="keyword">double</span> nb = b + c.b;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> - (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> na = a - c.a;</span><br><span class="line">	<span class="keyword">double</span> nb = b - c.b;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> * (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> na = a * c.a - b * c.b;</span><br><span class="line">	<span class="keyword">double</span> nb = a * c.b + b * c.a;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> / (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> cm = c.a*c.a + c.b+c.b;</span><br><span class="line">	<span class="keyword">double</span> na = (a * c.a - b * c.b) / cm;</span><br><span class="line">	<span class="keyword">double</span> nb = (b * c.a - a * c.b) / cm;</span><br><span class="line">	<span class="function">Complex <span class="title">ret</span><span class="params">(na,nb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Complex::<span class="keyword">operator</span> == (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (a==c.a) &amp;&amp; (b==c.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Complex::<span class="keyword">operator</span> != (Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex&amp;  Complex::<span class="keyword">operator</span> = (<span class="keyword">const</span> Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> != &amp;c)</span><br><span class="line">	&#123;</span><br><span class="line">		a = c.a;</span><br><span class="line">		b = c.b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试主程序</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">#include <span class="string">&quot;stdafx.h&quot;</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include <span class="string">&quot;complex.h&quot;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">1</span>(<span class="number">1</span><span class="punctuation">,</span><span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">2</span>(<span class="number">3</span><span class="punctuation">,</span><span class="number">6</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">3</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> + <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">4</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> - <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">5</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> * <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">6</span> <span class="operator">=</span><span class="keyword">c</span><span class="number">1</span> / <span class="keyword">c</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	printf(<span class="string">&quot;c3.a = %f, c3.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">3</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">3</span>.getB())<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c4.a = %f, c4.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span>.getB())<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c5.a = %f, c5.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">5</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">5</span>.getB())<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c6.a = %f, c6.b = %f\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">6</span>.getA()<span class="punctuation">,</span><span class="keyword">c</span><span class="number">6</span>.getB())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">c</span><span class="number">7</span>(<span class="number">1</span><span class="punctuation">,</span><span class="number">-4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	printf(<span class="string">&quot;c4 == c7: %d\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span> <span class="operator">=</span><span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>)<span class="comment">;</span></span><br><span class="line">	printf(<span class="string">&quot;c4 != c7: %d\n&quot;</span><span class="punctuation">,</span><span class="keyword">c</span><span class="number">4</span> !<span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">c</span><span class="number">3</span>.a <span class="operator">=</span> <span class="number">4.000000</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">3</span>.b <span class="operator">=</span> <span class="number">8.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">4</span>.a <span class="operator">=</span> <span class="number">-2.000000</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">4</span>.b <span class="operator">=</span> <span class="number">-4.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">5</span>.a <span class="operator">=</span> <span class="number">-9.000000</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">5</span>.b <span class="operator">=</span> <span class="number">12.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">6</span>.a <span class="operator">=</span> <span class="number">-0.428571</span><span class="punctuation">,</span> <span class="keyword">c</span><span class="number">6</span>.b <span class="operator">=</span> <span class="number">0.000000</span></span><br><span class="line"><span class="keyword">c</span><span class="number">4</span> <span class="operator">=</span><span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>: <span class="number">0</span></span><br><span class="line"><span class="keyword">c</span><span class="number">4</span> !<span class="operator">=</span> <span class="keyword">c</span><span class="number">7</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意事项：<br>C++规定赋值操作符（=）只能重载为成员函数<br>操作符重载不能改变原操作符的优先级<br>操作符重载不能改变操作数的个数<br>操作符重载不应改变操作符的原有语义</p>
<p><strong>有趣的重载</strong><br>重载左移操作符，将变量或常量左移到一个对象中！<br><strong>手动通过重载简单实现cout</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">endl</span> = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Console</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">char</span> c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">char</span>* c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Console</span>&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">double</span> f)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,f);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Console</span> <span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;123\n&quot;</span> &lt;&lt; <span class="number">1.25</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h1><p>C++标准库并不是C++语言的一部分<br>C++标准库是由类库和函数库组成的集合<br>C++标准库中定义的类和对象都位于std命名空间中<br>C++标准库的头文件都不带.h后缀<br>C++标准库涵盖了C库的功能</p>
<h2 id="1、C-编译环境的组成"><a href="#1、C-编译环境的组成" class="headerlink" title="1、C++编译环境的组成"></a>1、C++编译环境的组成</h2><p>插图</p>
<h2 id="2、C-标准库预定义了多数常用的数据结构"><a href="#2、C-标准库预定义了多数常用的数据结构" class="headerlink" title="2、C++标准库预定义了多数常用的数据结构"></a>2、C++标准库预定义了多数常用的数据结构</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><bitset></td>
<td><set></td>
<td><cstdio></td>
</tr>
</tbody></table>
<p><strong>编程体验c++标准库</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello Word！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;input a: &quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;input b: &quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> c = <span class="built_in">sqrt</span>(a*a + b*b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-中的字符串类"><a href="#C-中的字符串类" class="headerlink" title="C++中的字符串类"></a>C++中的字符串类</h1><p>C++ 语言直接支持C语言所有的概念<br>C++ 语言中没有原生的字符串类型<br>C++ 标准库提供了string类型<br>string 直接支持字符串连接<br>string 直接支持字符串的大小比较<br>string 直接支持子串查找和提取<br>string 直接支持字符串的插入和替换</p>
<p>字符串与数字的转换<br>标准库中提供了相关类对字符串和数字的转换<br>字符串流类（sstream）用于string的转换</p>
<ul>
<li><sstream> -相关头文件</li>
<li>istringstream -字符串输入流</li>
<li>ostringstream -字符串输出流</li>
</ul>
<p>使用方法<br>string-&gt;数字</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">istringstream iss(<span class="string">&quot;123.45&quot;</span>)<span class="comment">;</span></span><br><span class="line">double num<span class="comment">;</span></span><br><span class="line">iss &gt;&gt; num<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>数字-&gt;string</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ostringstream oss<span class="comment">;</span></span><br><span class="line">oss &lt;&lt; <span class="number">562.63</span><span class="comment">;</span></span><br><span class="line">string s = oss.str()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>编程实现</strong><br>字符串转换为数字与数字转换为字符串的功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_NUMBER(str,n) (istringstream(str) &gt;&gt; n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING(n) (((ostringstream&amp;)(ostringstream() &lt;&lt; n)).str())</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">double</span> n;</span><br><span class="line">	TO_NUMBER(<span class="string">&quot;1.23&quot;</span>,n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; TO_STRING(<span class="number">12.34</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1.23</span></span><br><span class="line"><span class="number">12.34</span></span><br></pre></td></tr></table></figure>
<p>字符串循环右移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">right_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">	n = n % s.length();</span><br><span class="line">	pos = s.length() - n;</span><br><span class="line"></span><br><span class="line">	ret = s.substr(pos);</span><br><span class="line">	ret += s.substr(<span class="number">0</span>,pos);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">string</span> r = right_func(<span class="string">&quot;123456&quot;</span>,<span class="number">8</span>); <span class="comment">//循环右移8位</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">561234</span></span><br></pre></td></tr></table></figure>
<h1 id="数组操作符的重载"><a href="#数组操作符的重载" class="headerlink" title="数组操作符的重载"></a>数组操作符的重载</h1><p><strong>字符串类的兼容性</strong><br>string类最大限度的考虑了C字符串的兼容性<br>可以按照使用C字符串的方式使用string对象<br><strong>被忽略的事实</strong><br>-数组访问符是C/C++中的内置操作符<br>数组访问符的原生意义是数组访问和指针运算</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">a[n] &lt;--&gt; *(a + n) &lt;--&gt; *(n + a) &lt;--&gt; n[a]</span><br></pre></td></tr></table></figure>
<p><strong>优化数组类</strong><br><strong>interry.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INTARRY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTARRY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_pointer;</span><br><span class="line">	IntArry(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">construct</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> IntArry* <span class="title">NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line">	IntArry(<span class="keyword">const</span> IntArry&amp; obj);</span><br><span class="line">	~IntArry();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">IntArry&amp; <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>interry.cpp文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	m_length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( m_pointer )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			m_pointer[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::IntArry(<span class="keyword">const</span> IntArry&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	m_pointer = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_length];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[i] = obj.m_pointer[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_length = obj.m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IntArry* <span class="title">IntArry::NewIntArry</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArry* ret = <span class="keyword">new</span> IntArry(len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(ret &amp;&amp; ret-&gt;construct()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] ret;</span><br><span class="line">		ret = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IntArry::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		value = m_pointer[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntArry::set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = ( <span class="number">0</span>&lt;= index) &amp;&amp; (index &lt;= m_length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ret )</span><br><span class="line">	&#123;</span><br><span class="line">		m_pointer[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntArry::~IntArry()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; IntArry::<span class="keyword">operator</span> [] (<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_pointer[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IntArry&amp; <span class="title">IntArry::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试主函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;intarry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	IntArry* a = IntArry::NewIntArry(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(a != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IntArry&amp; arry = a-&gt;self();</span><br><span class="line"></span><br><span class="line">		arry[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arry.length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; arry[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="经典问题解析"><a href="#经典问题解析" class="headerlink" title="经典问题解析"></a>经典问题解析</h1><h2 id="1、关于赋值的疑问"><a href="#1、关于赋值的疑问" class="headerlink" title="1、关于赋值的疑问"></a>1、关于赋值的疑问</h2><p>编译器为每个类默认重载了赋值操作符<br>默认的赋值操作符仅完成浅拷贝<br>当需要进行深拷贝时必须重载赋值操作符<br>赋值操作符与拷贝构造函数有相同的存在意义</p>
<blockquote>
<p>一般性原则<br>重载赋值操作符，必然需要实现深拷贝</p>
</blockquote>
<p>编译器默认提供的函数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Test</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数体等价于</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Test</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="keyword">Test</span>();</span><br><span class="line">	<span class="keyword">Test</span>(<span class="keyword">const</span> <span class="keyword">Test</span>&amp; );</span><br><span class="line">	<span class="keyword">Test</span> operator = (<span class="keyword">const</span> <span class="keyword">Test</span>&amp;);</span><br><span class="line">	~<span class="keyword">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、关于string的疑问"><a href="#2、关于string的疑问" class="headerlink" title="2、关于string的疑问"></a>2、关于string的疑问</h2><p>string 类通过一个数据空间保存字符数据<br>string 类通过一个成员变量保存当前字符串长度<br>C++开发时尽量避开C语言中惯用的编程思想</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>一个特殊的指针，指针生命周期结束时主动释放堆空间，一片堆空间最多智能由一个指针标识，杜绝指针运算和指针比较</p>
<blockquote>
<p>智能用来指向堆空间中的对象或者变量</p>
</blockquote>
<p><strong>编程实现</strong><br>通过重载指针操作符(-&gt;和*)，使用对象代替指针 </p>
<h1 id="逻辑操作符的陷阱"><a href="#逻辑操作符的陷阱" class="headerlink" title="逻辑操作符的陷阱"></a>逻辑操作符的陷阱</h1><p>C++通过函数调用扩展操作符的功能，进入函数体前必须完成所有参数的计算，函数参数的计算次序是不定的，短路法则则完全失效</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &amp;&amp; (<span class="keyword">const</span> Test&amp; l,<span class="keyword">const</span> Test&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> l.getValue() &amp;&amp; r.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> || (<span class="keyword">const</span> Test&amp; l,<span class="keyword">const</span> Test&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> l.getValue() || r.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test func(Test t): t.value = &quot;</span> &lt;&lt; t.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="function">Test <span class="title">t0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(func(t0) &amp;&amp; func(t1)) <span class="comment">// 等价于调用 operator &amp;&amp;( func(t0), func(t1)) 函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is true!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is false!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(func(t0) || func(t1)) <span class="comment">// 等价于调用 operator ||( func(t0), func(t1)) 函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is true!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is false!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">1</span></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">0</span></span><br><span class="line">Result is <span class="literal">false</span>!</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">1</span></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test t)</span>: t.value </span>= <span class="number">0</span></span><br><span class="line">Result is <span class="literal">true</span>!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不推荐重载逻辑与或 ，逻辑操作符重载后无法实现原生的语义<br>通过重载比较操作符代替逻辑操作符重载<br>直接使用成员函数代替逻辑操作符重载<br>使用全局函数对对逻辑操作符进行重载</p>
</blockquote>
<h1 id="逗号表达式的重载"><a href="#逗号表达式的重载" class="headerlink" title="逗号表达式的重载"></a>逗号表达式的重载</h1><p>逗号表达式用于将多个字表达式连接为一个表达式,逗号表达式的值为最后一个子表达式的值,逗号表达式,的前N-1个子表达式可以没有返回值,逗号表达式按照从左向右的顺序计算每个子表达式的值</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">exp1 , exp2 , exp3 , ... , expN</span><br></pre></td></tr></table></figure>
<p>在C++中使用全局函数对逗号操作符进行重载，重载函数的参数必须有一个是类类型，重载函数的返回值必须是引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class&amp; , (<span class="keyword">const</span> Class&amp; a, <span class="keyword">const</span> Class&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Class&amp;&gt;(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议使用全局函数重载逗号操作符</p>
<p>存在问题<br>C++通过函数调用扩展操作符的功能，进入函数体前必须完成所有参数的计算，函数参数的计算次序是不定的，重载后无法严格从左向右计算表达式，工程开发中不要重载逗号操作符</p>
<h1 id="前置操作符与后置操作符的重载"><a href="#前置操作符与后置操作符的重载" class="headerlink" title="前置操作符与后置操作符的重载"></a>前置操作符与后置操作符的重载</h1><p>++ 操作符可以被重载，全局函数和成员函数均可以进行重载，重载前置++操作符不需要额外的参数，重载后置 ++ 操作符需要一个 int 类型的占位参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test&amp; <span class="keyword">operator</span> ++ () <span class="comment">// 前置++实现</span></span><br><span class="line">	&#123;</span><br><span class="line">		++value;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> ++ (<span class="keyword">int</span>) <span class="comment">//后置++实现</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value)</span></span>;</span><br><span class="line"></span><br><span class="line">		value++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="function">Test <span class="title">t0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	Test t1 = t0++;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t0.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t1.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Test t2 = ++t0;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t0.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; t2.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h1><p>构造函数可以定义不同类型的参数，参数满足下列条件时称为<strong>转换构造函数</strong>：有且仅有一个参数、参数是基本类型、参数是其他类类型</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test </span>t;</span><br><span class="line">t = 100;</span><br></pre></td></tr></table></figure>
<p>编译器会尽量尝试让源码通过编译，当将100赋值给对象t时，编译器首先看看有没有转换构造函数，如果有转换构造函数则进行转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		value = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Test(<span class="keyword">int</span> i)   <span class="comment">//转换构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Test t ;</span><br><span class="line"></span><br><span class="line">	t = <span class="number">5</span>; <span class="comment">//进行隐式类型转换，调用转换构造函数，==&gt; t = Test(5)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器尽量尝试的结果是隐式类型转换：会让程序以意想不到的方式进行工作，是工程中bug的重要来源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()&#123;&#125;;</span><br><span class="line">	Test(<span class="keyword">int</span> i)</span><br><span class="line">	&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; obj) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value+ obj.value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Test t ;</span><br><span class="line"></span><br><span class="line">	t = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	Test r;</span><br><span class="line"></span><br><span class="line">	r = t + <span class="number">5</span>; <span class="comment">// ==&gt; r = t + Test(5); 编译器自作聪明的编译通过，容易产生bug</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++编译器通过explicit关键字杜绝编译器的转换尝试，转换构造函数被explicit修饰时只能进行显示转换<br>转换方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;ClassName&gt;(value)</span><br><span class="line">ClassName(value)</span><br><span class="line">(ClassName)value <span class="comment">//不推荐</span></span><br></pre></td></tr></table></figure>
<p>手动进行转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; obj) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value+ obj.value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Test t ;</span><br><span class="line">	</span><br><span class="line">	t = <span class="keyword">static_cast</span>&lt;Test&gt;(<span class="number">5</span>); <span class="comment">// 手动类型转换</span></span><br><span class="line">	Test r;</span><br><span class="line"></span><br><span class="line">	r = t + Test(<span class="number">5</span>) + (Test)<span class="number">3</span>; <span class="comment">// 手动类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++中可以定义<strong>类型转换函数</strong>，类型转换函数用于将类对象转化为其他类型</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">operator <span class="keyword">Type</span> <span class="type">()</span></span><br><span class="line"><span class="type">&#123;</span></span><br><span class="line"><span class="type">	</span><span class="keyword">Type</span> <span class="type">ret;</span></span><br><span class="line"><span class="type"></span></span><br><span class="line"><span class="type">	</span><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型转换函数与转换构造函数具有同等的地位、使得编译器有能力将类对象转化为其他类型，编译器能够隐式使用类型转换函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		value = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; obj) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Test <span class="title">ret</span><span class="params">(value+ obj.value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> <span class="comment">//类型转换函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function">Test <span class="title">t</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	i = t; <span class="comment">//编译器隐式调用类型转换函数 == &gt; t.operator int()</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>谨慎使用隐式类型转换，非常容易引入bug</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tmp(<span class="keyword">int</span>) <span class="comment">//类型转换函数</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		value = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Tmp</span> <span class="params">()</span> <span class="comment">//转换构造函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">Tmp <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Tmp i = <span class="number">0</span>;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">	Tmp = t; <span class="comment">// 转换构造函数与类型转换函数相互冲突</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过在转换构造函数前加explicit关键字解决，在实际工程中通常不使用转换构造函数而采用普通构造函数的方式实现转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tmp(<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">	&#123;</span><br><span class="line">		value = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">Tmp <span class="title">toTmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">Tmp <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Tmp i = <span class="number">0</span>;</span><br><span class="line">	Test t;</span><br><span class="line"></span><br><span class="line">	i = t.toTmp(); <span class="comment">// 通过构造函数实现类的类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承的概念和意义"><a href="#继承的概念和意义" class="headerlink" title="继承的概念和意义"></a>继承的概念和意义</h1><p>面向对象中的继承指类之间的父子关系：子类拥有父类的所有属性和行为、子类就是一种特殊的父类、子类对象可以当做父类对象使用、子类中可以添加父类没有的方法和属性</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Child</span> : <span class="symbol">public</span> <span class="symbol">Parent</span> //描述继承关系</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>子类是一个特殊的父类，子类对象可以直接初始化父类对象，子类对象可以直接赋值给父类对象。</p>
<p>继承是C++中代码复用的重要手段。通过继承可以获得父类所有功能，并且可以在子类中重写已有功能，或者添加新功能。</p>
<h2 id="继承中的访问级别"><a href="#继承中的访问级别" class="headerlink" title="继承中的访问级别"></a>继承中的访问级别</h2><p>面向对象中的访问级别不知是public和private，可以定义protected访问级别：protected修饰的成员不能被外界直接访问、修饰的成员可以被子类直接访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span> :  <span class="comment">//protected访问级别</span></span><br><span class="line">		<span class="keyword">int</span> mv;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Parent()</span><br><span class="line">	&#123;</span><br><span class="line">		mv = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">addValue</span><span class="params">(<span class="keyword">int</span> mv)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Parent::mv = Parent::mv + mv; <span class="comment">//子类直接访问父类私有成员</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.addValue(<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义类时访问级别的选择"><a href="#定义类时访问级别的选择" class="headerlink" title="定义类时访问级别的选择"></a>定义类时访问级别的选择</h2><p>插图44课</p>
<h1 id="不同的继承方式"><a href="#不同的继承方式" class="headerlink" title="不同的继承方式"></a>不同的继承方式</h1><p>public继承<br>父类成员在子类中保持原有的访问级别<br>private继承<br>父类成员在子类中变为私有成员<br>protected继承<br>父类中的公有成员变为保护成员，其他成员保持不变</p>
<p>插图44课</p>
<p>继承成员的访问属性<br> = Max{继承方式，父类成员访问属性}</p>
<p>C++中的默认继承方式为private</p>
<p>一般而言，C++工程项目中只使用public继承，C++的派生语言只支持一种继承方式（public继承），protected和private继承带来的复杂性远大于使用性</p>
<h1 id="继承中的构造与析构"><a href="#继承中的构造与析构" class="headerlink" title="继承中的构造与析构"></a>继承中的构造与析构</h1><p>子类可以定义构造函数，子类的构造函数必须对继承而来的成员进行初始化：直接通过初始化列表或者赋值的方式进行初始化、调用父类的构造函数进行初始化</p>
<p>父类构造函数在子类中的调用方式：默认调用，适用于无参构造函数和使用默认参数的构造函数、显示调用，通过初始化列表进行调用，适用于所有父类构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Parent()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Parent(<span class="built_in">string</span> s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent(string s) : &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Child() <span class="comment">//隐式调用父类构造函数Parent()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Child(<span class="built_in">string</span> s)</span><br><span class="line">		: Parent(<span class="string">&quot;Parameter to Parent&quot;</span>) <span class="comment">//显示调用父类构造函数Parent(string s)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child() : &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Child <span class="title">cc</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Parent()</span><br><span class="line">Child()</span><br><span class="line"></span><br><span class="line">Parent(<span class="built_in">string</span> s) : Parameter to Parent</span><br><span class="line">Child() : hello</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造规则：子类对象在创建时会首先调用父类的构造函数、先执行父类构造函数<br>再执行子类的构造函数、父类构造函数可以被隐式调用或者显示调用</p>
</blockquote>
<p>对象创建时构造函数的调用顺序</p>
<ol>
<li>调用父类的构造函数</li>
<li>调用成员变量的构造函数</li>
<li>调用类自身的构造函数</li>
</ol>
<p><strong>口诀心法：</strong><br><strong>先父母、后客人、再自己</strong></p>
<p>析构函数的调用顺序与构造函数相反</p>
<ol>
<li>执行自身的析构函数</li>
<li>执行成员变量的析构函数</li>
<li>执行父类的析构函数</li>
</ol>
<h1 id="父子间的冲突"><a href="#父子间的冲突" class="headerlink" title="父子间的冲突"></a>父子间的冲突</h1><p>子类可以定义父类中的同名成员，子类中的成员将隐藏父类中的同名成员，父类中的同名成员依然存在于子类中，子类可以定义父类中的同名函数，使用作用域分辨符::访问父类中的同名成员和同名函数</p>
<p><strong>特殊的同名函数</strong><br>子类中可以定义父类中已经存在的成员函数，这种定义发生在继承中，叫函数重写，函数重写是同名覆盖的一种特殊情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mi;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child c;</span><br><span class="line"></span><br><span class="line">	c.mi = <span class="number">100</span>;</span><br><span class="line">	c.Parent::mi = <span class="number">10</span>; <span class="comment">//调用父类中的成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.Get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c.Parent::Get() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//调用父类同名的函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>父子间的赋值兼容</strong><br>子类对象可以当做父类对象使用（兼容性）：子类对象可以直接赋值给父类对象使用、子类对象可以直接初始化父类对象、父类指针可以直接指向子类对象、父类引用可以直接引用子类对象</p>
<p>当使用父类指针（引用）指向子类对象时，子类对象退化为父类对象，只能访问父类中定义的成员，可以访问被子类覆盖的同名成员</p>
<h1 id="多态的概念和意义"><a href="#多态的概念和意义" class="headerlink" title="多态的概念和意义"></a>多态的概念和意义</h1><p>根据实际的对象类型决定函数调用的具体目标，同样的语句在实际运行时有多种不同的表现形式</p>
<p>C++语言直接支持多态的概念，通过使用virtual关键字对多态进行支持，被virtual声明的函数被重写后具有多态特性，被virtual声明的函数叫做<strong>虚函数</strong>。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandfather</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//通过关键字virtual实现多态</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Grandfather&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> :</span> Grandfather</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//通过关键字virtual实现多态</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Parent&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_A</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Child A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_B</span> :</span> <span class="keyword">public</span> Parent <span class="comment">//描述继承关系</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I&#x27;m Child B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Child_A a;</span><br><span class="line">	Child_B b;</span><br><span class="line"></span><br><span class="line">	Parent* pa = &amp;a;</span><br><span class="line">	pa-&gt;<span class="built_in">print</span>();	</span><br><span class="line"></span><br><span class="line">	Parent&amp; A = a;</span><br><span class="line">	A.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Parent* pb = &amp;b;</span><br><span class="line">	pb-&gt;<span class="built_in">print</span>();	</span><br><span class="line"></span><br><span class="line">	Parent&amp; B = b;</span><br><span class="line">	B.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">I<span class="number">&#x27;</span>m Child A</span><br><span class="line">I<span class="number">&#x27;</span>m Child A</span><br><span class="line"></span><br><span class="line">I<span class="number">&#x27;</span>m Child B</span><br><span class="line">I<span class="number">&#x27;</span>m Child B</span><br></pre></td></tr></table></figure>
<p>多态的意义<br>在程序运行中展现出动态特性、函数重写必须多态实现，否则没有意义、多态是面向对象组件化和程序设计的基础特性</p>
<p>理论中的概念<br>静态联编，在程序编译期间就能确定具体的函数调用，如函数重载<br>动态联编，在程序实际运行后才能确定具体的函数调用，如函数重写</p>
<h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><p>class是一种特殊的struct，在内存中class依旧可以看做变量的集合，class与struct遵循相同的内存对齐规则，class中的成员函数与成员变量是分开存放的：每个对象有独立的成员变量、所有类对象共享类中的成员函数</p>
<p>运行时的对象退化为结构体的形式，所有的成员变量在内存中依次排布，成员变量间可能存在内存空隙，可以通过内存地址直接访问成员变量，访问权限关键字在运行时失效</p>
<p>继承对象模型<br>在C++编译器的内部类可以理解为结构体，子类是由父类成员叠加子类新成员得到的</p>
<p>C++多态的实现原理<br>当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数地址的数据结构，虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续….."></a>未完待续…..</h1>]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动-基础知识</title>
    <url>/2020/01/03/linux%E9%A9%B1%E5%8A%A8-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><strong>前言:</strong></p>
<p>整理 linux 相关基础知识点，参考文献</p>
<ul>
<li>linux 字符设备驱动详解</li>
<li>LDD3</li>
<li>韦东山驱动大全/linux 应用开发完全手册 4.0</li>
<li>文中提到的相关博客</li>
</ul>
<blockquote>
<p>特别说明：这篇文章为摘抄总结，非原创文章，如果内容涉及侵权请及时告知，作者会立即删除相关内容。</p>
</blockquote>
<a id="more"></a>
<h1 id="一、字符设备"><a href="#一、字符设备" class="headerlink" title="一、字符设备"></a><div align=center>一、字符设备</div></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;字符设备是指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED设备等，而字符设备用到的核心数据结构有<font color=red>file</font>、<font color=red>inode</font>、<font color=red>cdev</font>、<font color=red>file_operations</font>。</p>
<h2 id="1、struct-file-数据结构"><a href="#1、struct-file-数据结构" class="headerlink" title="1、struct file 数据结构"></a>1、struct file 数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;struct file 结构与用户空间程序中的FILE结构<font color=red>没有任何关联</font>，FILE结构在C库中定义不会出现在内核代码中，struct file 是一个内核结构，它不会出现在用户程序中。struct file 结构代表一个打开的文件(它不仅仅限定于设备驱动程序，<font color=red>系统中每个打开的文件在内核空间都有一个对应的 file 结构</font>)。它由内核在open时创建，并且传递给在该文件上操作的所有函数，直到最后的close函数，在文件的所有实例都被关闭后，内核会释放这个数据结构。在内核和驱动源代码中，<font color=red>struct file 的指针通常被命名为 file 或 filp </font>，为了不和这个结构本身混淆，我们一致将指向该结构的指针称为 filp，file 则为结构本身。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>        <span class="title">fu_llist</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>          <span class="title">fu_rcuhead</span>;</span></span><br><span class="line"> &#125; f_u;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">path</span>                  <span class="title">f_path</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f_dentry              f_path.dentry</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                 *<span class="title">f_inode</span>;</span>		<span class="comment">/* cached value */</span></span><br><span class="line"> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span>		<span class="comment">/* 和文件关联的操作 */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">  * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">spinlock_t</span>           f_lock;</span><br><span class="line"> <span class="keyword">atomic_long_t</span>        f_count;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span>         f_flags;			<span class="comment">/* 文件标志，如O_RDONLY、O_NONBLOCK、O_SYNC */</span></span><br><span class="line"> <span class="keyword">fmode_t</span>              f_mode;			<span class="comment">/* 文件读/写模式，FMODE_READ和FMODE_WRITE ，文件打开是已经做了判断，基本用不着 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>         <span class="title">f_pos_lock</span>;</span></span><br><span class="line"> <span class="keyword">loff_t</span>               f_pos;			<span class="comment">/* 当前读写位置 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>   <span class="title">f_owner</span>;</span></span><br><span class="line"> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>    *<span class="title">f_cred</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">　 u64                 f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFiG_SECURITY</span></span><br><span class="line"> <span class="keyword">void</span>         *f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line"> <span class="keyword">void</span>         *private_data;           <span class="comment">/* 文件私有数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFiG_EPOLL</span></span><br><span class="line"> <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">f_ep_links</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                                <span class="comment">/* #ifdef CONFiG_EPOLL */</span></span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));        <span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>
<p>这个数据结构中驱动相关的几个重要成员变量如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">重要成员</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">loff_t&nbsp;f_pos</td>
<td>当前读/写位置。loff_t有64位，驱动程序要知道文件中的当前位置，可以读取这个值，但不要去修改它。read/write会使用他们接收到的最后那个指针参数来更新这一位置，而不是直接针对filp-&gt;f_pos进行操作。这一规则的一个例外是llseek方法，该方法的目的本身就是为了修改文件位置</td>
</tr>
<tr>
<td align="left">unsigned&nbsp;int&nbsp;f_flags</td>
<td>文件标志，如O_RDONLY、O_NONBLOCK、O_SYNC，检查用户的请求是否是非阻塞式的操作，驱动程序需要检查O_NONBLOCK标志，而其他标志很少用到。注意：检测读写权限应该使用f_mode而不是f_flags。所有这些标志都被定义在&lt;linux/fcntl.h&gt;中</td>
</tr>
<tr>
<td align="left">struct&nbsp;file_operations&nbsp;*f_op;</td>
<td>与文件相关的操作。内核在执行open操作时对这个指针赋值，以后需要处理这个操作时就读取这个指针。</td>
</tr>
<tr>
<td align="left">void *private_data;</td>
<td>file 结构的私有数据，被初始化为NULL</td>
</tr>
</tbody></table>
<h2 id="2、struct-inode-结构体"><a href="#2、struct-inode-结构体" class="headerlink" title="2、struct inode 结构体"></a>2、struct inode 结构体</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;内核用inode结构在内部表示文件，因此它和file结构不同，后者表示打开的文件描述。对单个文件可能有多个打开的file文件描述(上层可以多次open一个文件)，但他们都指向同一个inode文件。inode包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等大量文件信息。部分数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">umode_t</span> i_mode;        <span class="comment">/* inode的权限 */</span></span><br><span class="line">    <span class="keyword">uid_t</span> i_uid;           <span class="comment">/* inode拥有者的id */</span></span><br><span class="line">    <span class="keyword">gid_t</span> i_gid;           <span class="comment">/* inode所属的群组id */</span></span><br><span class="line">    <span class="keyword">dev_t</span> i_rdev;          <span class="comment">/* 若是设备文件，此字段将记录设备的设备号 */</span></span><br><span class="line">    <span class="keyword">loff_t</span> i_size;         <span class="comment">/* inode所代表的文件大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_atime</span>;</span> <span class="comment">/* inode最近一次的存取时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_mtime</span>;</span> <span class="comment">/* inode最近一次的修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_ctime</span>;</span> <span class="comment">/* inode的产生时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_blkbits;</span><br><span class="line">    <span class="keyword">blkcnt_t</span>        i_blocks;    <span class="comment">/* inode所使用的block数，一个block为512 字节 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">i_cdev</span>;</span>       <span class="comment">/* 若是字符设备，为其对应的cdev结构体指针。 若是块设备，为其对应的block_device结构体指针*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中驱动对驱动编程有用的成员变量只有两个如下：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>dev_t&nbsp;i_rdev</td>
<td>表示设备文件inode结构，它包含了真正的设备编号</td>
</tr>
<tr>
<td>struct&nbsp;cdev&nbsp;*i_cdev</td>
<td>当inode指向一个字符设备文件时，i_cdev为其对应的cdev结构体指针</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在驱动中也可通过i_rdev获取设备号，内核提供了下面两个函数来获取inode结构中i_rdev字段中的设备号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">imajor</span><span class="params">(struct inode* inode)</span></span>;  <span class="comment">//获取主设备号</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">iminor</span><span class="params">(struct inode* inode)</span></span>;  <span class="comment">//获取次设备号</span></span><br></pre></td></tr></table></figure>
<h2 id="3、struct-file-operations-结构体"><a href="#3、struct-file-operations-结构体" class="headerlink" title="3、struct file_operations 结构体"></a>3、struct file_operations 结构体</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;该结构体是系统调用与驱动连接的桥梁，例如：当我们在应用层使用open函数打开一个设备的时候，内核会创建一个file结构并关联file_operations中的一组函数，最终会调用到驱动中关联的file_operations结构体实例中open函数。而file_operations定义了一组操作函数，我们不一定全部用到，通常用到什么函数就关联什么函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">  <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">  <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">  <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">  <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">  <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">  <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line">  <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,<span class="keyword">loff_t</span> len);</span><br><span class="line">  <span class="keyword">int</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;file_operations的重要性不言而喻，因此以下详细给出重要成员的说明.</p>
<h3 id="1）struct-module-owner"><a href="#1）struct-module-owner" class="headerlink" title="1）struct module *owner;"></a>1）struct module *owner;</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一个指向拥有这个结构的模块的指针，内核使用这个字段以避免在模块的操作正在被使用时卸载该模块，几乎所有情况被初始化为THIS_MODULE。</p>
<h3 id="2）open-函数"><a href="#2）open-函数" class="headerlink" title="2）open() 函数"></a>2）open() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对设备文件进行的第一个操作，不要求驱动声明一个对应的方法。如果这个函数没有实现，当用户调用open()时，一直显示成功，但是你的驱动不会得到通知。open函数提供给驱动程序以初始化的能力，从而<font color=red>为以后的操作完成初始化做准备</font>。大部分驱动程序中应当完成下面工作。</p>
<blockquote>
<ol>
<li>检测设备特定的错误（注入设备未就绪或类似的硬件问题）</li>
<li>如果设备是首次打开，则对其进行初始化。</li>
<li>如果有必要，更新fop指针</li>
<li>分配并填写置于 filp-&gt;private_date 里的数据结构</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int (*open) (struct inode *inode , struct file *filp);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>inode</td>
<td>为文件节点(详细见前面inode结构)</td>
</tr>
<tr>
<td>filp</td>
<td>指向内核创建的文件结构(详细见前面file结构)</td>
</tr>
</tbody></table>
<h3 id="3）read-函数"><a href="#3）read-函数" class="headerlink" title="3）read() 函数"></a>3）read() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用来从设备读取数据，成功时函数返回读取的字节数，返回值是一个 “signed size” 类型, 常常是目标平台本地的整数类型，出错时返回一个负值,如果此函数未实现(被指为NULL)，当用户调用read()时，将得到 -EINVAL 的返回值，它与用户空间的fread()函数对应。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>ssize_t (*read) (struct file *filp, char __user *buffer, size_t size , loff_t *ppos);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>filp</td>
<td>指向内核创建的文件结构</td>
</tr>
<tr>
<td>buffer</td>
<td>为对应放置信息的缓冲区（即用户空间内存地址）</td>
</tr>
<tr>
<td>size</td>
<td>为要读取的信息长度,以字节为单位</td>
</tr>
<tr>
<td>ppos</td>
<td>为读的位置相对于文件开头的偏移，在读取信息后，这个指针一般都会移动，移动的值为要读取信息的长度值</td>
</tr>
</tbody></table>
<h3 id="3）write-函数"><a href="#3）write-函数" class="headerlink" title="3）write() 函数"></a>3）write() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;向设备发送数据，成功时返回写入的字节数，如果此函数未实现，当用户调用write()时，将得到 -EINVAL 的返回值，它与用户空间的fwrite()函数对应</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>ssize_t (*write) (struct file * filp, const char __user *buffer, size_t size, loff_t * ppos);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>filp</td>
<td>指向系统open时内核创建的文件结构</td>
</tr>
<tr>
<td>buffe</td>
<td>用户要写入文件的信息缓冲区</td>
</tr>
<tr>
<td>size</td>
<td>要写入信息的长度</td>
</tr>
<tr>
<td>ppos</td>
<td>当前的读/写位置，这个值通常是用来判断写文件是否越界</td>
</tr>
</tbody></table>
<blockquote>
<p>注：这个操作和上面的对文件进行读的操作均为阻塞操作</p>
</blockquote>
<h3 id="4）ioctl-函数"><a href="#4）ioctl-函数" class="headerlink" title="4）ioctl() 函数"></a>4）ioctl() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;提供设备相关控制命令的实现（既不是读操作也不是写操作），当调用成功时，返回给调用程序一个非负值。如果设备不提供ioctl入口点，则对于任何内核未预先定义的请求，ioctl系统调用将返回错误。(-ENOTTY,”No such ioctl for device, 该设备无此iotcl命令”)。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int (*ioctl) (struct inode *inode, struct file *flip, unsigned int cmd, unsigned long arg);</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>inode</td>
<td>为文件节点</td>
</tr>
<tr>
<td>filp</td>
<td>指向系统open时内核创建的文件结构</td>
</tr>
<tr>
<td>cmd</td>
<td>从用户那里不改变地传下来的命令</td>
</tr>
<tr>
<td>arg</td>
<td>对应命令的参数</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为了保证用户传递下来的命令安全可靠，内核定义了iotcl命令的组成方式，当使用这个函数是应当遵循这个规则。</p>
<h4 id="a-命令的组成"><a href="#a-命令的组成" class="headerlink" title="a. 命令的组成"></a>a. 命令的组成</h4><img width=800 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/6.jpg" >

<ul>
<li><strong>设备类型</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;设备类型由8位组成，在linux下我们将它称为“幻数”，可以是0~0xFF之间的值，内核中的 ioctl-number.txt 给出了一些推荐的和已经被使用的“幻数”，新设备驱动定义“幻数”的时候要避免与其冲突。</li>
<li><strong>方向</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;方向由2位组成，表示数据传输的方向</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>_IOC_NONE</td>
<td>无数据传输</td>
</tr>
<tr>
<td>_IOC_READ</td>
<td>读操作</td>
</tr>
<tr>
<td>_IOC_WRITE</td>
<td>写操作</td>
</tr>
<tr>
<td>_IOC_READ | _IOC_WRITE</td>
<td>双向操作</td>
</tr>
</tbody></table>
<ul>
<li><strong>数据尺寸</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;数据长度字段表示涉及的用户数据的大小，这个成员的宽度依赖于体系结构，通常是 13 位或者14 位。</p>
<h4 id="b-命令生成方式"><a href="#b-命令生成方式" class="headerlink" title="b. 命令生成方式"></a>b. 命令生成方式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;linux也给出了该命令生成的方式，用户空间与内核空间应声明为相同方式。声明方式如下：</p>
<ul>
<li><strong>_IO()</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;用于生成不涉及数据传输的简单命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IOR()</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;用于生成读操作命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),\</span></span><br><span class="line">  (_IOC_TYPECHECK(size)))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IOW()</strong></li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;用于生成写操作命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),\</span></span><br><span class="line">  (_IOC_TYPECHECK(size)))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IOWR()</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;用于生成即可读也可写的操作命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr), \</span></span><br><span class="line">  (_IOC_TYPECHECK(size)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>_IO、_IOR 等使用的_IOC 宏</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line">   (((dir) &lt;&lt; _IOC_DIRSHIFT) | \</span><br><span class="line">   ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span><br><span class="line">   ((nr) &lt;&lt; _IOC_NRSHIFT) | \</span><br><span class="line">   ((size) &lt;&lt; _IOC_SIZESHIFT))</span><br></pre></td></tr></table></figure>
<h4 id="c-简单使用"><a href="#c-简单使用" class="headerlink" title="c. 简单使用"></a>c. 简单使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;下面的代码为伪代码，主要用于说明使用方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_NAME <span class="meta-string">&#x27;D&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_CMD				_IO( DEV_NAME, 0)	<span class="comment">//只向内核传递一条DEV_CMD命令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_CMD_READ_SOMTHING	_IOR(DEV_NAME, 1, unsigned int)	<span class="comment">//从内核读取一些数据(数据类型 unsigned int)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		DEV_CMD_WRITE_SOMTHING	_IOW(DEV_NAME, 2, unsigned int)	<span class="comment">//向内核写入一些数据(数据类型 int)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5）llseek-函数"><a href="#5）llseek-函数" class="headerlink" title="5）llseek()函数"></a>5）llseek()函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用来修改一个文件当前读写位置，并将新位置返回，出错时这个函数返回一个负值。如果这个函数指针是NULL，对seek的钓鱼用将会以某种不可预期的方式修改file结构中的位置计数器。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>loff_t (*llseek) (struct file *filp , loff_t p, int orig);</th>
</tr>
</thead>
<tbody><tr>
<td>filp</td>
<td>指向系统open时内核创建的文件结构</td>
</tr>
<tr>
<td>p</td>
<td>当前的读/写位置，这个值通常是用来判断写文件是否越界</td>
</tr>
<tr>
<td>orig</td>
<td>文件定位的地址，文件开头（SEEK_SET、0），当前位置（SEEK_CUR、1），文件末尾（SEEK_END、2）</td>
</tr>
</tbody></table>
<blockquote>
<p>更多请参考博客<a href="https://www.cnblogs.com/Ph-one/p/4670804.html">Ph_one</a>以及书籍<strong>linux设备驱动开发详解</strong></p>
</blockquote>
<h2 id="4、struct-cdev-结构体"><a href="#4、struct-cdev-结构体" class="headerlink" title="4、struct cdev 结构体"></a>4、struct cdev 结构体</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这也是字符设备最重要的数据结构之一，在当前的liux内核中每一个字符设备都有一个cdev描述，即一个cdev结构表示一个字符设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> 			<span class="comment">/* 内嵌的kobject对象 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>			<span class="comment">/* 所属模块*/</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>		<span class="comment">/* 文件操作结构体*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="keyword">dev_t</span> dev;				<span class="comment">/* 设备号*/</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;利用这个数据结构就可以在内核创建一个字符设备，分配和初始化cdev的方式有两种，第一种是直接利用同struct cdev类型创建，除此之外还可以使用运行时使用动态创建以及释放，函数接口如下表所示</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>struct&nbsp;cdev&nbsp;*cdev_alloc(void)</td>
<td>动态申请一个cdev内存。</td>
</tr>
<tr>
<td>void&nbsp;cdev_put(struct cdev *p)</td>
<td>释放cdev_alloc申请的内存</td>
</tr>
</tbody></table>
<h2 id="5、字符设备的注册与卸载"><a href="#5、字符设备的注册与卸载" class="headerlink" title="5、字符设备的注册与卸载"></a>5、字符设备的注册与卸载</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;获得cdev这个结构之后我们还需将其初始化以及注册到内核。</p>
<h3 id="1）cdev-init-初始化函数"><a href="#1）cdev-init-初始化函数" class="headerlink" title="1）cdev_init()初始化函数"></a>1）cdev_init()初始化函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);            <span class="comment">// 将整个结构体清零；</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);              <span class="comment">// 初始化list成员使其指向自身；</span></span><br><span class="line">    cdev-&gt;kobj.ktype = &amp;ktype_cdev_default;   <span class="comment">// 初始ktype</span></span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj);                <span class="comment">// 初始化kobj成员；</span></span><br><span class="line">    cdev-&gt;ops = fops                          <span class="comment">// 初始化ops成员；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;初始化函数主要完成以下几个功能，其中就包括建立cdev和file_operation 之间的连接</p>
<ol>
<li>将整个cdev结构体清零</li>
<li>初始化list成员使其指向自身</li>
<li>初适化kobj成员</li>
<li>初始化cdev-&gt;ops，即建立cdev和file_operation 之间的连接</li>
</ol>
<h3 id="2）cdev-add-函数"><a href="#2）cdev-add-函数" class="headerlink" title="2）cdev_add()函数"></a>2）cdev_add()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;dev = dev;</span><br><span class="line">    p-&gt;count = count;</span><br><span class="line">    <span class="keyword">return</span> kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>, exact_match, exact_lock, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中count参数是应该和该设备关联的设备编号的数量，count经常取1，但是也存在多个设备编号对应一个特定的设备的特殊情况。cdev_add()可能会失败，如果它返回一个负的错误码，则设备不会被添加到系统中。但这个调用几乎总会成功。对cdev_add的调用通常发生在字符设备驱动模块加载函数中，一旦调用成功，我们的设备就”活”了，他的操作就会被内核调用，因此在驱动设备还没有完全准备好处理设备上的操作时，不能调用cdev_add。这个函数主要完成的功能如下：</p>
<ol>
<li>初始化cdev结构的dev设备号</li>
<li>初始化cdev的设备数目</li>
<li>向系统添加一个cdev，完成字符设备的注册</li>
</ol>
<h3 id="3）cdev-del-函数"><a href="#3）cdev-del-函数" class="headerlink" title="3）cdev_del()函数"></a>3）cdev_del()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cdev_unmap(p-&gt;dev, p-&gt;count);</span><br><span class="line">    kobject_put(&amp;p-&gt;kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;向系统删除一个cdev，完成字符设备的卸载，对cdev_del的调用通常发生在字符设备驱动模块卸载函数中，当cdev_del被调用后对应的cdev结构就不应被访问了。在早期的内核中还有另外一种注册卸载字符设备的方式，使用register_chrdev()注册用unregister_chrdev()卸载具体如下表所示：</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int register_chrdev(unsigned int major, const char* name, struct file_operations* fops)</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>major</td>
<td>设备的主设备号</td>
</tr>
<tr>
<td>name</td>
<td>驱动程序的名称</td>
</tr>
<tr>
<td>fops</td>
<td>默认的file_operations结构</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用这个函数将为给定的主设备号注册0~255作为次设备号，并为每个设备建立一个对应默认cdev结构。使用这一接口的驱动程序必须能够处理所有256个次设备号的open调用，而且也不能使用大于255的主设备号和次设备号。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>int unregister_chrdev(unsigned int major, const char* name)</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>major</td>
<td>要卸载的设备的主设备号</td>
</tr>
<tr>
<td>name</td>
<td>要卸载驱动程序的名称</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;新的代码中不应在使用这些接口，这种机制在未来的内核中将会消失。</p>
<h2 id="6、设备节点"><a href="#6、设备节点" class="headerlink" title="6、设备节点"></a>6、设备节点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设备节点设备驱动程序的接口，出现在文件系统中就好像它是普通文件一样，通常在/dev目录下，创建设备节点的方式有两种，一种是手动创建，linux内核在运行起来之后，在系统中通过命令手动创建，命令如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建设备节点</span></span><br><span class="line">mknod /dev/xyz c（表示是字符设备） 主设备号 次设备号</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看设备信息：</span></span><br><span class="line">ls -l /dev/xyz</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;除此之外还可以在驱动中自动创建设备文件，该方式依赖于设备模型，<font color=red>字符设备和设备模型的通过设备号关联在一起，只要有设备号就会在 /dev/ 下创建设备节点</font>，参考<a href="https://baron-z.cn/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/#more">设备驱动模型</a>，在这篇文章中搜索 <strong>devtmpfs_create_node</strong>。，一般情况下我们通常按照下面步骤创建</p>
<ol>
<li>调用class_create()函数，可以用它来创建一个类，这个类存放于sys/class/下面，</li>
<li>再调用 device_create() 函数来在/dev目录下创建相应的设备节点，同时也会在sys/class/下创建出对应的设备文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// owner: 模块的拥有着，一般为&quot;THIS_MODULE&quot;</span></span><br><span class="line"><span class="comment">// name : 类名，创建成功后显示 &quot;/sys/class/xxx&quot;</span></span><br><span class="line"><span class="function">struct class *<span class="title">class_create</span><span class="params">(struct <span class="keyword">module</span> *owner, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class: 设备模型中设备所属的类</span></span><br><span class="line"><span class="comment">// parent: 要创建的设备的父设备</span></span><br><span class="line"><span class="comment">// devt: 添加该设备的设备号 dev_t，用于关联字符设备</span></span><br><span class="line"><span class="comment">// drvdata: 该设备的私有数据</span></span><br><span class="line"><span class="comment">// fmt: 备名的名称,创建成功后，将出现 &quot;dev/fmt&quot; 已经 &quot;/sys/class/xxx/fmt&quot;</span></span><br><span class="line"><span class="function">struct device *<span class="title">device_create</span><span class="params">(struct class *class, struct device *parent, <span class="keyword">dev_t</span> devt, <span class="keyword">void</span> *drvdata, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当卸载设备的时候使用函数 device_destroy()从linux内核系统设备驱动程序模型中移除一个设备，并删除/sys/devices/virtual目录下对应的设备目录及/dev/目录下对应的设备文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev:  创建的设备类</span></span><br><span class="line"><span class="comment">// devt: 对应的设备号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_destroy</span><span class="params">(struct class *dev, <span class="keyword">dev_t</span> devt)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="7、字符设备驱动流程"><a href="#7、字符设备驱动流程" class="headerlink" title="7、字符设备驱动流程"></a>7、字符设备驱动流程</h2><p>1）应用层使用open、write、read函数操作dev目录下的设备文件<br>2）设备文件通过内核中对应设备的主设备号，次设备号，找到对应的file_operations结构<br>3）调用file_operations结构中对应的open、write、read函数驱动相关硬件进行操作</p>
<img width=300 src="https://myblog-1259396478.cos.ap-chengdu.myqcloud.com/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/1-1.jpg" >

<h2 id="8、用户与内核内存交互"><a href="#8、用户与内核内存交互" class="headerlink" title="8、用户与内核内存交互"></a>8、用户与内核内存交互</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;用户空间与内核空间之间的数据不能直接进行简单的赋值交互，linux内核提供了两者交互的函数通过 copy_from_user 获取用户空间的数据，通过 copy_to_user 将内核空间的数据传给用户空间，当操作成功后均返回0，操作失败返回负值。</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>static inline unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n)</th>
</tr>
</thead>
<tbody><tr>
<td><div align=center>函数参数</td>
<td><div align=center>参数含义</td>
</tr>
<tr>
<td>to</td>
<td>目标地址，内核空间地址</td>
</tr>
<tr>
<td>from</td>
<td>源地址，用户空间地址</td>
</tr>
<tr>
<td>n</td>
<td>要拷贝的数据字节数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><div align=center><strong>函数接口</strong></td>
<td><div align=center><strong>unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)</strong></td>
</tr>
<tr>
<td>to</td>
<td>目标地址，用户空间地址</td>
</tr>
<tr>
<td>from</td>
<td>源地址，内核空间地址</td>
</tr>
<tr>
<td>n</td>
<td>要拷贝的数据字节数</td>
</tr>
</tbody></table>
<h1 id="二、同步与互斥"><a href="#二、同步与互斥" class="headerlink" title="二、同步与互斥"></a><div align=center>二、同步与互斥</div></h1><p> &nbsp;&nbsp;&nbsp;&nbsp;<font color=red>互斥</font>指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是<strong>无序</strong>的。<font color=red>同步</font>指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的<strong>有序</strong>访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<p>参考<a href="https://mp.weixin.qq.com/s?__biz=MzAxNTAyOTczMw==&mid=2649332930&idx=1&sn=cf6b11d2d344e1f192d07d5f5467bccb&chksm=83977848b4e0f15e0650ec8e39593a755d19f4e4f32b8a25e2a2de7ecb0a641bba98019f7e98&scene=126&sessionid=1594705404&key=fa39e04f3e1bcf44088e1716b6d43d3a03b055518147584373ba2c95ca0956ad080126390dacea464cf8ffc82257ffe2d3bf3ebcb9405b6446a978c602cb657a4da2cd6b3cbf401b3a61731f333a9093&ascene=1&uin=NjY2NDMyNjc3&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=Ac2AMR9MZ4QTTczcCBTu2/E=&pass_ticket=zyBtnDr5s7LlelcQOyYHgtbncGCTFppo47/yH8Kh7rf/WiwN/09CMEDyCfHkbEIF">【干货】同步与互斥的失败例子</a></p>
<h2 id="1、原子变量"><a href="#1、原子变量" class="headerlink" title="1、原子变量"></a>1、原子变量</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1) 基本概念"></a>1) 基本概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 原子操作的基本单位，原子操作指的是由多步操作组成的一个操作。如果操作不能原子地执行，则要么执行完所有的步骤，要么一步也不执行，不可能执行所有步骤的一个子集。<font color=red>原子操作就是不能打断的操作</font>，内核定义的原子变量结构如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel<span class="number">-4.4</span>/include/linux/types.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;armv6 之前的架构 soc 不支持 smp，因此原子变量的实现非常简单，直接采用关中断的方式，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arch\arm\include\<span class="keyword">asm</span>\atomic.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OP(op, c_op, asm_op)                 \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> atomic_#<span class="meta">#op(int i, atomic_t *v)  \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;            \  </span><br><span class="line">                                    \  <span class="comment">// 直接关闭中断</span></span><br><span class="line">    raw_local_irq_save(flags);      \</span><br><span class="line">    v-&gt;counter c_op i;              \</span><br><span class="line">    raw_local_irq_restore(flags);   \  <span class="comment">// 打开中断</span></span><br><span class="line">&#125;                                   \</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OP_RETURN(op, c_op, asm_op)              \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> atomic_#<span class="meta">#op##_return(int i, atomic_t *v)      \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;            \</span><br><span class="line">    <span class="keyword">int</span> val;                        \</span><br><span class="line">                                    \</span><br><span class="line">    raw_local_irq_save(flags);      \   <span class="comment">// 直接关闭中断 </span></span><br><span class="line">    v-&gt;counter c_op i;              \</span><br><span class="line">    val = v-&gt;counter;               \</span><br><span class="line">    raw_local_irq_restore(flags);   \  <span class="comment">// 打开中断</span></span><br><span class="line">                                    \</span><br><span class="line">    <span class="keyword">return</span> val;                     \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_FETCH_OP(op, c_op, asm_op)               \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> atomic_fetch_#<span class="meta">#op(int i, atomic_t *v)         \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;            \</span><br><span class="line">    <span class="keyword">int</span> val;                        \</span><br><span class="line">                                    \</span><br><span class="line">    raw_local_irq_save(flags);      \  <span class="comment">// 直接关闭中断 </span></span><br><span class="line">    val = v-&gt;counter;               \</span><br><span class="line">    v-&gt;counter c_op i;              \</span><br><span class="line">    raw_local_irq_restore(flags);   \  <span class="comment">// 打开中断</span></span><br><span class="line">                                    \</span><br><span class="line">    <span class="keyword">return</span> val;                     \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OPS(op, c_op, asm_op)                    \</span></span><br><span class="line">    ATOMIC_OP(op, c_op, asm_op)                 \</span><br><span class="line">    ATOMIC_OP_RETURN(op, c_op, asm_op)              \</span><br><span class="line">    ATOMIC_FETCH_OP(op, c_op, asm_op)</span><br></pre></td></tr></table></figure>



<p>&nbsp;&nbsp;&nbsp;&nbsp;smp 系统则是使用<font color=dark>内联汇编来实现的</font>。对于 atomic_read 和 atomic_set 这些操作都只需要一条汇编指令，他们本身就是原子的。而 atomic_add 等操作，需要读出，修改，写入则需要特别处理,以 atomic_add 为例说明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除接续符方便代码阅读</span></span><br><span class="line">arch\arm\include\<span class="keyword">asm</span>\atomic.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 6  <span class="comment">// 当 arm 架构 &gt; armv6 的实现</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OP(op, c_op, asm_op)                 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> atomic_#<span class="meta">#op(int i, atomic_t *v)          </span></span><br><span class="line">&#123;                                                     </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;                                </span><br><span class="line">    <span class="keyword">int</span> result;                                       </span><br><span class="line">                                                      </span><br><span class="line">    prefetchw(&amp;v-&gt;counter);                           </span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;@ atomic_&quot;</span> <span class="meta">#op <span class="meta-string">&quot;\n&quot;</span>         </span></span><br><span class="line"><span class="string">&quot;1: ldrex   %0, [%3]\n&quot;</span>         <span class="comment">// 从第 3 个操作数 &quot;r&quot; 的地址读出值，存入第 1 个操作数 &quot;=&amp;r&quot;</span></span><br><span class="line"><span class="string">&quot;   &quot;</span> #asm_op <span class="string">&quot; %0, %0, %4\n&quot;</span>   <span class="comment">// 将第 0 个操作数 &quot;=&amp;r&quot; 加上第 4 个操作数 &quot;Ir&quot; 结果存回第 0 个操作数 &quot;=&amp;r&quot;</span></span><br><span class="line"><span class="string">&quot;   strex   %1, %0, [%3]\n&quot;</span>     <span class="comment">// 将第 0 个操作数的值，即计算的结果，存入第 3 个操作数的值，即 v-&gt;counter 中</span></span><br><span class="line"><span class="string">&quot;   teq %1, #0\n&quot;</span>               <span class="comment">// 判断返回值是否为 0 如果不是跳转到 1: 重新执行上述操作。</span></span><br><span class="line"><span class="string">&quot;   bne 1b&quot;</span> </span><br><span class="line">    <span class="comment">// 第 0 个操作数为 &quot;=&amp;r&quot;  值为 result</span></span><br><span class="line">    <span class="comment">// 第 1 个操作数为 &quot;=&amp;r&quot;  值为 tmp</span></span><br><span class="line">    <span class="comment">// 第 2 个操作数为 &quot;+Qo&quot;  值为 v-&gt;counter</span></span><br><span class="line">    <span class="comment">// 第 3 个操作数为 &quot;r&quot;    值为 &amp;v-&gt;counter</span></span><br><span class="line">    <span class="comment">// 第 4 个操作数为 &quot;cc&quot;   值为 i</span></span><br><span class="line">    : <span class="string">&quot;=&amp;r&quot;</span> (result), <span class="string">&quot;=&amp;r&quot;</span> (tmp), <span class="string">&quot;+Qo&quot;</span> (v-&gt;counter) </span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (&amp;v-&gt;counter), <span class="string">&quot;Ir&quot;</span> (i)                     </span><br><span class="line">    : <span class="string">&quot;cc&quot;</span>);                                          </span><br><span class="line">&#125;                                                     </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_OPS(op, c_op, asm_op)            \</span></span><br><span class="line">    ATOMIC_OP(op, c_op, asm_op)                 \</span><br><span class="line">    ATOMIC_OP_RETURN(op, c_op, asm_op)          \</span><br><span class="line">    ATOMIC_FETCH_OP(op, c_op, asm_op)</span><br><span class="line"></span><br><span class="line">ATOMIC_OPS(add)</span><br><span class="line">ATOMIC_OPS(sub)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;原子操作的实现也主要依靠上述的两条指令 ldrex 和 strex</p>
<ul>
<li><p>ldrex  r0, [r1]<br>读取 r1 所指内存的数据，存入 r0；</p>
</li>
<li><p>strex  r2, r0, [r1]<br>把 r0 的值写入 r1 所指内存，把 r2 设为 0 表示成功。如果没有写入则把 r2 设为 1 表示失败。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这两条指令怎么实现原子操作的呢，是通过 <font color=blue>Local monitor</font> 和<font color=blue> Global monitor </font>来实现的。<font color=blue>Local monitor</font> ：对非共享内存和共享内存都会使用到，是对该 CPU <font color=red>本地的内存进行标记</font>。<font color=blue> Global monitor </font> ： 对共享内存使用，也就是<font color=purple>多个 CPU 都依赖于Global monitor</font>。</p>
<p>对于同一个 cpu 的多线程处理方式如下</p>
<table>
<thead>
<tr>
<th align="center">thread 1</th>
<th align="center">thread 2</th>
<th align="center">local monitor的状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">Open Access state</td>
</tr>
<tr>
<td align="center">LDREX</td>
<td align="center"></td>
<td align="center">Exclusive Access state</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">LDREX</td>
<td align="center">Exclusive Access state</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Modify</td>
<td align="center">Exclusive Access state</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">STREX</td>
<td align="center">Open Access state</td>
</tr>
<tr>
<td align="center">Modify</td>
<td align="center"></td>
<td align="center">Open Access state</td>
</tr>
<tr>
<td align="center">STREX</td>
<td align="center"></td>
<td align="center">在 Open Access state 的状态下，执行 STREX 指令会导致该指令执行失败</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">保持Open Access state，直到下一个 LDREX 指令</td>
</tr>
</tbody></table>
<ul>
<li>刚开始默认情况 local monitor 的状态为 Open Access state</li>
<li>thread 1 运行 LDREX 这条指令将 local monitor 的状态修改为 Exclusive Access state。</li>
<li>后切换到 thread 2 执行 LDREX 这时检测到 local monitor 的状态为 Exclusive Access state </li>
<li>执行 Modify </li>
<li>执行 STREX，执行完 STREX 之后 local monitor 被设置为 Open Access state </li>
<li>回到 thread 1 执行 Modify</li>
<li>执行 STREX ，当执行 STREX 指令会导致该指令执行失败</li>
<li>结合前面的汇编实现。这时候 thread 1 又会重新执行 LDREX，Modify，STREX 直到执行成功。以此来实现原子操作。</li>
</ul>
<p>可以总结出 ldrex 和 strex 的特性如下。</p>
<table>
<thead>
<tr>
<th>local monitor state</th>
<th>ldrex</th>
<th>strex</th>
</tr>
</thead>
<tbody><tr>
<td>Open&nbsp;Access&nbsp;state</td>
<td>指令正常执行且修改 local monitor 状态为 Exclusive Access state</td>
<td>STREX 指令执行失败并返回 1</td>
</tr>
<tr>
<td>Exclusive&nbsp;Access&nbsp;state</td>
<td>指令正常执行且修改 local monitor 状态为 Exclusive Access state</td>
<td>STREX 正常执行且 local monitor 被设置为 Open Access state 同时返回 0</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Global monitor 则用于多 cpu 之间的，状态和 local monitor 是一样的，这里就不再赘述了。</p>
<blockquote>
<p>参考博客<a href="https://blog.csdn.net/weixin_29379325/article/details/80313840">armv7实现原子操作的本质——ldrex和strex指令</a>、<a href="https://blog.csdn.net/w906787/article/details/78907067">ARM同步指令之LDREX和STREX</a></p>
</blockquote>
<h3 id="2-原子操作"><a href="#2-原子操作" class="headerlink" title="2) 原子操作"></a>2) 原子操作</h3><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>atomic_t v = ATOMIC_INIT(0)</td>
<td>定义原子变量并初始化v为0</td>
</tr>
<tr>
<td>void atomic_set(atomic_t* v,int i)</td>
<td>设置原子变量的值为i</td>
</tr>
<tr>
<td>atomic_read(atomic_t* v)</td>
<td>返回原子变量的值</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t* v)</td>
<td>原子变量增加i</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t* v)</td>
<td>原子变量减少i</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t* v)</td>
<td>原子变量自增1</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t* v)</td>
<td>源自变量自减1</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t* v)</td>
<td>原子变量自增1，并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t* v)</td>
<td>原子变量自减1，并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t* v)</td>
<td>原子变量减少i， 并测试其值是否为0。为0返回true，否则返回false</td>
</tr>
<tr>
<td>int atomic_add_return(int i, atomic_t* v)</td>
<td>原子变量的值增加i，并返回新的值</td>
</tr>
<tr>
<td>int atomic_sub_return(int i, atomic_t* v)</td>
<td>原子变量的值减少i，并返回新的值</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t* v)</td>
<td>原子变量的值自增1，并返回新的值</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t* v)</td>
<td>原子变量的值自减1，并返回新的值</td>
</tr>
<tr>
<td>void set_bit(nr,void* addr);</td>
<td>设置addr地址的第nr位，即将nr位置1</td>
</tr>
<tr>
<td>void clear_bit(nr, void* addr);</td>
<td>清除addr地址的nr位，即将nr位清0</td>
</tr>
<tr>
<td>void chang_bit(nr, void* addr);</td>
<td>将addr的nr为反置</td>
</tr>
<tr>
<td>test_bit(nr, void* addr);</td>
<td>返回addr的第nr位</td>
</tr>
<tr>
<td>int test_and_set_bit(nt, void* addr);</td>
<td>测试addr的nr位，再设置为1</td>
</tr>
<tr>
<td>int test_and_clear_bit(nr, void* addr);</td>
<td>测试addr的nr位，再清为0</td>
</tr>
<tr>
<td>int test_and_chang_bit(nr, void* addr);</td>
<td>测试addr的nr位，再反置nr位</td>
</tr>
</tbody></table>
<h2 id="2、linux-中的锁"><a href="#2、linux-中的锁" class="headerlink" title="2、linux 中的锁"></a>2、linux 中的锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;linux 内核提供了很多类型的锁，他们可以分为两类，<font color=red>自旋锁(spinning lock)</font>、<font color=blue>睡眠锁(sleeping lock)</font>。自旋锁就是无法获得锁时，<font color=brown>不会休眠，会一直循环等待</font>。睡眠锁则是是无法获得锁时，<font color=purple>当前线程就会休眠</font>。</p>
<h3 id="1-自旋锁-spin-lock"><a href="#1-自旋锁-spin-lock" class="headerlink" title="1) 自旋锁 spin_lock"></a>1) 自旋锁 spin_lock</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁的实现也需要考虑到两种情况，单 cpu 系统和多 cpu 系统(smp 系统)。对于不同的架构自旋锁的实现方式不同，arm 架构自旋锁的数据结构如下所示，其中实现自旋的关键就是 next 和 owner 两个变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">    <span class="keyword">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> magic, owner_cpu;</span><br><span class="line">    <span class="keyword">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">raw_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> lock;</span><br><span class="line">&#125; <span class="keyword">arch_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arch/arm/include/asm/spinlock_types.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        u32 slock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> &#123;</span> <span class="comment">// 实现自旋锁的关键就是 next 和 owner</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">            u16 next;</span><br><span class="line">            u16 owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            u16 owner;</span><br><span class="line">            u16 next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; tickets;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于没有其他 CPU 的单 CPU 系统，如果内核不支持进程抢占（preempt），当前在内核态执行的线程也不可能被其他线程抢占，也就没有其他进程/线程。所以<font color=dark>对于不支持进程抢占（preempt）的单 CPU 系统，spin_lock 是空函数，不需要做其他事情。</font></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果<font color=blue>单 CPU 系统的内核支持进程抢占（preempt）</font>，即当前线程正在执行内核态函数时，它是有可能被别的线程抢占的。这时 spin_lock 的实现就是<font color=brown>调用 preempt_disable() 函数，关闭 cpu 的进程抢占功能。</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock(lock) _raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_lock(lock)            __LOCK(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LOCK(lock) \ <span class="comment">// 调用 preempt_disable 关闭进程间抢占功能</span></span></span><br><span class="line">  <span class="keyword">do</span> &#123; preempt_disable(); ___LOCK(lock); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___LOCK(lock) \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; __acquire(lock); (<span class="keyword">void</span>)(lock); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/compiler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CHECKER__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __acquire(x)   __context__(x,1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">define __acquire(x) (<span class="keyword">void</span>)<span class="number">0</span> <span class="comment">// 为空函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于 spin_lock_irq()，在 UP 系统中就退化为 local_irq_disable() 和 preempt_disable()，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/spinlock_api_up.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LOCK_IRQ(lock) \ <span class="comment">// 多了一个关中断的操作</span></span></span><br><span class="line">  <span class="keyword">do</span> &#123; local_irq_disable(); __LOCK(lock); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于多 cpu 系统内核怎么实现自旋锁的呢，先来看一下源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/spinlock.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock(lock) _raw_spin_lock(lock)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/spinlock.c</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    __raw_spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//include/linux/spinlock_api_smp.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable(); <span class="comment">// 关闭进程抢占功能</span></span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_); <span class="comment">// 啥也没干</span></span><br><span class="line">    LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//include/linux/lockdep.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spin_acquire(l, s, t, i)        lock_acquire_exclusive(l, s, t, NULL, i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lock_acquire_exclusive(l, s, t, n, i)       lock_acquire(l, s, t, 0, 1, n, i</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> lock_acquire(l, s, t, r, c, n, i)  do &#123; &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//include/linux/lockdep.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONTENDED(_lock, try, lock)                \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                    \</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">try</span>(_lock)) &#123;                                  \ <span class="comment">// </span></span><br><span class="line">        lock_contended(&amp;(_lock)-&gt;dep_map, _RET_IP_);    \</span><br><span class="line">        lock(_lock);                                    \</span><br><span class="line">    &#125;                                                   \</span><br><span class="line">    lock_acquired(&amp;(_lock)-&gt;dep_map, _RET_IP_);         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏替换之后得到下面函数</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                    </span><br><span class="line">    <span class="keyword">if</span> (!do_raw_spin_trylock(lock)) &#123;                                   </span><br><span class="line">        lock_contended(&amp;(lock)-&gt;dep_map, _RET_IP_);   </span><br><span class="line">        do_raw_spin_lock(lock);                                   </span><br><span class="line">    &#125;                                                   </span><br><span class="line">    lock_acquired(&amp;(lock)-&gt;dep_map, _RET_IP_);        </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux/spinlock.h</span></span><br><span class="line"><span class="function">tatic <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">do_raw_spin_trylock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arch_spin_trylock(&amp;(lock)-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arch/alpha/include/asm/spinlock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">arch_spin_trylock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !test_and_set_bit(<span class="number">0</span>, &amp;lock-&gt;lock); <span class="comment">//原子操作测试 lock-&gt;lock 的第 0 位再设置为 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/spinlock_debug.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_raw_spin_lock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    debug_spin_lock_before(lock);</span><br><span class="line">    arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">    debug_spin_lock_after(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arch/arm/include/asm/spinlock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_spin_lock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line">    u32 newval;</span><br><span class="line">    <span class="keyword">arch_spinlock_t</span> lockval;</span><br><span class="line"></span><br><span class="line">    prefetchw(&amp;lock-&gt;slock);</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line"><span class="string">&quot;1: ldrex   %0, [%3]\n&quot;</span>       <span class="comment">// 取出 lock-&gt;slock 中的值存入 lockval</span></span><br><span class="line"><span class="string">&quot;   add %1, %0, %4\n&quot;</span>         <span class="comment">// lockval += 1 &lt;&lt; TICKET_SHIFT，TICKET_SHIFT == 16，即 ockval.tickets.next ++</span></span><br><span class="line"><span class="string">&quot;   strex   %2, %1, [%3]\n&quot;</span>   <span class="comment">// 将 lockval 的计算结果重新赋值给 &amp;lock-&gt;slock</span></span><br><span class="line"><span class="string">&quot;   teq %2, #0\n&quot;</span>             <span class="comment">// 确认是否写入成功</span></span><br><span class="line"><span class="string">&quot;   bne 1b&quot;</span>                   <span class="comment">// 写入失败则再来一次，确保操作的原子性</span></span><br><span class="line">    : <span class="string">&quot;=&amp;r&quot;</span> (lockval), <span class="string">&quot;=&amp;r&quot;</span> (newval), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (&amp;lock-&gt;slock), <span class="string">&quot;I&quot;</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span><br><span class="line">    : <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 lockval.tickets.next 不等于 lockval.tickets.owner 则死循环</span></span><br><span class="line">    <span class="keyword">while</span> (lockval.tickets.next != lockval.tickets.owner) &#123;</span><br><span class="line">        wfe(); <span class="comment">// 将 cpu 进入低功耗待机状态，等待一会</span></span><br><span class="line">        lockval.tickets.owner = ACCESS_ONCE(lock-&gt;tickets.owner); <span class="comment">// 更新一下 lock-&gt;tickets.owner 的状态。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到锁可以进行临界区的访问。</span></span><br><span class="line">    smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由源码可以得出 spin_lock 主要做了下面的事情</p>
<ul>
<li>调用 preempt_disable 关闭进程间的抢占</li>
<li>使用 ldrex 和 strex 以实现操作的原子性</li>
<li>如果 lockval.tickets.next 不等于 lockval.tickets.owner 如果不相等，循环将 cpu 进入低功耗待机状态，等待一会之后更新一下 lock-&gt;tickets.owner 的状态。直到拿到锁为止</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;通过 lockval.tickets.next  实现了排队的操作，每一个 spinlock 都有一个独一无二 lockval.tickets.next ，后来的 spinlock 都是在前一个的基础上增加 1，lock-&gt;tickets.owner 则保存当前轮到谁来获取临界资源。当我们释放锁的时候只需要将 lock-&gt;tickets.owner ++，下一个等待的进程进程就能够拿到对应的锁了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_spin_unlock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    smp_mb();</span><br><span class="line">    lock-&gt;tickets.owner++;</span><br><span class="line">    dsb_sev();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spin_lock 常用了接口如下</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>spin_lock_init</td>
<td>初始化自旋锁 lock</td>
</tr>
<tr>
<td>spin_lock</td>
<td>如果能够获得自旋锁则立刻返回，否则将在那里等待，直到该自旋锁的持有者释放。</td>
</tr>
<tr>
<td>spin_unlock</td>
<td>释放自旋锁 lock</td>
</tr>
<tr>
<td>spin_try_lock</td>
<td>尝试获得自旋锁，如果能立刻获得锁返回 true，否则立刻返回 false</td>
</tr>
<tr>
<td>spin_lock_bh/spin_unlock_bh</td>
<td>加锁时禁止下半部(软中断)，解锁时使能下半部(软中断)</td>
</tr>
<tr>
<td>spin_lock_irq/spin_unlock_irq</td>
<td>加锁时禁止中断，解锁时使能中断</td>
</tr>
<tr>
<td>spin_lock_irqsave/spin_lock_restore</td>
<td>加锁时禁止并中断并记录状态，解锁时恢复中断为所记录的状态</td>
</tr>
</tbody></table>
<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2) 信号量"></a>2) 信号量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一个信号量本质上是一个整数值，它和一对函数联合使用，这对函数通常称为 P 和 V。希望进入临界区的进程将在相关信号量上调用 P;如果信号量的值大于 0,则该值会减1，而进程可以继续。相反，如果信号量的值为 0(或者更小)，进程进入休眠并等待直到其他人释放该信号量。对信号量的解锁通过调用 V 来完成；该函数增加信号量的值，并在必要时唤醒等待的进程。当我们需要将信号量用于互斥时，只需将信号量的值设为 1。这样的信号量在任何给定时刻只能由单个线程拥有。内核定义的信号量如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/semaphore.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出信号量其实也使用了 raw_spinlock_t 这个结构体，来看看源码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/semaphore.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags); <span class="comment">// 使用自旋锁实现互斥，防止在操作过程被打断</span></span><br><span class="line">    <span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __down(sem);</span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(down);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    __down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sched __down_common(struct semaphore *sem, <span class="keyword">long</span> state,</span><br><span class="line">                                <span class="keyword">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list); <span class="comment">// 将当前信号量添加进 sem-&gt;wait_list 链表。</span></span><br><span class="line">    waiter.task = task;</span><br><span class="line">    waiter.up = <span class="literal">false</span>; <span class="comment">// 初始化唤醒状态为 false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending_state(state, task)) </span><br><span class="line">            <span class="keyword">goto</span> interrupted;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">goto</span> timed_out;</span><br><span class="line">        __set_task_state(task, state);        <span class="comment">// 设置进程状态为 TASK_UNINTERRUPTIBLE</span></span><br><span class="line">        raw_spin_unlock_irq(&amp;sem-&gt;lock);      <span class="comment">// 将前面拿到的锁释放掉，以便其他进行在获取不到信号量是能跑到这里。</span></span><br><span class="line">        timeout = schedule_timeout(timeout);  <span class="comment">// 当今进程进入休眠，调度其他进行运行</span></span><br><span class="line">        raw_spin_lock_irq(&amp;sem-&gt;lock);        <span class="comment">// 唤醒后要先拿锁，两个作用防止后面的状态被打断，同时要和后面 raw_spin_unlock_irqrestore 进行配对。</span></span><br><span class="line">        <span class="keyword">if</span> (waiter.up)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">    list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">    list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;总的来说只有得到信号量的进程才能执行临界区的代码，<font color=red>当得不到信号量时，进程会进入休眠等待状态</font>。并将当前进程放入对应的链表中。当有信号量被释放时遍历这个链表，唤醒被休眠的进程继续执行。信号量释放的流程如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags); <span class="comment">// 拿锁实现互斥，防止同时间其他信号量的释放带来的异常。</span></span><br><span class="line">    <span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list))) <span class="comment">// 当队列中没有需要获取信号量的进程时释放信号量</span></span><br><span class="line">        sem-&gt;count++; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __up(sem); <span class="comment">// 唤醒队列中的第一个进行并将信号量交给该进程。</span></span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(up);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __up(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line">                        struct semaphore_waiter, <span class="built_in">list</span>); <span class="comment">// 获取队列中的第一项</span></span><br><span class="line">    list_del(&amp;waiter-&gt;<span class="built_in">list</span>);       <span class="comment">// 从队列中将其删除</span></span><br><span class="line">    waiter-&gt;up = <span class="literal">true</span>;             <span class="comment">// 设置其唤醒状态</span></span><br><span class="line">    wake_up_process(waiter-&gt;task); <span class="comment">// 唤醒这个进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;常用接口</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECLARE_MUTEX(name);</td>
<td>将信号量name初始化为1</td>
</tr>
<tr>
<td>DECLARE_MUTEX_LOCKED(name);</td>
<td>将信号量name初始化为0</td>
</tr>
<tr>
<td>void init_MUTEX(struct semaphore *sem)</td>
<td>将信号量sem初始化为1</td>
</tr>
<tr>
<td>void init_NUTEX_LOCKED(struct semaphore *sem);</td>
<td>将信号量sem初始化为0</td>
</tr>
<tr>
<td>void sema_init(struct semaphore* sem, int val);</td>
<td>初始化信号量的值为 val</td>
</tr>
<tr>
<td>void&nbsp;down(struct&nbsp;semaphore&nbsp;*sem);</td>
<td>递减信号量的值，获取不到是进程进入休眠</td>
</tr>
<tr>
<td>int&nbsp;down_interruptible(struct&nbsp;semaphore&nbsp;*sem);</td>
<td>递减信号量的值，获取不到是进程进入休眠，但是操作是可以中断的，它允许一个在等待的信号量的用户空间进程被用户中断。如果在操作中被中断，函数会返回一个非零值，并且调用者不持有信号量，真确的使用它需要一直检查返回值并针对性地响应。</td>
</tr>
<tr>
<td>int&nbsp;down_trylock(struct&nbsp;seamphore*&nbsp;sem);</td>
<td>永远不会休眠，如果信号量在调用时不可获得，它会返回一个非零值</td>
</tr>
<tr>
<td>void up(struct semaphore *sem);</td>
<td>当队列中没有需要获取信号量的进程时释放信号量，如果有则唤醒队列中的第一个线程同时将信号量的持有转交给该线程</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;任何拿到信号量的线程都必须通过一次对 up 的调用而释放该信号量。在出现错误的情况下，经常需要特别小心。如果在拥有一个信号量时发生错误，必须将错误状态返回给调用者之前释放该信号量。忘记释放信号量将导致进程在某些无关的位置被意外挂起，很难复现和跟踪</p>
<h3 id="3-互斥锁"><a href="#3-互斥锁" class="headerlink" title="3) 互斥锁"></a>3) 互斥锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;互斥锁主要用于实现内核中的互斥访问功能。一般用来保护一段代码，的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        count; <span class="comment">// 1 表示unlocked，0 表示有线程拿锁，但是没有其他线程排队， -1 表示有线程拿锁，并且有其他线程在排队。</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">owner</span>;</span> <span class="comment">// 用来调试或者优化性能，只有位两个不同的 cpu 进程同时拿锁时，并且只有一个在等待时，就不会休眠会多等待一回合，提高效率。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="keyword">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;mutex 的实现分为两个部分 fastpath 和 slowpath。如果 fastpath 成功就不再使用 slowpath。同样的 mutex 的实现在不同的架构下实现方式也不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/asm/mutex.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LINUX_ARM_ARCH__ &lt; 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-generic/mutex-xchg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-generic/mutex-dec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* _ASM_MUTEX_H */</span></span></span><br></pre></td></tr></table></figure>
<p> armv6 之前的实现就不贴出来了，基本差不多。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">mutex_lock</span><span class="params">(struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The locking fastpath is the 1-&gt;0 transition from</span></span><br><span class="line"><span class="comment">     * &#x27;unlocked&#x27; into &#x27;locked&#x27; state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);</span><br><span class="line">    mutex_set_owner(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/mutex-dec.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__mutex_fastpath_lock(<span class="keyword">atomic_t</span> *count, <span class="keyword">void</span> (*fail_fn)(<span class="keyword">atomic_t</span> *))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 count 的初始值 为 1</span></span><br><span class="line">    <span class="comment">// 减 1 后为 0, if 条件不成立直接得到锁返回</span></span><br><span class="line">    <span class="comment">// 如果初始 count &lt; = 0 减 1 后 &lt;= 0 调用回调函数 fail_fn 即 __mutex_lock_slowpath</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(atomic_dec_return_acquire(count) &lt; <span class="number">0</span>))</span><br><span class="line">        fail_fn(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line">__mutex_lock_slowpath(<span class="keyword">atomic_t</span> *lock_count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span> =</span> container_of(lock_count, struct mutex, count);</span><br><span class="line"></span><br><span class="line">    __mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, <span class="number">0</span>,</span><br><span class="line">                <span class="literal">NULL</span>, _RET_IP_, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * kernel/locking/mutex.c</span></span><br><span class="line"><span class="comment"> * lock = lock</span></span><br><span class="line"><span class="comment"> * state = TASK_UNINTERRUPTIBLE</span></span><br><span class="line"><span class="comment"> * subclass = 0</span></span><br><span class="line"><span class="comment"> * nest_lock = null</span></span><br><span class="line"><span class="comment"> * ip = _RET_IP_</span></span><br><span class="line"><span class="comment"> * ww_ctx = NULL</span></span><br><span class="line"><span class="comment"> * use_ww_ctx = 0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span> __sched</span><br><span class="line">__mutex_lock_common(struct mutex *lock, <span class="keyword">long</span> state, <span class="keyword">unsigned</span> <span class="keyword">int</span> subclass,</span><br><span class="line">            struct lockdep_map *nest_lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> ip,</span><br><span class="line">            struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> <span class="keyword">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_ww_ctx) &#123; <span class="comment">// 为 0 直接跳过</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span> =</span> container_of(lock, struct ww_mutex, base);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line">            <span class="keyword">return</span> -EALREADY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preempt_disable(); <span class="comment">// 关闭 cpu 线程抢占功能</span></span><br><span class="line">    mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也许其他 cpu 获得了 mutex 它会很快释放，可能不需要休眠</span></span><br><span class="line">    <span class="keyword">if</span> (mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx)) &#123;</span><br><span class="line">        <span class="comment">/* got the lock, yay! */</span></span><br><span class="line">        preempt_enable();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 spin_lock 实现操作的互斥性</span></span><br><span class="line">    spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次尝试获取 mutex 锁。 </span></span><br><span class="line">    <span class="keyword">if</span> (!mutex_is_locked(lock) &amp;&amp;</span><br><span class="line">        (atomic_xchg_acquire(&amp;lock-&gt;count, <span class="number">0</span>) == <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">goto</span> skip_wait;</span><br><span class="line"></span><br><span class="line">    debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line">    debug_mutex_add_waiter(lock, &amp;waiter, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前进程放入 mutex 的 wait_list,这个 wait_list 是 FIFO ，谁先排队，谁就可以先得到 mutex。</span></span><br><span class="line">    list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;lock-&gt;wait_list);</span><br><span class="line">    waiter.task = task;</span><br><span class="line"></span><br><span class="line">    lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 再次尝试获取锁</span></span><br><span class="line">        <span class="comment">// 如果 count == 1 ，表示锁没有人用，我们将其设置为 -1 ，直接退出</span></span><br><span class="line">        <span class="comment">// 如果 count == 0 ，表示锁被人拿走，并且没人排队，我们将其设置为 -1，继续往下</span></span><br><span class="line">        <span class="comment">// 如果 count &lt; 0 ，表示锁被别人拿走，并且有人在排队，继续往下</span></span><br><span class="line">        <span class="keyword">if</span> (atomic_read(&amp;lock-&gt;count) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (atomic_xchg_acquire(&amp;lock-&gt;count, <span class="number">-1</span>) == <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测进程是否可以休眠，如果有信号在 pending 状态，而且 state 状态还是UNINTERRUPTIBLE 状态的话，是不能休眠等待的</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(signal_pending_state(state, task))) &#123;</span><br><span class="line">            ret = -EINTR;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx-&gt;acquired &gt; <span class="number">0</span>) &#123; <span class="comment">// use_ww_ctx 为 0</span></span><br><span class="line">            ret = __ww_mutex_lock_check_stamp(lock, ww_ctx);</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置进程状态</span></span><br><span class="line">        __set_task_state(task, state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* didn&#x27;t get the lock, go to sleep: */</span></span><br><span class="line">        spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">        schedule_preempt_disabled(); <span class="comment">// 调度进程进入休眠</span></span><br><span class="line">        spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    __set_task_state(task, TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前进程从 mutex 链表中删除</span></span><br><span class="line">    mutex_remove_waiter(lock, &amp;waiter, task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如过没有其他进程等待获取 mutex 锁将 count 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))</span><br><span class="line">        atomic_set(&amp;lock-&gt;count, <span class="number">0</span>);</span><br><span class="line">    debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line">    <span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">    lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line">    mutex_set_owner(lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_ww_ctx) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span> =</span> container_of(lock, struct ww_mutex, base);</span><br><span class="line">        ww_mutex_set_context_slowpath(ww, ww_ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags); <span class="comment">// 关闭前面获取的 spin lock</span></span><br><span class="line">    preempt_enable(); <span class="comment">// 打开进程抢占功能，到这里我们已经获取到 mutex 锁，可以正常访问临界区了。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    mutex_remove_waiter(lock, &amp;waiter, task);</span><br><span class="line">    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">    mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">    preempt_enable();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;总结：进程在获取 mutex 锁时 count 为 1 时，将 count 减 1 直接获取该锁，访问临界区。如果获取锁时获取不到，则进入如下的休眠流程。</p>
<ul>
<li>将当前进程放入 mutex 的 wait_list</li>
<li>将 count 设置为 -1 ，表示有进程正在排队</li>
<li>设置进程状态，进程休眠，调度其他进程工作</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;再来看一下释放流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">mutex_unlock</span><span class="params">(struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    mutex_clear_owner(lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    __mutex_fastpath_unlock(&amp;lock-&gt;count, __mutex_unlock_slowpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(mutex_unlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/mutex-dec.h</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__mutex_fastpath_unlock(<span class="keyword">atomic_t</span> *count, <span class="keyword">void</span> (*fail_fn)(<span class="keyword">atomic_t</span> *))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// count 曾加 1 如果结果 &gt; 0 表示无人等待直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(atomic_inc_return_release(count) &lt;= <span class="number">0</span>))</span><br><span class="line">        fail_fn(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line">__visible <span class="keyword">void</span> __mutex_unlock_slowpath(<span class="keyword">atomic_t</span> *lock_count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span> =</span> container_of(lock_count, struct mutex, count);</span><br><span class="line"></span><br><span class="line">    __mutex_unlock_common_slowpath(lock, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/locking/mutex.c</span></span><br><span class="line">__mutex_unlock_common_slowpath(struct mutex *lock, <span class="keyword">int</span> nested)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __mutex_slowpath_needs_to_unlock() 这是个宏被初始化为 1</span></span><br><span class="line">    <span class="comment">// 因此这里就是将 count 设置为 1</span></span><br><span class="line">    <span class="keyword">if</span> (__mutex_slowpath_needs_to_unlock())</span><br><span class="line">        atomic_set(&amp;lock-&gt;count, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 spin lock</span></span><br><span class="line">    spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    mutex_release(&amp;lock-&gt;dep_map, nested, _RET_IP_);</span><br><span class="line">    debug_mutex_unlock(lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;lock-&gt;wait_list)) &#123;</span><br><span class="line">        <span class="comment">// 如果还有进程在等待获取锁则，从 wait_list 中取出第一个进程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> *<span class="title">waiter</span> =</span></span><br><span class="line">                list_entry(lock-&gt;wait_list.next,</span><br><span class="line">                       struct mutex_waiter, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        debug_mutex_wake_waiter(lock, waiter);</span><br><span class="line">        wake_q_add(&amp;wake_q, waiter-&gt;task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放前面获取的 spin lock</span></span><br><span class="line">    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">    wake_up_q(&amp;wake_q); <span class="comment">// 唤醒这个进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;总结：如果 count = 0 表示没线程等待，直接将 count 加 1。如果 count 等于 -1 表示有线程等待，进入唤醒流程</p>
<ul>
<li>从 wait_list 中取出第一个进程，并将其唤醒</li>
<li>根据是否还有进程在等待设置 count 的状态，有进程等待设置为 -1，没有则设置为 0</li>
<li>唤醒的进程从 mutex 链表中删除自己</li>
<li>被唤醒的进程访问临界区资源</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;常用接口如下</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name);</td>
<td>静态创建化互斥锁 name</td>
</tr>
<tr>
<td>mutex_init(&amp;mutex);</td>
<td>动态初始化互斥锁 mutex</td>
</tr>
<tr>
<td>mutex_lock(lock)；</td>
<td>获取互斥锁，获取不到则进入睡眠</td>
</tr>
<tr>
<td>mutex_trylock(lock)；</td>
<td>尝试获取互斥锁，成功返回1，    失败返回0</td>
</tr>
<tr>
<td>mutex_unlock(lock)；</td>
<td>释放互斥锁</td>
</tr>
<tr>
<td>mutex_is_lock(lock)；</td>
<td>如果锁已被使用返回1，否则返回0</td>
</tr>
</tbody></table>
<h3 id="4-锁的使用场景"><a href="#4-锁的使用场景" class="headerlink" title="4) 锁的使用场景"></a>4) 锁的使用场景</h3><ul>
<li>在可以睡眠的用户上下文中加锁使用<font color=red>信号量(semaphore)</font>和<font color=blue>互斥锁(mutex)</font>。其中 mutex 一般不会被长期持有，用于保护一段代码。</li>
<li>在用户上下文与 Softirqs 之间加锁使用 spin_lock_bh/spin_unlock_bh</li>
<li>在用户上下文与 Tasklet 之间加锁 spin_lock_bh/spin_unlock_bh</li>
<li>在用户上下文与 Timer 之间加锁 spin_lock_bh/spin_unlock_bh</li>
<li>不同 cpu 之间在 Tasklet 与 Timer 之间无需加锁</li>
<li>在 Softirq 之间加锁 spin_lock/pin_unlock</li>
</ul>
<h1 id="三、linux-队列"><a href="#三、linux-队列" class="headerlink" title="三、linux 队列"></a><div align=center>三、linux 队列</div></h1><h2 id="1、等待队列"><a href="#1、等待队列" class="headerlink" title="1、等待队列"></a>1、等待队列</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;等待队列从功能上可以简单理解为：让进程进入睡眠，在你想让他工作的时候唤醒。它有两部分组成首先是挂接我们等待队列项的等待头，等待队列头的数据结构描述如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include/linux/wait.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock; <span class="comment">// 在对task_list与操作的过程中，使用该锁实现对等待队列的互斥访问。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">task_list</span>;</span> <span class="comment">// 链接等待进程 wait_queue_t</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>而挂接在其上面的等待队列项的数据局结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> <span class="title">wait_queue_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* falgs 标识 wait_queue_t 成员的状态和属性 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE   0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_WOKEN       0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_BOOKMARK    0x04</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        flags;</span><br><span class="line">    <span class="keyword">void</span>            *<span class="keyword">private</span>;  <span class="comment">// 保存当前任务的 task_struct 对象地址，一般默认为 current</span></span><br><span class="line">    <span class="keyword">wait_queue_func_t</span>   func;  <span class="comment">// 唤醒函数的回调函数，一般默认为 default_wake_function</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span> <span class="comment">// 用于将该结构挂接到 wait_queue_head_t</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>他们的创建与与初始化如下</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECLARE_WAIT_QUEUE_HEAD(name)</td>
<td>声明等待队列头 name</td>
</tr>
<tr>
<td>init_waitqueue_head(name)</td>
<td>初始化等待队列头 name</td>
</tr>
<tr>
<td>DECLARE_WAITQUEUE(name, tsk)</td>
<td>定义等待队列成员 name</td>
</tr>
</tbody></table>
<h3 id="2-添加-删除等待队列成员"><a href="#2-添加-删除等待队列成员" class="headerlink" title="2. 添加/删除等待队列成员"></a>2. 添加/删除等待队列成员</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; <span class="comment">//将 WQ_FLAG_EXCLUSIVE 清零</span></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue(wq_head, wq_entry);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue_exclusive</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    wq_entry-&gt;flags |= WQ_FLAG_EXCLUSIVE; <span class="comment">//将 WQ_FLAG_EXCLUSIVE 置为</span></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue_entry_tail(wq_head, wq_entry);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue_exclusive);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue_entry_tail(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">    list_add_tail(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_wait_queue</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    __remove_wait_queue(wq_head, wq_entry);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(remove_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">    list_del(&amp;wq_entry-&gt;entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-进程休眠"><a href="#3-进程休眠" class="headerlink" title="3. 进程休眠"></a>3. 进程休眠</h3><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>wait_event(wq,&nbsp;condition)</td>
<td>如果condition为0，则进程休眠，且休眠状态不能被中断打断</td>
</tr>
<tr>
<td>wait_event_timeout(wq,&nbsp;condition,&nbsp;timeout)</td>
<td>如果condition为0，则进入休眠，当 timeout 到了则唤醒进程不管此时condition为真为假都会返回</td>
</tr>
<tr>
<td>wait_event_interruptible(wq,&nbsp;condition)</td>
<td>如果condition为0，则进程休眠，休眠状态可以被中断打断，当休眠被中断打断时返回0，这时驱动应返回 -ERESTARTSYS</td>
</tr>
<tr>
<td>wait_event_interruptible_timeout(wq,&nbsp;condition,&nbsp;timeout)</td>
<td>如果condition为0，则进程休眠，休眠状态可以被中断打断，当休眠被中断打断时返回0，这时驱动应返回 -ERESTARTSY，当 timeout 到了则唤醒进程不管此时condition为真为假都会返回</td>
</tr>
</tbody></table>
<p>源码分析如下</p>
<h4 id="1-wait-event"><a href="#1-wait-event" class="headerlink" title="1) wait_event"></a>1) wait_event</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq_head, condition)                      </span></span><br><span class="line"><span class="keyword">do</span> &#123;                                        </span><br><span class="line">    might_sleep();                              </span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="comment">//如果 condition  为真直接返回     </span></span><br><span class="line">        <span class="keyword">break</span>;                              </span><br><span class="line">    __wait_event(wq_head, condition);                   </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq_head, condition)                    \</span></span><br><span class="line">    (<span class="keyword">void</span>)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="number">0</span>, schedule())</span><br></pre></td></tr></table></figure>
<h4 id="2-wait-event"><a href="#2-wait-event" class="headerlink" title="2) ___wait_event"></a>2) ___wait_event</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__wait_event 的默认值如下</span></span><br><span class="line"><span class="comment">//state = TASK_UNINTERRUPTIBLE</span></span><br><span class="line"><span class="comment">//exclusive = 0</span></span><br><span class="line"><span class="comment">//ret = 0</span></span><br><span class="line"><span class="comment">//cmd = schedule()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___wait_event(wq_head, condition, state, exclusive, ret, cmd)       </span></span><br><span class="line">(&#123;                                      </span><br><span class="line">    __label__ __out;                            </span><br><span class="line">    <span class="comment">//创建一个等待队列成员 __wq_entry</span></span><br><span class="line">    struct wait_queue_entry __wq_entry;                </span><br><span class="line">    <span class="keyword">long</span> __ret = ret;   <span class="comment">/* explicit shadow */</span>               </span><br><span class="line">                                                         </span><br><span class="line">    <span class="comment">//初始化等待队列成员 __wq_entry</span></span><br><span class="line">    <span class="comment">//flags 为 0</span></span><br><span class="line">    <span class="comment">//private 被初始化为 current</span></span><br><span class="line">    <span class="comment">//fun 被初始化为 autoremove_wake_function</span></span><br><span class="line">    init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : <span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//死循环</span></span><br><span class="line">        <span class="comment">// 1. 检查当前信号是否有待处理的信号</span></span><br><span class="line">        <span class="comment">// 2. 检测链表状态防止等待队列成员未插入等待队列头</span></span><br><span class="line">        <span class="comment">// 3. 设置进程状态为 TASK_UNINTERRUPTIBLE</span></span><br><span class="line">        <span class="keyword">long</span> __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);</span><br><span class="line">                                        </span><br><span class="line">        <span class="keyword">if</span> (condition)    <span class="comment">//再次检测 condition 如果为真则返回                  </span></span><br><span class="line">            <span class="keyword">break</span>;                          </span><br><span class="line">         <span class="comment">//进程有待处理信号且处于可中断状态(TASK_INTERRUPTIBLE、TASK_KILLABLE)则跳出循环                               </span></span><br><span class="line">        <span class="keyword">if</span> (___wait_is_interruptible(state) &amp;&amp; __int) &#123;         </span><br><span class="line">            __ret = __int;                      </span><br><span class="line">            <span class="keyword">goto</span> __out;                     </span><br><span class="line">        &#125;                               </span><br><span class="line">                                        </span><br><span class="line">        cmd; <span class="comment">//调用 schedule() 函数,让进程休眠，调度其他进程工作。</span></span><br><span class="line">    &#125;                                   </span><br><span class="line">    finish_wait(&amp;wq_head, &amp;__wq_entry);                 </span><br><span class="line">__out:  __ret;                                  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="3-init-wait-entry"><a href="#3-init-wait-entry" class="headerlink" title="3) init_wait_entry"></a>3) init_wait_entry</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wait_entry</span><span class="params">(struct wait_queue_entry *wq_entry, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wq_entry-&gt;flags = flags;</span><br><span class="line">    wq_entry-&gt;<span class="keyword">private</span> = current;</span><br><span class="line">    wq_entry-&gt;func = autoremove_wake_function;</span><br><span class="line">    INIT_LIST_HEAD(&amp;wq_entry-&gt;entry);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(init_wait_entry);</span><br></pre></td></tr></table></figure>
<h4 id="4-prepare-to-wait-event"><a href="#4-prepare-to-wait-event" class="headerlink" title="4). prepare_to_wait_event"></a>4). prepare_to_wait_event</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">prepare_to_wait_event</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123; <span class="comment">// 检测信号状态是否是待处理状态</span></span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;wq_entry-&gt;entry);</span><br><span class="line">        ret = -ERESTARTSYS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;wq_entry-&gt;entry)) &#123; <span class="comment">// 检查链表是否已经插入等待队列头</span></span><br><span class="line">            <span class="keyword">if</span> (wq_entry-&gt;flags &amp; WQ_FLAG_EXCLUSIVE)</span><br><span class="line">                __add_wait_queue_entry_tail(wq_head, wq_entry); <span class="comment">//将其插入到队列头的尾部</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                __add_wait_queue(wq_head, wq_entry); <span class="comment">//将其插入到等待队列头</span></span><br><span class="line">        &#125;</span><br><span class="line">        set_current_state(state); <span class="comment">//设置进程状态为 TASK_UNINTERRUPTIBLE</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_to_wait_event);</span><br></pre></td></tr></table></figure>
<h3 id="4-唤醒进程"><a href="#4-唤醒进程" class="headerlink" title="4. 唤醒进程"></a>4. 唤醒进程</h3><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>void&nbsp;wake_up(wait_queue_head_t&nbsp;*q);</td>
<td>唤醒等待队列 q 上的进程，如果 condition 为真则返回</td>
</tr>
<tr>
<td>void&nbsp;wake_up_interruptible(wait_queue_head_t&nbsp;*q);</td>
<td>唤醒等待队列 q 上的进程，如果 condition 为真则返回</td>
</tr>
</tbody></table>
<p>源码分析如下</p>
<h4 id="1-wake-up"><a href="#1-wake-up" class="headerlink" title="1) __wake_up"></a>1) __wake_up</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __wake_up(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    __wake_up_common_lock(wq_head, mode, nr_exclusive, <span class="number">0</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__wake_up);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common_lock(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">wait_queue_entry_t</span> bookmark; <span class="comment">// 创建一个等待队列成员 bookmark</span></span><br><span class="line"></span><br><span class="line">    bookmark.flags = <span class="number">0</span>;          <span class="comment">// 初始化 flag 为 0</span></span><br><span class="line">    bookmark.<span class="keyword">private</span> = <span class="literal">NULL</span>;     <span class="comment">// 初始化 private 为空</span></span><br><span class="line">    bookmark.func = <span class="literal">NULL</span>;        <span class="comment">// 初始化唤醒函数为空</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;bookmark.entry);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &amp;bookmark);</span><br><span class="line">    spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bookmark.flags &amp; WQ_FLAG_BOOKMARK) &#123;</span><br><span class="line">        spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">        nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,</span><br><span class="line">                        wake_flags, key, &amp;bookmark);</span><br><span class="line">        spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-wake-up-common"><a href="#2-wake-up-common" class="headerlink" title="2) __wake_up_common"></a>2) __wake_up_common</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __wake_up_common(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key,</span><br><span class="line">            <span class="keyword">wait_queue_entry_t</span> *bookmark)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">wait_queue_entry_t</span> *curr, *next;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) &#123;</span><br><span class="line">        curr = list_next_entry(bookmark, entry); <span class="comment">//获取bookmark的下一个等待队列成员</span></span><br><span class="line"></span><br><span class="line">        list_del(&amp;bookmark-&gt;entry); <span class="comment">//删除当前成员 bookmark</span></span><br><span class="line">        bookmark-&gt;flags = <span class="number">0</span>; <span class="comment">//将当前的 flag 清零</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        curr = list_first_entry(&amp;wq_head-&gt;head, <span class="keyword">wait_queue_entry_t</span>, entry); <span class="comment">//查找等待队列头的第一个的等待队列成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (&amp;curr-&gt;entry == &amp;wq_head-&gt;head) <span class="comment">//如果当前等待队列是空则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nr_exclusive;</span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123; <span class="comment">//从 curr 的下一个等待成员开始循环遍历一遍等待队列头中的等待队列成员。</span></span><br><span class="line">        <span class="keyword">unsigned</span> flags = curr-&gt;flags; <span class="comment">//获取 flags</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; WQ_FLAG_BOOKMARK) <span class="comment">//如果为 WQ_FLAG_BOOKMARK 进入下次循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用对应的 func 成员函数,一般为默认的唤醒函数 autoremove_wake_function</span></span><br><span class="line">        ret = curr-&gt;func(curr, mode, wake_flags, key);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果唤醒的进程的 flags 为WQ_FLAG_EXCLUSIVE 且 nr_exclusive 为 0 则推出</span></span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;</span><br><span class="line">                (&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123;</span><br><span class="line">            bookmark-&gt;flags = WQ_FLAG_BOOKMARK;</span><br><span class="line">            list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nr_exclusive;</span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure>
<h2 id="2、工作队列"><a href="#2、工作队列" class="headerlink" title="2、工作队列"></a>2、工作队列</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;工作队列（work queue）是一种将工作推后执行的形式，它和tasklet有所不同。工作队列可以把工作推后，交由一个内核线程去执行，也就是说，这个下半部分可以在进程上下文中执行。这样，通过工作队列执行的代码能占尽进程上下文的所有优势。最重要的就是工作队列允许被重新调度甚至是睡眠。它的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://blog.csdn.net/bullbat/article/details/7410563">Linux内核实践之工作队列</a></p>
<h3 id="3-操作函数"><a href="#3-操作函数" class="headerlink" title="3) 操作函数"></a>3) 操作函数</h3><h4 id="1-初始化工作队列"><a href="#1-初始化工作队列" class="headerlink" title="1. 初始化工作队列"></a>1. 初始化工作队列</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>INIT_WORK(work,func)</td>
<td>初始化工作队列项 work，并设置回调函数func</td>
</tr>
<tr>
<td>DECLARE_WORK(name,func)</td>
<td>声明一个等待队列项 name，并设置回调函数func</td>
</tr>
</tbody></table>
<h4 id="2-调度工作队列"><a href="#2-调度工作队列" class="headerlink" title="2. 调度工作队列"></a>2. 调度工作队列</h4><table>
<thead>
<tr>
<th>函数接口</th>
<th>接口含义</th>
</tr>
</thead>
<tbody><tr>
<td>schedule_work(&amp;work)</td>
<td>调度工作队列</td>
</tr>
<tr>
<td>schedule_delayed_work(&amp;work,tick)</td>
<td>延时tick个滴答应答之后调度工作队列</td>
</tr>
</tbody></table>
<h1 id="四、linux内核通知链"><a href="#四、linux内核通知链" class="headerlink" title="四、linux内核通知链"></a>四、linux内核通知链</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;内核中不同模块间的消息通知机制，告诉其他模块，当前发生了什么事情。内核通知链只能用于内核之间，不能用于内核于用户空间之间的通信。实现原理很简单，就是<font color=red>通知的模块</font>提供一个链表，<font color=blue>被通知的模块</font>将回调函数注册进入通知模块提供的链表中。当发生事件时通知模块遍历链表中的所有回调函数，并根据传入的参数依次调用。以原子通知链为例进行说名，原子通知链提供的链表头如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">//原子通知链的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span> <span class="comment">//用于挂接该链表上的 notifier_block 结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>无论是什么通知链，都是使用 notifier_block 作为该通知链的成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">notifier_fn_t</span>)</span><span class="params">(struct notifier_block *nb,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">notifier_fn_t</span> notifier_call;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">next</span>;</span> <span class="comment">//指向所属的链表头</span></span><br><span class="line">    <span class="keyword">int</span> priority; <span class="comment">//优先级，越大优先级越高，且将位于队列的更前面，更先被调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;实现过程很简单，就两步，第一步<font color=red>注册被通知模块的成员 notifier_block 到发出通知模块提供的链表头 atomic_notifier_head 上</font>，第二步<font color=blue>当发出通知模块要通知时，调用该链表头上的成员的回调函数即可</font>。注册过程很简单如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_chain_register</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;nh-&gt;lock, flags);</span><br><span class="line">    ret = notifier_chain_register(&amp;nh-&gt;head, n); <span class="comment">//将 n 注册到 nh-&gt;head 链表</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_chain_register);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_chain_register</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((*nl) != <span class="literal">NULL</span>) &#123; <span class="comment">//遍历到 atomic_notifier_head 的尾部</span></span><br><span class="line">        <span class="keyword">if</span> (n-&gt;priority &gt; (*nl)-&gt;priority)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nl = &amp;((*nl)-&gt;next); </span><br><span class="line">    &#125;</span><br><span class="line">    n-&gt;next = *nl; <span class="comment">//指向对应的链表头 nl</span></span><br><span class="line">    rcu_assign_pointer(*nl, n); <span class="comment">//将 n 插入到链表头 nl 的尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下调用过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_call_chain</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __atomic_notifier_call_chain(nh, val, v, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_call_chain);</span><br><span class="line">NOKPROBE_SYMBOL(atomic_notifier_call_chain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __atomic_notifier_call_chain(struct atomic_notifier_head *nh,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v,</span><br><span class="line">                 <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">//调用 notifier_call_chain 回调 atomic_notifier_head 上成员的回调函数</span></span><br><span class="line">    ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call, nr_calls);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__atomic_notifier_call_chain);</span><br><span class="line">NOKPROBE_SYMBOL(__atomic_notifier_call_chain);</span><br><span class="line"></span><br><span class="line"><span class="comment">// nl = &amp;nh-&gt;head</span></span><br><span class="line"><span class="comment">// val = val</span></span><br><span class="line"><span class="comment">// v = v</span></span><br><span class="line"><span class="comment">// nr_to_call = -1</span></span><br><span class="line"><span class="comment">// nr_calls = NULL</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_call_chain</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = NOTIFY_DONE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">nb</span>, *<span class="title">next_nb</span>;</span></span><br><span class="line"></span><br><span class="line">    nb = rcu_dereference_raw(*nl); <span class="comment">//获取链表指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nb &amp;&amp; nr_to_call) &#123; <span class="comment">//循环遍历 nb 链表上的 notifier_block ，nr_to_call 表示调用的次数。</span></span><br><span class="line">        next_nb = rcu_dereference_raw(nb-&gt;next); <span class="comment">//获取下一个 notifier_block</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_NOTIFIERS </span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!func_ptr_is_kernel_text(nb-&gt;notifier_call))) &#123; <span class="comment">//debug检测是否有 notifier_call 回调函数，如果没有则直接调用下一个。</span></span><br><span class="line">            WARN(<span class="number">1</span>, <span class="string">&quot;Invalid notifier called!&quot;</span>);</span><br><span class="line">            nb = next_nb;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ret = nb-&gt;notifier_call(nb, val, v); <span class="comment">//调用回调函数 notifier_call</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nr_calls)</span><br><span class="line">            (*nr_calls)++; <span class="comment">//用于记调用了几个回调函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &amp; NOTIFY_STOP_MASK)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nb = next_nb;</span><br><span class="line">        nr_to_call--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(notifier_call_chain);</span><br></pre></td></tr></table></figure>
<h2 id="2、接口整理"><a href="#2、接口整理" class="headerlink" title="2、接口整理"></a>2、接口整理</h2><h3 id="1、原子通知链"><a href="#1、原子通知链" class="headerlink" title="1、原子通知链"></a>1、原子通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;可以看出原子通知链使用的是自旋锁，因此原子通知链可以用在中断上下文中，不能阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">//原子通知链的锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span> <span class="comment">//用于挂接该链表上的 notifier_block 结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;创建原子通知连</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_HEAD(name)              \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> <span class="title">name</span> =</span>          \</span><br><span class="line">        ATOMIC_NOTIFIER_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_INIT(name) &#123;                \</span></span><br><span class="line">        .lock = __SPIN_LOCK_UNLOCKED(name.lock),    \</span><br><span class="line">        .head = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用原子通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 actorn</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_call_chain</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 action</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="comment">// nr_to_call = 遍历多少个 atomic_notifier_head 中的成员</span></span><br><span class="line"><span class="comment">// nr_calls = 用于记录遍历了几个成员</span></span><br><span class="line"><span class="keyword">int</span> __atomic_notifier_call_chain(struct atomic_notifier_head *nh,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v, <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注册原子通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">atomic_notifier_chain_register</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct notifier_block *nb)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2、阻塞通知链"><a href="#2、阻塞通知链" class="headerlink" title="2、阻塞通知链"></a>2、阻塞通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;阻塞通知连使用的读写信号量，因此阻塞通知链使用在进程上下文，可以阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;创建阻塞通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_HEAD(name)                \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">name</span> =</span>            \</span><br><span class="line">        BLOCKING_NOTIFIER_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_INIT(name) &#123;              \</span></span><br><span class="line">        .rwsem = __RWSEM_INITIALIZER((name).rwsem), \</span><br><span class="line">        .head = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用阻塞通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 actorn</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blocking_notifier_call_chain</span><span class="params">(struct blocking_notifier_head *nh, <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 action</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="comment">// nr_to_call = 遍历多少个 atomic_notifier_head 中的成员</span></span><br><span class="line"><span class="comment">// nr_calls = 用于记录遍历了几个成员</span></span><br><span class="line"><span class="keyword">int</span> __blocking_notifier_call_chain(struct blocking_notifier_head *nh,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v, <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注册阻塞通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">blocking_notifier_chain_register</span><span class="params">(struct blocking_notifier_head *nh,struct notifier_block *nb)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="3、原始通知链"><a href="#3、原始通知链" class="headerlink" title="3、原始通知链"></a>3、原始通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;非常原始，啥锁都没有</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">raw_notifier_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;创建原始通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_HEAD(name)                 \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">raw_notifier_head</span> <span class="title">name</span> =</span>             \</span><br><span class="line">        RAW_NOTIFIER_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_INIT(name) &#123;               \</span></span><br><span class="line">        .head = <span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;调用原始通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 actorn</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raw_notifier_call_chain</span><span class="params">(struct raw_notifier_head *nh,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nh 要调用的通知链头</span></span><br><span class="line"><span class="comment">// val = 传入回调函数的 action</span></span><br><span class="line"><span class="comment">// v = 传入回调函数的私有数据</span></span><br><span class="line"><span class="comment">// nr_to_call = 遍历多少个 atomic_notifier_head 中的成员</span></span><br><span class="line"><span class="comment">// nr_calls = 用于记录遍历了几个成员</span></span><br><span class="line"><span class="keyword">int</span> __raw_notifier_call_chain(struct raw_notifier_head *nh,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v, <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注册原始通链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raw_notifier_chain_register</span><span class="params">(struct raw_notifier_head *nh, struct notifier_block *nb)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="4、SRCU-通知链"><a href="#4、SRCU-通知链" class="headerlink" title="4、SRCU 通知链"></a>4、SRCU 通知链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;可以阻塞的通知链。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">srcu_notifier_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mutex</span> <span class="title">mutex</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">srcu_struct</span>  <span class="title">srcu</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>驱动</tag>
      </tags>
  </entry>
</search>
