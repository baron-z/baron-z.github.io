<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux驱动-项目杂记</title>
    <url>/2021/06/16/%E9%A1%B9%E7%9B%AE%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>用于记录项目中乱七八糟的东西，不定期更新，没有排版。</p>
<a id="more"></a>

<h2 id="一、G90-mt67850-SIM卡功能"><a href="#一、G90-mt67850-SIM卡功能" class="headerlink" title="一、G90(mt67850)-SIM卡功能"></a>一、G90(mt67850)-SIM卡功能</h2><h3 id="1、支持双卡，配置config文件"><a href="#1、支持双卡，配置config文件" class="headerlink" title="1、支持双卡，配置config文件"></a>1、支持双卡，配置config文件</h3><p>路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/device/mediateksample/k85v1_64/ProjectConfig.mk</span><br></pre></td></tr></table></figure>
<p>修改参数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MTK_SIM1_SOCKET_TYPE = <span class="number">1</span></span><br><span class="line">MTK_SIM2_SOCKET_TYPE = <span class="number">1</span></span><br><span class="line">MTK_SIM_CARD_ONOFF = <span class="number">2</span></span><br><span class="line">MTK_SIM_HOT_SWAP = yes</span><br><span class="line">MTK_SIM_HOT_SWAP_COMMON_SLOT = no</span><br><span class="line">MTK_SIM_LOCK_POWER_ON_WRITE_PROTECT = no</span><br><span class="line">MTK_SIM_RECOVERY = yes</span><br><span class="line"></span><br><span class="line">MTK_MULTI_SIM_SUPPORT = dsds <span class="comment">//一般只需修改这个就好了，其他都是默认配好的，单卡配置成ss</span></span><br><span class="line"></span><br><span class="line">SIM_ME_LOCK_MODE = <span class="number">3</span></span><br><span class="line">SIM_REFRESH_RESET_BY_MODEM = yes</span><br><span class="line">MTK_EAP_SIM_AKA = yes</span><br><span class="line">MTK_EXTERNAL_SIM_ONLY_SLOTS = <span class="number">0</span></span><br><span class="line">MTK_EXTERNAL_SIM_SUPPORT = no</span><br></pre></td></tr></table></figure>
<h3 id="2、配置dct文件"><a href="#2、配置dct文件" class="headerlink" title="2、配置dct文件"></a>2、配置dct文件</h3><p>路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\vendor\mediatek\proprietary\scripts\dct\DrvGen.exe <span class="comment">//dct配置工具</span></span><br><span class="line">\vendor\mediatek\proprietary\bootable\bootloader\lk\target\k85v1_64\dct\dct\codegen.dws <span class="comment">//lk下dct路径</span></span><br><span class="line">\vendor\mediatek\proprietary\bootable\bootloader\preloader\custom\k85v1_64\dct\dct\codegen.dws <span class="comment">//pl下dct路径</span></span><br><span class="line">\kernel<span class="number">-4.14</span>\drivers\misc\mediatek\dws\mt6785\codegen.dws  <span class="comment">//kernel下dct路径</span></span><br></pre></td></tr></table></figure>
<p>配置根据中断检测脚状态来配置</p>
<blockquote>
<p>如果插入sim卡为高电平拔出时为低电平则配置 PlugOutPolarity 为低电平<br>如果插入sim卡为低电平拔出时为高电平则配置 PlugOutPolarity 为高电平</p>
</blockquote>
<p>我的为第一种情况因此如下配置：<br><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/G90%E9%A1%B9%E7%9B%AE/sim.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1610763714;88010677314&q-key-time=1610763714;88010677314&q-header-list=&q-url-param-list=&q-signature=1da371ae29efdf84b431edf5f87f58b688f98308"></p>
<h2 id="二、tf卡配置"><a href="#二、tf卡配置" class="headerlink" title="二、tf卡配置"></a>二、tf卡配置</h2><h3 id="1、配置中断引脚"><a href="#1、配置中断引脚" class="headerlink" title="1、配置中断引脚"></a>1、配置中断引脚</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">路径： /arch/arm64/boot/dts/mediatek/cust_mt6785_msdc.dtsi</span><br><span class="line"></span><br><span class="line">具体修改： 原理图使用的 msdc1</span><br><span class="line"></span><br><span class="line">        host_function = /bits/ <span class="number">8</span> &lt;MSDC_SD&gt;;</span><br><span class="line"></span><br><span class="line">-       cd_level = /bits/ <span class="number">8</span> &lt;MSDC_CD_LOW&gt;;</span><br><span class="line">+       cd_level = /bits/ <span class="number">8</span> &lt;MSDC_CD_HIGH&gt;; <span class="comment">//由于插入tf卡中断检测脚为高这里修改为高电平触发</span></span><br><span class="line">        cd-gpios = &lt;&amp;pio <span class="number">8</span> <span class="number">0</span>&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="2、配置下电方式"><a href="#2、配置下电方式" class="headerlink" title="2、配置下电方式"></a>2、配置下电方式</h3><p>mt6360 的 sdcard 的下电方式可以配置选择</p>
<p><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/G90%E9%A1%B9%E7%9B%AE/pmic_sdcard_det_n.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1610765551;88010679151&q-key-time=1610765551;88010679151&q-header-list=&q-url-param-list=&q-signature=111ac4de6885b0162b548936698497afe9a03fa8"></p>
<p>我的原理图长这样</p>
<p><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/G90%E9%A1%B9%E7%9B%AE/tfcard.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1610765022;88010678622&q-key-time=1610765022;88010678622&q-header-list=&q-url-param-list=&q-signature=d9ed65e258e6dbbbcad0bf533de040fbb6809cbd"></p>
<p>=-= 我的原理图插入 sd 卡之后，EINT_SD 会被拉高，由于它和 SD_CARD_DET_N_PMU 短接在一起的，因此 SD_CARD_DET_N_PMU 跟着被拉高了，于是满图上图第一种情况 active high，LD05 被拉低。。。。。，sd卡的供电就被拉低了，现象就是插上tf卡供电就掉下来 =w= 导致tf卡没功能。这种情况需要配置为上图的第二种状态 active low，配置如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">路径： drivers/misc/mediatek/pmic/mt6360/ldo/mt6360_ldo_i2c.c</span><br><span class="line">具体修改：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mt6360_ldo_platform_data</span> <span class="title">def_platform_data</span> =</span> &#123;</span><br><span class="line">-       .sdcard_det_en = <span class="literal">true</span>,</span><br><span class="line">+       .sdcard_det_en = <span class="literal">false</span>,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外记得检测卡托，卡托和卡座一定要匹配，不匹配的卡托可能会在插入的过程中短路，导致 pmic 因为自身的保护机制直接关掉对应的 ldo5 引脚供电，这种情况和上面出现的现象是一样的。</p>
<h2 id="三、G90-mt6785-快充配置"><a href="#三、G90-mt6785-快充配置" class="headerlink" title="三、G90(mt6785)-快充配置"></a>三、G90(mt6785)-快充配置</h2><p>这款芯片是支持快充的，默认没有打开需要手动配置一下</p>
<h3 id="1、快充说明"><a href="#1、快充说明" class="headerlink" title="1、快充说明"></a>1、快充说明</h3><h4 id="1-充电策略"><a href="#1-充电策略" class="headerlink" title="1) 充电策略"></a>1) 充电策略</h4><blockquote>
<p>VAT在比较小的时候，转换效率很低：假设VBAT=3.4V,IBAT=3A,当VBUS=7.5V的时候，转换效率为82.7%，当VBUS=12V的时候，转换效率为80.51%，差了接近%2；而当VBAT比较高的时候，转换效率对电压就不会很敏感，在VBAT=4V的情况下，最低一档的转换效率都有86.94%，所以mtk的充电策略：在保证充电功率的情况下，转换效率尽可能的高</p>
</blockquote>
<h4 id="2-温度控制充电"><a href="#2-温度控制充电" class="headerlink" title="2) 温度控制充电"></a>2) 温度控制充电</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max_charge_temp = &lt;<span class="number">50</span>&gt;; <span class="comment">//大于50°停止充电</span></span><br><span class="line">max_charge_temp_minux_x_degree = &lt;<span class="number">47</span>&gt;; <span class="comment">//从50°降低到47°之后，允许充电</span></span><br></pre></td></tr></table></figure>
<h4 id="3-充电检测"><a href="#3-充电检测" class="headerlink" title="3) 充电检测"></a>3) 充电检测</h4><p>手机插入充电线之后，会走一个充电器类型检测，这个检测流程软硬件都有参与，要满足最基本的 BC1.2 协议才会充电，协议规定几种接口，DCP,SDP,CDP都是5v，mtk 有类似的机制在 dual charger 进入 PE40 的时候，会判断当前点量来决定跑不跑 dual charger 快充，涉及 dts 里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pe40_stop_battery_soc,pd_stop_battery_sooc</span><br></pre></td></tr></table></figure>
<h4 id="4-充电挡位支持"><a href="#4-充电挡位支持" class="headerlink" title="4) 充电挡位支持"></a>4) 充电挡位支持</h4><p>PE快充可以支持三档7v、9v、12v，三选一，</p>
<p>当使用 switch_charger 时没有这种机制，在 85% 电量的时候插入充电器，它一样是跑 switch_charger, 和手机插着充电器从 0% 开始一直充电没有差别</p>
<h4 id="5）-mtk-电量计算法"><a href="#5）-mtk-电量计算法" class="headerlink" title="5） mtk 电量计算法"></a>5） mtk 电量计算法</h4><p>MTK的电量算法是由 driver 和上层的 daemon组成的，<br>电量变化时 Gauge 的硬件产生中断来通知 driver，<br>然后由 driver 将电量计算要用的值传到上层 daemon，<br>上层计算出的 SOC 会用您问题中的 CMD FG_DAEMON_CMD_SET_KERNEL_UISOC 再写到 kernel。</p>
<h4 id="6-相关参数含义"><a href="#6-相关参数含义" class="headerlink" title="6) 相关参数含义"></a>6) 相关参数含义</h4><p>ICHG = “設定的充電電流”,<br>AICR = “AICR 保護下允許的最高抽電流”<br>MIVR = “設定的允許的充電器最低電壓”<br>IEOC = “設定的截止充電電流”<br>CV = “設定的Constant Voltage 值”<br>VSYS = “量測到的 VSYS 值”<br>VBAT = “测量到的电池电压”<br>IBAT = “测量到的充电电流”<br>IBUS = “测量到充电器的电流”<br>VBUS = “测量到充电器的电压”<br>soc = 底层电量百分比<br>uiso = 上层显示电量百分比<br>CT = 充电器类型</p>
<h3 id="2、打开dts中的相关配置"><a href="#2、打开dts中的相关配置" class="headerlink" title="2、打开dts中的相关配置"></a>2、打开dts中的相关配置</h3><p>具体修改：<br>/kernel-4.14/arch/arm64/boot/dts/mediatek/mt6785.dts b/arch/arm64/boot/dts/mediatek/mt6785.dts</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        charger: charger &#123;</span><br><span class="line">                compatible = <span class="string">&quot;mediatek,charger&quot;</span>;</span><br><span class="line">                algorithm_name = <span class="string">&quot;SwitchCharging&quot;</span>;</span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-               <span class="comment">/* enable_sw_jeita; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_plus; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_2; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_3; */</span></span><br><span class="line">-               <span class="comment">/* enable_pe_4; */</span></span><br><span class="line"><span class="comment">//修改后               </span></span><br><span class="line">+               enable_sw_jeita;</span><br><span class="line">+               enable_pe_plus;</span><br><span class="line">+               enable_pe_2;</span><br><span class="line">+               enable_pe_3;</span><br><span class="line">+               enable_pe_4;</span><br><span class="line">               </span><br><span class="line">                enable_type_c;</span><br><span class="line">                power_path_support;</span><br><span class="line">                enable_dynamic_mivr;</span><br><span class="line">                <span class="comment">/* common */</span></span><br><span class="line">                battery_cv = &lt;<span class="number">4350000</span>&gt;; <span class="comment">//cv 电压，如果想提高快充时间可以适当调高，不过要考虑到电池耐压。</span></span><br><span class="line">                max_charger_voltage = &lt;<span class="number">6500000</span>&gt;;</span><br><span class="line">                min_charger_voltage = &lt;<span class="number">4600000</span>&gt;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* dynamic mivr */</span></span><br><span class="line">                min_charger_voltage_1 = &lt;<span class="number">4400000</span>&gt;;</span><br><span class="line">                min_charger_voltage_2 = &lt;<span class="number">4200000</span>&gt;;</span><br><span class="line">                max_dmivr_charger_current = &lt;<span class="number">1400000</span>&gt;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* charging current */</span></span><br><span class="line">                usb_charger_current_suspend = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">                usb_charger_current_unconfigured = &lt;<span class="number">70000</span>&gt;;</span><br><span class="line">                usb_charger_current_configured = &lt;<span class="number">500000</span>&gt;;</span><br><span class="line">                usb_charger_current = &lt;<span class="number">500000</span>&gt;;</span><br><span class="line">                ac_charger_current = &lt;<span class="number">2050000</span>&gt;; <span class="comment">// 普通充电的 ichg </span></span><br><span class="line">                ac_charger_input_current = &lt;<span class="number">2050000</span>&gt;; <span class="comment">// ibus</span></span><br><span class="line">                non_std_ac_charger_current = &lt;<span class="number">500000</span>&gt;;</span><br><span class="line">                charging_host_charger_current = &lt;<span class="number">1500000</span>&gt;;</span><br><span class="line">                apple_1_0a_charger_current = &lt;<span class="number">650000</span>&gt;;</span><br><span class="line">                apple_2_1a_charger_current = &lt;<span class="number">800000</span>&gt;;</span><br><span class="line">                ta_ac_charger_current = &lt;<span class="number">3000000</span>&gt;; <span class="comment">//快充的 ichg</span></span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* PD */</span></span><br><span class="line">                pd_vbus_low_bound = &lt;<span class="number">5000000</span>&gt;; <span class="comment">//支持的充电最低电压，pd-&gt;vbus_l</span></span><br><span class="line">                pd_vbus_upper_bound = &lt;<span class="number">9000000</span>&gt;; <span class="comment">//支持的充电最高电压,pd-&gt;vbus_h</span></span><br><span class="line">                pd_ichg_level_threshold = &lt;<span class="number">1000000</span>&gt;; <span class="comment">/* uA */</span></span><br><span class="line">                pd_stop_battery_soc = &lt;<span class="number">90</span>&gt;; <span class="comment">//停止快充电量，gm3 已经舍弃</span></span><br><span class="line"></span><br><span class="line">                ibus_err = &lt;<span class="number">14</span>&gt;;</span><br><span class="line">                vsys_watt = &lt;<span class="number">5000000</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>kernel-4.14/arch/arm64/boot/dts/mediatek/bat_setting/mt6765_battery_prop.dtsi</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bat_gm30: battery&#123;</span><br><span class="line">    compatible = <span class="string">&quot;mediatek,bat_gm30&quot;</span>;</span><br><span class="line">     ......</span><br><span class="line"><span class="comment">/*  The ui_soc will keep 100% until SOC drop X percents after unplugged*/</span></span><br><span class="line">    R_FG_VALUE = &lt;(<span class="number">10</span>)&gt;; <span class="comment">//rf 电阻用于测量充电流，需要校准</span></span><br><span class="line">    ......</span><br><span class="line">    ACTIVE_TABLE = &lt;(<span class="number">4</span>)&gt;; <span class="comment">//这里要注意一下，我们用到的电池参数table一般为四个</span></span><br><span class="line"><span class="comment">/* Table numbers per battery*/</span></span><br><span class="line">    MULTI_TEMP_GAUGE0 = &lt;(<span class="number">1</span>)&gt;;</span><br><span class="line"><span class="comment">/* Multi gauge0 enable*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mt6785_battery_table.dtsi&quot;</span> <span class="comment">// ACTIVE_TABLE 的值就是里面的参数的数组数量。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mt6785_battery_prop_dim2_ext.dtsi&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、修改-kernel-下的-config-文件"><a href="#3、修改-kernel-下的-config-文件" class="headerlink" title="3、修改 kernel 下的 config 文件"></a>3、修改 kernel 下的 config 文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/kernel<span class="number">-4.14</span>/arch/arm64/configs/k85v1_64_defconfig b/arch/arm64/configs/k85v1_64_defconfig</span><br><span class="line"></span><br><span class="line"> CONFIG_ACCDET_EINT_IRQ=y</span><br><span class="line"> CONFIG_ACCDET_SUPPORT_EINT0=y</span><br><span class="line"> CONFIG_MTK_LENS=y</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加相关配置</span></span><br><span class="line">+CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT=y</span><br><span class="line">+CONFIG_MTK_PUMP_EXPRESS_PLUS_20_SUPPORT=y</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/device/mediateksample/k85v1_64/ProjectConfig.mk b/mediateksample/k85v1_64/ProjectConfig.mk</span><br><span class="line"></span><br><span class="line"> MTK_PROTOCOL2_RAT_CONFIG = L/W/G</span><br><span class="line"> MTK_PROTOCOL3_RAT_CONFIG = G</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-MTK_PUMP_EXPRESS_PLUS_SUPPORT = no</span><br><span class="line">-MTK_PUMP_EXPRESS_PLUS_20_SUPPORT = no</span><br><span class="line"></span><br><span class="line"> MTK_PUMP_EXPRESS_PLUS_30_SUPPORT = no</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">+MTK_PUMP_EXPRESS_PLUS_20_SUPPORT = yes</span><br><span class="line">+MTK_PUMP_EXPRESS_PLUS_SUPPORT = yes</span><br><span class="line"></span><br><span class="line"> MTK_PUMP_EXPRESS_SUPPORT = no</span><br><span class="line"> MTK_RADIOOFF_POWER_OFF_MD = no</span><br><span class="line"> MTK_RAT_WCDMA_PREFERRED = no</span><br></pre></td></tr></table></figure>
<h3 id="4、vendor-目录下修改lk配置文件"><a href="#4、vendor-目录下修改lk配置文件" class="headerlink" title="4、vendor 目录下修改lk配置文件"></a>4、vendor 目录下修改lk配置文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/vendor/mediatek/proprietary/bootable/bootloader/lk/project/k85v1_64.mk b/mediatek/proprietary/bootable/bootloader/lk/project/k85v1_64.mk</span><br><span class="line"></span><br><span class="line"> DEFINES += MTK_NEW_COMBO_EMMC_SUPPORT</span><br><span class="line"> DEFINES += MTK_GPT_SCHEME_SUPPORT</span><br><span class="line"> MTK_CHARGER_NEW_ARCH := yes</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-MTK_PUMP_EXPRESS_PLUS_SUPPORT := no</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">+MTK_PUMP_EXPRESS_PLUS_SUPPORT := yes</span><br><span class="line"></span><br><span class="line"> MTK_CHARGER_INTERFACE := yes</span><br><span class="line"> MTK_MT6360_PMU_CHARGER_SUPPORT := yes</span><br><span class="line"> MTK_LCM_PHYSICAL_ROTATION = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="四、G90-mt6785-功放调试之控制"><a href="#四、G90-mt6785-功放调试之控制" class="headerlink" title="四、G90(mt6785)-功放调试之控制"></a>四、G90(mt6785)-功放调试之控制</h2><h3 id="1、耳机检测代码"><a href="#1、耳机检测代码" class="headerlink" title="1、耳机检测代码"></a>1、耳机检测代码</h3><p>G90 的功放和 8788 平台的有点不一样，在插上耳机的时候功放不会自动停止播放，因此在耳机检测的时候手动添加开关功放的使能引脚的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/drivers/misc/mediatek/accdet/mt6359/accdet.c</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> PMIC_ACCDET_KERNEL</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eint_work_callback</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"> <span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eint_work_callback</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> <span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     pr_info(<span class="string">&quot;accdet %s(),DCC EINT func\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cur_eint_state == EINT_PIN_PLUG_IN) &#123; <span class="comment">//检测到耳机插入跑这里</span></span><br><span class="line">         <span class="comment">/* wk, disable vusb LP */</span></span><br><span class="line">         pmic_write(PMIC_RG_LDO_VUSB_HW0_OP_EN_ADDR, <span class="number">0x8000</span>);</span><br><span class="line">         pr_info(<span class="string">&quot;%s VUSB LP dis\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">         pr_info(<span class="string">&quot;accdet cur: plug-in, cur_eint_state = %d\n&quot;</span>,</span><br><span class="line">             cur_eint_state);</span><br><span class="line"></span><br><span class="line">         amplifier_control_off();<span class="comment">/* 关闭功放， 这个函数是自己添加的 */</span></span><br><span class="line"></span><br><span class="line">         mutex_lock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         eint_accdet_sync_flag = <span class="literal">true</span>;</span><br><span class="line">         mutex_unlock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         __pm_wakeup_event(accdet_timer_lock,</span><br><span class="line">             jiffies_to_msecs(<span class="number">7</span> * HZ));</span><br><span class="line"></span><br><span class="line">         accdet_init();</span><br><span class="line"></span><br><span class="line">         pr_info(<span class="string">&quot;%s VUSB LP dis done\n&quot;</span>, __func__);</span><br><span class="line">         enable_accdet(<span class="number">0</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  <span class="comment">//检测到耳机拔出跑这里</span></span><br><span class="line">         pr_info(<span class="string">&quot;accdet cur:plug-out, cur_eint_state = %d\n&quot;</span>,</span><br><span class="line">             cur_eint_state);</span><br><span class="line"></span><br><span class="line">         amplifier_control_on();<span class="comment">/* 打开功放，这个函数是自己添加的 */</span></span><br><span class="line"></span><br><span class="line">         mutex_lock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         eint_accdet_sync_flag = <span class="literal">false</span>;</span><br><span class="line">         accdet_thing_in_flag = <span class="literal">false</span>;</span><br><span class="line">         mutex_unlock(&amp;accdet_eint_irq_sync_mutex);</span><br><span class="line">         <span class="keyword">if</span> (accdet_dts.moisture_detect_mode != <span class="number">0x5</span>)</span><br><span class="line">             del_timer_sync(&amp;micbias_timer);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* disable accdet_sw_en=0</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         pmic_write_clr(PMIC_ACCDET_SW_EN_ADDR,</span><br><span class="line">             PMIC_ACCDET_SW_EN_SHIFT);</span><br><span class="line">         disable_accdet();</span><br><span class="line">         headset_plug_out();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ACCDET_EINT_IRQ</span></span><br><span class="line"> <span class="keyword">if</span> (get_moisture_det_en() == <span class="number">0x1</span>)</span><br><span class="line">     recover_moisture_setting(gmoistureID);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     recover_eint_setting(gmoistureID);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ACCDET_EINT</span></span><br><span class="line"> enable_irq(accdet_irq);</span><br><span class="line"> pr_info(<span class="string">&quot;accdet %s enable_irq !!\n&quot;</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、耳机有声音功放没声音"><a href="#2、耳机有声音功放没声音" class="headerlink" title="2、耳机有声音功放没声音"></a>2、耳机有声音功放没声音</h3><p>插上耳机 pmu 才有功放信号输出，拔出耳机就没有信号输出，这里的信号指 pmu 端的信号，其实就是外置功放修改，修改如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/device/mediateksample/k85v1_64/ProjectConfig.mk b/mediateksample/k85v1_64/ProjectConfig.mk</span><br><span class="line"></span><br><span class="line"> MTK_AUDIO_MIC_INVERSE = no</span><br><span class="line"> MTK_AUDIO_NUMBER_OF_MIC = <span class="number">2</span></span><br><span class="line"> MTK_AUDIO_NUMBER_OF_SPEAKER = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改前</span></span><br><span class="line">-MTK_AUDIO_SPEAKER_PATH = smartpa_mtk_mt6660</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line">+MTK_AUDIO_SPEAKER_PATH = int_hp_buf</span><br><span class="line"> MTK_AUDIO_TUNING_TOOL_VERSION = V2<span class="number">.2</span></span><br><span class="line"> MTK_AUDIO_TUNNELING_SUPPORT = no</span><br><span class="line"> MTK_AUIDO_MIC_INVERSE = no</span><br></pre></td></tr></table></figure>
<h3 id="3、喇叭尾音"><a href="#3、喇叭尾音" class="headerlink" title="3、喇叭尾音"></a>3、喇叭尾音</h3><p>Android系统默认播放停止后3秒会进入Standby模式以节省电源.standby里面有pcm_close接口，会关闭speaker的输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/av/services/audioflinger/AudioFlinger.h b/av/services/audioflinger/AudioFlinger.h</span><br><span class="line">old mode <span class="number">100644</span></span><br><span class="line"><span class="keyword">new</span> mode <span class="number">100755</span></span><br><span class="line">index <span class="number">978</span>d39132.<span class="number">.73</span>db1b203</span><br><span class="line">--- a/av/services/audioflinger/AudioFlinger.h</span><br><span class="line">+++ b/av/services/audioflinger/AudioFlinger.h</span><br><span class="line">@@ <span class="number">-97</span>,<span class="number">7</span> +<span class="number">97</span>,<span class="number">7</span> @@ class ServerProxy;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">-<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">nsecs_t</span> kDefaultStandbyTimeInNsecs = seconds(<span class="number">3</span>);</span><br><span class="line">+<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">nsecs_t</span> kDefaultStandbyTimeInNsecs = milliseconds(<span class="number">200</span>);</span><br><span class="line"> <span class="comment">//MTK_AUDIO_FIX_DEFAULT_DEFECT</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">nsecs_t</span> kDefaultA2dpStandbyTimeInNsecs = milliseconds(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<h3 id="四、耳机立体声修改"><a href="#四、耳机立体声修改" class="headerlink" title="四、耳机立体声修改"></a>四、耳机立体声修改</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vendor/mediatek/proprietary/custom/tb8788p1_64_bsp/hal/audioflinger/audio/audio_custom_exp.h</span><br><span class="line"><span class="comment">//在这个文件中增加宏 #define ENABLE_STEREO_SPEAKER</span></span><br></pre></td></tr></table></figure>
<h3 id="4、-打开-ATCI"><a href="#4、-打开-ATCI" class="headerlink" title="4、 打开 ATCI"></a>4、 打开 ATCI</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*#*#<span class="number">3646633</span>#*#*</span><br></pre></td></tr></table></figure>
<p>Log and Debugging -&gt; ATCI -&gt; ALWAYS ENABLE ATCI</p>
<p><strong>喇叭文件频响曲线存放目录</strong><br>device/mediatek/common/audio_param</p>
<h2 id="三、G90-mt6785-sensorhub"><a href="#三、G90-mt6785-sensorhub" class="headerlink" title="三、G90(mt6785)-sensorhub"></a>三、G90(mt6785)-sensorhub</h2><h2 id="四、背光能调到黑屏"><a href="#四、背光能调到黑屏" class="headerlink" title="四、背光能调到黑屏"></a>四、背光能调到黑屏</h2><p>当打开自动调节背光功能的时候，手动调节设置中背光滚动条将背光设置到最小，屏幕会完全变黑，这种现象可能与lcm的最小亮度有关，可以采用如下方式解决：</p>
<p>1、adb comand设置背光，确定可以使lcm点亮的最小背光值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adb shell echo xx &gt;/sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">lcd</span>-<span class="title">backlight</span>/<span class="title">brightness</span>    <span class="title">xx</span>为<span class="title">backlight</span> <span class="title">level</span></span></span><br></pre></td></tr></table></figure>
<p>2、修改alps/frameworks/base/core/res/res/values/config.xml中如下参数的值为步骤1中所获取的最小背光值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;!-- Minimum allowable screen brightness to use in a very dark room.</span><br><span class="line">This value sets the <span class="built_in">floor</span> <span class="keyword">for</span> the darkest possible <span class="keyword">auto</span>-brightness</span><br><span class="line">adjustment. It is expected to be somewhat less than the first entry in</span><br><span class="line">config_autoBrightnessLcdBacklightValues so as to allow the user to have</span><br><span class="line">some range of adjustment to dim the screen further than usual in very</span><br><span class="line">dark rooms. The contents of the screen must still be clearly visible</span><br><span class="line">in darkness (although they may not be visible in a bright room). --&gt;</span><br><span class="line">&lt;integer name=<span class="string">&quot;config_screenBrightnessDark&quot;</span>&gt;<span class="number">1</span>&lt;/integer&gt;</span><br></pre></td></tr></table></figure>
<h2 id="五、摄像头"><a href="#五、摄像头" class="headerlink" title="五、摄像头"></a>五、摄像头</h2><h3 id="1、摄像头引脚"><a href="#1、摄像头引脚" class="headerlink" title="1、摄像头引脚"></a>1、摄像头引脚</h3><p>IOVDD(input output vdd): 负责i2c电压，没有这路电无法读到id，电压一般为 1.8, 少数为2.8内部转化为1.8</p>
<p>DVDD(digital vdd): 用于给数字信号供电，1.2v</p>
<p>AVDD( VDD)：用于给 cmos 供电，放大模拟信号，2.8v</p>
<p>PWDN(power wdn): 给摄像头芯片供电，1.8</p>
<p>RESET: 芯片复位信号</p>
<p>MCLK:一般为 24/26MHZ</p>
<h3 id="2、摄像头去掉af"><a href="#2、摄像头去掉af" class="headerlink" title="2、摄像头去掉af"></a>2、摄像头去掉af</h3><p>vendor/mediatek/proprietary/custom/mt6785/hal/imgsensor_metadata/gc5035_mipi_raw/config_static_metadata.module.gc5035mipiraw.h</p>
<p>将 MTK_CONTROL_AF_MODE_CONTINUOUS_PICTRUE 改为 MTK_CONTROL_AF_MODE_OFF</p>
<p>同时修改<br>vendor/mediatek/proprietary/custom/mt6785/hal/lens/src/lenslist.cpp<br>将对应的配置改为 “Dummy” 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;S5K3M3_SENSOR_ID, DUMMY_MODULE_ID, AK7371AF_LENS_ID, <span class="string">&quot;Dummy&quot;</span>, pAK7371AF_MAIN2_getDefaultData&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="3、修改摄像头方向以及mipi通道"><a href="#3、修改摄像头方向以及mipi通道" class="headerlink" title="3、修改摄像头方向以及mipi通道"></a>3、修改摄像头方向以及mipi通道</h3><p>vendor\mediatek\proprietary\custom\mt8168\hal\imgsensor_src\cfg_setting_imgsensor.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> CUSTOM_CFG gCustomCfg[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .sensorIdx     = IMGSENSOR_SENSOR_IDX_MAIN,</span><br><span class="line"><span class="comment">//        .mclk          = CUSTOM_CFG_MCLK_1,</span></span><br><span class="line"><span class="comment">//        .port          = CUSTOM_CFG_CSI_PORT_0,</span></span><br><span class="line">        .mclk          = CUSTOM_CFG_MCLK_3, <span class="comment">//修改mipi通道为 3</span></span><br><span class="line">        .port          = CUSTOM_CFG_CSI_PORT_2,</span><br><span class="line">        .dir           = CUSTOM_CFG_DIR_REAR,</span><br><span class="line">        .bitOrder      = CUSTOM_CFG_BITORDER_9_2,</span><br><span class="line">        .orientation   = <span class="number">90</span>, <span class="comment">//设置方向</span></span><br><span class="line">        .horizontalFov = <span class="number">67</span>,</span><br><span class="line">        .verticalFov   = <span class="number">49</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .sensorIdx     = IMGSENSOR_SENSOR_IDX_SUB,</span><br><span class="line"> <span class="comment">//       .mclk          = CUSTOM_CFG_MCLK_3,</span></span><br><span class="line"> <span class="comment">//       .port          = CUSTOM_CFG_CSI_PORT_2,</span></span><br><span class="line">        .mclk          = CUSTOM_CFG_MCLK_1,</span><br><span class="line">        .port          = CUSTOM_CFG_CSI_PORT_0,</span><br><span class="line">        .dir           = CUSTOM_CFG_DIR_FRONT,</span><br><span class="line">        .bitOrder      = CUSTOM_CFG_BITORDER_9_2,</span><br><span class="line">        .orientation   = <span class="number">270</span>,</span><br><span class="line">        .horizontalFov = <span class="number">63</span>,</span><br><span class="line">        .verticalFov   = <span class="number">40</span>,</span><br><span class="line">        .secure        = CUSTOM_CFG_SECURE_M0</span><br><span class="line">    &#125;,</span><br><span class="line">.......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="六、adb-remount"><a href="#六、adb-remount" class="headerlink" title="六、adb remount"></a>六、adb remount</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader </span><br><span class="line">echo 等待进入bootloader</span><br><span class="line">pause</span><br><span class="line">fastboot flashing unlock</span><br><span class="line">echo 按照界面提示按小机音量+按键</span><br><span class="line">pause</span><br><span class="line">fastboot reboot</span><br><span class="line">echo 等待开机完成</span><br><span class="line">pause</span><br><span class="line">adb root</span><br><span class="line">pause</span><br><span class="line">adb disable-verity </span><br><span class="line">adb reboot</span><br><span class="line">pause</span><br><span class="line">adb root </span><br><span class="line">adb remount</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<h2 id="七、安卓11打开串口log"><a href="#七、安卓11打开串口log" class="headerlink" title="七、安卓11打开串口log"></a>七、安卓11打开串口log</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- a/drivers/misc/mediatek/mtprintk/mtk_printk_ctrl.c</span><br><span class="line">+++ b/drivers/misc/mediatek/mtprintk/mtk_printk_ctrl.c</span><br><span class="line">@@ <span class="number">-34</span>,<span class="number">7</span> +<span class="number">34</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTK_ENG_BUILD</span></span><br><span class="line"> <span class="keyword">int</span> printk_ctrl;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">-<span class="keyword">int</span> printk_ctrl = <span class="number">1</span>;</span><br><span class="line">+<span class="keyword">int</span> printk_ctrl = <span class="number">0</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> module_param_named(disable_uart, printk_ctrl, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">@@ <span class="number">-51</span>,<span class="number">7</span> +<span class="number">51</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">bool</span> <span class="title">mt_get_uartlog_status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">mt_disable_uart</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="comment">/* uart print not always enable */</span></span><br><span class="line">-       <span class="keyword">if</span> (printk_ctrl != <span class="number">2</span>)</span><br><span class="line">+       <span class="keyword">if</span> (printk_ctrl != <span class="number">0</span>)</span><br><span class="line">                printk_ctrl = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="八、安卓按键映射"><a href="#八、安卓按键映射" class="headerlink" title="八、安卓按键映射"></a>八、安卓按键映射</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\out\target\product\tb8168p1_64_bsp\system\usr\keylayout\Generic.kl</span><br></pre></td></tr></table></figure>
<h2 id="九、mtk-平台反汇编-dts"><a href="#九、mtk-平台反汇编-dts" class="headerlink" title="九、mtk 平台反汇编 dts"></a>九、mtk 平台反汇编 dts</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out/target/product/tb8788p1_64_bsp/obj/KERNEL_OBJ/scripts/dtc/dtc -I dtb -O dts -o out/target/product/tb8788p1_64_bsp/obj/KERNEL_OBJ/arch/arm64/boot/dts/mediatek/mt6771.dtb</span><br></pre></td></tr></table></figure>
<p>1、dtbo img -&gt; dtb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./out/host/linux-x86/bin/mkdtimg dump out/target/product/tb8788p1_64_bsp/dtbo-verified.img -b a<span class="number">.0</span></span><br><span class="line">执行后生成a<span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>2、dtb-&gt;dts</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./out/target/product/tb8788p1_64_bsp/obj/KERNEL_OBJ/scripts/dtc/dtc -I dtb -O dts -o x100.dts a<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">执行后生成x100.dts</span><br></pre></td></tr></table></figure>
<h2 id="十、快速打包patch"><a href="#十、快速打包patch" class="headerlink" title="十、快速打包patch"></a>十、快速打包patch</h2><ol>
<li>将脚本 outdiff 拷贝进需要打包的目录</li>
<li>运行 git status &gt; a.txt 创建 a.txt 文件</li>
<li>运行脚本 ./outdiff 创建出 patch 目录 out_diff 该目录有 modified 文件</li>
<li>对比 a.txt 将新曾文件拷贝进对应目录</li>
</ol>
<h2 id="十一、打开mtklog"><a href="#十一、打开mtklog" class="headerlink" title="十一、打开mtklog"></a>十一、打开mtklog</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adb shell am start -n com.mediatek.mtklogger/com.mediatek.mtklogger.MainActivity</span><br></pre></td></tr></table></figure>
<h2 id="十二、给sys节点权限"><a href="#十二、给sys节点权限" class="headerlink" title="十二、给sys节点权限"></a>十二、给sys节点权限</h2><p>1.并非所有的 Linux distributions 都支持 SELinux<br> 目前 SELinux 支持三种模式，分别如下：<br>enforcing ： 强制模式，代表 SELInux 运作中，且已经 正确的开始限制domain/type<br>permisssive:宽容模式，代表 SELinux 运座钟，不过仅会有警告讯息并不会限制<br>domain/type的存取。这个模式可以用来运作为 SELinux 的 debug 之用。<br>disabled： 关闭， SELinux 并没有实际运作</p>
<p>2.查看 SELinux 的模式<br> get enforcing =》enforcing<br>在 MTK 的平台下查看 SELinux 的方法是使用 getenforce<br>如果显示是 enforcing 就说明 SELinux 是打开的<br>如果显示是 disabled 就说明 SELinux 是关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第一处修改</span><br><span class="line">system/core/init/selinux.cpp</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">IsEnforcing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+       <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//这里返回false</span></span><br><span class="line">     <span class="keyword">if</span> (ALLOW_PERMISSIVE_SELINUX) &#123;</span><br><span class="line">         <span class="keyword">return</span> StatusFromCmdline() == SELINUX_ENFORCING;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二处修改</span><br><span class="line">diff --git a/mediateksample/k71v1_64_bsp/init.project.rc b/mediateksample/k71v1_64_bsp/init.project.rc</span><br><span class="line">index <span class="number">8722</span>a5a5..c87338c3 <span class="number">100755</span></span><br><span class="line">--- a/mediateksample/k71v1_64_bsp/init.project.rc</span><br><span class="line">+++ b/mediateksample/k71v1_64_bsp/init.project.rc</span><br><span class="line">@@ <span class="number">-35</span>,<span class="number">6</span> +<span class="number">35</span>,<span class="number">11</span> @@ on post-fs-data</span><br><span class="line">     chmod <span class="number">0660</span> /dev/spm</span><br><span class="line">     chown system system /dev/spm</span><br><span class="line"></span><br><span class="line">+#ADDNODE</span><br><span class="line">+       chmod <span class="number">0666</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">led_ctrl</span>/<span class="title">led_ctrl</span></span></span><br><span class="line"><span class="class">+       <span class="title">chmod</span> 0666 /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">hall</span>/<span class="title">hall_1</span></span></span><br><span class="line"><span class="class">+       <span class="title">chmod</span> 0666 /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">hall</span>/<span class="title">hall_2</span></span></span><br></pre></td></tr></table></figure>
<h2 id="十三、安卓11编译相关"><a href="#十三、安卓11编译相关" class="headerlink" title="十三、安卓11编译相关"></a>十三、安卓11编译相关</h2><h3 id="1、-Split-command-build-for-system-product"><a href="#1、-Split-command-build-for-system-product" class="headerlink" title="1、 Split command build for system product"></a>1、 Split command build for system product</h3><h4 id="1）Build-system-project"><a href="#1）Build-system-project" class="headerlink" title="1）Build system project"></a>1）Build system project</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out_sys</span><br><span class="line">lunch sys_mssi_64_ww-eng</span><br><span class="line">make sys_images</span><br></pre></td></tr></table></figure>
<h4 id="2）Partial-build"><a href="#2）Partial-build" class="headerlink" title="2）Partial build"></a>2）Partial build</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out_sys</span><br><span class="line">lunch sys_mssi_64_ww-eng</span><br><span class="line">mmma system/related/paths</span><br><span class="line">(<span class="keyword">or</span> make system_module_name, <span class="keyword">or</span> mm, mmm google <span class="keyword">default</span> command.)</span><br></pre></td></tr></table></figure>
<h3 id="2、Split-command-build-for-vendor-product"><a href="#2、Split-command-build-for-vendor-product" class="headerlink" title="2、Split command build for vendor product"></a>2、Split command build for vendor product</h3><h4 id="1）Build-vendor-project"><a href="#1）Build-vendor-project" class="headerlink" title="1）Build vendor project"></a>1）Build vendor project</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out</span><br><span class="line">lunch vnd_k71v1_64_bsp-eng</span><br><span class="line">make vnd_images krn_images</span><br></pre></td></tr></table></figure>
<h4 id="2-Partial-build"><a href="#2-Partial-build" class="headerlink" title="2) Partial build"></a>2) Partial build</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="keyword">export</span> OUT_DIR=out</span><br><span class="line">lunch vnd_k71v1_64_bsp-eng</span><br><span class="line">mmma vendor/related/paths</span><br></pre></td></tr></table></figure>
<h3 id="3、Image-post-process"><a href="#3、Image-post-process" class="headerlink" title="3、Image post process"></a>3、Image post process</h3><h4 id="1-Normal-load"><a href="#1-Normal-load" class="headerlink" title="1) Normal load"></a>1) Normal load</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out/target/product/mssi_t_64_cn/images/split_build.py --system-dir out/target/product/mssi_t_64_cn/images --vendor-dir out/target/product/tb8789p2_64/images --kernel-dir out/target/product/tb8789p2_64/images --output-dir out/target/product/tb8789p2_64/merged</span><br></pre></td></tr></table></figure>
<h4 id="2-Normal-OTA"><a href="#2-Normal-OTA" class="headerlink" title="2) Normal + OTA"></a>2) Normal + OTA</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out_sys/target/product/mssi_64_ww/images/split_build.py --system-dir out_sys/target/product/mssi</span><br><span class="line">_64_ww/images --vendor-dir out/target/product/k71v1_64_bsp/images --kernel-dir out/target/product/k71v1</span><br><span class="line">_64_bsp/images --output-dir output_load --otapackage</span><br></pre></td></tr></table></figure>
<h4 id="3-Normal-CTS"><a href="#3-Normal-CTS" class="headerlink" title="3) Normal + CTS"></a>3) Normal + CTS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out_sys/target/product/mssi_64_ww/images/split_build.py --system-dir out_sys/target/product/mssi</span><br><span class="line">_64_ww/images --vendor-dir out/target/product/k71v1_64_bsp/images --kernel-dir out/target/product/k71v1</span><br><span class="line">_64_bsp/images --output-dir output_load --certs-dir $CTS_SECURITY_KEY</span><br></pre></td></tr></table></figure>
<h4 id="4-Normal-OTA-CTS"><a href="#4-Normal-OTA-CTS" class="headerlink" title="4) Normal + OTA + CTS"></a>4) Normal + OTA + CTS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python out_sys/target/product/mssi_64_ww/images/split_build.py --system-dir out_sys/target/product/mssi</span><br><span class="line">_64_ww/images --vendor-dir out/target/product/k71v1_64_bsp/images --kernel-dir out/target/product/k71v1</span><br><span class="line">_64_bsp/images --output-dir output_load --otapackage --certs-dir $CTS_SECURITY_KEY</span><br></pre></td></tr></table></figure>
<h2 id="十四、linux-查看内存空间"><a href="#十四、linux-查看内存空间" class="headerlink" title="十四、linux 查看内存空间"></a>十四、linux 查看内存空间</h2><p>df -h</p>
<h2 id="十五、设置蓝牙开机默认状态"><a href="#十五、设置蓝牙开机默认状态" class="headerlink" title="十五、设置蓝牙开机默认状态"></a>十五、设置蓝牙开机默认状态</h2><p>开机设置系统将 wifi 蓝牙 gsensor 默认打开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vendor/mediatek/proprietary/packages/apps/SettingsProvider/ res/values/defaults.xml</span><br><span class="line">&lt;<span class="keyword">bool</span> name=<span class="string">&quot;def_accelerometer_rotation&quot;</span>&gt;<span class="literal">true</span>&lt;/<span class="keyword">bool</span>&gt;</span><br><span class="line">&lt;integer name=<span class="string">&quot;def_user_rotation&quot;</span>&gt;<span class="number">1</span>&lt;/integer&gt;</span><br><span class="line">&lt;<span class="keyword">bool</span> name=<span class="string">&quot;def_bluetooth_on&quot;</span>&gt;<span class="literal">true</span>&lt;/<span class="keyword">bool</span>&gt;</span><br><span class="line">&lt;<span class="keyword">bool</span> name=<span class="string">&quot;def_wifi_on&quot;</span>&gt;<span class="literal">true</span>&lt;/<span class="keyword">bool</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="十六、快速获取设备路径"><a href="#十六、快速获取设备路径" class="headerlink" title="十六、快速获取设备路径"></a>十六、快速获取设备路径</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">    dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">    path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>pinctrl 子系统</title>
    <url>/2021/06/11/linux%E9%A9%B1%E5%8A%A8-pinctrl/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;分析总结 pinctrl 子系统框架结构，平台 mtk6771 内核版本 kernel-4.4 , 本文所有的分析均基于此版本。</p>
<a id="more"></a>

<h2 id="一、pinctrl-子系统基本概念"><a href="#一、pinctrl-子系统基本概念" class="headerlink" title="一、pinctrl 子系统基本概念"></a>一、pinctrl 子系统基本概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; 引脚控制子系统(pin control subsystem)，和设备模型一样是linux驱动最基础的系统之一。 对于一块 soc 的 cpu 上有很多引脚，驱动工程师需要根据其应用场景使其处于我们需要的状态，例如配置某个引脚为 gpio 或者 配置其为 i2c。对于不同的 cpu 其寄存器的地址往往是不一样的，比如 S3C2440 的 gpio 控制器的基地址为 0x53000000，而 mtk 的 gpio 地址为 0x10005000，而且寄存器的地址的位也表示不同的含义，而内核为了兼容不同的芯片于是创建出 pinctrl 子系统，该系统用于<font color=red>将板级信息从内核分离出来</font>，对于真正的寄存器的操作，由 soc 厂家来完成(bsp工程师)，而对于普通的驱动工程师来讲，我们调用内核给出的统一接口来设置对应的pin脚就行了。</p>
<h3 id="1、pinctrl-dev"><a href="#1、pinctrl-dev" class="headerlink" title="1、pinctrl_dev"></a>1、pinctrl_dev</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;该结构是 pinctrl 子系统的核心结构，每一个 soc 都需要向内核注册一个 pinctrl_dev 来描述该 pinctl 子系统，它包含下面几部分内容。</p>
<ol>
<li>注册到该子系统的 soc 的引脚控制器 pinctrl_desc</li>
<li>注册到该子系统的 pin 脚 pin_desc_tree</li>
<li>注册到该子系统的 pin 脚对应的 gpio_rang</li>
<li>注册到该子系统的 私有数据</li>
<li>soc 的 pin 脚的默认状态以及，板子休眠时 pin 脚的状态，我看了一下 mtk 平台好像并没有用到这部分功能，不知道其他平台有没有用到这个功能。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>                <span class="comment">// 挂接到全局 pinctrldev_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span>            <span class="comment">// 引脚控制器描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span> <span class="comment">// 用于挂接所有注册到该设备的 pin 脚，注册的 pin 脚由</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span>         <span class="comment">// 用于挂接 gpio_range</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                   <span class="comment">// 设备模型中的设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *driver_data;                    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>                    <span class="comment">// 当前设备的 pinctrl ，用于管理整个 soc 板子的 pin 脚状态。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span>    <span class="comment">// 板子默认的 pin 脚状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span>      <span class="comment">// 板子休眠时的 pin 脚状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、pinctrl-desc"><a href="#2、pinctrl-desc" class="headerlink" title="2、pinctrl_desc"></a>2、pinctrl_desc</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;pinctrl_desc 表示引脚控制器，它是软件上抽象出来的概念，抽象这个结构是为了方便代码的编写，实际硬件并不存在这样的控制器，该结构描述对 pin 脚寄存器真正的操作接口，该接口通常由 soc 厂完成，一般情况一个 soc 只有一个 pinctrl_desc 结构，它包含了下面内容。</p>
<ol>
<li>soc 要处理的<font color=red>所有引脚</font>的软件描述</li>
<li>获取每个(组)引脚的 pin 脚信息的操作接口 pctlops</li>
<li>每个(组)引脚的复用(pinmux)操作接口 pmxops</li>
<li>每个(组)引脚的电器特性(pinconfig)操作接口 confops</li>
<li>支持客制化的 pinconfig</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引脚控制器描述符，将其注册到引脚控制子系统</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                    <span class="comment">// 引脚控制器的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span> <span class="comment">// 引脚描述符数组，描述此引脚控制器处理的所有引脚</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> npins;                  <span class="comment">// 数组中描述符的数量，通常只是上面的 pin 字段的 ARRAY_SIZE()</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span>   <span class="comment">// 用于获取pin group 信息以及将设备树中的引脚配置(引脚复用以及pinconfig)转换为对应的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>     <span class="comment">// pin 复用相关操作，以 group 为单位进行操作</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span>   <span class="comment">// 配饰 pin 的 pinconfg(上拉、下拉、输出方式等)，以 pin 或 group 为操作对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                <span class="comment">// 提供引脚控制器的模块，用于重新计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_custom_params;      <span class="comment">// 客制化引脚支持的 pinconfig 的数量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span> <span class="comment">// 客制化引脚支持的 pinconfig</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span>    <span class="comment">// 有关如何在 debugfs 中打印 @params 的信息，必须与 @custom_params 大小相同，即 @num_custom_params</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-pinctrl-pin-desc"><a href="#1-pinctrl-pin-desc" class="headerlink" title="1) pinctrl_pin_desc"></a>1) pinctrl_pin_desc</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; soc上有大量引脚，每一个引脚使用 pinctrl_pin_desc 来描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核中用其描述 pin 的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> number;  <span class="comment">// pin 引脚号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 此引脚的名称，将用来初始化 pin_desc 的 name，如果为空将使用 PIN + number 例如：PIN0</span></span><br><span class="line">    <span class="keyword">void</span> *drv_data;   <span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-pinctrl-ops"><a href="#2-pinctrl-ops" class="headerlink" title="2) pinctrl_ops"></a>2) pinctrl_ops</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于引脚的使用，有时候一次性会使用到多个引脚，I2C接口会同时使用 2 个引脚，SPI 接口会同时使用 4 个引脚。需要以 group 为单位，访问控制多个 pin，这就是 <strong>pin groups</strong>。但是 <font color=red>mtk 平台采取的策略则是每一个 pin 就是一个 group。</font>，而 pinctrl_ops 则用于获取对应 group 的 pin 脚信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 获取 pin group 的数量，对于mtk平台这里就是 pin 脚的数量</span></span><br><span class="line">    <span class="keyword">int</span> (*get_groups_count) (struct pinctrl_dev *pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取使用 selector 作为数组下标指定 group 的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*get_group_name) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 selector 作为数组下标返回指定 group 所用到的 pins 以及 pin 的数量 num_pins，由于mtk 平台采一个 pin 就是一个 group，因此这里固定返回 1.</span></span><br><span class="line">    <span class="keyword">int</span> (*get_group_pins) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">const</span> <span class="keyword">unsigned</span> **pins, <span class="keyword">unsigned</span> *num_pins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug 相关</span></span><br><span class="line">    <span class="keyword">void</span> (*pin_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于将设备树中的引脚配置转换为对应的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">int</span> (*dt_node_to_map) (struct pinctrl_dev *pctldev, struct device_node *np_config, struct pinctrl_map **<span class="built_in">map</span>, <span class="keyword">unsigned</span> *num_maps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于释放前面创建的 pinctrl_map</span></span><br><span class="line">    <span class="keyword">void</span> (*dt_free_map) (struct pinctrl_dev *pctldev, struct pinctrl_map *<span class="built_in">map</span>, <span class="keyword">unsigned</span> num_maps);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是该接口除了能够获取 pin group 信息之外,还有一个非常重要的回调接口 dt_node_to_map ，用于<font color=red>将设备树中的引脚配置转换为对应的 pinctrl_map</font>。 该接口的实现通常由soc原厂实现。</p>
<h4 id="3-pinmux"><a href="#3-pinmux" class="headerlink" title="3) pinmux"></a>3) pinmux</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;pinmux 表示引脚复，用这个概念就不做解释了。需要注意的是引脚复用和引脚的电器特性(pinconfig)并不是相同的概念, pinctrl子系统中引脚的复用类型用 <font color=red>func</font> 来描述，例如，某 pin 可以复用为 i2c 也可复用为 spi，那么这个引脚则拥有两个 func。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查某个 pin 是否已作它用，用于管脚复用时的互斥（避免多个功能同时使用某个 pin 而不知道，导致奇怪的错误）。</span></span><br><span class="line">    <span class="keyword">int</span> (*request) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回板子 functions 支持的引脚复用的类型的总数，spi0、i2c0、mmc0 这三种类型则应该返回 3   </span></span><br><span class="line">    <span class="keyword">int</span> (*get_functions_count) (struct pinctrl_dev *pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过数组下标 selector 返回 functions 数组中对应的引脚复用为什么功能</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*get_function_name) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 selector 表示的复用功能有哪些 group, 例如：当 selector 表示的复用功能为 i2c 的数组下标时，可能返回 &quot;i2c-0&quot;，&quot;i2c-1&quot;,num_groups = 2.</span></span><br><span class="line">    <span class="keyword">int</span> (*get_function_groups) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> **groups, <span class="keyword">unsigned</span> *num_groups);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 group 为 func_selector 表示的复用功能</span></span><br><span class="line">    <span class="keyword">int</span> (*set_mux) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> func_selector, <span class="keyword">unsigned</span> group_selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是gpio相关</span></span><br><span class="line">    <span class="keyword">int</span> (*gpio_request_enable) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">void</span> (*gpio_disable_free) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*gpio_set_direction) (struct pinctrl_dev *pctldev, struct pinctrl_gpio_range *range, <span class="keyword">unsigned</span> offset, <span class="keyword">bool</span> input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> strict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-pinconf-ops"><a href="#4-pinconf-ops" class="headerlink" title="4) pinconf_ops"></a>4) pinconf_ops</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于每一个引脚都有其特定的电器特性，如上拉、下拉、三态、强推挽输出等用 pinconfig 来描述，pinctrl子系统同样也给出了电器特性的操作函数回调接口。对于电器特性的操作既可以操作一个引脚，也可以操作一组引脚。<font color = red>对于 mtk 平台每个 pin 都是一个 group，因此只用到了 pin_config_group_get 和 pin_config_group_set 接口</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">    <span class="keyword">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//获取一个引脚的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_get) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> pin, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个引脚的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_set) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> pin, <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取一个 group 描述的 pin 的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_group_get) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个 group 描述的 pin 的 pinconfig</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_group_set) (struct pinctrl_dev *pctldev, <span class="keyword">unsigned</span> selector, <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs, <span class="keyword">unsigned</span> num_configs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面这写接口基本用不着，debug相关接口</span></span><br><span class="line">    <span class="keyword">int</span> (*pin_config_dbg_parse_modify) (struct pinctrl_dev *pctldev, <span class="keyword">const</span> <span class="keyword">char</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> *config);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> offset);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_group_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> selector);</span><br><span class="line">    <span class="keyword">void</span> (*pin_config_config_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> config);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、pinctrl"><a href="#3、pinctrl" class="headerlink" title="3、pinctrl"></a>3、pinctrl</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于不同的设备的引脚状态统一由属于该设备的 pinctrl 统一管理。也就是说每一个设备都有一个属于自己的 pinctrl ,该 pinctrl 管理着该设备的 pinctrl_state。相关结构如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>        <span class="comment">// 挂接到全局的 pinctrl_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>           <span class="comment">// 表示所属的 dev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span>      <span class="comment">// 挂接该 pinctrl 所有的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span>     <span class="comment">// 用来挂接 pinctrl_dt_map ，该结构管理着 pinctrl 下所有的 pinctrl_map</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个设备中都有自己的 pin_info</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> *<span class="title">pins</span>;</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>  <span class="comment">//每个创建的设备中的 pinctrl</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-pinctrl-state"><a href="#1-pinctrl-state" class="headerlink" title="1) pinctrl_state"></a>1) pinctrl_state</h4><p>用于描述设备上的 pin 脚所处的状态，一个设备上的 pin 脚可以有多种状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 挂接到所属的 pinctrl</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;      <span class="comment">// 对应的 pinctrl_map 的 name</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span> <span class="comment">// 挂接该 state 下所有的 setting</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个 pin 脚有两个状态, 引脚复用(pinmux)，和引脚状态(pinconfig)，这两种状态由 pinctrl_setting 来描述。</p>
<h4 id="2-pinctrl-setting"><a href="#2-pinctrl-setting" class="headerlink" title="2) pinctrl_setting"></a>2) pinctrl_setting</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一个 pinctrl_setting 只能表示一个引脚复用(pinmux)或者一组电器特性(pinconfig)，通过 pinctrl_map_type 来区分当前的 pinctrl_setting 是描述 pinmux 还是描述 pinconfig，如果 pinctrl_map_type 为 PIN_MAP_TYPE_MUX_GROUP 表示该 setting 或 pinctrl_map 为引脚复用，如果为 PIN_MAP_TYPE_CONFIGS_GROUP 则表示 setting 或 pinctrl_map 为 pinconfig。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>       <span class="comment">// 挂接到所属的 state</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span>  <span class="comment">// 该 setting 的 pinctrl_map 的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span> <span class="comment">// 该 pinctrl_map 所属的 pinctrl_dev</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;        <span class="comment">// 被设置为 pinctrl_map-&gt;dev_name</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> <span class="title">mux</span>;</span> <span class="comment">//如果 type 为 PIN_MAP_TYPE_MUX_GROUP 则使用这个结构来保存引脚复用相关参数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> <span class="title">configs</span>;</span> <span class="comment">//如果 type 为 PIN_MAP_TYPE_CONFIGS_PIN 或者  PIN_MAP_TYPE_CONFIGS_GROUP 则使用这个结构来保存引脚电器特性相关参数</span></span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> group; <span class="comment">// 要用到的  pin group 的数组下标</span></span><br><span class="line">    <span class="keyword">unsigned</span> func;  <span class="comment">// 要用到的 func 的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> group_or_pin;  <span class="comment">// 要配置的 pin 或者 pin group 的数组下标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs; <span class="comment">// 对应的 pinconfig，具体的含义由 soc 原厂定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_configs;   <span class="comment">// config 数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过这个结构需要通过中间结构 pinctrl_map 转化而来，这个结构又通过 dts 配置的引脚参数创建而来。</p>
<h4 id="3-pinctrl-map"><a href="#3-pinctrl-map" class="headerlink" title="3) pinctrl_map"></a>3) pinctrl_map</h4><p>该结构也是提供对应的索引，不过它提供的索引是以字符串的形式提供的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span> <span class="comment">//三个 name 都是在 pinctrl_dt_to_map 函数获取，在 dt_remember_or_free_map 函数进行初始化。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;       <span class="comment">// 所属 pinctrl 的 name</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 设备树中的 pinctrl-names 的属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 pinctrl_map 所属的类别，一般用到的有两大类，复用(mux) 和 pinconfig,</span></span><br><span class="line">    <span class="comment">// 当使用 mux 时使用 pinctrl_map_mux，而 pinconfig 则使用 pinctrl_map_configs</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ctrl_dev_name;  <span class="comment">// 所属的 pinctrl_dev 的 name</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span> <span class="comment">// 当 type 为 PIN_MAP_TYPE_MUX_GROUP 则使用这个</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span> <span class="comment">// 当 type为 IN_MAP_TYPE_CONFIGS_PIN、PIN_MAP_TYPE_CONFIGS_GROUP 使用这个</span></span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *group;       <span class="comment">//具体用到的group，例如：i2c0 有 &quot;i2c0_grp1&quot;、&quot;i2c0_grp1&quot;,如果使用 &quot;i2c0_grp1&quot; 这组，则 group = &quot;i2c0_grp1&quot;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *function;    <span class="comment">//要用到的复用功能，例如: i2c0、i2c1、spi1 等</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *group_or_pin; <span class="comment">// 该 pin 或者pin group的名字</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *configs;   <span class="comment">// 要设置的 pinconfig 数组首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_configs;     <span class="comment">// 数组大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、mtk-平台寄存器的表示方式"><a href="#二、mtk-平台寄存器的表示方式" class="headerlink" title="二、mtk 平台寄存器的表示方式"></a>二、mtk 平台寄存器的表示方式</h2><p>如下图所示，mtk 平台的寄存器在内核中的数据组织方式如下所示：</p>
<p><img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/mtk%E5%B9%B3%E5%8F%B0pin%E8%84%9A%E5%AF%84%E5%AD%98%E5%99%A8%E8%A1%A8%E7%A4%BA.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1622682822;86400000001622600000&q-key-time=1622682822;86400000001622600000&q-header-list=&q-url-param-list=&q-signature=8050114349f3348de91b2edb09e72d1d84cfbb58" alt="mtk 平台寄存器的表示方式"></p>
<h2 id="三、pinctrl-子系统的系统框架"><a href="#三、pinctrl-子系统的系统框架" class="headerlink" title="三、pinctrl 子系统的系统框架"></a>三、pinctrl 子系统的系统框架</h2><h3 id="1、框架接口"><a href="#1、框架接口" class="headerlink" title="1、框架接口"></a>1、框架接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;pinctrl 子系统提供的服务并不复杂，主要提供了以下两个服务，向驱动工程师提供操作 pin 的接口也就是具体的设备要使用的接口，向 bsp 工程师提供对应的寄存器操作的接口。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1622712744;86400000001622640000&q-key-time=1622712744;86400000001622640000&q-header-list=&q-url-param-list=&q-signature=4c7485bd86a798d58e70091a2a2453f819fffda1" width="75%" height="75%" alt="pinctrl 子系统的系统框架">

<h3 id="2、内部实现"><a href="#2、内部实现" class="headerlink" title="2、内部实现"></a>2、内部实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;pinctrl 子系统提供的服务接口很简单，但它的内部实现还是有点复杂的。内核驱动都是基于设备模型来开发的，因此对引脚的操作都是基于设备来讲的。对于一个设备首先要做的就是配置其需要使用到的软硬件资源，当然其中就包括 pin 脚资源。而 pinctrl 子系统则需要解析处理我们配置的 pin 脚资源。当我们配置设备的引脚资源后 pinctrl 会在合适的时机来解析我们配置的引脚资源，什么时机是最合适的呢，显而易见设备和驱动匹配的时候。因为设备资源最终的使用者是驱动，当驱动匹配到设备的时候也就是要使用该资源的时候。当完成对资源的解析，我们只需要调用简单的接口就能使我们的设备上的 pin 脚处于我们需要的状态。</p>
<h4 id="1-配置设备的引脚资源"><a href="#1-配置设备的引脚资源" class="headerlink" title="1) 配置设备的引脚资源"></a>1) 配置设备的引脚资源</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; 配置引脚资源有两种方式首先是使用设备树，这也是目前主流的方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lcm_dev: lcm &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;lcm_1v8_en_low&quot;</span> , <span class="string">&quot;lcm_1v8_en_high&quot;</span>; <span class="comment">//对应的 pinctrl_state 的 name</span></span><br><span class="line"></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gpio_lcm_pwr1v8_low&gt;;  <span class="comment">//----这是一个 pinctrl_state</span></span><br><span class="line">    pinctrl<span class="number">-1</span> = &lt;&amp;gpio_lcm_pwr1v8_high&gt;; <span class="comment">//----这是一个 pinctrl_state</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;pio &#123; </span><br><span class="line"></span><br><span class="line">    gpio_lcm_pwr1v8_low: gpio_lcm_pwr1v8_low &#123; <span class="comment">//----这是一组 pinctrl_map </span></span><br><span class="line">        pins_cmd_dat &#123;</span><br><span class="line">            pinmux = &lt;PINMUX_GPIO5__FUNC_GPIO5&gt;; <span class="comment">//这被解析 pinctrl_map-&gt;data-&gt;mux</span></span><br><span class="line">            slew-rate = &lt;<span class="number">1</span>&gt;;           <span class="comment">//这两个被解析到pinctrl_map-&gt;data-&gt;configs   </span></span><br><span class="line">            output-low;                          </span><br><span class="line">        &#125;;  <span class="comment">//于是这里将创建有 2 个 pinctrl_map 的数组</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio_lcm_pwr1v8_high: gpio_lcm_pwr1v8_high &#123; <span class="comment">//----这是一组 pinctrl_map </span></span><br><span class="line">        pins_cmd_dat &#123;</span><br><span class="line">            pinmux = &lt;PINMUX_GPIO5__FUNC_GPIO5&gt;; <span class="comment">//这被解析到 pinctrl_map-&gt;data-&gt;mux</span></span><br><span class="line">            output-high;                         <span class="comment">//这被解析到 pinctrl_map-&gt;data-&gt;configs</span></span><br><span class="line">        &#125;; <span class="comment">// 于是这里将创建有 2 个 pinctrl_map 的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 lcm 配置了两个 state ，他们分别是”lcm_1v8_en_low” 和 “lcm_1v8_en_high”.</p>
<h4 id="2-解析设备引脚资源的时机"><a href="#2-解析设备引脚资源的时机" class="headerlink" title="2) 解析设备引脚资源的时机"></a>2) 解析设备引脚资源的时机</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当设备和驱动匹配的时候在 really_probe 函数中会调用 pinctrl_bind_pins 来解析并创建属于该设备的 pinctrl，匹配流程可以参考<a href="https://baron-z.cn/2021/01/03/linux%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-%E9%87%8D%E6%9E%84/#more">linux设备模型</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    ret = pinctrl_bind_pins(dev);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看这个函数做了什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pinctrl_bind_pins</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    dev-&gt;pins = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;pins)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析 pin 脚信息并返回 pinctrl</span></span><br><span class="line">    dev-&gt;pins-&gt;p = devm_pinctrl_get(dev);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;p)) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no pinctrl handle\n&quot;</span>);</span><br><span class="line">        ret = PTR_ERR(dev-&gt;pins-&gt;p);</span><br><span class="line">        <span class="keyword">goto</span> cleanup_alloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 default 的 sate</span></span><br><span class="line">    dev-&gt;pins-&gt;default_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;default_state)) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no default pinctrl state\n&quot;</span>);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> cleanup_get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 init 的 state 如果不存在则设置为 default 否则设置为 init</span></span><br><span class="line">    dev-&gt;pins-&gt;init_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_INIT);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;init_state)) &#123;</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no init pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ret = pinctrl_select_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                       dev-&gt;pins-&gt;default_state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = pinctrl_select_state(dev-&gt;pins-&gt;p, dev-&gt;pins-&gt;init_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;failed to activate initial pinctrl state\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> cleanup_get;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">    <span class="comment">//查找 sleep 的 state</span></span><br><span class="line">    dev-&gt;pins-&gt;sleep_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_SLEEP);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;sleep_state))</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no sleep pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找 sleep 的 state</span></span><br><span class="line">    dev-&gt;pins-&gt;idle_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">                    PINCTRL_STATE_IDLE);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;idle_state))</span><br><span class="line">        <span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;no idle pinctrl state\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cleanup_get:</span><br><span class="line">    devm_pinctrl_put(dev-&gt;pins-&gt;p);</span><br><span class="line">cleanup_alloc:</span><br><span class="line">    devm_kfree(dev, dev-&gt;pins);</span><br><span class="line">    dev-&gt;pins = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only return deferrals */</span></span><br><span class="line">    <span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数解析 pin 脚信息并返回 pinctrl ，获取 default 以及其他默认state，这些state 在 include/linux/pinctrl/pinctrl-state.h 中提供</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_DEFAULT <span class="meta-string">&quot;default&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_INIT <span class="meta-string">&quot;init&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_IDLE <span class="meta-string">&quot;idle&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINCTRL_STATE_SLEEP <span class="meta-string">&quot;sleep&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>在 default 之后查找 init 的 state 如果不存在则设置为 default ，从代码也可以看出如果没有 default 也不会去获取后面的 state ，因此<font color=red>如果需要使用到 init、idle、sleep 这三个 state 必须配置 default state</font>。由于解析过程涉及的函数比较多因此先给出内部数据结构的组织结构方便理解。</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%20pinctr%20%E7%9A%84%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1622778256;86400000001622700000&q-key-time=1622778256;86400000001622700000&q-header-list=&q-url-param-list=&q-signature=da4eb2c74bc03c747b997c052e507548c1aada8e" width="100%" height="100%" alt="设备 pinctr 的内部数据组织结构">

<p>可以从数据结构中看出涉及到两个关键的数据 pinctrl_map 和 pinctrl_setting， 这两个数据结构是直接连接到外部的 pinmux 信息和 pinconfig 信息。</p>
<h4 id="3-pinctrl-解析设备引脚资源"><a href="#3-pinctrl-解析设备引脚资源" class="headerlink" title="3) pinctrl 解析设备引脚资源"></a>3) pinctrl 解析设备引脚资源</h4><p>解析过程如下图所示</p>
<img src="https://myblog-1258129986.cos.ap-chengdu.myqcloud.com/linux%E9%A9%B1%E5%8A%A8/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/pin_state%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png?q-sign-algorithm=sha1&q-ak=AKIDhKF3mfZXf8SeirDbHrMiLZbzDlsoqM1W&q-sign-time=1623235951;86400000001623150000&q-key-time=1623235951;86400000001623150000&q-header-list=&q-url-param-list=&q-signature=bf31a7976aeadcc08a17b2740d6c73d5da2b9331" width="100%" height="100%" alt="设备树 pin_state 解析流程">

<h4 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4) 源码分析"></a>4) 源码分析</h4><p>涉及到的代码相对比较多就不去排版了，每个函数都有注释可以作为一个手册阅读。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在 pinctrl_list 链表中查找属于本设备的 pinctrl</span></span><br><span class="line"><span class="comment">// 2. 如果不存在则注册一个 pinctrl</span></span><br><span class="line"><span class="function">struct pinctrl *<span class="title">pinctrl_get</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!dev))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 pinctrl 被注册则,直接返回该 pinctrl</span></span><br><span class="line">    p = find_pinctrl(dev);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_dbg(dev, <span class="string">&quot;obtain a copy of previously claimed pinctrl\n&quot;</span>);</span><br><span class="line">        kref_get(&amp;p-&gt;users);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 pinctrl</span></span><br><span class="line">    <span class="keyword">return</span> create_pinctrl(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 pinctrl_list 链表中查找属于本设备的 pinctrl</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct pinctrl *<span class="title">find_pinctrl</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">    list_for_each_entry(p, &amp;pinctrl_list, node)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;dev == dev) &#123;</span><br><span class="line">            mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pinctrl *<span class="title">create_pinctrl</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span> <span class="comment">//map索引</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> <span class="title">const</span> *<span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化 pinctrl -------------------------- part 1</span></span><br><span class="line">    p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;failed to alloc struct pinctrl\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;dev = dev; <span class="comment">//初始化所属的dev</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;states); <span class="comment">//初始化 states 链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;dt_maps); <span class="comment">//初始化 dt_maps链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该设备 dts 中的 pin state 转化为 pinctrl_map ------------------- part 2</span></span><br><span class="line">    ret = pinctrl_dt_to_map(p);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    devname = dev_name(dev);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于 maps_node 中的每一组属于该设备的 map 调用 add_setting，将对应的 pinctrl_map 转换为 pinctrl_setting ------ patr 3</span></span><br><span class="line">    for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line">        <span class="comment">/* Map must be for this device */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;dev_name, devname))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">        ret = add_setting(p, <span class="built_in">map</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">            pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">            mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* If some other error than deferral occured, return here */</span></span><br><span class="line">        pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kref_init(&amp;p-&gt;users);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">    <span class="comment">//将 pinctrl 加入到全局链表 pinctrl_list</span></span><br><span class="line">    list_add_tail(&amp;p-&gt;node, &amp;pinctrl_list);</span><br><span class="line">    mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实整个解析过程也是分为三步、<strong>part1</strong>-创建本设备的 pinctrl、<strong>part2</strong>-将 dts 转化为对应的 pinctrl_map、<strong>part3</strong>-最后是将 pinctrl_map 转换为pinctrl_setting</p>
</blockquote>
<h5 id="a-创建-pinctrl-map"><a href="#a-创建-pinctrl-map" class="headerlink" title="a. 创建 pinctrl_map"></a>a. 创建 pinctrl_map</h5><h6 id="pinctrl-dt-to-map"><a href="#pinctrl-dt-to-map" class="headerlink" title="pinctrl_dt_to_map"></a>pinctrl_dt_to_map</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 从state = 0 开始，递增判断 pinctrl 所属的设备的的设备树节点是否存在 pinctrl-state ，不存